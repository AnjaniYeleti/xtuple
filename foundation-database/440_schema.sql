-- Dumped from database version 9.1.12
-- Dumped by pg_dump version 9.1.12
-- Started on 2014-03-27 11:30:47 EDT

SET statement_timeout = 0;
SET client_encoding = 'SQL_ASCII';
SET standard_conforming_strings = on;
SET check_function_bodies = false;
SET client_min_messages = warning;


CREATE SCHEMA api;
ALTER SCHEMA api OWNER TO admin;

REVOKE ALL ON SCHEMA api FROM PUBLIC;
REVOKE ALL ON SCHEMA api FROM admin;
GRANT ALL ON SCHEMA api TO admin;
GRANT ALL ON SCHEMA api TO xtrole;

CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;
COMMENT ON EXTENSION plpgsql IS 'PL/pgSQL procedural language';

SET search_path = public, pg_catalog;

--
-- TOC entry 2648 (class 1247 OID 146565173)
-- Dependencies: 8 165
-- Name: achline; Type: TYPE; Schema: public; Owner: admin
--

CREATE TYPE achline AS (
	achline_checkhead_id integer,
	achline_batch text,
	achline_type text,
	achline_value text
);


ALTER TYPE public.achline OWNER TO admin;

--
-- TOC entry 2651 (class 1247 OID 146565176)
-- Dependencies: 8 166
-- Name: apaging; Type: TYPE; Schema: public; Owner: admin
--

CREATE TYPE apaging AS (
	apaging_docdate text,
	apaging_duedate date,
	apaging_ponumber text,
	apaging_reference text,
	apaging_invcnumber text,
	apaging_docnumber text,
	apaging_doctype text,
	apaging_vend_id integer,
	apaging_vend_number text,
	apaging_vend_name text,
	apaging_vend_vendtype_id integer,
	apaging_vendtype_code text,
	apaging_terms_descrip text,
	apaging_apopen_amount numeric,
	apaging_cur_val numeric,
	apaging_thirty_val numeric,
	apaging_sixty_val numeric,
	apaging_ninety_val numeric,
	apaging_plus_val numeric,
	apaging_total_val numeric,
	apaging_discdate date,
	apaging_disc_val numeric,
	apaging_discdays numeric,
	apaging_discprcnt numeric
);


ALTER TYPE public.apaging OWNER TO admin;

--
-- TOC entry 2654 (class 1247 OID 146565179)
-- Dependencies: 8 167
-- Name: araging; Type: TYPE; Schema: public; Owner: admin
--

CREATE TYPE araging AS (
	araging_docdate date,
	araging_duedate date,
	araging_ponumber text,
	araging_docnumber text,
	araging_doctype text,
	araging_cust_id integer,
	araging_cust_number text,
	araging_cust_name text,
	araging_cust_custtype_id integer,
	araging_custtype_code text,
	araging_terms_descrip text,
	araging_aropen_amount numeric,
	araging_cur_val numeric,
	araging_thirty_val numeric,
	araging_sixty_val numeric,
	araging_ninety_val numeric,
	araging_plus_val numeric,
	araging_total_val numeric
);


ALTER TYPE public.araging OWNER TO admin;

--
-- TOC entry 2657 (class 1247 OID 146565182)
-- Dependencies: 8 168
-- Name: bomdata; Type: TYPE; Schema: public; Owner: admin
--

CREATE TYPE bomdata AS (
	bomdata_bomwork_id integer,
	bomdata_bomwork_parent_id integer,
	bomdata_bomwork_level integer,
	bomdata_bomwork_seqnumber integer,
	bomdata_bomitem_id integer,
	bomdata_item_id integer,
	bomdata_item_number text,
	bomdata_uom_name text,
	bomdata_item_descrip1 text,
	bomdata_item_descrip2 text,
	bomdata_itemdescription text,
	bomdata_batchsize numeric,
	bomdata_qtyfxd numeric,
	bomdata_qtyper numeric,
	bomdata_qtyreq numeric,
	bomdata_scrap numeric,
	bomdata_createchild boolean,
	bomdata_issuemethod text,
	bomdata_effective date,
	bomdata_expires date,
	bomdata_expired boolean,
	bomdata_future boolean,
	bomdata_actunitcost numeric,
	bomdata_stdunitcost numeric,
	bomdata_actextendedcost numeric,
	bomdata_stdextendedcost numeric,
	bomdata_ecn text,
	bomdata_char_id integer,
	bomdata_value text,
	bomdata_notes text,
	bomdata_ref text
);


ALTER TYPE public.bomdata OWNER TO admin;

--
-- TOC entry 2660 (class 1247 OID 146565185)
-- Dependencies: 8 169
-- Name: checkdata; Type: TYPE; Schema: public; Owner: admin
--

CREATE TYPE checkdata AS (
	checkdata_page integer,
	checkdata_checknumber text,
	checkdata_checkwords text,
	checkdata_checkdate text,
	checkdata_checkamount text,
	checkdata_checkcurrsymbol text,
	checkdata_checkcurrabbr text,
	checkdata_checkcurrname text,
	checkdata_checkpayto text,
	checkdata_checkaddress text,
	checkdata_checkmemo text,
	checkdata_docnumber text,
	checkdata_docreference text,
	checkdata_docdate text,
	checkdata_docamount text,
	checkdata_docdiscount text,
	checkdata_docnetamount text
);


ALTER TYPE public.checkdata OWNER TO admin;

--
-- TOC entry 2663 (class 1247 OID 146565188)
-- Dependencies: 8 170
-- Name: cntctdup; Type: TYPE; Schema: public; Owner: admin
--

CREATE TYPE cntctdup AS (
	cntct_id integer,
	cntct_crmacct_id integer,
	cntct_addr_id integer,
	cntct_first_name text,
	cntct_last_name text,
	cntct_honorific text,
	cntct_initials text,
	cntct_active boolean,
	cntct_phone text,
	cntct_phone2 text,
	cntct_fax text,
	cntct_email text,
	cntct_webaddr text,
	cntct_notes text,
	cntct_title text,
	cntct_number text,
	cntct_middle text,
	cntct_suffix text,
	cntct_owner_username text,
	cntct_name text,
	crmacct_number text,
	crmacct_name text,
	addr_id integer,
	addr_active boolean,
	addr_line1 text,
	addr_line2 text,
	addr_line3 text,
	addr_city text,
	addr_state text,
	addr_postalcode text,
	addr_country text,
	addr_notes text,
	addr_number text,
	cntctdup_level integer
);


ALTER TYPE public.cntctdup OWNER TO admin;

--
-- TOC entry 2666 (class 1247 OID 146565191)
-- Dependencies: 8 171
-- Name: flcoldata; Type: TYPE; Schema: public; Owner: admin
--

CREATE TYPE flcoldata AS (
	flcoldata_column integer,
	flcoldata_start date,
	flcoldata_end date
);


ALTER TYPE public.flcoldata OWNER TO admin;

--
-- TOC entry 2669 (class 1247 OID 146565194)
-- Dependencies: 8 172
-- Name: flstmthead; Type: TYPE; Schema: public; Owner: admin
--

CREATE TYPE flstmthead AS (
	flstmthead_flhead_id integer,
	flstmthead_flcol_id integer,
	flstmthead_period_id integer,
	flstmthead_username text,
	flstmthead_typedescrip1 text,
	flstmthead_typedescrip2 text,
	flstmthead_flhead_name text,
	flstmthead_flcol_name text,
	flstmthead_month text,
	flstmthead_qtr text,
	flstmthead_year text,
	flstmthead_prmonth text,
	flstmthead_prqtr text,
	flstmthead_pryear text
);


ALTER TYPE public.flstmthead OWNER TO admin;

--
-- TOC entry 2672 (class 1247 OID 146565197)
-- Dependencies: 8 173
-- Name: flstmtitem; Type: TYPE; Schema: public; Owner: admin
--

CREATE TYPE flstmtitem AS (
	flstmtitem_flhead_id integer,
	flstmtitem_period_id integer,
	flstmtitem_username text,
	flstmtitem_order integer,
	flstmtitem_level integer,
	flstmtitem_subgrp integer,
	flstmtitem_type text,
	flstmtitem_type_id integer,
	flstmtitem_parent_id integer,
	flstmtitem_accnt_id integer,
	flstmtitem_name text,
	flstmtitem_month numeric,
	flstmtitem_monthdb numeric,
	flstmtitem_monthcr numeric,
	flstmtitem_monthprcnt numeric,
	flstmtitem_monthbudget numeric,
	flstmtitem_monthbudgetprcnt numeric,
	flstmtitem_monthbudgetdiff numeric,
	flstmtitem_monthbudgetdiffprcnt numeric,
	flstmtitem_qtr numeric,
	flstmtitem_qtrdb numeric,
	flstmtitem_qtrcr numeric,
	flstmtitem_qtrprcnt numeric,
	flstmtitem_qtrbudget numeric,
	flstmtitem_qtrbudgetprcnt numeric,
	flstmtitem_qtrbudgetdiff numeric,
	flstmtitem_qtrbudgetdiffprcnt numeric,
	flstmtitem_year numeric,
	flstmtitem_yeardb numeric,
	flstmtitem_yearcr numeric,
	flstmtitem_yearprcnt numeric,
	flstmtitem_yearbudget numeric,
	flstmtitem_yearbudgetprcnt numeric,
	flstmtitem_yearbudgetdiff numeric,
	flstmtitem_yearbudgetdiffprcnt numeric,
	flstmtitem_prmonth numeric,
	flstmtitem_prmonthprcnt numeric,
	flstmtitem_prmonthdiff numeric,
	flstmtitem_prmonthdiffprcnt numeric,
	flstmtitem_prqtr numeric,
	flstmtitem_prqtrprcnt numeric,
	flstmtitem_prqtrdiff numeric,
	flstmtitem_prqtrdiffprcnt numeric,
	flstmtitem_pryear numeric,
	flstmtitem_pryearprcnt numeric,
	flstmtitem_pryeardiff numeric,
	flstmtitem_pryeardiffprcnt numeric
);


ALTER TYPE public.flstmtitem OWNER TO admin;

--
-- TOC entry 2675 (class 1247 OID 146565200)
-- Dependencies: 8 174
-- Name: fltrendhead; Type: TYPE; Schema: public; Owner: admin
--

CREATE TYPE fltrendhead AS (
	fltrendhead_flhead_id integer,
	fltrendhead_username text,
	fltrendhead_typedescrip text,
	fltrendhead_flhead_name text,
	fltrendhead_fld1 text,
	fltrendhead_fld2 text,
	fltrendhead_fld3 text,
	fltrendhead_fld4 text,
	fltrendhead_fld5 text,
	fltrendhead_fld6 text,
	fltrendhead_fld7 text,
	fltrendhead_fld8 text,
	fltrendhead_fld9 text,
	fltrendhead_fld10 text,
	fltrendhead_fld11 text,
	fltrendhead_fld12 text,
	fltrendhead_grndttl text
);


ALTER TYPE public.fltrendhead OWNER TO admin;

--
-- TOC entry 2678 (class 1247 OID 146565203)
-- Dependencies: 8 175
-- Name: fltrenditem; Type: TYPE; Schema: public; Owner: admin
--

CREATE TYPE fltrenditem AS (
	fltrenditem_flhead_id integer,
	fltrenditem_username text,
	fltrenditem_order integer,
	fltrenditem_level integer,
	fltrenditem_subgrp integer,
	fltrenditem_type text,
	fltrenditem_type_id integer,
	fltrenditem_parent_id integer,
	fltrenditem_accnt_id integer,
	fltrenditem_name text,
	fltrenditem_fld1 text,
	fltrenditem_fld2 text,
	fltrenditem_fld3 text,
	fltrenditem_fld4 text,
	fltrenditem_fld5 text,
	fltrenditem_fld6 text,
	fltrenditem_fld7 text,
	fltrenditem_fld8 text,
	fltrenditem_fld9 text,
	fltrenditem_fld10 text,
	fltrenditem_fld11 text,
	fltrenditem_fld12 text,
	fltrenditem_grndttl text
);


ALTER TYPE public.fltrenditem OWNER TO admin;

--
-- TOC entry 2681 (class 1247 OID 146565206)
-- Dependencies: 8 176
-- Name: freightdata; Type: TYPE; Schema: public; Owner: admin
--

CREATE TYPE freightdata AS (
	freightdata_schedule text,
	freightdata_from text,
	freightdata_to text,
	freightdata_shipvia text,
	freightdata_freightclass text,
	freightdata_weight numeric,
	freightdata_uom text,
	freightdata_price numeric,
	freightdata_type text,
	freightdata_total numeric,
	freightdata_currency text
);


ALTER TYPE public.freightdata OWNER TO admin;

--
-- TOC entry 2684 (class 1247 OID 146565209)
-- Dependencies: 8 177
-- Name: itemprice; Type: TYPE; Schema: public; Owner: admin
--

CREATE TYPE itemprice AS (
	itemprice_price numeric,
	itemprice_type character(1)
);


ALTER TYPE public.itemprice OWNER TO admin;

--
-- TOC entry 2687 (class 1247 OID 146565212)
-- Dependencies: 8 178
-- Name: orderitemtype; Type: TYPE; Schema: public; Owner: admin
--

CREATE TYPE orderitemtype AS (
	orderitem_id integer,
	orderitem_orderhead_type text,
	orderitem_orderhead_id integer,
	orderitem_linenumber integer,
	orderitem_status text,
	orderitem_itemsite_id integer,
	orderitem_scheddate date,
	orderitem_qty_ordered numeric,
	orderitem_qty_shipped numeric,
	orderitem_qty_received numeric,
	orderitem_qty_uom_id integer,
	orderitem_qty_invuomratio numeric,
	orderitem_unitcost numeric,
	orderitem_unitcost_curr_id integer,
	orderitem_freight numeric,
	orderitem_freight_received numeric,
	orderitem_freight_curr_id integer
);


ALTER TYPE public.orderitemtype OWNER TO admin;

--
-- TOC entry 2690 (class 1247 OID 146565215)
-- Dependencies: 8 179
-- Name: ordhead; Type: TYPE; Schema: public; Owner: admin
--

CREATE TYPE ordhead AS (
	orderhead_id integer,
	orderhead_type text,
	orderhead_number text,
	orderhead_status text,
	orderhead_orderdate date,
	orderhead_linecount integer,
	orderhead_from_id integer,
	orderhead_from text,
	orderhead_to_id integer,
	orderhead_to text,
	orderhead_curr_id integer,
	orderhead_agent_username text,
	orderhead_shipvia text
);


ALTER TYPE public.ordhead OWNER TO admin;

--
-- TOC entry 2693 (class 1247 OID 146565218)
-- Dependencies: 8 180
-- Name: orditem; Type: TYPE; Schema: public; Owner: admin
--

CREATE TYPE orditem AS (
	orderitem_id integer,
	orderitem_orderhead_type text,
	orderitem_orderhead_id integer,
	orderitem_linenumber integer,
	orderitem_status text,
	orderitem_itemsite_id integer,
	orderitem_scheddate date,
	orderitem_qty_ordered numeric,
	orderitem_qty_shipped numeric,
	orderitem_qty_received numeric,
	orderitem_qty_uom_id integer,
	orderitem_qty_invuomratio numeric,
	orderitem_unitcost numeric,
	orderitem_unitcost_curr_id integer,
	orderitem_freight numeric,
	orderitem_freight_received numeric,
	orderitem_freight_curr_id integer
);


ALTER TYPE public.orditem OWNER TO admin;

--
-- TOC entry 2696 (class 1247 OID 146565221)
-- Dependencies: 8 181
-- Name: reordlvl; Type: TYPE; Schema: public; Owner: admin
--

CREATE TYPE reordlvl AS (
	reordlvl_itemsite_id integer,
	reordlvl_item_id integer,
	reordlvl_warehous_code text,
	reordlvl_item_number text,
	reordlvl_item_descrip text,
	reordlvl_leadtime integer,
	reordlvl_daysofstock integer,
	reordlvl_curr_level numeric,
	reordlvl_total_days numeric,
	reordlvl_total_usage numeric,
	reordlvl_calc_level integer
);


ALTER TYPE public.reordlvl OWNER TO admin;

--
-- TOC entry 2699 (class 1247 OID 146565224)
-- Dependencies: 8 182
-- Name: seqiss; Type: TYPE; Schema: public; Owner: admin
--

CREATE TYPE seqiss AS (
	seqiss_number integer,
	seqiss_time timestamp with time zone
);


ALTER TYPE public.seqiss OWNER TO admin;

--
-- TOC entry 2702 (class 1247 OID 146565227)
-- Dependencies: 8 183
-- Name: subtax; Type: TYPE; Schema: public; Owner: admin
--

CREATE TYPE subtax AS (
	subtax_taxcode_id integer,
	subtax_taxcode_code text,
	subtax_taxcode_descrip text,
	subtax_taxcode_level integer
);


ALTER TYPE public.subtax OWNER TO admin;

--
-- TOC entry 2705 (class 1247 OID 146565230)
-- Dependencies: 8 184
-- Name: taxassign; Type: TYPE; Schema: public; Owner: admin
--

CREATE TYPE taxassign AS (
	taxassign_taxzone_id integer,
	taxassign_taxtype_id integer,
	taxassign_level integer,
	taxassign_zone_code text,
	taxassign_type_descrip text,
	taxassign_taxclass_code text,
	taxassign_taxclass_sequence integer
);


ALTER TYPE public.taxassign OWNER TO admin;

--
-- TOC entry 2708 (class 1247 OID 146565233)
-- Dependencies: 8 185
-- Name: taxdetail; Type: TYPE; Schema: public; Owner: admin
--

CREATE TYPE taxdetail AS (
	taxdetail_tax_id integer,
	taxdetail_tax_code text,
	taxdetail_tax_descrip text,
	taxdetail_tax_basis_tax_id integer,
	taxdetail_taxrate_percent numeric(10,6),
	taxdetail_taxrate_amount numeric(16,2),
	taxdetail_level integer,
	taxdetail_taxclass_id integer,
	taxdetail_taxclass_code text,
	taxdetail_taxclass_sequence integer,
	taxdetail_tax numeric(16,6),
	taxdetail_curr_id integer,
	taxdetail_curr_abbr text
);


ALTER TYPE public.taxdetail OWNER TO admin;

--
-- TOC entry 2711 (class 1247 OID 146565236)
-- Dependencies: 8 186
-- Name: wodata; Type: TYPE; Schema: public; Owner: admin
--

CREATE TYPE wodata AS (
	wodata_id integer,
	wodata_id_type integer,
	wodata_number integer,
	wodata_subnumber integer,
	wodata_itemnumber text,
	wodata_descrip text,
	wodata_status character(1),
	wodata_startdate date,
	wodata_duedate date,
	wodata_adhoc boolean,
	wodata_itemsite_id integer,
	wodata_listprice numeric,
	wodata_custprice numeric,
	wodata_qoh numeric,
	wodata_short numeric,
	wodata_qtyper numeric,
	wodata_qtyiss numeric,
	wodata_qtyrcv numeric,
	wodata_qtyordreq numeric,
	wodata_qtyuom text,
	wodata_scrap numeric,
	wodata_setup numeric,
	wodata_run numeric,
	wodata_notes text,
	wodata_ref text,
	wodata_level integer
);


ALTER TYPE public.wodata OWNER TO admin;

--
-- TOC entry 2714 (class 1247 OID 146565239)
-- Dependencies: 8 187
-- Name: woinvav; Type: TYPE; Schema: public; Owner: admin
--

CREATE TYPE woinvav AS (
	woinvav_itemsite_id integer,
	woinvav_womatl_id integer,
	woinvav_type character(1),
	woinvav_item_wo_number text,
	woinvav_descrip text,
	woinvav_uomname text,
	woinvav_qoh numeric,
	woinvav_balance numeric,
	woinvav_allocated numeric,
	woinvav_ordered numeric,
	woinvav_woavail numeric,
	woinvav_totalavail numeric,
	woinvav_reorderlevel numeric,
	woinvav_level integer
);


ALTER TYPE public.woinvav OWNER TO admin;

SET search_path = api, pg_catalog;

--
-- TOC entry 901 (class 1255 OID 146565243)
-- Dependencies: 4536 6
-- Name: getcustnumberfrominfo(text, text, text, text, text, boolean); Type: FUNCTION; Schema: api; Owner: admin
--

CREATE FUNCTION getcustnumberfrominfo(text, text, text, text, text, boolean) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _email	TEXT	:= COALESCE(UPPER($1), '');
  _company	TEXT	:= COALESCE(UPPER($2), '');
  _first	TEXT	:= COALESCE(UPPER($3), '');
  _last		TEXT	:= COALESCE(UPPER($4), '');
  _fullname	TEXT	:= COALESCE(UPPER($5), TRIM(_first || ' ' || _last));
  _generate	BOOLEAN	:= COALESCE($6, FALSE);
  _counter	INTEGER;
  _custcount	INTEGER	:= 0;
  _custnumber	TEXT;
  _candidate	TEXT	:= '';
  _loopmax	INTEGER := 0;
  _minlength	INTEGER := 5;
  _maxlength	INTEGER := 8;
  _numformat	TEXT	:= '';
  _testme	TEXT;
BEGIN
  IF (_email != '') THEN
    SELECT count(*), cust_number INTO _custcount, _custnumber
    FROM custinfo LEFT OUTER JOIN cntct ON (cust_cntct_id=cntct_id)
    WHERE (UPPER(cntct_email)=_email)
    GROUP BY cust_number;
    IF (NOT FOUND) THEN
      _custcount := 0;
    ELSIF(_custcount = 1) THEN
      RETURN _custnumber;
    END IF;
  END IF;

  IF (_company != '') THEN
    SELECT count(*), cust_number INTO _custcount, _custnumber
    FROM custinfo
    WHERE (UPPER(cust_name)=_company)
    GROUP BY cust_number;
    IF (NOT FOUND) THEN
      _custcount := 0;
    ELSIF(_custcount = 1) THEN
      RETURN _custnumber;
    END IF;
  END IF;

  IF (_fullname = '' AND (_first != '' OR _last != '')) THEN
    _fullname := TRIM(_first || ' ' || _last);
  END IF;

  IF (_custcount <= 0 AND _fullname != '') THEN
    SELECT count(*), cust_number INTO _custcount, _custnumber
    FROM custinfo
    WHERE (UPPER(cust_name)=_fullname)
    GROUP BY cust_number;
    IF (NOT FOUND) THEN
      _custcount := 0;
    ELSIF(_custcount = 1) THEN
      RETURN _custnumber;
    END IF;
  END IF;

  IF (_custcount > 1) THEN
    RAISE EXCEPTION 'Found % possible Customers for % and % and %',
		    _custcount, _email, _company, _fullname;
  END IF;

  IF (_custcount <= 0 AND _generate) THEN
    IF (_maxlength < _minlength) THEN
      RAISE EXCEPTION 'Fix getCustNumberFromInfo: max length < min length';
    END IF;

    IF (_company != '') THEN
      _candidate := _company;
    ELSIF (_email != '') THEN
      _candidate := SUBSTRING(_email FOR POSITION('@' IN _email) - 1);
    ELSIF (_last != '') THEN
      _candidate := _last;
      IF (_first != '') THEN
	_candidate := _candidate || _first;
      END IF;
    ELSIF (_fullname != '' AND (POSITION(' ' IN _fullname) > 0)) THEN
      _candidate := SUBSTRING(_fullname FROM POSITION(' ' IN _fullname) + 1) ||
		    SUBSTRING(_fullname FOR  POSITION(' ' IN _fullname) - 1);
    END IF;
    WHILE (POSITION(' ' IN _candidate) > 0) LOOP
      _candidate := SUBSTRING(_candidate FOR  POSITION(' ' IN _candidate) - 1) ||
		    SUBSTRING(_candidate FROM POSITION(' ' IN _candidate) + 1);
    END LOOP;
    FOR _counter IN _minlength.._maxlength LOOP
      _testme := SUBSTRING(_candidate FOR _counter);
      IF (NOT EXISTS(SELECT cust_number
		     FROM custinfo
		     WHERE (cust_number=_testme))) THEN
	_custnumber := _testme;
	EXIT;
      END IF;
    END LOOP;
    IF (_custnumber IS NULL OR _custnumber = '') THEN
      IF (LENGTH(_candidate) < _minlength) THEN
	_minlength := LENGTH(_candidate);
      END IF;
      FOR _counter IN _minlength.._maxlength LOOP
	_loopmax := _loopmax * 10 + 9;
	_numformat := _numformat || '0';
      END LOOP;
      FOR _counter IN 1.._loopmax LOOP
	_testme := SUBSTRING(_candidate FOR _minlength) ||
		   TRIM(TO_CHAR(_counter, _numformat));
	IF (NOT EXISTS(SELECT cust_number
		       FROM custinfo
		       WHERE (cust_number=_testme))) THEN
	  _custnumber := _testme;
	  EXIT;
	END IF;
      END LOOP;
    END IF;
    IF (_custnumber IS NULL OR _custnumber = '') THEN
      RAISE EXCEPTION 'Could not generate a new Customer Number';
    END IF;
  END IF;

  IF (_custnumber IS NULL OR _custnumber = '') THEN
    RAISE EXCEPTION 'Could not find Customer Number for % and % and %',
		    _email, _company, _fullname;
  END IF;

  RETURN _custnumber;
END;
$_$;


ALTER FUNCTION api.getcustnumberfrominfo(text, text, text, text, text, boolean) OWNER TO admin;

SET search_path = public, pg_catalog;

--
-- TOC entry 902 (class 1255 OID 146565244)
-- Dependencies: 4536 8
-- Name: formatlocationname(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatlocationname(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pLocationid ALIAS FOR $1;
  _name TEXT;
  _r RECORD;

BEGIN

  SELECT location_aisle, location_rack,
         location_bin, location_name INTO _r
  FROM location
  WHERE (location_id=pLocationid);
  IF (FOUND) THEN
    IF (_r.location_aisle IS NOT NULL) THEN
      _name := _r.location_aisle;
    ELSE
      _name := '';
    END IF;

    IF (_r.location_rack IS NOT NULL) THEN
      _name := (_name || _r.location_rack);
    END IF;

    IF (_r.location_bin IS NOT NULL) THEN
      _name := (_name || _r.location_bin);
    END IF;

    IF (_r.location_name IS NOT NULL) THEN
      _name := (_name || _r.location_name);
    END IF;

    RETURN _name;
  ELSE
    RETURN 'N/A';
  END IF;

END;
$_$;


ALTER FUNCTION public.formatlocationname(integer) OWNER TO admin;

SET default_tablespace = '';

SET default_with_oids = false;

--
-- TOC entry 189 (class 1259 OID 146565245)
-- Dependencies: 5838 8
-- Name: cntslip; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE cntslip (
    cntslip_id integer DEFAULT nextval(('"cntslip_cntslip_id_seq"'::text)::regclass) NOT NULL,
    cntslip_cnttag_id integer,
    cntslip_entered timestamp with time zone,
    cntslip_posted boolean,
    cntslip_number text,
    cntslip_qty numeric(18,6),
    cntslip_comments text,
    cntslip_location_id integer,
    cntslip_lotserial text,
    cntslip_lotserial_expiration date,
    cntslip_lotserial_warrpurc date,
    cntslip_username text
);


ALTER TABLE public.cntslip OWNER TO admin;

--
-- TOC entry 8908 (class 0 OID 0)
-- Dependencies: 189
-- Name: TABLE cntslip; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE cntslip IS 'Count Slip information';


--
-- TOC entry 190 (class 1259 OID 146565252)
-- Dependencies: 5839 8
-- Name: invcnt; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE invcnt (
    invcnt_id integer DEFAULT nextval(('invcnt_invcnt_id_seq'::text)::regclass) NOT NULL,
    invcnt_itemsite_id integer,
    invcnt_tagdate timestamp with time zone,
    invcnt_cntdate timestamp with time zone,
    invcnt_qoh_before numeric(18,6),
    invcnt_qoh_after numeric(18,6),
    invcnt_matcost numeric(16,6),
    invcnt_posted boolean,
    invcnt_postdate timestamp with time zone,
    invcnt_comments text,
    invcnt_priority boolean,
    invcnt_tagnumber text,
    invcnt_invhist_id integer,
    invcnt_location_id integer,
    invcnt_cnt_username text,
    invcnt_post_username text,
    invcnt_tag_username text
);


ALTER TABLE public.invcnt OWNER TO admin;

--
-- TOC entry 8910 (class 0 OID 0)
-- Dependencies: 190
-- Name: TABLE invcnt; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE invcnt IS 'Count Tag information';


--
-- TOC entry 191 (class 1259 OID 146565259)
-- Dependencies: 5840 5841 5842 5843 5844 5845 5846 5847 5848 5849 5850 5851 5852 5853 8
-- Name: item; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE item (
    item_id integer DEFAULT nextval(('item_item_id_seq'::text)::regclass) NOT NULL,
    item_number text NOT NULL,
    item_descrip1 text NOT NULL,
    item_descrip2 text NOT NULL,
    item_classcode_id integer NOT NULL,
    item_picklist boolean DEFAULT true NOT NULL,
    item_comments text,
    item_sold boolean NOT NULL,
    item_fractional boolean NOT NULL,
    item_active boolean NOT NULL,
    item_type character(1) DEFAULT 'R'::bpchar NOT NULL,
    item_prodweight numeric(16,2) DEFAULT 0 NOT NULL,
    item_packweight numeric(16,2) DEFAULT 0 NOT NULL,
    item_prodcat_id integer NOT NULL,
    item_exclusive boolean DEFAULT false NOT NULL,
    item_listprice numeric(16,4) NOT NULL,
    item_config boolean DEFAULT false,
    item_extdescrip text,
    item_upccode text,
    item_maxcost numeric(16,6) DEFAULT 0 NOT NULL,
    item_inv_uom_id integer NOT NULL,
    item_price_uom_id integer NOT NULL,
    item_warrdays integer DEFAULT 0,
    item_freightclass_id integer,
    item_tax_recoverable boolean DEFAULT false NOT NULL,
    item_listcost numeric(16,6) DEFAULT 0.0 NOT NULL,
    CONSTRAINT item_item_number_check CHECK ((item_number <> ''::text)),
    CONSTRAINT item_item_type_check CHECK (((((((((((((item_type = 'P'::bpchar) OR (item_type = 'M'::bpchar)) OR (item_type = 'F'::bpchar)) OR (item_type = 'O'::bpchar)) OR (item_type = 'R'::bpchar)) OR (item_type = 'S'::bpchar)) OR (item_type = 'T'::bpchar)) OR (item_type = 'B'::bpchar)) OR (item_type = 'L'::bpchar)) OR (item_type = 'Y'::bpchar)) OR (item_type = 'C'::bpchar)) OR (item_type = 'K'::bpchar))),
    CONSTRAINT item_sold_check CHECK ((NOT (item_sold AND (item_prodcat_id = (-1)))))
);


ALTER TABLE public.item OWNER TO admin;


--
-- TOC entry 192 (class 1259 OID 146565279)
-- Dependencies: 5854 5855 5856 5857 5858 5859 5860 5861 5862 5863 5864 5865 5866 5867 5868 5869 5870 5871 5872 5873 5874 5875 5876 5877 5878 5879 5880 8
-- Name: itemsite; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE itemsite (
    itemsite_id integer DEFAULT nextval(('itemsite_itemsite_id_seq'::text)::regclass) NOT NULL,
    itemsite_item_id integer NOT NULL,
    itemsite_warehous_id integer,
    itemsite_qtyonhand numeric(18,6) NOT NULL,
    itemsite_reorderlevel numeric(18,6) NOT NULL,
    itemsite_ordertoqty numeric(18,6) NOT NULL,
    itemsite_cyclecountfreq integer NOT NULL,
    itemsite_datelastcount date,
    itemsite_datelastused date,
    itemsite_loccntrl boolean NOT NULL,
    itemsite_safetystock numeric(18,6) NOT NULL,
    itemsite_minordqty numeric(18,6) NOT NULL,
    itemsite_multordqty numeric(18,6) NOT NULL,
    itemsite_leadtime integer NOT NULL,
    itemsite_abcclass character(1),
    itemsite_issuemethod character(1),
    itemsite_controlmethod character(1),
    itemsite_active boolean NOT NULL,
    itemsite_plancode_id integer NOT NULL,
    itemsite_costcat_id integer NOT NULL,
    itemsite_eventfence integer NOT NULL,
    itemsite_sold boolean NOT NULL,
    itemsite_stocked boolean NOT NULL,
    itemsite_freeze boolean DEFAULT false NOT NULL,
    itemsite_location_id integer NOT NULL,
    itemsite_useparams boolean NOT NULL,
    itemsite_useparamsmanual boolean NOT NULL,
    itemsite_soldranking integer DEFAULT 1,
    itemsite_createpr boolean,
    itemsite_location text,
    itemsite_location_comments text,
    itemsite_notes text,
    itemsite_perishable boolean NOT NULL,
    itemsite_nnqoh numeric(18,6) DEFAULT 0 NOT NULL,
    itemsite_autoabcclass boolean NOT NULL,
    itemsite_ordergroup integer DEFAULT 1 NOT NULL,
    itemsite_disallowblankwip boolean DEFAULT false NOT NULL,
    itemsite_maxordqty numeric(18,6) DEFAULT 0.0 NOT NULL,
    itemsite_mps_timefence integer DEFAULT 0 NOT NULL,
    itemsite_createwo boolean DEFAULT false NOT NULL,
    itemsite_warrpurc boolean DEFAULT false NOT NULL,
    itemsite_autoreg boolean DEFAULT false,
    itemsite_costmethod character(1) NOT NULL,
    itemsite_value numeric(12,2) NOT NULL,
    itemsite_ordergroup_first boolean DEFAULT false NOT NULL,
    itemsite_supply_itemsite_id integer,
    itemsite_planning_type character(1) DEFAULT 'M'::bpchar NOT NULL,
    itemsite_wosupply boolean DEFAULT false NOT NULL,
    itemsite_posupply boolean DEFAULT false NOT NULL,
    itemsite_lsseq_id integer,
    itemsite_cosdefault character(1),
    itemsite_createsopr boolean DEFAULT false,
    itemsite_createsopo boolean DEFAULT false,
    itemsite_dropship boolean DEFAULT false,
    itemsite_recvlocation_id integer DEFAULT (-1) NOT NULL,
    itemsite_issuelocation_id integer DEFAULT (-1) NOT NULL,
    itemsite_location_dist boolean DEFAULT false NOT NULL,
    itemsite_recvlocation_dist boolean DEFAULT false NOT NULL,
    itemsite_issuelocation_dist boolean DEFAULT false NOT NULL,
    CONSTRAINT itemsite_itemsite_abcclass_check CHECK (((((itemsite_abcclass = 'A'::bpchar) OR (itemsite_abcclass = 'B'::bpchar)) OR (itemsite_abcclass = 'C'::bpchar)) OR (itemsite_abcclass = 'T'::bpchar))),
    CONSTRAINT itemsite_itemsite_controlmethod_check CHECK (((((itemsite_controlmethod = 'N'::bpchar) OR (itemsite_controlmethod = 'R'::bpchar)) OR (itemsite_controlmethod = 'S'::bpchar)) OR (itemsite_controlmethod = 'L'::bpchar))),
    CONSTRAINT itemsite_itemsite_costmethod_check CHECK (((((itemsite_costmethod = 'N'::bpchar) OR (itemsite_costmethod = 'A'::bpchar)) OR (itemsite_costmethod = 'S'::bpchar)) OR (itemsite_costmethod = 'J'::bpchar))),
    CONSTRAINT itemsite_itemsite_ordergroup_check CHECK ((itemsite_ordergroup > 0))
);


ALTER TABLE public.itemsite OWNER TO admin;


--
-- TOC entry 193 (class 1259 OID 146565312)
-- Dependencies: 5881 5882 5883 5884 5885 5886 8
-- Name: whsinfo; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE whsinfo (
    warehous_id integer DEFAULT nextval(('warehous_warehous_id_seq'::text)::regclass) NOT NULL,
    warehous_code text NOT NULL,
    warehous_descrip text,
    warehous_fob text,
    warehous_active boolean,
    warehous_counttag_prefix text,
    warehous_counttag_number integer,
    warehous_bol_prefix text,
    warehous_bol_number integer,
    warehous_shipping boolean,
    warehous_useslips boolean,
    warehous_usezones boolean,
    warehous_aislesize integer,
    warehous_aislealpha boolean,
    warehous_racksize integer,
    warehous_rackalpha boolean,
    warehous_binsize integer,
    warehous_binalpha boolean,
    warehous_locationsize integer,
    warehous_locationalpha boolean,
    warehous_enforcearbl boolean,
    warehous_default_accnt_id integer,
    warehous_shipping_commission numeric(8,4) DEFAULT 0.00,
    warehous_cntct_id integer,
    warehous_addr_id integer,
    warehous_transit boolean DEFAULT false NOT NULL,
    warehous_shipform_id integer,
    warehous_shipvia_id integer,
    warehous_shipcomments text,
    warehous_costcat_id integer,
    warehous_sitetype_id integer,
    warehous_taxzone_id integer,
    warehous_sequence integer DEFAULT 0 NOT NULL,
    CONSTRAINT whsinfo_check CHECK (((warehous_transit AND (warehous_costcat_id IS NOT NULL)) OR (NOT warehous_transit))),
    CONSTRAINT whsinfo_warehous_code_check CHECK ((warehous_code <> ''::text))
);


ALTER TABLE public.whsinfo OWNER TO admin;


SET search_path = api, pg_catalog;

--
-- TOC entry 194 (class 1259 OID 146565324)
-- Dependencies: 8469 6
-- Name: physinvcount; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW physinvcount AS
    SELECT whsinfo.warehous_code AS site, item.item_number, invcnt.invcnt_tagnumber AS tag_number, cntslip.cntslip_qty AS quantity, public.formatlocationname(cntslip.cntslip_location_id) AS location, cntslip.cntslip_lotserial AS lotserial, cntslip.cntslip_comments AS comment FROM ((((public.invcnt JOIN public.itemsite ON ((itemsite.itemsite_id = invcnt.invcnt_itemsite_id))) JOIN public.whsinfo ON ((whsinfo.warehous_id = itemsite.itemsite_warehous_id))) JOIN public.item ON ((item.item_id = itemsite.itemsite_item_id))) LEFT JOIN public.cntslip ON ((cntslip.cntslip_cnttag_id = invcnt.invcnt_id)));


ALTER TABLE api.physinvcount OWNER TO admin;

--
-- TOC entry 8924 (class 0 OID 0)
-- Dependencies: 194
-- Name: VIEW physinvcount; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW physinvcount IS 'Physical Inventory Count Tag and Slip';


--
-- TOC entry 906 (class 1255 OID 146565329)
-- Dependencies: 2740 4536 6
-- Name: insertphysinvcount(physinvcount); Type: FUNCTION; Schema: api; Owner: admin
--

CREATE FUNCTION insertphysinvcount(physinvcount) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pNEW ALIAS FOR $1;
  _itemid INTEGER;
  _type TEXT;
  _siteid INTEGER;
  _itemsiteid INTEGER;
  _controlmethod TEXT;
  _loccntrl BOOLEAN;
  _locationid INTEGER;
  _lsid INTEGER;
  _invcntid INTEGER;
  _cntslipid INTEGER;
  _result INTEGER;

BEGIN

  -- Check Item
  SELECT item_id, item_type INTO _itemid, _type
  FROM item
  WHERE (item_number=UPPER(pNEW.item_number));
  IF (NOT FOUND OR _type IN ('F', 'R', 'L','J')) THEN
    SELECT item_id, item_type INTO _itemid, _type
    FROM item
    WHERE (item_upccode=pNEW.item_number);
    IF (NOT FOUND OR _type IN ('F', 'R', 'L','J')) THEN
      RAISE EXCEPTION 'Function insertPhysInvCount failed because Item % not found or invalid type', pNEW.item_number;
    END IF;
  END IF;

  -- Check Site
  SELECT warehous_id INTO _siteid
  FROM whsinfo
  WHERE (warehous_code=COALESCE(pNEW.site, (SELECT warehous_code
                                            FROM usrpref,whsinfo
                                            WHERE (usrpref_username=getEffectiveXtUser())
                                              AND (usrpref_name='PreferredWarehouse')
                                              AND (warehous_id=CAST(usrpref_value AS INTEGER)))));
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Function insertPhysInvCount failed because Site % not found', pNEW.site;
  END IF;

  -- Check Itemsite
  SELECT itemsite_id, itemsite_controlmethod, itemsite_loccntrl INTO _itemsiteid, _controlmethod, _loccntrl
  FROM itemsite
  WHERE (itemsite_item_id=_itemid)
    AND (itemsite_warehous_id=_siteid);
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Function insertPhysInvCount failed because Itemsite %, % not found', pNEW.site, pNEW.item_number;
  END IF;
  IF (_controlmethod = 'N') THEN
    RAISE EXCEPTION 'Function insertPhysInvCount failed because Itemsite %, % not inventory control method', pNEW.site, pNEW.item_number;
  END IF;
  IF (_controlmethod IN ('L', 'S') AND COALESCE(pNEW.lotserial, '') = '') THEN
    RAISE EXCEPTION 'Function insertPhysInvCount failed because Itemsite %, % lot/serial controlled and lotserial not provided', pNEW.site, pNEW.item_number;
  END IF;
  IF (_controlmethod = 'S') THEN
    -- Check for unique serial id
    SELECT ls_id INTO _lsid
    FROM ls
    WHERE (ls_number=pNEW.lotserial);
    IF (FOUND) THEN
      RAISE EXCEPTION 'Function insertPhysInvCount failed because Serial %, %, % not unique', pNEW.site, pNEW.item_number, pNEW.lotserial;
    END IF;
  END IF;
  IF (_loccntrl) THEN
    IF (pNEW.location IS NULL) THEN
      RAISE EXCEPTION 'Function insertPhysInvCount failed because Itemsite %, % multi location and location not provided', pNEW.site, pNEW.item_number;
    ELSE
      -- Check Location
      SELECT location_id INTO _locationid
      FROM location
      WHERE (location_id=getLocationId(pNEW.site, pNEW.location));
      IF (NOT FOUND) THEN
        RAISE EXCEPTION 'Function insertPhysInvCount failed because Location %, % not found', pNEW.site, pNEW.location;
      END IF;
    END IF;
  END IF;

  -- Create Count Tag
  SELECT CreateCountTag(_itemsiteid, pNEW.comment, FALSE, FALSE) INTO _invcntid;
  IF (_invcntid <= 0) THEN
    RAISE EXCEPTION 'Function insertPhysInvCount failed because CreateCountTag failed for Itemsite %, %', pNEW.site, pNEW.item_number;
  END IF;

  -- Create Count Slip
  INSERT INTO cntslip
  ( cntslip_cnttag_id,
    cntslip_username, cntslip_entered, cntslip_posted,
    cntslip_number, cntslip_qty,
    cntslip_location_id, cntslip_lotserial,
    cntslip_lotserial_expiration,
    cntslip_lotserial_warrpurc,
    cntslip_comments )
  VALUES
  ( _invcntid,
    getEffectiveXtUser(), CURRENT_TIMESTAMP, FALSE,
    'N/A', pNEW.quantity,
    COALESCE(_locationid, -1), pNEW.lotserial,
    NULL,
    NULL,
    pNEW.comment )
  RETURNING cntslip_id INTO _cntslipid;

  -- Post Count Slip
  SELECT postCountSlip(_cntslipid) INTO _result;
  IF (_result < 0) THEN
    RAISE EXCEPTION 'Function insertPhysInvCount failed because postCountSlip failed for Itemsite %, %, %', pNEW.site, pNEW.item_number, _result;
  END IF;

  RETURN TRUE;
END;
$_$;


ALTER FUNCTION api.insertphysinvcount(physinvcount) OWNER TO admin;

SET search_path = public, pg_catalog;

--
-- TOC entry 907 (class 1255 OID 146565330)
-- Dependencies: 4536 8
-- Name: basecurrid(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION basecurrid() RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  returnVal INTEGER;
BEGIN
  SELECT curr_id INTO returnVal
    FROM curr_symbol
   WHERE curr_base = TRUE;
  IF NOT FOUND THEN
    RAISE EXCEPTION 'No base currency found';
  END IF;
  RETURN returnVal;
END;
$$;


ALTER FUNCTION public.basecurrid() OWNER TO admin;

--
-- TOC entry 908 (class 1255 OID 146565331)
-- Dependencies: 4536 8
-- Name: formatglaccount(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatglaccount(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pAccntid ALIAS FOR $1;
  _accnt RECORD;

BEGIN

  SELECT COALESCE(accnt_company, '') AS accnt_company,
         COALESCE(accnt_profit, '') AS accnt_profit,
         accnt_number,
         COALESCE(accnt_sub, '') AS accnt_sub INTO _accnt
  FROM accnt
  WHERE (accnt_id=pAccntid);

  IF (NOT FOUND) THEN
    RETURN 'Error';
  END IF;

  RETURN formatGlAccount(_accnt.accnt_company, _accnt.accnt_profit, _accnt.accnt_number, _accnt.accnt_sub);

END;
$_$;


ALTER FUNCTION public.formatglaccount(integer) OWNER TO admin;

--
-- TOC entry 909 (class 1255 OID 146565332)
-- Dependencies: 4536 8
-- Name: formatsolinenumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatsolinenumber(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSoitemid ALIAS FOR $1;
  _r RECORD;

BEGIN

  SELECT coitem_linenumber, coitem_subnumber
    INTO _r
    FROM coitem
   WHERE(coitem_id=pSoitemid);

  IF(NOT FOUND) THEN
    RETURN NULL;
  END IF;

  IF(COALESCE(_r.coitem_subnumber, 0) > 0) THEN
    RETURN _r.coitem_linenumber || '.' || _r.coitem_subnumber;
  END IF;

  RETURN _r.coitem_linenumber;
END;
$_$;


ALTER FUNCTION public.formatsolinenumber(integer) OWNER TO admin;

--
-- TOC entry 910 (class 1255 OID 146565333)
-- Dependencies: 4536 8
-- Name: geteffectivextuser(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION geteffectivextuser() RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
/*
  The default return value of this function is simply
  the user currently connected.

  Overload this function from another schema
  to implement specific user handling from an external
  application that uses connection pooling.
  Use setEffectiveXtUser(text) to create a temporary table that
  inserts user data that can in turn be used as a lookup
  reference for an over loaded version of this function like so:

  SELECT effective_value
  FROM effective_user
  WHERE effective_key = 'username'
*/

  RETURN CURRENT_USER;

END;
$$;


ALTER FUNCTION public.geteffectivextuser() OWNER TO admin;

--
-- TOC entry 911 (class 1255 OID 146565334)
-- Dependencies: 4536 8
-- Name: getitemtaxtype(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getitemtaxtype(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pTaxzoneid ALIAS FOR $2;
  _taxtypeid INTEGER;
BEGIN
  SELECT itemtax_taxtype_id
    INTO _taxtypeid
    FROM itemtax
   WHERE ((itemtax_item_id=pItemid)
     AND  (itemtax_taxzone_id=pTaxzoneid));
  IF (NOT FOUND) THEN
    SELECT itemtax_taxtype_id
      INTO _taxtypeid
      FROM itemtax
     WHERE ((itemtax_item_id=pItemid)
       AND  (itemtax_taxzone_id IS NULL));
    IF (NOT FOUND) THEN
      RETURN NULL;
    END IF;
  END IF;

  RETURN _taxtypeid;
END;
$_$;


ALTER FUNCTION public.getitemtaxtype(integer, integer) OWNER TO admin;

--
-- TOC entry 195 (class 1259 OID 146565335)
-- Dependencies: 5887 5888 5889 5890 5891 5892 5893 5894 5895 5896 5897 5898 5899 8
-- Name: cohead; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE cohead (
    cohead_id integer DEFAULT nextval(('cohead_cohead_id_seq'::text)::regclass) NOT NULL,
    cohead_number text NOT NULL,
    cohead_cust_id integer NOT NULL,
    cohead_custponumber text,
    cohead_orderdate date,
    cohead_warehous_id integer,
    cohead_shipto_id integer,
    cohead_shiptoname text,
    cohead_shiptoaddress1 text,
    cohead_shiptoaddress2 text,
    cohead_shiptoaddress3 text,
    cohead_shiptoaddress4 text,
    cohead_shiptoaddress5 text,
    cohead_salesrep_id integer NOT NULL,
    cohead_terms_id integer NOT NULL,
    cohead_fob text,
    cohead_shipvia text,
    cohead_shiptocity text,
    cohead_shiptostate text,
    cohead_shiptozipcode text,
    cohead_freight numeric(16,4) NOT NULL,
    cohead_misc numeric(16,4) DEFAULT 0 NOT NULL,
    cohead_imported boolean DEFAULT false,
    cohead_ordercomments text,
    cohead_shipcomments text,
    cohead_shiptophone text,
    cohead_shipchrg_id integer,
    cohead_shipform_id integer,
    cohead_billtoname text,
    cohead_billtoaddress1 text,
    cohead_billtoaddress2 text,
    cohead_billtoaddress3 text,
    cohead_billtocity text,
    cohead_billtostate text,
    cohead_billtozipcode text,
    cohead_misc_accnt_id integer,
    cohead_misc_descrip text,
    cohead_commission numeric(16,4),
    cohead_miscdate date,
    cohead_holdtype character(1),
    cohead_packdate date,
    cohead_prj_id integer,
    cohead_wasquote boolean DEFAULT false NOT NULL,
    cohead_lastupdated timestamp without time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL,
    cohead_shipcomplete boolean DEFAULT false NOT NULL,
    cohead_created timestamp without time zone DEFAULT ('now'::text)::timestamp(6) with time zone,
    cohead_creator text DEFAULT geteffectivextuser(),
    cohead_quote_number text,
    cohead_billtocountry text,
    cohead_shiptocountry text,
    cohead_curr_id integer DEFAULT basecurrid(),
    cohead_calcfreight boolean DEFAULT false NOT NULL,
    cohead_shipto_cntct_id integer,
    cohead_shipto_cntct_honorific text,
    cohead_shipto_cntct_first_name text,
    cohead_shipto_cntct_middle text,
    cohead_shipto_cntct_last_name text,
    cohead_shipto_cntct_suffix text,
    cohead_shipto_cntct_phone text,
    cohead_shipto_cntct_title text,
    cohead_shipto_cntct_fax text,
    cohead_shipto_cntct_email text,
    cohead_billto_cntct_id integer,
    cohead_billto_cntct_honorific text,
    cohead_billto_cntct_first_name text,
    cohead_billto_cntct_middle text,
    cohead_billto_cntct_last_name text,
    cohead_billto_cntct_suffix text,
    cohead_billto_cntct_phone text,
    cohead_billto_cntct_title text,
    cohead_billto_cntct_fax text,
    cohead_billto_cntct_email text,
    cohead_taxzone_id integer,
    cohead_taxtype_id integer,
    cohead_ophead_id integer,
    cohead_status character(1) DEFAULT 'O'::bpchar NOT NULL,
    cohead_saletype_id integer,
    cohead_shipzone_id integer,
    CONSTRAINT cohead_check CHECK (((cohead_misc = (0)::numeric) OR ((cohead_misc <> (0)::numeric) AND (cohead_misc_accnt_id IS NOT NULL)))),
    CONSTRAINT cohead_cohead_number_check CHECK ((cohead_number <> ''::text))
);


ALTER TABLE public.cohead OWNER TO admin;


--
-- TOC entry 196 (class 1259 OID 146565354)
-- Dependencies: 5900 5901 5902 5903 5904 5905 5906 5907 5908 5909 5910 5911 8
-- Name: coitem; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE coitem (
    coitem_id integer DEFAULT nextval(('coitem_coitem_id_seq'::text)::regclass) NOT NULL,
    coitem_cohead_id integer,
    coitem_linenumber integer NOT NULL,
    coitem_itemsite_id integer,
    coitem_status character(1),
    coitem_scheddate date,
    coitem_promdate date,
    coitem_qtyord numeric(18,6) NOT NULL,
    coitem_unitcost numeric(16,6) NOT NULL,
    coitem_price numeric(16,4) NOT NULL,
    coitem_custprice numeric(16,4) NOT NULL,
    coitem_qtyshipped numeric(18,6) NOT NULL,
    coitem_order_id integer,
    coitem_memo text,
    coitem_imported boolean DEFAULT false,
    coitem_qtyreturned numeric(18,6),
    coitem_closedate timestamp with time zone,
    coitem_custpn text,
    coitem_order_type character(1),
    coitem_close_username text,
    coitem_lastupdated timestamp without time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL,
    coitem_substitute_item_id integer,
    coitem_created timestamp without time zone DEFAULT ('now'::text)::timestamp(6) with time zone,
    coitem_creator text DEFAULT geteffectivextuser(),
    coitem_prcost numeric(16,6),
    coitem_qty_uom_id integer NOT NULL,
    coitem_qty_invuomratio numeric(20,10) NOT NULL,
    coitem_price_uom_id integer NOT NULL,
    coitem_price_invuomratio numeric(20,10) NOT NULL,
    coitem_warranty boolean DEFAULT false NOT NULL,
    coitem_cos_accnt_id integer,
    coitem_qtyreserved numeric(18,6) DEFAULT 0.0 NOT NULL,
    coitem_subnumber integer DEFAULT 0 NOT NULL,
    coitem_firm boolean DEFAULT false NOT NULL,
    coitem_taxtype_id integer,
    coitem_rev_accnt_id integer,
    coitem_pricemode character(1) DEFAULT 'D'::bpchar NOT NULL,
    CONSTRAINT coitem_coitem_status_check CHECK ((((coitem_status = 'O'::bpchar) OR (coitem_status = 'C'::bpchar)) OR (coitem_status = 'X'::bpchar))),
    CONSTRAINT valid_coitem_pricemode CHECK ((coitem_pricemode = ANY (ARRAY['D'::bpchar, 'M'::bpchar])))
);


ALTER TABLE public.coitem OWNER TO admin;


--
-- TOC entry 197 (class 1259 OID 146565372)
-- Dependencies: 5912 5913 5914 5915 5916 5917 5918 5919 8
-- Name: pohead; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE pohead (
    pohead_id integer DEFAULT nextval(('pohead_pohead_id_seq'::text)::regclass) NOT NULL,
    pohead_status character(1),
    pohead_number text NOT NULL,
    pohead_orderdate date,
    pohead_vend_id integer,
    pohead_fob text,
    pohead_shipvia text,
    pohead_comments text,
    pohead_freight numeric(16,2) DEFAULT 0,
    pohead_printed boolean DEFAULT false,
    pohead_terms_id integer,
    pohead_warehous_id integer,
    pohead_vendaddr_id integer,
    pohead_agent_username text,
    pohead_curr_id integer DEFAULT basecurrid(),
    pohead_saved boolean DEFAULT true NOT NULL,
    pohead_taxzone_id integer,
    pohead_taxtype_id integer,
    pohead_dropship boolean DEFAULT false,
    pohead_vend_cntct_id integer,
    pohead_vend_cntct_honorific text,
    pohead_vend_cntct_first_name text,
    pohead_vend_cntct_middle text,
    pohead_vend_cntct_last_name text,
    pohead_vend_cntct_suffix text,
    pohead_vend_cntct_phone text,
    pohead_vend_cntct_title text,
    pohead_vend_cntct_fax text,
    pohead_vend_cntct_email text,
    pohead_vendaddress1 text,
    pohead_vendaddress2 text,
    pohead_vendaddress3 text,
    pohead_vendcity text,
    pohead_vendstate text,
    pohead_vendzipcode text,
    pohead_vendcountry text,
    pohead_shipto_cntct_id integer,
    pohead_shipto_cntct_honorific text,
    pohead_shipto_cntct_first_name text,
    pohead_shipto_cntct_middle text,
    pohead_shipto_cntct_last_name text,
    pohead_shipto_cntct_suffix text,
    pohead_shipto_cntct_phone text,
    pohead_shipto_cntct_title text,
    pohead_shipto_cntct_fax text,
    pohead_shipto_cntct_email text,
    pohead_shiptoaddress_id integer,
    pohead_shiptoaddress1 text,
    pohead_shiptoaddress2 text,
    pohead_shiptoaddress3 text,
    pohead_shiptocity text,
    pohead_shiptostate text,
    pohead_shiptozipcode text,
    pohead_shiptocountry text,
    pohead_cohead_id integer,
    pohead_released date,
    pohead_shiptoname text,
    CONSTRAINT pohead_pohead_number_check CHECK ((pohead_number <> ''::text)),
    CONSTRAINT pohead_pohead_status_check CHECK ((((pohead_status = 'U'::bpchar) OR (pohead_status = 'O'::bpchar)) OR (pohead_status = 'C'::bpchar)))
);


ALTER TABLE public.pohead OWNER TO admin;


--
-- TOC entry 198 (class 1259 OID 146565386)
-- Dependencies: 5920 5921 5922 5923 5924 5925 5926 5927 5928 8
-- Name: poitem; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE poitem (
    poitem_id integer DEFAULT nextval(('poitem_poitem_id_seq'::text)::regclass) NOT NULL,
    poitem_status character(1),
    poitem_pohead_id integer,
    poitem_linenumber integer,
    poitem_duedate date,
    poitem_itemsite_id integer,
    poitem_vend_item_descrip text,
    poitem_vend_uom text,
    poitem_invvenduomratio numeric(20,10),
    poitem_qty_ordered numeric(18,6) NOT NULL,
    poitem_qty_received numeric(18,6) DEFAULT 0.0 NOT NULL,
    poitem_qty_returned numeric(18,6) DEFAULT 0.0 NOT NULL,
    poitem_qty_vouchered numeric(18,6) DEFAULT 0.0 NOT NULL,
    poitem_unitprice numeric(16,6),
    poitem_vend_item_number text,
    poitem_comments text,
    poitem_qty_toreceive numeric(18,6),
    poitem_expcat_id integer,
    poitem_itemsrc_id integer,
    poitem_freight numeric(16,4) DEFAULT 0.0 NOT NULL,
    poitem_freight_received numeric(16,4) DEFAULT 0.0 NOT NULL,
    poitem_freight_vouchered numeric(16,4) DEFAULT 0.0 NOT NULL,
    poitem_prj_id integer,
    poitem_stdcost numeric(16,6),
    poitem_bom_rev_id integer,
    poitem_boo_rev_id integer,
    poitem_manuf_name text,
    poitem_manuf_item_number text,
    poitem_manuf_item_descrip text,
    poitem_taxtype_id integer,
    poitem_tax_recoverable boolean DEFAULT true NOT NULL,
    poitem_rlsd_duedate date,
    poitem_order_id integer,
    poitem_order_type character(1),
    CONSTRAINT poitem_poitem_status_check CHECK ((((poitem_status = 'U'::bpchar) OR (poitem_status = 'O'::bpchar)) OR (poitem_status = 'C'::bpchar)))
);


ALTER TABLE public.poitem OWNER TO admin;


--
-- TOC entry 199 (class 1259 OID 146565401)
-- Dependencies: 5930 5931 8
-- Name: taxtype; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE taxtype (
    taxtype_id integer NOT NULL,
    taxtype_name text NOT NULL,
    taxtype_descrip text,
    taxtype_sys boolean DEFAULT false NOT NULL,
    CONSTRAINT taxtype_taxtype_name_check CHECK ((taxtype_name <> ''::text))
);


ALTER TABLE public.taxtype OWNER TO admin;

--
-- TOC entry 8937 (class 0 OID 0)
-- Dependencies: 199
-- Name: TABLE taxtype; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE taxtype IS 'The list of Tax Types';


--
-- TOC entry 200 (class 1259 OID 146565409)
-- Dependencies: 5933 5934 8
-- Name: uom; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE uom (
    uom_id integer NOT NULL,
    uom_name text NOT NULL,
    uom_descrip text,
    uom_item_weight boolean DEFAULT false NOT NULL,
    CONSTRAINT uom_uom_name_check CHECK ((uom_name <> ''::text))
);


ALTER TABLE public.uom OWNER TO admin;

--
-- TOC entry 8939 (class 0 OID 0)
-- Dependencies: 200
-- Name: TABLE uom; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE uom IS 'Unit of Measure information';


SET search_path = api, pg_catalog;

--
-- TOC entry 201 (class 1259 OID 146565417)
-- Dependencies: 8470 6
-- Name: salesline; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW salesline AS
    SELECT (cohead.cohead_number)::character varying AS order_number, (public.formatsolinenumber(coitem.coitem_id))::character varying AS line_number, l.item_number, coitem.coitem_custpn AS customer_pn, s.item_number AS substitute_for, whsinfo.warehous_code AS sold_from_site, coitem.coitem_status AS status, coitem.coitem_qtyord AS qty_ordered, q.uom_name AS qty_uom, coitem.coitem_price AS net_unit_price, p.uom_name AS price_uom, coitem.coitem_scheddate AS scheduled_date, coitem.coitem_promdate AS promise_date, coitem.coitem_warranty AS warranty, COALESCE((SELECT taxtype.taxtype_name FROM public.taxtype WHERE (taxtype.taxtype_id = public.getitemtaxtype(l.item_id, cohead.cohead_taxzone_id))), 'None'::text) AS tax_type, CASE WHEN (coitem.coitem_price = (0)::numeric) THEN '100'::text WHEN (coitem.coitem_custprice = (0)::numeric) THEN 'N/A'::text ELSE (round((((1)::numeric - (coitem.coitem_price / coitem.coitem_custprice)) * (100)::numeric), 4))::text END AS discount_pct_from_list, CASE WHEN (coitem.coitem_order_id = (-1)) THEN false ELSE true END AS create_order, CASE WHEN (coitem.coitem_order_id = (-1)) THEN ''::text ELSE ((pohead.pohead_number || '-'::text) || poitem.poitem_linenumber) END AS create_po, coitem.coitem_prcost AS overwrite_po_price, coitem.coitem_memo AS notes, CASE WHEN (coitem.coitem_cos_accnt_id IS NOT NULL) THEN public.formatglaccount(coitem.coitem_cos_accnt_id) ELSE NULL::text END AS alternate_cos_account, CASE WHEN (coitem.coitem_rev_accnt_id IS NOT NULL) THEN public.formatglaccount(coitem.coitem_rev_accnt_id) ELSE NULL::text END AS alternate_rev_account FROM public.cohead, (((public.coitem LEFT JOIN public.itemsite isb ON ((coitem.coitem_substitute_item_id = isb.itemsite_id))) LEFT JOIN public.item s ON ((isb.itemsite_item_id = s.item_id))) LEFT JOIN (public.poitem JOIN public.pohead ON ((poitem.poitem_pohead_id = pohead.pohead_id))) ON ((poitem.poitem_id = coitem.coitem_order_id))), public.itemsite il, public.item l, public.whsinfo, public.uom q, public.uom p WHERE ((((((cohead.cohead_id = coitem.coitem_cohead_id) AND (coitem.coitem_itemsite_id = il.itemsite_id)) AND (il.itemsite_item_id = l.item_id)) AND (il.itemsite_warehous_id = whsinfo.warehous_id)) AND (coitem.coitem_qty_uom_id = q.uom_id)) AND (coitem.coitem_price_uom_id = p.uom_id)) ORDER BY cohead.cohead_number, coitem.coitem_linenumber, coitem.coitem_subnumber;


ALTER TABLE api.salesline OWNER TO admin;

--
-- TOC entry 8941 (class 0 OID 0)
-- Dependencies: 201
-- Name: VIEW salesline; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW salesline IS 'Sales Order Line Item';


--
-- TOC entry 912 (class 1255 OID 146565422)
-- Dependencies: 2767 4536 6
-- Name: insertsalesline(salesline); Type: FUNCTION; Schema: api; Owner: admin
--

CREATE FUNCTION insertsalesline(salesline) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pNEW ALIAS FOR $1;
  _r RECORD;

BEGIN

  IF (NOT EXISTS (SELECT cohead_id FROM cohead WHERE cohead_number=pNEW.order_number)) THEN
    RAISE EXCEPTION 'Function insertSalesLine failed because Sales Order % not found', pNEW.order_number;
  END IF;

  IF (NOT EXISTS (SELECT item_id FROM item WHERE item_number=pNEW.item_number)) THEN
    RAISE EXCEPTION 'Function insertSalesLine failed because Item Number % not found', pNEW.item_number;
  END IF;

  SELECT * INTO _r
  FROM cohead, itemsite, item, whsinfo
  WHERE ((cohead_number=pNEW.order_number)
  AND (itemsite_warehous_id=warehous_id
  AND (itemsite_item_id=item_id)
  AND (itemsite_active)
  AND (item_number=pNEW.item_number)
  AND (warehous_active)
  AND (warehous_id=COALESCE(getWarehousId(pNEW.sold_from_site,'ALL'),cohead_warehous_id,fetchprefwarehousid()))));

  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Function insertSalesLine failed with unknown failure to retrieve Sales Order';
  END IF;

  INSERT INTO coitem (
    coitem_cohead_id,
    coitem_linenumber,
    coitem_itemsite_id,
    coitem_status,
    coitem_scheddate,
    coitem_promdate,
    coitem_qtyord,
    coitem_qty_uom_id,
    coitem_qty_invuomratio,
    coitem_qtyshipped,
    coitem_unitcost,
    coitem_price,
    coitem_price_uom_id,
    coitem_price_invuomratio,
    coitem_custprice,
    coitem_order_id,
    coitem_memo,
    coitem_imported,
    coitem_qtyreturned,
    coitem_custpn,
    coitem_order_type,
    coitem_substitute_item_id,
    coitem_prcost,
    coitem_taxtype_id,
    coitem_warranty,
    coitem_cos_accnt_id,
    coitem_rev_accnt_id)
  VALUES (
    _r.cohead_id,
    pNEW.line_number::INTEGER,
    _r.itemsite_id,
    pNEW.status,
    pNEW.scheduled_date,
    pNEW.promise_date,
    pNEW.qty_ordered,
    COALESCE(getUomId(pNEW.qty_uom),_r.item_inv_uom_id),
    itemuomtouomratio(_r.item_id,COALESCE(getUomId(pNEW.qty_uom),_r.item_inv_uom_id),_r.item_inv_uom_id),
    0,
    stdCost(_r.item_id),
    COALESCE(pNEW.net_unit_price,itemPrice(_r.item_id,_r.cohead_cust_id,
             _r.cohead_shipto_id,pNEW.qty_ordered,_r.cohead_curr_id,_r.cohead_orderdate)),
    COALESCE(getUomId(pNEW.price_uom),_r.item_price_uom_id),
    itemuomtouomratio(_r.item_id,COALESCE(getUomId(pNEW.price_uom),_r.item_price_uom_id),_r.item_price_uom_id),
    itemPrice(_r.item_id, _r.cohead_cust_id, _r.cohead_shipto_id,
              pNEW.qty_ordered, _r.item_inv_uom_id, _r.item_price_uom_id,
              _r.cohead_curr_id,_r.cohead_orderdate,
              CASE WHEN (fetchMetricText('soPriceEffective') = 'ScheduleDate') THEN pNEW.scheduled_date
                   WHEN (fetchMetricText('soPriceEffective') = 'OrderDate') THEN _r.cohead_orderdate
                   ELSE CURRENT_DATE END,
              NULL)
    -1,
    pNEW.notes,
    true,
    0,
    pNEW.customer_pn,
    CASE
      WHEN ((pNEW.create_order  AND (_r.item_type = 'M')) OR
           ((pNEW.create_order IS NULL) AND _r.itemsite_createwo)) THEN
        'W'
      WHEN ((pNEW.create_order AND (_r.item_type = 'P')) OR
           ((pNEW.create_order IS NULL) AND _r.itemsite_createsopr)) THEN
        'R'
      WHEN ((pNEW.create_order AND (_r.item_type = 'P') AND (_r.itemsite_createsopo)) OR
           ((pNEW.create_order IS NULL) AND _r.itemsite_createsopo)) THEN
        'P'
    END,
    getitemid(pNEW.substitute_for),
    pNEW.overwrite_po_price,
    COALESCE(getTaxTypeId(pNEW.tax_type), getItemTaxType(_r.itemsite_item_id, _r.cohead_taxzone_id)),
    pNEW.warranty,
    getGlAccntId(pNEW.alternate_cos_account),
    getGlAccntId(pNEW.alternate_rev_account)
    );

  RETURN TRUE;
END;
$_$;


ALTER FUNCTION api.insertsalesline(salesline) OWNER TO admin;

SET search_path = public, pg_catalog;

--
-- TOC entry 917 (class 1255 OID 146565426)
-- Dependencies: 4536 8
-- Name: _addrtrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _addrtrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  DECLARE
    _uses	INTEGER	:= 0;

  BEGIN

    IF (TG_OP = 'INSERT') THEN
      --- clear the number from the issue cache
      PERFORM clearNumberIssue('AddressNumber', NEW.addr_number);
    ELSE
      SELECT count(*) INTO _uses
      FROM cntct
      WHERE ((cntct_addr_id=OLD.addr_id)
        AND   cntct_active);
    END IF;

    IF (TG_OP = 'UPDATE') THEN
      IF (OLD.addr_active AND NOT NEW.addr_active AND _uses > 0) THEN
	RAISE EXCEPTION 'Cannot inactivate Address with Active Contacts (%)',
			_uses;
      END IF;
    ELSIF (TG_OP = 'DELETE') THEN
      IF (_uses > 0) THEN
	RAISE EXCEPTION 'Cannot Delete Address with Active Contacts (%)',
			_uses;
      END IF;

      UPDATE cntct SET cntct_addr_id = NULL
      WHERE ((cntct_addr_id=OLD.addr_id)
	AND  (NOT cntct_active));

      RETURN OLD;
    END IF;

    RETURN NEW;
  END;
$$;


ALTER FUNCTION public._addrtrigger() OWNER TO admin;

--
-- TOC entry 918 (class 1255 OID 146565427)
-- Dependencies: 4536 8
-- Name: _alarmbeforetrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _alarmbeforetrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  BEGIN
    PERFORM clearNumberIssue('AlarmNumber', NEW.alarm_number);

    RETURN NEW;
  END;
$$;


ALTER FUNCTION public._alarmbeforetrigger() OWNER TO admin;

--
-- TOC entry 925 (class 1255 OID 146565439)
-- Dependencies: 4536 8
-- Name: _bomitemsubtrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _bomitemsubtrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

-- Privilege Checks
  IF (NOT checkPrivilege('MaintainBOMs')) THEN
    RAISE EXCEPTION 'You do not have privileges to maintain Bills of Material.';
  END IF;

  IF (TG_OP = 'DELETE') THEN
    RETURN OLD;
  ELSE
    RETURN NEW;
  END IF;

END;
$$;


ALTER FUNCTION public._bomitemsubtrigger() OWNER TO admin;

--
-- TOC entry 931 (class 1255 OID 146565444)
-- Dependencies: 4536 8
-- Name: _ccardtrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _ccardtrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE

BEGIN

  New.ccard_lastupdated := current_timestamp;
  New.ccard_last_updated_by_username := getEffectiveXtUser();

  IF (TG_OP = 'UPDATE') THEN
    INSERT INTO ccardaud
         VALUES (nextval('ccardaud_ccardaud_id_seq'), NEW.ccard_id,
                 OLD.ccard_seq, NEW.ccard_seq, OLD.ccard_cust_id, NEW.ccard_cust_id,
                 OLD.ccard_active, NEW.ccard_active, OLD.ccard_name, NEW.ccard_name,
                 OLD.ccard_address1, NEW.ccard_address1, OLD.ccard_address2,
                 NEW.ccard_address2, OLD.ccard_city, NEW.ccard_city, OLD.ccard_state,
                 NEW.ccard_state, OLD.ccard_zip, NEW.ccard_zip, OLD.ccard_country,
                 NEW.ccard_country, OLD.ccard_number, NEW.ccard_number, OLD.ccard_debit,
                 NEW.ccard_debit, OLD.ccard_month_expired, NEW.ccard_month_expired,
                 OLD.ccard_year_expired, NEW.ccard_year_expired, OLD.ccard_type, NEW.ccard_type);
  ELSE
-- We are inserting a record, therefore no old values
    INSERT INTO ccardaud
         VALUES (nextval('ccardaud_ccardaud_id_seq'), NEW.ccard_id,
                 NULL, NEW.ccard_seq, NULL, NEW.ccard_cust_id, NULL,
                 NEW.ccard_active, NULL, NEW.ccard_name, NULL,
                 NEW.ccard_address1, NULL, NEW.ccard_address2, NULL,
                 NEW.ccard_city, NULL, NEW.ccard_state, NULL,
                 NEW.ccard_zip, NULL, NEW.ccard_country, NULL,
                 NEW.ccard_number, NULL, NEW.ccard_debit, NULL,
                 NEW.ccard_month_expired, NULL, NEW.ccard_year_expired, NULL,
                 NEW.ccard_type);
  END IF;

  RETURN NEW;

END;
$$;


ALTER FUNCTION public._ccardtrigger() OWNER TO admin;

--
-- TOC entry 932 (class 1255 OID 146565445)
-- Dependencies: 4536 8
-- Name: _charasshistorytrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _charasshistorytrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF(TG_OP = 'DELETE') THEN
    IF (OLD.charass_target_type = 'INCDT') THEN
      INSERT INTO incdthist
            (incdthist_incdt_id, incdthist_descrip)
      VALUES(OLD.charass_target_id,
             ('Characteristic ' ||
               COALESCE((SELECT char_name
                           FROM char
                          WHERE (char_id=OLD.charass_char_id)), '')
              || ' Deleted: "' ||
              COALESCE(OLD.charass_value,'')
              || '"') );
    END IF;
    RETURN OLD;
  ELSIF (NEW.charass_target_type = 'INCDT') THEN
    IF (TG_OP = 'INSERT') THEN
      INSERT INTO incdthist
            (incdthist_incdt_id, incdthist_descrip)
      VALUES(NEW.charass_target_id,
             ('Characteristic ' ||
               COALESCE((SELECT char_name
                           FROM char
                          WHERE (char_id=NEW.charass_char_id)), '')
              || ' Added: "' ||
              COALESCE(NEW.charass_value,'')
              || '"') );
    ELSIF (TG_OP = 'UPDATE') THEN
      IF (COALESCE(NEW.charass_value,'') <> COALESCE(OLD.charass_value,'')) THEN
        INSERT INTO incdthist
              (incdthist_incdt_id, incdthist_descrip)
        VALUES(NEW.charass_target_id,
               ('Characteristic ' ||
                 COALESCE((SELECT char_name
                             FROM char
                            WHERE (char_id=NEW.charass_char_id)), '')
                || ' Changed: "' ||
                COALESCE(OLD.charass_value,'')
                || '" -> "' ||
                COALESCE(NEW.charass_value,'')
                || '"') );
      END IF;
    END IF;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION public._charasshistorytrigger() OWNER TO admin;

--
-- TOC entry 933 (class 1255 OID 146565446)
-- Dependencies: 4536 8
-- Name: _charasstrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _charasstrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

-- Privilege Checks
   IF (NEW.charass_target_type = 'I' AND NOT checkPrivilege('MaintainItemMasters')) THEN
     RAISE EXCEPTION 'You do not have privileges to maintain Items.';
   END IF;

   IF (NEW.charass_target_type = 'C' AND NOT checkPrivilege('MaintainCustomerMasters')) THEN
     RAISE EXCEPTION 'You do not have privileges to maintain Customers.';
   END IF;

-- Data check
  IF (NEW.charass_char_id IS NULL) THEN
	RAISE EXCEPTION 'You must supply a valid Characteristic ID.';
  END IF;

-- Default Logic
  IF (NEW.charass_default) THEN
    UPDATE charass
    SET charass_default = false
    WHERE ((charass_target_id=NEW.charass_target_id)
    AND  (charass_target_type=NEW.charass_target_type)
    AND  (charass_char_id=NEW.charass_char_id)
    AND  (charass_id <> NEW.charass_ID));
  END IF;

-- Incident update
  IF (NEW.charass_target_type = 'INCDT') THEN
    UPDATE incdt SET incdt_updated = now() WHERE incdt_id = NEW.charass_target_id;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._charasstrigger() OWNER TO admin;

--
-- TOC entry 935 (class 1255 OID 146565448)
-- Dependencies: 4536 8
-- Name: _charopttrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _charopttrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (NOT checkPrivilege('MaintainCharacteristics')) THEN
    RAISE EXCEPTION 'You do not have privileges to maintain Characteristic options.';
  END IF;

  IF (TG_OP = 'UPDATE') THEN
    UPDATE charass SET
      charass_value = NEW.charopt_value
    WHERE ((charass_char_id=NEW.charopt_char_id)
      AND (charass_value=OLD.charopt_value));
  END IF;

  IF (TG_OP = 'DELETE') THEN
    IF (SELECT (count(charass_id) > 0)
        FROM charass
        WHERE ((charass_char_id=OLD.charopt_char_id)
         AND (charass_value=OLD.charopt_value))) THEN
       RAISE EXCEPTION 'This characteristic option value is in use and can not be deleted.';
    END IF;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._charopttrigger() OWNER TO admin;

--
-- TOC entry 939 (class 1255 OID 146565450)
-- Dependencies: 4536 8
-- Name: _cmheadbeforetrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _cmheadbeforetrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _check BOOLEAN;
  _id INTEGER;
BEGIN
  -- Checks
  -- Start with privileges
  SELECT checkPrivilege('MaintainCreditMemos') INTO _check;
  IF ( (TG_OP = 'INSERT') OR (TG_OP = 'DELETE') ) THEN
    IF NOT (_check) THEN
      RAISE EXCEPTION 'You do not have privileges to maintain Credit Memos.';
    END IF;
  END IF;
  IF (TG_OP = 'UPDATE') THEN
    IF ((OLD.cmhead_printed = NEW.cmhead_printed) AND NOT (_check) ) THEN
      RAISE EXCEPTION 'You do not have privileges to maintain Credit Memos.';
    END IF;
  END IF;

  IF (TG_OP = 'DELETE') THEN
    DELETE FROM cmheadtax
    WHERE (taxhist_parent_id=OLD.cmhead_id);

    RETURN OLD;
  END IF;

  IF ( (NEW.cmhead_number IS NULL) OR (LENGTH(NEW.cmhead_number) = 0) ) THEN
    RAISE EXCEPTION 'You must enter a valid Memo # for this Credit Memo.';
  END IF;

  IF (TG_OP = 'INSERT') THEN
    SELECT cmhead_id INTO _id
    FROM cmhead
    WHERE (cmhead_number=NEW.cmhead_number);
    IF (FOUND) THEN
      RAISE EXCEPTION 'The Memo # is already in use.';
    END IF;

    IF (fetchMetricText('CMNumberGeneration') IN ('A','O')) THEN
      --- clear the number from the issue cache
      PERFORM clearNumberIssue('CmNumber', NEW.cmhead_number);
    ELSIF (fetchMetricText('CMNumberGeneration') = 'S') THEN
      --- clear the number from the issue cache
      PERFORM clearNumberIssue('SoNumber', NEW.cmhead_number);
    END IF;
  END IF;

  IF (NEW.cmhead_cust_id IS NOT NULL) THEN
    SELECT cust_id INTO _id
    FROM custinfo
    WHERE (cust_id=NEW.cmhead_cust_id);
    IF (NOT FOUND) THEN
      RAISE EXCEPTION 'You must enter a valid Customer # for this Credit Memo.';
    END IF;
  END IF;

  IF ( (NEW.cmhead_misc > 0) AND (NEW.cmhead_misc_accnt_id = -1) ) THEN
    RAISE EXCEPTION 'You may not enter a Misc. Charge without indicating the G/L Sales Account.';
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._cmheadbeforetrigger() OWNER TO admin;

--
-- TOC entry 940 (class 1255 OID 146565451)
-- Dependencies: 4536 8
-- Name: _cmheadtrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _cmheadtrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (TG_OP = 'DELETE') THEN
    -- If this was created by a return, then reset the return
    IF (OLD.cmhead_rahead_id IS NOT NULL) THEN
      UPDATE rahead SET
        rahead_headcredited=false
      WHERE (rahead_id=OLD.cmhead_rahead_id);
      DELETE FROM rahist
      WHERE ((rahist_rahead_id=OLD.cmhead_rahead_id)
      AND (rahist_source='CM')
      AND (rahist_source_id=OLD.cmhead_id));
    END IF;
    RETURN OLD;
  END IF;

-- Insert new row
  IF (TG_OP = 'INSERT') THEN

  -- Calculate Freight Tax
    IF (NEW.cmhead_freight <> 0) THEN
      PERFORM calculateTaxHist( 'cmheadtax',
                                NEW.cmhead_id,
                                NEW.cmhead_taxzone_id,
                                getFreightTaxtypeId(),
                                NEW.cmhead_docdate,
                                NEW.cmhead_curr_id,
                                NEW.cmhead_freight * -1 );
    END IF;
  END IF;

-- Update row
  IF (TG_OP = 'UPDATE') THEN

    IF ( (NEW.cmhead_freight <> OLD.cmhead_freight) OR
         (COALESCE(NEW.cmhead_taxzone_id,-1) <> COALESCE(OLD.cmhead_taxzone_id,-1)) OR
         (NEW.cmhead_docdate <> OLD.cmhead_docdate) OR
         (NEW.cmhead_curr_id <> OLD.cmhead_curr_id) ) THEN
  -- Calculate cmhead Tax
      PERFORM calculateTaxHist( 'cmheadtax',
                                NEW.cmhead_id,
                                NEW.cmhead_taxzone_id,
                                getFreightTaxtypeId(),
                                NEW.cmhead_docdate,
                                NEW.cmhead_curr_id,
                                NEW.cmhead_freight * -1 );
    END IF;

    IF ( (COALESCE(NEW.cmhead_taxzone_id,-1) <> COALESCE(OLD.cmhead_taxzone_id,-1)) OR
         (NEW.cmhead_docdate <> OLD.cmhead_docdate) OR
         (NEW.cmhead_curr_id <> OLD.cmhead_curr_id) ) THEN
  -- Calculate cmitem Tax
      IF (COALESCE(NEW.cmhead_taxzone_id,-1) <> COALESCE(OLD.cmhead_taxzone_id,-1)) THEN
    -- Cmitem trigger will calculate tax
        UPDATE cmitem SET cmitem_taxtype_id=getItemTaxType(itemsite_item_id,NEW.cmhead_taxzone_id)
        FROM itemsite
        WHERE ((itemsite_id=cmitem_itemsite_id)
          AND (cmitem_cmhead_id=NEW.cmhead_id));
      ELSE
        PERFORM calculateTaxHist( 'cmitemtax',
                                  cmitem_id,
                                  NEW.cmhead_taxzone_id,
                                  cmitem_taxtype_id,
                                  NEW.cmhead_docdate,
                                  NEW.cmhead_curr_id,
                                  (cmitem_qtycredit * cmitem_qty_invuomratio) *
                                  (cmitem_unitprice / cmitem_price_invuomratio) * -1)
        FROM cmitem
        WHERE (cmitem_cmhead_id = NEW.cmhead_id);
      END IF;
    END IF;

  END IF;


  RETURN NEW;
END;
$$;


ALTER FUNCTION public._cmheadtrigger() OWNER TO admin;

--
-- TOC entry 949 (class 1255 OID 146565457)
-- Dependencies: 4536 8
-- Name: _cntsliptrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _cntsliptrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _p RECORD;
  _comments TEXT;
  _temp TEXT;

BEGIN
  IF (TG_OP = 'DELETE') THEN
    SELECT itemsite_loccntrl, itemsite_controlmethod,
           cntslip_posted, cntslip_lotserial, cntslip_comments,
           cntslip_number, cntslip_qty INTO _p
      FROM cntslip, invcnt, itemsite
     WHERE ( (cntslip_cnttag_id=invcnt_id)
       AND   (invcnt_itemsite_id=itemsite_id)
       AND   (cntslip_id=OLD.cntslip_id) );

    IF(_p.cntslip_posted) THEN
      SELECT ( '
Count Slip #' || _p.cntslip_number ||
             ' deleted ' || formatQty(_p.cntslip_qty) ) INTO _comments;

--  Add the Location name if the itemsite is MLC
      IF (_p.itemsite_loccntrl) THEN
        SELECT ( ', Location:' || location_name ) INTO _temp
          FROM location, cntslip
         WHERE ( (cntslip_location_id=location_id)
           AND   (cntslip_id=OLD.cntslip_id) );

        _comments := (_comments || _temp);
      END IF;

--  Add the Lot/Serial if the itemsite is Lot or Serial controlled
      IF (_p.itemsite_controlmethod = 'L') THEN
        _comments := (_comments || ( ', Lot #:' || _p.cntslip_lotserial));
      ELSIF (_p.itemsite_controlmethod = 'S') THEN
        _comments := (_comments || ( ', Serial #:' || _p.cntslip_lotserial));
      END IF;

      _comments := (_comments || ' ' || _p.cntslip_comments);

      UPDATE invcnt
         SET invcnt_qoh_after = ( COALESCE(invcnt_qoh_after, 0) - cntslip_qty),
             invcnt_comments = (invcnt_comments || _comments)
        FROM cntslip
       WHERE ( (cntslip_cnttag_id=invcnt_id)
         AND   (NOT invcnt_posted)
         AND   (cntslip_id=OLD.cntslip_id) );

    END IF;

    RETURN OLD;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._cntsliptrigger() OWNER TO admin;

--
-- TOC entry 950 (class 1255 OID 146565458)
-- Dependencies: 4536 8
-- Name: _cobillbeforetrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _cobillbeforetrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE

BEGIN
  IF (TG_OP = 'DELETE') THEN
    DELETE FROM cobilltax
    WHERE (taxhist_parent_id=OLD.cobill_id);

    RETURN OLD;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._cobillbeforetrigger() OWNER TO admin;

--
-- TOC entry 951 (class 1255 OID 146565459)
-- Dependencies: 4536 8
-- Name: _cobilltrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _cobilltrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _r RECORD;

BEGIN
  IF (TG_OP = 'DELETE') THEN
    RETURN OLD;
  END IF;

-- Cache Billing Head
  SELECT * INTO _r
  FROM cobmisc
  WHERE (cobmisc_id=NEW.cobill_cobmisc_id);
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Billing head not found';
  END IF;

-- Insert new row
  IF (TG_OP = 'INSERT') THEN

  -- Calculate Tax
      PERFORM calculateTaxHist( 'cobilltax',
                                NEW.cobill_id,
                                COALESCE(_r.cobmisc_taxzone_id, -1),
                                NEW.cobill_taxtype_id,
                                COALESCE(_r.cobmisc_shipdate, CURRENT_DATE),
                                COALESCE(_r.cobmisc_curr_id, -1),
                                (NEW.cobill_qty * coitem_qty_invuomratio) *
                                (coitem_price / coitem_price_invuomratio) )
      FROM coitem
      WHERE (coitem_id=NEW.cobill_coitem_id);
  END IF;

-- Update row
  IF (TG_OP = 'UPDATE') THEN

  -- Calculate Tax
    IF ( (NEW.cobill_qty <> OLD.cobill_qty) OR
         (NEW.cobill_taxtype_id <> OLD.cobill_taxtype_id) ) THEN
      PERFORM calculateTaxHist( 'cobilltax',
                                NEW.cobill_id,
                                COALESCE(_r.cobmisc_taxzone_id, -1),
                                NEW.cobill_taxtype_id,
                                COALESCE(_r.cobmisc_shipdate, CURRENT_DATE),
                                COALESCE(_r.cobmisc_curr_id, -1),
                                (NEW.cobill_qty * coitem_qty_invuomratio) *
                                (coitem_price / coitem_price_invuomratio) )
      FROM coitem
      WHERE (coitem_id=NEW.cobill_coitem_id);
    END IF;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._cobilltrigger() OWNER TO admin;

--
-- TOC entry 936 (class 1255 OID 146565460)
-- Dependencies: 4536 8
-- Name: _cobmiscbeforetrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _cobmiscbeforetrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE

BEGIN
  IF (TG_OP = 'DELETE') THEN
    DELETE FROM cobmisctax
    WHERE (taxhist_parent_id=OLD.cobmisc_id);

    RETURN OLD;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._cobmiscbeforetrigger() OWNER TO admin;

--
-- TOC entry 937 (class 1255 OID 146565461)
-- Dependencies: 4536 8
-- Name: _cobmisctrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _cobmisctrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (TG_OP = 'DELETE') THEN
    -- Something can go here
    RETURN OLD;
  END IF;

-- Insert new row
  IF (TG_OP = 'INSERT') THEN

  -- Calculate Freight Tax
    IF (NEW.cobmisc_freight <> 0) THEN
      PERFORM calculateTaxHist( 'cobmisctax',
                                NEW.cobmisc_id,
                                NEW.cobmisc_taxzone_id,
                                getFreightTaxtypeId(),
                                NEW.cobmisc_invcdate,
                                NEW.cobmisc_curr_id,
                                NEW.cobmisc_freight );
    END IF;
  END IF;

-- Update row
  IF (TG_OP = 'UPDATE') THEN

  -- Calculate Tax
    IF (COALESCE(NEW.cobmisc_taxzone_id,-1) <> COALESCE(OLD.cobmisc_taxzone_id,-1)) THEN
      UPDATE cobill SET cobill_taxtype_id=getItemTaxType(itemsite_item_id,NEW.cobmisc_taxzone_id)
      FROM coitem
        JOIN itemsite ON (coitem_itemsite_id=itemsite_id)
      WHERE ((coitem_id=cobill_coitem_id)
       AND (cobill_cobmisc_id=NEW.cobmisc_id));
    END IF;

    IF ( (NEW.cobmisc_freight <> OLD.cobmisc_freight) OR
         (COALESCE(NEW.cobmisc_taxzone_id,-1) <> COALESCE(OLD.cobmisc_taxzone_id,-1)) OR
         (NEW.cobmisc_invcdate <> OLD.cobmisc_invcdate) OR
         (NEW.cobmisc_curr_id <> OLD.cobmisc_curr_id) ) THEN
      PERFORM calculateTaxHist( 'cobmisctax',
                                NEW.cobmisc_id,
                                NEW.cobmisc_taxzone_id,
                                getFreightTaxtypeId(),
                                NEW.cobmisc_invcdate,
                                NEW.cobmisc_curr_id,
                                NEW.cobmisc_freight );
      PERFORM calculateTaxHist( 'cobilltax',
                                cobill_id,
                                NEW.cobmisc_taxzone_id,
                                cobill_taxtype_id,
                                NEW.cobmisc_invcdate,
                                NEW.cobmisc_curr_id,
                                (cobill_qty * coitem_qty_invuomratio) *
                                (coitem_price / coitem_price_invuomratio) )
      FROM cobill JOIN coitem ON (coitem_id = cobill_coitem_id)
      WHERE (cobill_cobmisc_id = NEW.cobmisc_id);
    END IF;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._cobmisctrigger() OWNER TO admin;

--
-- TOC entry 944 (class 1255 OID 146565462)
-- Dependencies: 4536 8
-- Name: _commenttrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _commenttrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (NEW.comment_cmnttype_id IS NULL) THEN
	RAISE EXCEPTION 'You must supply a valid Comment Type ID.';
  ELSIF (NEW.comment_source = 'INCDT') THEN
    UPDATE incdt SET incdt_updated = now() WHERE incdt_id = NEW.comment_source_id;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._commenttrigger() OWNER TO admin;

--
-- TOC entry 953 (class 1255 OID 146565464)
-- Dependencies: 4536 8
-- Name: _contrctaftertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _contrctaftertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE

BEGIN

  -- synchronize contract effectivity with item source effectivity
  IF (NEW.contrct_effective <> OLD.contrct_effective) THEN
    UPDATE itemsrc SET itemsrc_effective=NEW.contrct_effective
    WHERE itemsrc_contrct_id=NEW.contrct_id;
  END IF;

  IF (NEW.contrct_expires <> OLD.contrct_expires) THEN
    UPDATE itemsrc SET itemsrc_expires=NEW.contrct_expires
    WHERE itemsrc_contrct_id=NEW.contrct_id;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._contrctaftertrigger() OWNER TO admin;

--
-- TOC entry 954 (class 1255 OID 146565465)
-- Dependencies: 4536 8
-- Name: _crmacctaftertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _crmacctaftertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _cmnttypeid INTEGER;
  _gotpriv    BOOLEAN;

BEGIN
  /* update _number and _name separately to propagate just what changed.
     the priv manipulation allows targeted updates of crmaccount-maintained data
     (note: grantPriv() == false if the user already had the priv, true if this
     call granted the priv).
   */
  IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN
    IF (NEW.crmacct_cust_id IS NOT NULL) THEN
      _gotpriv := grantPriv(getEffectiveXtUser(), 'MaintainCustomerMasters');
      UPDATE custinfo SET cust_number = NEW.crmacct_number
      WHERE ((cust_id=NEW.crmacct_cust_id)
        AND  (cust_number!=NEW.crmacct_number));
      UPDATE custinfo SET cust_name = NEW.crmacct_name
      WHERE ((cust_id=NEW.crmacct_cust_id)
        AND  (cust_name!=NEW.crmacct_name));
      IF (_gotpriv) THEN
        PERFORM revokePriv(getEffectiveXtUser(), 'MaintainCustomerMasters');
      END IF;
    END IF;

    IF (NEW.crmacct_emp_id IS NOT NULL) THEN
      _gotpriv := grantPriv(getEffectiveXtUser(), 'MaintainEmployees');
      UPDATE emp SET emp_code = NEW.crmacct_number
      WHERE ((emp_id=NEW.crmacct_emp_id)
        AND  (emp_code!=NEW.crmacct_number));
      UPDATE emp SET emp_name = NEW.crmacct_name
      WHERE ((emp_id=NEW.crmacct_emp_id)
        AND  (emp_name!=NEW.crmacct_name));
      IF (_gotpriv) THEN
        PERFORM revokePriv(getEffectiveXtUser(), 'MaintainEmployees');
      END IF;
    END IF;

    IF (NEW.crmacct_prospect_id IS NOT NULL) THEN
      _gotpriv := grantPriv(getEffectiveXtUser(), 'MaintainProspectMasters');
      UPDATE prospect SET prospect_number = NEW.crmacct_number
      WHERE ((prospect_id=NEW.crmacct_prospect_id)
        AND  (prospect_number!=NEW.crmacct_number));
      UPDATE prospect SET prospect_name = NEW.crmacct_name
      WHERE ((prospect_id=NEW.crmacct_prospect_id)
        AND  (prospect_name!=NEW.crmacct_name));
      IF (_gotpriv) THEN
        PERFORM revokePriv(getEffectiveXtUser(), 'MaintainProspectMasters');
      END IF;
    END IF;

    IF (NEW.crmacct_salesrep_id IS NOT NULL) THEN
      _gotpriv := grantPriv(getEffectiveXtUser(), 'MaintainSalesReps');
      UPDATE salesrep SET salesrep_number = NEW.crmacct_number
      WHERE ((salesrep_id=NEW.crmacct_salesrep_id)
        AND  (salesrep_number!=NEW.crmacct_number));
      UPDATE salesrep SET salesrep_name = NEW.crmacct_name
      WHERE ((salesrep_id=NEW.crmacct_salesrep_id)
        AND  (salesrep_name!=NEW.crmacct_name));
      IF (_gotpriv) THEN
        PERFORM revokePriv(getEffectiveXtUser(), 'MaintainSalesReps');
      END IF;
    END IF;

    IF (NEW.crmacct_taxauth_id IS NOT NULL) THEN
      _gotpriv := grantPriv(getEffectiveXtUser(), 'MaintainTaxAuthorities');
      UPDATE taxauth SET taxauth_code = NEW.crmacct_number
      WHERE ((taxauth_id=NEW.crmacct_taxauth_id)
        AND  (taxauth_code!=NEW.crmacct_number));
      UPDATE taxauth SET taxauth_name = NEW.crmacct_name
      WHERE ((taxauth_id=NEW.crmacct_taxauth_id)
        AND  (taxauth_name!=NEW.crmacct_name));
      IF (_gotpriv) THEN
        PERFORM revokePriv(getEffectiveXtUser(), 'MaintainTaxAuthorities');
      END IF;
    END IF;

    IF (NEW.crmacct_vend_id IS NOT NULL) THEN
      _gotpriv := grantPriv(getEffectiveXtUser(), 'MaintainVendors');
      UPDATE vendinfo SET vend_number = NEW.crmacct_number
      WHERE ((vend_id=NEW.crmacct_vend_id)
        AND  (vend_number!=NEW.crmacct_number));
      UPDATE vendinfo SET vend_name = NEW.crmacct_name
      WHERE ((vend_id=NEW.crmacct_vend_id)
        AND  (vend_name!=NEW.crmacct_name));
      IF (_gotpriv) THEN
        PERFORM revokePriv(getEffectiveXtUser(), 'MaintainVendors');
      END IF;
    END IF;

    -- Link Primary and Secondary Contacts to this Account if they are not already
    IF (NEW.crmacct_cntct_id_1 IS NOT NULL) THEN
      _gotpriv := grantPriv(getEffectiveXtUser(), 'MaintainAllContacts');
      UPDATE cntct SET cntct_crmacct_id = NEW.crmacct_id
       WHERE cntct_id=NEW.crmacct_cntct_id_1;
      IF (_gotpriv) THEN
        PERFORM revokePriv(getEffectiveXtUser(), 'MaintainAllContacts');
      END IF;
    END IF;

    IF (NEW.crmacct_cntct_id_2 IS NOT NULL) THEN
      _gotpriv := grantPriv(getEffectiveXtUser(), 'MaintainAllContacts');
      UPDATE cntct SET cntct_crmacct_id = NEW.crmacct_id
       WHERE cntct_id=NEW.crmacct_cntct_id_2;
      IF (_gotpriv) THEN
        PERFORM revokePriv(getEffectiveXtUser(), 'MaintainAllContacts');
      END IF;
    END IF;

    -- cannot have fkey references to system catalogs so enforce them here
    IF (NEW.crmacct_usr_username IS NOT NULL) THEN
      IF (NOT EXISTS(SELECT usr_username
                       FROM usr
                      WHERE usr_username=NEW.crmacct_usr_username)) THEN
        RAISE EXCEPTION 'User % does not exist so this CRM Account Number is invalid.',
                        NEW.crmacct_usr_username;
      END IF;
      IF (TG_OP = 'UPDATE') THEN
        -- reminder: this evaluates to false if either is NULL
        IF (NEW.crmacct_usr_username != OLD.crmacct_usr_username) THEN
          RAISE EXCEPTION 'Cannot change the user name for %',
                          OLD.crmacct_usr_username;
        END IF;
      END IF;
      UPDATE usrpref SET usrpref_value = NEW.crmacct_name
      WHERE ((usrpref_username=NEW.crmacct_usr_username)
        AND  (usrpref_name='propername')
        AND  (usrpref_value!=NEW.crmacct_name));
    END IF;

  ELSIF (TG_OP = 'DELETE') THEN
    IF (OLD.crmacct_cust_id IS NOT NULL) THEN
      RAISE EXCEPTION 'Cannot delete CRM Account because it is a Customer [xtuple: deleteCrmAccount, -1]';
    END IF;

    IF (OLD.crmacct_emp_id IS NOT NULL) THEN
      RAISE EXCEPTION 'Cannot delete CRM Account because it is an Employee [xtuple: deleteCrmAccount, -7]';
    END IF;

    IF (OLD.crmacct_prospect_id IS NOT NULL) THEN
      RAISE EXCEPTION 'Cannot delete CRM Account because it is a Prospect [xtuple: deleteCrmAccount, -3]';
    END IF;

    DELETE FROM salesrep WHERE salesrep_id  = OLD.crmacct_salesrep_id;
    IF (OLD.crmacct_salesrep_id IS NOT NULL) THEN
      RAISE EXCEPTION 'Cannot delete CRM Account because it is a Sales Rep [xtuple: deleteCrmAccount, -6]';
    END IF;

    IF (OLD.crmacct_taxauth_id IS NOT NULL) THEN
      RAISE EXCEPTION 'Cannot delete CRM Account because it is a Tax Authority [xtuple: deleteCrmAccount, -5]';
    END IF;

    IF (EXISTS(SELECT usename
                 FROM pg_user
                WHERE usename=OLD.crmacct_usr_username)) THEN
      RAISE EXCEPTION 'Cannot delete CRM Account because it is a User [xtuple: deleteCrmAccount, -8]';
    END IF;

    IF (OLD.crmacct_vend_id IS NOT NULL) THEN
      RAISE EXCEPTION 'Cannot delete CRM Account because it is a Vendor [xtuple: deleteCrmAccount, -2]';
    END IF;

    DELETE FROM imageass
     WHERE (imageass_source_id=OLD.crmacct_id) AND (imageass_source='CRMA');
    DELETE FROM url
     WHERE (url_source_id=OLD.crmacct_id)      AND (url_source='CRMA');

  END IF;

  SELECT cmnttype_id INTO _cmnttypeid
    FROM cmnttype
   WHERE (cmnttype_name='ChangeLog');
  IF (_cmnttypeid IS NOT NULL) THEN
    IF (TG_OP = 'INSERT') THEN
      PERFORM postComment(_cmnttypeid, 'CRMA', NEW.crmacct_id,
                          ('Created by ' || getEffectiveXtUser()));

    ELSIF (TG_OP = 'DELETE') THEN
      PERFORM postComment(_cmnttypeid, 'CRMA', OLD.crmacct_id,
                          'Deleted "' || OLD.crmacct_number || '"');
    END IF;
  END IF;

  IF (TG_OP = 'DELETE') THEN
    RETURN OLD;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._crmacctaftertrigger() OWNER TO admin;

--
-- TOC entry 955 (class 1255 OID 146565467)
-- Dependencies: 4536 8
-- Name: _crmacctbeforetrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _crmacctbeforetrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _count        INTEGER;
BEGIN
  -- disallow reusing crmacct_numbers
  IF (TG_OP IN ('INSERT', 'UPDATE')) THEN
    IF (TG_OP = 'INSERT' AND fetchMetricText('CRMAccountNumberGeneration') IN ('A','O')) THEN
      PERFORM clearNumberIssue('CRMAccountNumber', NEW.crmacct_number);
    END IF;

    NEW.crmacct_usr_username := LOWER(TRIM(NEW.crmacct_usr_username));
    IF (NEW.crmacct_usr_username = '') THEN
      NEW.crmacct_usr_username = NULL;
    END IF;

    NEW.crmacct_owner_username := LOWER(TRIM(NEW.crmacct_owner_username));
    IF (COALESCE(NEW.crmacct_owner_username, '') = '') THEN
      NEW.crmacct_owner_username = getEffectiveXtUser();
    END IF;

    IF (NEW.crmacct_competitor_id < 0) THEN
      NEW.crmacct_competitor_id := NULL;
    END IF;
    IF (NEW.crmacct_partner_id < 0) THEN
      NEW.crmacct_partner_id := NULL;
    END IF;

    NEW.crmacct_number = UPPER(NEW.crmacct_number);

    IF (TG_OP = 'UPDATE') THEN
      -- TODO: why not ALTER USER OLD.crmacct_number RENAME TO LOWER(NEW.crmacct_number)?
      IF (NEW.crmacct_number != UPPER(OLD.crmacct_number) AND
          NEW.crmacct_usr_username IS NOT NULL            AND
          UPPER(NEW.crmacct_usr_username) != NEW.crmacct_number) THEN
        RAISE EXCEPTION 'The CRM Account % is associated with a system User so the number cannot be changed.',
                        NEW.crmacct_number;
      END IF;
    END IF;

  ELSIF (TG_OP = 'DELETE') THEN
    UPDATE cntct SET cntct_crmacct_id = NULL
     WHERE cntct_crmacct_id = OLD.crmacct_id;

    DELETE FROM docass WHERE docass_source_id = OLD.crmacct_id AND docass_source_type = 'CRMA';
    DELETE FROM docass WHERE docass_target_id = OLD.crmacct_id AND docass_target_type = 'CRMA';

    GET DIAGNOSTICS _count = ROW_COUNT;
    RAISE DEBUG 'updated % contacts', _count;

    RETURN OLD;

  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._crmacctbeforetrigger() OWNER TO admin;

--
-- TOC entry 961 (class 1255 OID 146565472)
-- Dependencies: 4536 8
-- Name: _custtypeafterdeletetrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _custtypeafterdeletetrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (SELECT fetchMetricValue('DefaultCustType') = OLD.custtype_id) THEN
    RAISE EXCEPTION 'Cannot delete the default Customer Type [xtuple: custtype, -1, %]',
                    OLD.custtype_code;
  END IF;

  RETURN OLD;
END;
$$;


ALTER FUNCTION public._custtypeafterdeletetrigger() OWNER TO admin;

--
-- TOC entry 962 (class 1255 OID 146565473)
-- Dependencies: 4536 8
-- Name: _custtypetrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _custtypetrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _check      BOOLEAN;
  _code       TEXT;

BEGIN

--  Checks
  IF (TG_OP IN ('INSERT','UPDATE')) THEN

    IF (LENGTH(COALESCE(NEW.custtype_code, ''))=0) THEN
      RAISE EXCEPTION 'You must supply a valid Customer Type Code.';
    END IF;

    SELECT custtype_code INTO _code
    FROM custtype
    WHERE ( (UPPER(custtype_code)=UPPER(NEW.custtype_code))
      AND (custtype_id<>NEW.custtype_id) );
    IF (FOUND) THEN
      RAISE EXCEPTION 'The Customer Type Code entered cannot be used as it is in use.';
    END IF;

  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._custtypetrigger() OWNER TO admin;

--
-- TOC entry 968 (class 1255 OID 146565479)
-- Dependencies: 4536 8
-- Name: _evntlogafterinserttrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _evntlogafterinserttrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _r RECORD;

BEGIN

  IF (NEW.evntlog_username = 'autopilot') THEN
    SELECT * INTO _r FROM evnttype WHERE (evnttype_id=NEW.evntlog_evnttype_id);
    IF (_r.evnttype_name = 'SoCreated') THEN
      PERFORM createPrjToSale(NEW.evntlog_ord_id);
    END IF;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._evntlogafterinserttrigger() OWNER TO admin;

--
-- TOC entry 969 (class 1255 OID 146565480)
-- Dependencies: 4536 8
-- Name: _gltransaltertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _gltransaltertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _externalCompany      BOOLEAN := false;
  _updated BOOLEAN := false;
BEGIN
  IF(TG_OP='DELETE') THEN
    RAISE EXCEPTION 'You may not delete G/L Transactions once they have been created.';
  ELSIF (TG_OP = 'UPDATE') THEN
    SELECT company_external INTO _externalCompany
    FROM company JOIN accnt ON (company_number=accnt_company)
    WHERE (accnt_id=NEW.gltrans_accnt_id);
    IF (_externalCompany) THEN
      RAISE EXCEPTION 'Transactions are not allowed for G/L Accounts with External Company segments.';
    END IF;

    IF(OLD.gltrans_id != NEW.gltrans_id) THEN
      _updated := true;
    ELSIF(OLD.gltrans_date != NEW.gltrans_date) THEN
      _updated := true;
    ELSIF(OLD.gltrans_accnt_id != NEW.gltrans_accnt_id) THEN
      _updated := true;
    ELSIF(OLD.gltrans_amount != NEW.gltrans_amount) THEN
      _updated := true;
    ELSIF(OLD.gltrans_username != NEW.gltrans_username) THEN
      _updated := true;
    ELSIF( (OLD.gltrans_sequence IS NULL     AND NEW.gltrans_sequence IS NOT NULL)
        OR (OLD.gltrans_sequence IS NOT NULL AND NEW.gltrans_sequence IS NULL)
        OR (COALESCE(OLD.gltrans_sequence,0) != COALESCE(NEW.gltrans_sequence,0)) ) THEN
      _updated := true;
    ELSIF( (OLD.gltrans_created IS NULL     AND NEW.gltrans_created IS NOT NULL)
        OR (OLD.gltrans_created IS NOT NULL AND NEW.gltrans_created IS NULL)
        OR (COALESCE(OLD.gltrans_created,now()) != COALESCE(NEW.gltrans_created,now())) ) THEN
      _updated := true;
    ELSIF( (OLD.gltrans_source IS NULL     AND NEW.gltrans_source IS NOT NULL)
        OR (OLD.gltrans_source IS NOT NULL AND NEW.gltrans_source IS NULL)
        OR (COALESCE(OLD.gltrans_source,'') != COALESCE(NEW.gltrans_source,'')) ) THEN
      _updated := true;
    ELSIF( (OLD.gltrans_docnumber IS NULL     AND NEW.gltrans_docnumber IS NOT NULL)
        OR (OLD.gltrans_docnumber IS NOT NULL AND NEW.gltrans_docnumber IS NULL)
        OR (COALESCE(OLD.gltrans_docnumber,'') != COALESCE(NEW.gltrans_docnumber,'')) ) THEN
      _updated := true;
    ELSIF( (OLD.gltrans_doctype IS NULL     AND NEW.gltrans_doctype IS NOT NULL)
        OR (OLD.gltrans_doctype IS NOT NULL AND NEW.gltrans_doctype IS NULL)
        OR (COALESCE(OLD.gltrans_doctype,'') != COALESCE(NEW.gltrans_doctype,'')) ) THEN
      _updated := true;
    END IF;

    IF(_updated) THEN
      RAISE EXCEPTION 'You may not alter some G/L Transaction fields once they have been created.';
    END IF;
  ELSE
    RAISE EXCEPTION 'trigger for gltrans table called in unexpected state.';
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION public._gltransaltertrigger() OWNER TO admin;

--
-- TOC entry 970 (class 1255 OID 146565481)
-- Dependencies: 4536 8
-- Name: _gltransinserttrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _gltransinserttrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _reqNotes BOOLEAN;
  _externalCompany      BOOLEAN := false;
BEGIN
  -- Checks
  -- Start with privileges
  IF ((NEW.gltrans_doctype='JE') AND (NOT checkPrivilege('PostJournalEntries'))) THEN
      RAISE EXCEPTION 'You do not have privileges to create a Journal Entry.';
  END IF;

  SELECT company_external INTO _externalCompany
  FROM company JOIN accnt ON (company_number=accnt_company)
  WHERE (accnt_id=NEW.gltrans_accnt_id);
  IF (_externalCompany) THEN
    RAISE EXCEPTION 'Transactions are not allowed for G/L Accounts with External Company segments.';
  END IF;
  -- RAISE NOTICE '_gltransInsertTrigger(): company_external = %', _externalCompany;

  SELECT metric_value='t'
    INTO _reqNotes
    FROM metric
   WHERE(metric_name='MandatoryGLEntryNotes');
  IF (_reqNotes IS NULL) THEN
    _reqNotes := false;
  END IF;
  IF ((NEW.gltrans_doctype='JE') AND _reqNotes AND (TRIM(BOTH FROM COALESCE(NEW.gltrans_notes,''))='')) THEN
      RAISE EXCEPTION 'Notes are required for Journal Entries.';
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._gltransinserttrigger() OWNER TO admin;

--
-- TOC entry 971 (class 1255 OID 146565482)
-- Dependencies: 4536 8
-- Name: _grpprivtrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _grpprivtrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _check BOOLEAN;
  _returnVal INTEGER;
BEGIN
  -- This looks like a candidate for a foreign key but isn't.
  -- fkeys don't work if the foreign key value resides in a child of the
  -- table and not the table itself.
  IF ((TG_OP = 'UPDATE' OR TG_OP = 'INSERT') AND
      (NOT EXISTS(SELECT priv_id
                  FROM priv
                  WHERE (priv_id=NEW.grppriv_priv_id)))) THEN
    RAISE EXCEPTION 'Privilege id % does not exist or is part of a disabled package.',
                NEW.grppriv_priv_id;
    RETURN OLD;

  ELSIF (TG_OP = 'DELETE') THEN
    RETURN OLD;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._grpprivtrigger() OWNER TO admin;

--
-- TOC entry 972 (class 1255 OID 146565483)
-- Dependencies: 4536 8
-- Name: _imageasstrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _imageasstrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (NEW.imageass_source = 'INCDT') THEN
    UPDATE incdt SET incdt_updated = now() WHERE incdt_id = NEW.imageass_source_id;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._imageasstrigger() OWNER TO admin;

--
-- TOC entry 984 (class 1255 OID 146565494)
-- Dependencies: 4536 8
-- Name: _ipsitemcharbeforetrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _ipsitemcharbeforetrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  --  Checks
  IF NOT (checkPrivilege('MaintainPricingSchedules')) THEN
    RAISE EXCEPTION 'You do not have privileges to maintain Price Schedules.';
  END IF;

  IF (TG_OP IN ('INSERT','UPDATE')) THEN
    IF (SELECT (COUNT(item_id)=0)
        FROM ipsiteminfo JOIN item ON (item_id=ipsitem_item_id)
        WHERE ((ipsitem_id=NEW.ipsitemchar_ipsitem_id)
        AND (item_config))) THEN
      RAISE EXCEPTION 'Characteristic prices may only be set on configured items.';
    ELSIF (SELECT (COUNT(item_id)=0)
        FROM ipsiteminfo JOIN item ON (item_id=ipsitem_item_id)
                         JOIN charass ON (charass_target_id=item_id AND charass_target_type='I')
        WHERE ((ipsitem_id=NEW.ipsitemchar_ipsitem_id)
        AND (charass_char_id=NEW.ipsitemchar_char_id)
        AND (charass_value=NEW.ipsitemchar_value))) THEN
      RAISE EXCEPTION 'No characteristic with matching value exists for this item.';
    END IF;
    RETURN NEW;
  ELSE
    RETURN OLD;
  END IF;
END;
$$;


ALTER FUNCTION public._ipsitemcharbeforetrigger() OWNER TO admin;

--
-- TOC entry 985 (class 1255 OID 146565495)
-- Dependencies: 4536 8
-- Name: _ipsiteminfobeforetrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _ipsiteminfobeforetrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN

  --  Checks
  IF NOT (checkPrivilege('MaintainPricingSchedules')) THEN
    RAISE EXCEPTION 'You do not have privileges to maintain Price Schedules.';
  END IF;

  IF (TG_OP IN ('INSERT','UPDATE')) THEN
    RETURN NEW;
  ELSE
    RETURN OLD;
  END IF;
END;
$$;


ALTER FUNCTION public._ipsiteminfobeforetrigger() OWNER TO admin;

--
-- TOC entry 986 (class 1255 OID 146565496)
-- Dependencies: 4536 8
-- Name: _itemaftertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _itemaftertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _cmnttypeid INTEGER;

BEGIN
-- Privilege Checks
   IF (NOT checkPrivilege('MaintainItemMasters')) THEN
     RAISE EXCEPTION 'You do not have privileges to maintain Items.';
   END IF;

-- Integrity checks
  IF (TG_OP = 'UPDATE') THEN
    IF ((OLD.item_type <> NEW.item_type) AND (NEW.item_type = 'L')) THEN
      IF (SELECT COUNT(*) != 0 FROM bomitem WHERE (bomitem_item_id = OLD.item_id)) THEN
        RAISE EXCEPTION 'This item is part of one or more Bills of Materials and cannot be a Planning Item.';
      END IF;
    END IF;

    IF ((OLD.item_type <> NEW.item_type) AND
       (NEW.item_type IN ('R','S','T'))) THEN
      IF (SELECT COUNT(*) != 0
        FROM itemsite
        WHERE ((itemsite_item_id=OLD.item_id)
        AND (itemsite_qtyonhand + qtyallocated(itemsite_id,startoftime(),endoftime()) +
	   qtyordered(itemsite_id,startoftime(),endoftime()) > 0 ))) THEN
          RAISE EXCEPTION 'Item type not allowed when there are itemsites with quantities with on hand quantities or pending inventory activity for this item.';
      END IF;
    END IF;
-- If type changed remove costs and deactivate item sites
    IF (NEW.item_type <> OLD.item_type) THEN
      PERFORM updateCost(itemcost_id, 0) FROM itemcost WHERE (itemcost_item_id=OLD.item_id);
      UPDATE itemsite SET itemsite_active=false WHERE (itemsite_item_id=OLD.item_id);
      IF (NEW.item_type = 'R') THEN
        UPDATE itemsite SET itemsite_controlmethod='N' WHERE (itemsite_item_id=OLD.item_id);
      END IF;
    END IF;
  END IF;

  IF ( SELECT (metric_value='t')
       FROM metric
       WHERE (metric_name='ItemChangeLog') ) THEN

--  Cache the cmnttype_id for ChangeLog
    SELECT cmnttype_id INTO _cmnttypeid
    FROM cmnttype
    WHERE (cmnttype_name='ChangeLog');
    IF (FOUND) THEN
      IF (TG_OP = 'INSERT') THEN
        PERFORM postComment(_cmnttypeid, 'I', NEW.item_id, 'Created');

      ELSIF (TG_OP = 'UPDATE') THEN
        IF (OLD.item_active <> NEW.item_active) THEN
          IF (NEW.item_active) THEN
            PERFORM postComment(_cmnttypeid, 'I', NEW.item_id, 'Activated');
          ELSE
            PERFORM postComment(_cmnttypeid, 'I', NEW.item_id, 'Deactivated');
          END IF;
        END IF;

        IF (OLD.item_descrip1 <> NEW.item_descrip1) THEN
          PERFORM postComment( _cmnttypeid, 'I', NEW.item_id,
                               ( 'Description 1 Changed from "' || OLD.item_descrip1 ||
                                 '" to "' || NEW.item_descrip1 || '"' ) );
        END IF;

        IF (OLD.item_descrip2 <> NEW.item_descrip2) THEN
          PERFORM postComment( _cmnttypeid, 'I', NEW.item_id,
                               ( 'Description 2 Changed from "' || OLD.item_descrip2 ||
                                 '" to "' || NEW.item_descrip2 || '"' ) );
        END IF;

        IF (OLD.item_inv_uom_id <> NEW.item_inv_uom_id) THEN
          PERFORM postComment( _cmnttypeid, 'I', NEW.item_id,
                               ( 'Inventory UOM Changed from "' ||
                                 (SELECT uom_name FROM uom WHERE uom_id=OLD.item_inv_uom_id) ||
                                 '" (' || CAST(OLD.item_inv_uom_id AS TEXT) ||
                                 ') to "' ||
                                 (SELECT uom_name FROM uom WHERE uom_id=NEW.item_inv_uom_id) ||
                                 '" (' || CAST(NEW.item_inv_uom_id AS TEXT) || ')' ) );
        END IF;

        IF (OLD.item_sold <> NEW.item_sold) THEN
          PERFORM postComment( _cmnttypeid, 'I', NEW.item_id,
                               CASE WHEN (NEW.item_sold) THEN 'Sold Changed from FALSE to TRUE'
                                    ELSE 'Sold Changed from TRUE to FALSE'
                               END );
        END IF;

        IF (OLD.item_picklist <> NEW.item_picklist) THEN
          PERFORM postComment( _cmnttypeid, 'I', NEW.item_id,
                               CASE WHEN (NEW.item_picklist) THEN 'Pick List Changed from FALSE to TRUE'
                                    ELSE 'Pick List Changed from TRUE to FALSE'
                               END );
        END IF;

        IF (OLD.item_fractional <> NEW.item_fractional) THEN
          PERFORM postComment( _cmnttypeid, 'I', NEW.item_id,
                               CASE WHEN (NEW.item_fractional) THEN 'Fractional Changed from FALSE to TRUE'
                                    ELSE 'Fractional Changed from TRUE to FALSE'
                               END );
        END IF;

        IF (OLD.item_exclusive <> NEW.item_exclusive) THEN
          PERFORM postComment( _cmnttypeid, 'I', NEW.item_id,
                               CASE WHEN (NEW.item_exclusive) THEN 'Exclusive Changed from FALSE to TRUE'
                                    ELSE 'Exclusive Changed from TRUE to FALSE'
                               END );
        END IF;
        IF (OLD.item_config <> NEW.item_config) THEN
          PERFORM postComment( _cmnttypeid, 'I', NEW.item_id,
                               CASE WHEN (NEW.item_config) THEN 'Configured Changed from FALSE to TRUE'
                                    ELSE 'Configured Changed from TRUE to FALSE'
                               END );
        END IF;

        IF (OLD.item_listprice <> NEW.item_listprice) THEN
          PERFORM postComment( _cmnttypeid, 'I', NEW.item_id,
                               ( 'List Price Changed from "' || formatSalesPrice(OLD.item_listprice) ||
                                 '" to "' || formatSalesPrice(NEW.item_listprice) || '"' ) );
        END IF;

-- Add New stuff

        IF (OLD.item_type <> NEW.item_type) THEN
          PERFORM postComment( _cmnttypeid, 'I', NEW.item_id,
                               ( 'Type Changed from "' || OLD.item_type ||
                                 '" to "' || NEW.item_type || '"' ) );
        END IF;

        IF (OLD.item_price_uom_id <> NEW.item_price_uom_id) THEN
          PERFORM postComment( _cmnttypeid, 'I', NEW.item_id,
                               ( 'Price UOM Changed from "' ||
                                 (SELECT uom_name FROM uom WHERE uom_id=OLD.item_price_uom_id) ||
                                 '" (' || CAST(OLD.item_price_uom_id AS TEXT) ||
                                 ') to "' ||
                                 (SELECT uom_name FROM uom WHERE uom_id=NEW.item_price_uom_id) ||
                                 '" (' || CAST(NEW.item_price_uom_id AS TEXT) || ')' ) );
        END IF;

        IF (OLD.item_classcode_id <> NEW.item_classcode_id) THEN
          PERFORM postComment( _cmnttypeid, 'I', NEW.item_id,
                               ( 'Class Code Changed from "' ||
                                 (SELECT classcode_code || '-' || classcode_descrip FROM classcode WHERE classcode_id=OLD.item_classcode_id) ||
                                 '" (' || CAST(OLD.item_classcode_id AS TEXT) ||
                                 ') to "' ||
                                 (SELECT classcode_code || '-' || classcode_descrip FROM classcode WHERE classcode_id=NEW.item_classcode_id) ||
                                 '" (' || CAST(NEW.item_classcode_id AS TEXT) || ')' ) );
        END IF;

        IF (OLD.item_freightclass_id <> NEW.item_freightclass_id) THEN
          PERFORM postComment( _cmnttypeid, 'I', NEW.item_id,
                               ( 'Freight Class Changed from "' ||
                                 (SELECT freightclass_code || '-' || freightclass_descrip FROM freightclass WHERE freightclass_id=OLD.item_freightclass_id) ||
                                 '" (' || CAST(OLD.item_freightclass_id AS TEXT) ||
                                 ') to "' ||
                                 (SELECT freightclass_code || '-' || freightclass_descrip FROM freightclass WHERE freightclass_id=NEW.item_freightclass_id) ||
                                 '" (' || CAST(NEW.item_freightclass_id AS TEXT) || ')' ) );
        END IF;

        IF (OLD.item_prodcat_id <> NEW.item_prodcat_id) THEN
          PERFORM postComment( _cmnttypeid, 'I', NEW.item_id,
                               ( 'Product Category Changed from "' ||
                                 (SELECT prodcat_code || '-' || prodcat_descrip FROM prodcat WHERE prodcat_id=OLD.item_prodcat_id) ||
                                 '" (' || CAST(OLD.item_prodcat_id AS TEXT) ||
                                 ') to "' ||
                                 (SELECT prodcat_code || '-' || prodcat_descrip FROM prodcat WHERE prodcat_id=NEW.item_prodcat_id) ||
                                 '" (' || CAST(NEW.item_prodcat_id AS TEXT) || ')' ) );
        END IF;

        IF (OLD.item_upccode <> NEW.item_upccode) THEN
          PERFORM postComment( _cmnttypeid, 'I', NEW.item_id,
                               ( 'UPC Code Changed from "' || OLD.item_upccode ||
                                 '" to "' || NEW.item_upccode || '"' ) );
        END IF;

        IF (OLD.item_prodweight <> NEW.item_prodweight) THEN
          PERFORM postComment( _cmnttypeid, 'I', NEW.item_id,
                               ( 'Product Weight Changed from "' || formatWeight(OLD.item_prodweight) ||
                                 '" to "' || formatWeight(NEW.item_prodweight) || '"' ) );
        END IF;

        IF (OLD.item_packweight <> NEW.item_packweight) THEN
          PERFORM postComment( _cmnttypeid, 'I', NEW.item_id,
                               ( 'Packaging Weight Changed from "' || formatWeight(OLD.item_packweight) ||
                                 '" to "' || formatWeight(NEW.item_packweight) || '"' ) );
        END IF;

        IF (OLD.item_maxcost <> NEW.item_maxcost) THEN
          PERFORM postComment( _cmnttypeid, 'I', NEW.item_id,
                               ( 'Maximum Desired Cost Changed from "' || formatCost(OLD.item_maxcost) ||
                                 '" to "' || formatCost(NEW.item_maxcost) || '"' ) );
        END IF;

        IF (OLD.item_listcost <> NEW.item_listcost) THEN
          PERFORM postComment( _cmnttypeid, 'I', NEW.item_id,
                               ( 'List Cost Changed from "' || formatCost(OLD.item_listcost) ||
                                 '" to "' || formatCost(NEW.item_listcost) || '"' ) );
        END IF;
-- End changes

      END IF;
    END IF;
  END IF;

  IF (TG_OP = 'DELETE') THEN
    DELETE FROM imageass WHERE ((imageass_source_id=OLD.item_id) AND (imageass_source='I'));
    DELETE FROM url WHERE ((url_source_id=OLD.item_id) AND (url_source='I'));
    DELETE FROM docass WHERE docass_source_id = OLD.item_id AND docass_source_type = 'I';
    DELETE FROM docass WHERE docass_target_id = OLD.item_id AND docass_target_type = 'I';

    RETURN OLD;
  END IF;

  RETURN NEW;

END;
$$;


ALTER FUNCTION public._itemaftertrigger() OWNER TO admin;

--
-- TOC entry 987 (class 1255 OID 146565498)
-- Dependencies: 4536 8
-- Name: _itemaliastrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _itemaliastrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2012 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

-- Privilege Checks
   IF (NOT checkPrivilege('MaintainItemMasters')) THEN
     RAISE EXCEPTION 'You do not have privileges to maintain Item Aliases.';
   END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._itemaliastrigger() OWNER TO admin;

--
-- TOC entry 988 (class 1255 OID 146565499)
-- Dependencies: 4536 8
-- Name: _itemcostaftertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _itemcostaftertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _itemNumber TEXT;
  _maxCost NUMERIC;
  _oldStdCost NUMERIC;
  _oldActCost NUMERIC;
  _actualCost NUMERIC;
  _standardCost NUMERIC;

BEGIN

--  Create Event if Standard or Actual Cost is greater than Max Cost

IF NOT EXISTS(SELECT 1
     FROM evntnot
       JOIN evnttype ON (evnttype_id = evntnot_evnttype_id)
       JOIN usrpref ON (evntnot_username = usrpref_username)
     WHERE
          evnttype_name = 'CostExceedsMaxDesired'
          AND usrpref_name = 'active'
          AND usrpref_value = 't')
   THEN
     RETURN NEW;
END IF;

  SELECT item_number, item_maxcost, actcost(item_id), stdcost(item_id) INTO _itemNumber, _maxCost, _actualCost, _standardCost
  FROM item
  WHERE (item_id=NEW.itemcost_item_id);

  IF (_maxCost > 0.0) THEN
   -- IF (_standardCost > _maxCost)
      IF NOT EXISTS(SELECT 1 --COUNT(evntlog_id)
                    FROM
                      evntlog, evnttype
                      WHERE evntlog_evnttype_id = evnttype_id
                      AND evntlog_number LIKE
                          (_itemNumber || ' -Standard- New:' || '%')

                      AND (evntlog_dispatched IS NULL)
                      AND CAST(evntlog_evnttime AS DATE) = current_date

                      )
                      AND (_standardCost > _maxCost) THEN


      IF (TG_OP = 'INSERT') THEN
        _oldStdCost := 0;
        _oldActCost := 0;
      ELSE
        _oldStdCost := OLD.itemcost_stdcost;
        _oldActCost := OLD.itemcost_stdcost;
      END IF;
      PERFORM postEvent('CostExceedsMaxDesired', NULL, NEW.itemcost_item_id,
                        itemsite_warehous_id,
                        (_itemNumber || ' -Standard- ' ||
                         'New: ' || formatCost(_standardCost) ||
                         ' Max: '|| formatCost(_MaxCost)),
                        NEW.itemcost_stdcost, _oldStdCost,
                        NULL, NULL)
      FROM itemsite
      WHERE (itemsite_item_id=NEW.itemcost_item_id);
    END IF;
       IF NOT EXISTS(
                     SELECT 1 FROM
                      evntlog, evnttype
                      WHERE evntlog_evnttype_id = evnttype_id
                      AND evntlog_number LIKE
                          (_itemNumber || ' -Actual- New:' || '%')

                      AND (evntlog_dispatched IS NULL)
                      AND CAST(evntlog_evnttime AS DATE) = current_date
                      )

                 AND  (_actualCost > _maxCost)
          THEN

      PERFORM postEvent('CostExceedsMaxDesired', NULL, NEW.itemcost_item_id,
                        itemsite_warehous_id,
                        (_itemNumber || ' -Actual- ' ||
                         'New: ' || formatCost(_actualCost) ||
                         ' Max: '|| formatCost(_MaxCost)),
                        NEW.itemcost_actcost, _oldActCost,
                        NULL, NULL)
      FROM itemsite
      WHERE (itemsite_item_id=NEW.itemcost_item_id);
    END IF;
  END IF;

  RETURN NEW;

END;
$$;


ALTER FUNCTION public._itemcostaftertrigger() OWNER TO admin;

--
-- TOC entry 989 (class 1255 OID 146565500)
-- Dependencies: 4536 8
-- Name: _itemcosttrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _itemcosttrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  --Privilege Checks
  IF ( (TG_OP = 'INSERT') AND (NOT checkPrivilege('CreateCosts')) AND (NOT checkPrivilege('PostVouchers')) ) THEN
    RAISE EXCEPTION 'You do not have privileges to enter Item Costs.';
  END IF;

  IF ( (TG_OP = 'UPDATE') AND (NOT checkPrivilege('EnterActualCosts')) AND (NOT checkPrivilege('PostVouchers')) AND (NOT checkPrivilege('UpdateActualCosts')) AND (NOT checkPrivilege('PostActualCosts')) AND (NOT checkPrivilege('PostStandardCosts')) ) THEN
    RAISE EXCEPTION 'You do not have privileges to update Item Costs.';
  END IF;

  IF ( (TG_OP = 'DELETE') AND (NOT checkPrivilege('DeleteCosts')) ) THEN
    RAISE EXCEPTION 'You do not have privileges to delete Item Costs.';
  END IF;

  IF (TG_OP = 'UPDATE') THEN
    IF (NEW.itemcost_actcost <> OLD.itemcost_actcost OR
        NEW.itemcost_curr_id <> OLD.itemcost_curr_id) THEN
      INSERT INTO costhist
      ( costhist_item_id, costhist_costelem_id, costhist_type,
        costhist_lowlevel, costhist_username, costhist_date,
        costhist_oldcost, costhist_newcost,
        costhist_oldcurr_id, costhist_newcurr_id )
      VALUES
      ( NEW.itemcost_item_id, NEW.itemcost_costelem_id, 'A',
        NEW.itemcost_lowlevel, getEffectiveXtUser(), CURRENT_TIMESTAMP,
        OLD.itemcost_actcost, NEW.itemcost_actcost,
        OLD.itemcost_curr_id, NEW.itemcost_curr_id );
    END IF;

    IF (NEW.itemcost_stdcost <> OLD.itemcost_stdcost) THEN
      INSERT INTO costhist
      ( costhist_item_id, costhist_costelem_id, costhist_type,
        costhist_lowlevel, costhist_username, costhist_date,
        costhist_oldcost, costhist_newcost,
        costhist_oldcurr_id, costhist_newcurr_id )
      VALUES
      ( NEW.itemcost_item_id, NEW.itemcost_costelem_id, 'S',
        NEW.itemcost_lowlevel, getEffectiveXtUser(), CURRENT_TIMESTAMP,
        OLD.itemcost_stdcost, NEW.itemcost_stdcost,
        baseCurrId(), baseCurrId() );
    END IF;

    RETURN NEW;

  ELSIF (TG_OP = 'INSERT') THEN
    INSERT INTO costhist
    ( costhist_item_id, costhist_costelem_id, costhist_type,
      costhist_lowlevel, costhist_username, costhist_date,
      costhist_oldcost, costhist_newcost,
      costhist_oldcurr_id, costhist_newcurr_id )
    VALUES
    ( NEW.itemcost_item_id, NEW.itemcost_costelem_id, 'N',
      NEW.itemcost_lowlevel, getEffectiveXtUser(), CURRENT_TIMESTAMP,
      0, NEW.itemcost_actcost,
      baseCurrId(), NEW.itemcost_curr_id );

    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN
    INSERT INTO costhist
    ( costhist_item_id, costhist_costelem_id, costhist_type,
      costhist_lowlevel, costhist_username, costhist_date,
      costhist_oldcost, costhist_newcost,
      costhist_oldcurr_id, costhist_newcurr_id )
    VALUES
    ( OLD.itemcost_item_id, OLD.itemcost_costelem_id, 'D',
      OLD.itemcost_lowlevel, getEffectiveXtUser(), CURRENT_TIMESTAMP,
      OLD.itemcost_stdcost, 0,
      OLD.itemcost_curr_id, baseCurrId() );

    RETURN OLD;
  END IF;

END;
$$;


ALTER FUNCTION public._itemcosttrigger() OWNER TO admin;

--
-- TOC entry 990 (class 1255 OID 146565501)
-- Dependencies: 4536 8
-- Name: _itemsiteaftertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _itemsiteaftertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _state INTEGER;
  _wasLocationControl BOOLEAN;
  _isLocationControl BOOLEAN;
  _wasLotSerial BOOLEAN;
  _isLotSerial BOOLEAN;
  _wasPerishable BOOLEAN;
  _isPerishable BOOLEAN;
  _qty NUMERIC;
  _maint BOOLEAN;
  _cost NUMERIC;
  _variance NUMERIC;
  _application TEXT;

BEGIN
-- Cache Application
  SELECT fetchMetricText('Application') INTO _application;

-- Check if we are doing maintenance
  IF (TG_OP = 'INSERT') THEN
    _maint := TRUE;
  ELSIF (TG_OP = 'UPDATE') THEN
    IF ((OLD.itemsite_item_id           != NEW.itemsite_item_id)
     OR (OLD.itemsite_warehous_id       != NEW.itemsite_warehous_id)
     OR (OLD.itemsite_reorderlevel      != NEW.itemsite_reorderlevel)
     OR (OLD.itemsite_ordertoqty        != NEW.itemsite_ordertoqty)
     OR (OLD.itemsite_cyclecountfreq    != NEW.itemsite_cyclecountfreq)
     OR (OLD.itemsite_planning_type     != NEW.itemsite_planning_type)
     OR (OLD.itemsite_posupply          != NEW.itemsite_posupply)
     OR (OLD.itemsite_wosupply          != NEW.itemsite_wosupply)
     OR (OLD.itemsite_loccntrl          != NEW.itemsite_loccntrl)
     OR (OLD.itemsite_safetystock       != NEW.itemsite_safetystock)
     OR (OLD.itemsite_minordqty         != NEW.itemsite_minordqty)
     OR (OLD.itemsite_multordqty        != NEW.itemsite_multordqty)
     OR (OLD.itemsite_leadtime          != NEW.itemsite_leadtime)
     OR (OLD.itemsite_abcclass          != NEW.itemsite_abcclass)
     OR (OLD.itemsite_controlmethod     != NEW.itemsite_controlmethod)
     OR (OLD.itemsite_active            != NEW.itemsite_active)
     OR (OLD.itemsite_plancode_id       != NEW.itemsite_plancode_id)
     OR (OLD.itemsite_costcat_id        != NEW.itemsite_costcat_id)
     OR (OLD.itemsite_eventfence        != NEW.itemsite_eventfence)
     OR (OLD.itemsite_sold              != NEW.itemsite_sold)
     OR (OLD.itemsite_stocked           != NEW.itemsite_stocked)
     OR (OLD.itemsite_location_id       != NEW.itemsite_location_id)
     OR (OLD.itemsite_recvlocation_id   != NEW.itemsite_recvlocation_id)
     OR (OLD.itemsite_issuelocation_id  != NEW.itemsite_issuelocation_id)
     OR (OLD.itemsite_location_dist     != NEW.itemsite_location_dist)
     OR (OLD.itemsite_recvlocation_dist != NEW.itemsite_recvlocation_dist)
     OR (OLD.itemsite_issuelocation_dist != NEW.itemsite_issuelocation_dist)
     OR (OLD.itemsite_useparams         != NEW.itemsite_useparams)
     OR (OLD.itemsite_useparamsmanual   != NEW.itemsite_useparamsmanual)
     OR (OLD.itemsite_soldranking       != NEW.itemsite_soldranking)
     OR (OLD.itemsite_createpr          != NEW.itemsite_createpr)
     OR (OLD.itemsite_location          != NEW.itemsite_location)
     OR (OLD.itemsite_location_comments != NEW.itemsite_location_comments)
     OR (OLD.itemsite_notes             != NEW.itemsite_notes)
     OR (OLD.itemsite_perishable        != NEW.itemsite_perishable)
     OR (OLD.itemsite_autoabcclass      != NEW.itemsite_autoabcclass)
     OR (OLD.itemsite_ordergroup        != NEW.itemsite_ordergroup)
     OR (OLD.itemsite_disallowblankwip  != NEW.itemsite_disallowblankwip)
     OR (OLD.itemsite_maxordqty         != NEW.itemsite_maxordqty)
     OR (OLD.itemsite_mps_timefence     != NEW.itemsite_mps_timefence)
     OR (OLD.itemsite_createwo          != NEW.itemsite_createwo)
     OR (OLD.itemsite_warrpurc          != NEW.itemsite_warrpurc)
     OR (OLD.itemsite_costmethod        != NEW.itemsite_costmethod)
     OR (OLD.itemsite_autoreg           != NEW.itemsite_autoreg)
     OR (OLD.itemsite_lsseq_id          != NEW.itemsite_lsseq_id) ) THEN
      IF (OLD.itemsite_item_id != NEW.itemsite_item_id) THEN
        RAISE EXCEPTION 'The item number on an itemsite may not be changed.';
      ELSIF (OLD.itemsite_warehous_id != NEW.itemsite_warehous_id) THEN
        RAISE EXCEPTION 'The warehouse code on an itemsite may not be changed.';
      END IF;
      _maint := TRUE;
    END IF;
  ELSE
    _maint := FALSE;
  END IF;

  IF (_maint) THEN -- Begin Maintenance
-- Privilege Checks
    IF ( NOT checkPrivilege('MaintainItemSites') ) THEN
       RAISE EXCEPTION 'You do not have privileges to maintain Item Sites.';
    END IF;

-- Override values to avoid invalid data combinations
    IF (NOT NEW.itemsite_posupply) THEN
      UPDATE itemsite SET
        itemsite_createpr = FALSE
      WHERE (itemsite_id=NEW.itemsite_id);
    END IF;
    IF (NOT NEW.itemsite_wosupply) THEN
      UPDATE itemsite SET
        itemsite_createwo = FALSE
      WHERE (itemsite_id=NEW.itemsite_id);
    END IF;

    IF (NEW.itemsite_controlmethod NOT IN ('S','L')) THEN
      UPDATE itemsite SET
        itemsite_perishable = FALSE,
        itemsite_warrpurc = FALSE,
        itemsite_autoreg = FALSE,
        itemsite_lsseq_id = NULL
      WHERE (itemsite_id=NEW.itemsite_id);
    END IF;

    IF (NOT NEW.itemsite_loccntrl) THEN
      UPDATE itemsite SET
        itemsite_disallowblankwip = FALSE
      WHERE (itemsite_id=NEW.itemsite_id);
    END IF;

    IF (NOT NEW.itemsite_useparams) THEN
      UPDATE itemsite SET
        itemsite_reorderlevel    = 0,
        itemsite_ordertoqty      = 0,
        itemsite_minordqty       = 0,
        itemsite_maxordqty       = 0,
        itemsite_multordqty      = 0,
        itemsite_useparamsmanual = FALSE
      WHERE (itemsite_id = NEW.itemsite_id);
    END IF;

-- Integrity check

    -- Both insert and update
    IF ( (NEW.itemsite_controlmethod IN ('S', 'L')) AND
         (NEW.itemsite_location_dist OR NEW.itemsite_recvlocation_dist OR NEW.itemsite_issuelocation_dist) ) THEN
      RAISE EXCEPTION 'You cannot auto-distribute Lot/Serial controlled Item Sites.';
    END IF;

    IF (TG_OP = 'INSERT') THEN
      -- Handle MLC logic
      IF ( (NEW.itemsite_loccntrl) AND (NEW.itemsite_warehous_id IS NOT NULL) ) THEN
        IF (SELECT count(*)=0
            FROM location
            WHERE ((location_warehous_id=NEW.itemsite_warehous_id)
            AND ( (NOT location_restrict) OR
                ( (location_restrict) AND
                (location_id IN ( SELECT locitem_location_id
                                  FROM locitem
                                  WHERE (locitem_item_id=NEW.itemsite_item_id) ) ) ) ))) THEN
          RAISE EXCEPTION 'You must first create at least one valid
	    		  Location for this Item Site before it may be
	   	          multiply located.';
        END IF;
      END IF;

      --This could be made a table constraint later, but do not want to create a big problem
      --for users with problematic legacy data over a relatively trivial problem for now,
      --so we will just check moving forword.
      IF (NEW.itemsite_stocked AND NEW.itemsite_reorderlevel<=0) THEN
        RAISE EXCEPTION 'Stocked items must have postive reorder level specified.';
      END IF;
    END IF;

    IF (TG_OP = 'UPDATE') THEN
      --This could be made a table constraint later, but do not want to create a big problem
      --for users with problematic legacy data over a relatively trivial problem for now,
      --so we will just check moving forword.
      IF ((NEW.itemsite_stocked)
        AND (NEW.itemsite_stocked != OLD.itemsite_stocked) --Avoid checking unless explicitly changed
        AND (NEW.itemsite_reorderlevel<=0)) THEN
        RAISE EXCEPTION 'Stocked items must have postive reorder level specified.';
      END IF;
    END IF;

    IF (TG_OP = 'UPDATE') THEN

-- Integrity check
      IF (NOT OLD.itemsite_loccntrl AND NEW.itemsite_loccntrl) THEN
        IF (SELECT count(*)=0
          FROM location
          WHERE ((location_warehous_id=NEW.itemsite_warehous_id)
          AND ( (NOT location_restrict) OR
              ( (location_restrict) AND
              (location_id IN ( SELECT locitem_location_id
                                FROM locitem
                                WHERE (locitem_item_id=NEW.itemsite_item_id) ) ) ) ))) THEN
           RAISE EXCEPTION 'You must first create at least one valid
			  Location for this Item Site before it may be
		          multiply located.';
        END IF;
      END IF;

-- Update detail records based on control method changes
      _wasLocationControl := OLD.itemsite_loccntrl;
      _isLocationControl := NEW.itemsite_loccntrl;
      _wasLotSerial := OLD.itemsite_controlmethod IN ('S','L');
      _isLotSerial := NEW.itemsite_controlmethod IN ('S','L');
      _wasPerishable := OLD.itemsite_perishable;
      _isPerishable := NEW.itemsite_perishable;
      _state := 0;

      IF ( (_wasLocationControl) AND (_isLocationControl) ) THEN
        _state := 10;
      ELSIF ( (NOT _wasLocationControl) AND (NOT _isLocationControl) ) THEN
        _state := 20;
      ELSIF ( (NOT _wasLocationControl) AND (_isLocationControl) ) THEN
        _state := 30;
      ELSIF ( (_wasLocationControl) AND (NOT _isLocationControl) ) THEN
        _state := 40;
      END IF;

      IF ( (_wasLotSerial) AND (_isLotSerial) ) THEN
        _state := _state + 1;
      ELSIF ( (NOT _wasLotSerial) AND (NOT _isLotSerial) ) THEN
        _state := _state + 2;
      ELSIF ( (NOT _wasLotSerial) AND (_isLotSerial) ) THEN
        _state := _state + 3;
      ELSIF ( (_wasLotSerial) AND (NOT _isLotSerial) ) THEN
        _state := _state + 4;
      END IF;

      IF ( (_application = 'Standard') AND (_state IN (41, 43, 14, 34, 24, 42, 44)) ) THEN
        -- Check for Reservations
        IF (SELECT COUNT(*) > 0
            FROM itemloc JOIN reserve ON (reserve_supply_id=itemloc_id AND reserve_supply_type='I')
            WHERE (itemloc_itemsite_id=OLD.itemsite_id)) THEN
          RAISE EXCEPTION 'Sales Order Reservations by Location exist for this Item Site';
        END IF;
      END IF;

      IF (_state IN (41, 43)) THEN
        PERFORM consolidateLotSerial(OLD.itemsite_id);
      ELSIF (_state IN (14, 34)) THEN
        PERFORM consolidateLocations(OLD.itemsite_id);
      ELSIF (_state IN (24, 42, 44)) THEN

        RAISE NOTICE 'Deleting item site detail records,';

        SELECT SUM(itemloc_qty) INTO _qty
        FROM itemloc, location
        WHERE ((itemloc_location_id=location_id)
        AND (NOT location_netable)
        AND (itemloc_itemsite_id=OLD.itemsite_id));

        IF (_qty != 0) THEN
          UPDATE itemsite
          SET itemsite_qtyonhand = itemsite_qtyonhand + _qty,
            itemsite_nnqoh = itemsite_nnqoh - _qty
          WHERE (itemsite_id=OLD.itemsite_id);
        END IF;

        DELETE FROM itemloc
        WHERE (itemloc_itemsite_id=OLD.itemsite_id);
      END IF;

     IF (NEW.itemsite_qtyonhand != 0) THEN
--  Handle detail creation
--  Create itemloc records if they do not exist
       IF (_state IN (23, 32, 33)) THEN
          INSERT INTO itemloc
            ( itemloc_itemsite_id, itemloc_location_id,
              itemloc_expiration, itemloc_qty )
            VALUES
            ( NEW.itemsite_id, -1,
              endOfTime(), NEW.itemsite_qtyonhand );
        END IF;

--  Handle Location distribution
        IF (_state IN (31, 32, 33, 34)) THEN
          IF (SELECT (COUNT(*)=1)
              FROM location
              WHERE ((location_id=NEW.itemsite_location_id)
              AND (location_warehous_id=NEW.itemsite_warehous_id)
              AND ( (NOT location_restrict) OR
                  ( (location_restrict) AND
                  (location_id IN ( SELECT locitem_location_id
                                    FROM locitem
                                    WHERE (locitem_item_id=NEW.itemsite_item_id) ) ) ) ))) THEN
           PERFORM initialDistribution(NEW.itemsite_id, NEW.itemsite_location_id);
          ELSE
            RAISE EXCEPTION 'A valid default location must be selected to distribute existing inventory to.';
          END IF;
        END IF;

--  Handle Lot/Serial distribution
        IF ( (_state = 13) OR (_state = 23) OR (_state = 33) OR (_state = 43) ) THEN
          RAISE NOTICE 'You should now use the Reassign Lot/Serial # window to assign Lot/Serial #s.';
        END IF;
      END IF;
      IF (OLD.itemsite_costmethod='A' AND NEW.itemsite_costmethod='S') THEN
        -- TODO: Average costing cost method change
        SELECT stdcost(NEW.itemsite_item_id) * NEW.itemsite_qtyonhand
          INTO _cost;
        _variance := _cost - NEW.itemsite_value;
        NEW.itemsite_value := _cost;
        IF(_variance <> 0.0) THEN
          PERFORM insertGLTransaction( 'P/D', '', '', 'Itemsite converted from Average to Standard cost.',
                                       costcat_invcost_accnt_id, costcat_asset_accnt_id, NEW.itemsite_id,
                                      _variance, CURRENT_DATE )
             FROM costcat
            WHERE(costcat_id=NEW.itemsite_costcat_id);
          UPDATE itemsite SET itemsite_value = _cost WHERE (itemsite_id = NEW.itemsite_id);
        END IF;
      END IF;
    END IF;

--  Handle Perishable
    IF ( (_application = 'Standard') AND (_wasPerishable) AND (NOT _isPerishable) ) THEN
      UPDATE itemloc SET itemloc_expiration = endOfTime()
      WHERE (itemloc_itemsite_id = OLD.itemsite_id);
      PERFORM consolidateLotSerial(OLD.itemsite_id);
    END IF;

--  If Planning Type changed to None then delete all Planned Orders
    IF ( (_application = 'Standard') AND (TG_OP = 'UPDATE') ) THEN
      IF (NEW.itemsite_planning_type = 'N' AND OLD.itemsite_planning_type <> 'N') THEN
        PERFORM deletePlannedOrder(planord_id, TRUE)
        FROM planord
        WHERE (planord_itemsite_id=NEW.itemsite_id);
      END IF;
    END IF;

  END IF;  -- End Maintenance

  RETURN NEW;

END;
$$;


ALTER FUNCTION public._itemsiteaftertrigger() OWNER TO admin;

--
-- TOC entry 991 (class 1255 OID 146565503)
-- Dependencies: 4536 8
-- Name: _itemsitetrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _itemsitetrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _cmnttypeid INTEGER;
  _r RECORD;

BEGIN

  -- Cache some information
  SELECT item_type INTO _r
  FROM item
  WHERE (item_id=NEW.itemsite_item_id);

-- Override values to avoid invalid data combinations
  IF (_r.item_type IN ('J','R','S')) THEN
    NEW.itemsite_planning_type := 'N';
  END IF;

  IF (_r.item_type = 'L') THEN
    NEW.itemsite_planning_type := 'S';
  END IF;

  IF (TG_OP = 'UPDATE') THEN
    IF ( (NEW.itemsite_qtyonhand <> OLD.itemsite_qtyonhand) ) THEN
      IF (OLD.itemsite_freeze) THEN
        NEW.itemsite_qtyonhand := OLD.itemsite_qtyonhand;
      ELSE
        NEW.itemsite_datelastused := CURRENT_DATE;
      END IF;

      IF ( (NEW.itemsite_qtyonhand < 0) AND (OLD.itemsite_qtyonhand >= 0) AND (NEW.itemsite_eventfence > 0) ) THEN
        PERFORM postEvent('QOHBelowZero', 'I', NEW.itemsite_id,
                          warehous_id,
                          (item_number || '/' || warehous_code),
                          NULL, NULL, NULL, NULL)
        FROM item, whsinfo
        WHERE (item_id=NEW.itemsite_item_id)
          AND (warehous_id=NEW.itemsite_warehous_id);
      END IF;
    END IF;
    IF ( (NEW.itemsite_value <> OLD.itemsite_value) AND (OLD.itemsite_freeze) ) THEN
      NEW.itemsite_value := OLD.itemsite_value;
    END IF;
  END IF;

  IF (NEW.itemsite_qtyonhand < 0 AND NEW.itemsite_costmethod = 'A') THEN
    RAISE EXCEPTION 'Itemsite (%) is set to use average costing and is not allowed to have a negative quantity on hand.', NEW.itemsite_id;
  ELSIF (NEW.itemsite_value < 0 AND NEW.itemsite_costmethod = 'A') THEN
    RAISE EXCEPTION 'This transaction results in a negative itemsite value.  Itemsite (%) is set to use average costing and is not allowed to have a negative value.', NEW.itemsite_id;
  END IF;

--  Handle the ChangeLog
  IF ( SELECT (metric_value='t')
       FROM metric
       WHERE (metric_name='ItemSiteChangeLog') ) THEN

--  Cache the cmnttype_id for ChangeLog
    SELECT cmnttype_id INTO _cmnttypeid
    FROM cmnttype
    WHERE (cmnttype_name='ChangeLog');
    IF (FOUND) THEN
      IF (TG_OP = 'INSERT') THEN
        PERFORM postComment(_cmnttypeid, 'IS', NEW.itemsite_id, 'Created');

      ELSIF (TG_OP = 'UPDATE') THEN

        IF (OLD.itemsite_plancode_id <> NEW.itemsite_plancode_id) THEN
          PERFORM postComment( _cmnttypeid, 'IS', NEW.itemsite_id,
                               ( 'Planner Code Changed from "' || oldplancode.plancode_code ||
                                 '" to "' || newplancode.plancode_code || '"' ) )
          FROM plancode AS oldplancode, plancode AS newplancode
          WHERE ( (oldplancode.plancode_id=OLD.itemsite_plancode_id)
           AND (newplancode.plancode_id=NEW.itemsite_plancode_id) );
        END IF;

        IF (NEW.itemsite_reorderlevel <> OLD.itemsite_reorderlevel) THEN
          PERFORM postComment( _cmnttypeid, 'IS', NEW.itemsite_id,
                               ( 'Reorder Level Changed from ' || formatQty(OLD.itemsite_reorderlevel) ||
                                 ' to ' || formatQty(NEW.itemsite_reorderlevel ) ) );
        END IF;

        IF (NEW.itemsite_ordertoqty <> OLD.itemsite_ordertoqty) THEN
          PERFORM postComment( _cmnttypeid, 'IS', NEW.itemsite_id,
                               ( 'Order Up To Changed from ' || formatQty(OLD.itemsite_ordertoqty) ||
                                 ' to ' || formatQty(NEW.itemsite_ordertoqty ) ) );
        END IF;

        IF (NEW.itemsite_leadtime <> OLD.itemsite_leadtime) THEN
          PERFORM postComment( _cmnttypeid, 'IS', NEW.itemsite_id,
                               ( 'Itemsite Leadtime Changed from ' || formatQty(OLD.itemsite_leadtime) ||
                                 ' to ' || formatQty(NEW.itemsite_leadtime ) ) );
        END IF;

        IF (NEW.itemsite_abcclass <> OLD.itemsite_abcclass) THEN
          PERFORM postComment( _cmnttypeid, 'IS', NEW.itemsite_id,
                               ( 'Itemsite ABC Class Changed from ' || COALESCE(OLD.itemsite_abcclass, 'None') ||
                                 ' to ' || COALESCE(NEW.itemsite_abcclass,'None') ) );
        END IF;

        IF (NEW.itemsite_controlmethod <> OLD.itemsite_controlmethod) THEN
          PERFORM postComment( _cmnttypeid, 'IS', NEW.itemsite_id,
                               ( 'Itemsite Control Method Changed from ' || COALESCE(OLD.itemsite_controlmethod,'None') ||
                                 ' to ' || COALESCE(NEW.itemsite_controlmethod,'None') ) );
        END IF;

        IF (OLD.itemsite_sold <> NEW.itemsite_sold) THEN
          PERFORM postComment( _cmnttypeid, 'IS', NEW.itemsite_id,
            CASE WHEN (NEW.itemsite_sold) THEN 'Sold Changed from FALSE to TRUE'
                                          ELSE 'Sold Changed from TRUE to FALSE'
            END );
        END IF;

        IF (OLD.itemsite_active <> NEW.itemsite_active) THEN
          IF (NEW.itemsite_active) THEN
            PERFORM postComment(_cmnttypeid, 'IS', NEW.itemsite_id, 'Activated');
          ELSE
            PERFORM postComment(_cmnttypeid, 'IS', NEW.itemsite_id, 'Deactivated');
          END IF;
        END IF;

      END IF;
    END IF;
  END IF;

  RETURN NEW;

END;
$$;


ALTER FUNCTION public._itemsitetrigger() OWNER TO admin;

--
-- TOC entry 992 (class 1255 OID 146565504)
-- Dependencies: 4536 8
-- Name: _itemsrcaftertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _itemsrcaftertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

-- Privilege Checks
  IF (NOT checkPrivilege('MaintainItemSources')) THEN
    RAISE EXCEPTION 'You do not have privileges to maintain Item Sources.';
  END IF;

-- Set default to false for other item sources of this item
  IF (COALESCE(NEW.itemsrc_default, FALSE) = TRUE) THEN
    UPDATE itemsrc SET itemsrc_default = FALSE
    WHERE ( (itemsrc_item_id = NEW.itemsrc_item_id)
      AND (itemsrc_id <> NEW.itemsrc_id) );
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._itemsrcaftertrigger() OWNER TO admin;

--
-- TOC entry 993 (class 1255 OID 146565505)
-- Dependencies: 4536 8
-- Name: _itemsrcptrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _itemsrcptrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

-- Privilege Checks
   IF (NOT checkPrivilege('MaintainItemSources')) THEN
     RAISE EXCEPTION 'You do not have privileges to maintain Item Sources.';
   END IF;

-- Set defaults
   NEW.itemsrcp_curr_id	:= COALESCE(NEW.itemsrcp_curr_id,basecurrid());

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._itemsrcptrigger() OWNER TO admin;

--
-- TOC entry 994 (class 1255 OID 146565506)
-- Dependencies: 4536 8
-- Name: _itemsrctrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _itemsrctrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

-- Privilege Checks
   IF (NOT checkPrivilege('MaintainItemSources')) THEN
     RAISE EXCEPTION 'You do not have privileges to maintain Item Sources.';
   END IF;

-- Set defaults
   NEW.itemsrc_invvendoruomratio	:= COALESCE(NEW.itemsrc_invvendoruomratio,1);
   NEW.itemsrc_minordqty		:= COALESCE(NEW.itemsrc_minordqty,0);
   NEW.itemsrc_multordqty		:= COALESCE(NEW.itemsrc_multordqty,0);
   NEW.itemsrc_active			:= COALESCE(NEW.itemsrc_active,true);
   NEW.itemsrc_leadtime			:= COALESCE(NEW.itemsrc_leadtime,0);
   NEW.itemsrc_ranking			:= COALESCE(NEW.itemsrc_ranking,1);

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._itemsrctrigger() OWNER TO admin;

--
-- TOC entry 995 (class 1255 OID 146565507)
-- Dependencies: 4536 8
-- Name: _itemsubtrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _itemsubtrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

-- Privilege Checks
   IF (NOT checkPrivilege('MaintainItemMasters')) THEN
     RAISE EXCEPTION 'You do not have privileges to maintain Item Substitutes.';
   END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._itemsubtrigger() OWNER TO admin;

--
-- TOC entry 996 (class 1255 OID 146565508)
-- Dependencies: 4536 8
-- Name: _itemtaxtrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _itemtaxtrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

-- Privilege Checks
   IF (NOT checkPrivilege('MaintainItemMasters')) THEN
     RAISE EXCEPTION 'You do not have privileges to maintain Items.';
   END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._itemtaxtrigger() OWNER TO admin;

--
-- TOC entry 1001 (class 1255 OID 146565513)
-- Dependencies: 4536 8
-- Name: _metasqlaltertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _metasqlaltertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (NOT (isDBA() OR checkPrivilege('MaintainMetaSQL'))) THEN
    RAISE EXCEPTION '% does not have privileges to maintain MetaSQL statements in %.%',
                getEffectiveXtUser(), TG_TABLE_SCHEMA, TG_TABLE_NAME;
  END IF;

  IF ((TG_OP = 'UPDATE' OR TG_OP = 'DELETE')
      AND NEW.metasql_grade <= 0
      AND NOT isDBA()) THEN
    RAISE EXCEPTION 'You may not alter grade 0 metasql queries except using the xTuple Updater utility';
  END IF;

  IF (TG_OP = 'DELETE') THEN
    RETURN OLD;
  END IF;

  RETURN NEW;
END;

$$;


ALTER FUNCTION public._metasqlaltertrigger() OWNER TO admin;

--
-- TOC entry 1002 (class 1255 OID 146565514)
-- Dependencies: 4536 8
-- Name: _metasqltrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _metasqltrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  NEW.metasql_lastuser 		:= getEffectiveXtUser();
  NEW.metasql_lastupdate 	:= current_date;
  RETURN NEW;

END;

$$;


ALTER FUNCTION public._metasqltrigger() OWNER TO admin;

--
-- TOC entry 1007 (class 1255 OID 146565518)
-- Dependencies: 4536 8
-- Name: _periodaftertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _periodaftertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _idoffirst INTEGER;
  _test      INTEGER;
BEGIN
  -- This trigger can easily cause an infinite loop
  -- because of this we have to be very careful to not
  -- do an update on the period table if no updates
  -- are absolutely needed so we don't just keep
  -- trigger ourselves again and again

  -- Figure out which period is the first one
  SELECT period_id
    INTO _idoffirst
    FROM period
   ORDER BY period_start
   LIMIT 1;

  -- If we didn't find anything there is nothing to do
  IF( NOT FOUND ) THEN
    RETURN NEW;
  END IF;

  -- do a select to see if there is at least one record that needs to be
  -- updated. If we do not find any then we can just leave without
  -- causing a retrigger of ourselves
  SELECT period_id
    INTO _test
    FROM period
   WHERE((COALESCE(period_initial, true) AND (NOT period_id=_idoffirst))
      OR ((NOT COALESCE(period_initial, false)) AND (period_id=_idoffirst)))
   LIMIT 1;

  -- Nothing to update - get out of here
  IF( NOT FOUND ) THEN
    RETURN NEW;
  END IF;

  -- Update all the period records that already have the initial flag
  -- set and the one that we know should be the first.
  -- We don't have to be as careful here since we have already ruled
  -- out if don't need to update already.
  UPDATE period
     SET period_initial = (_idoffirst=period_id)
   WHERE((COALESCE(period_initial, true))
      OR (period_id=_idoffirst));

  RETURN NEW;

END;
$$;


ALTER FUNCTION public._periodaftertrigger() OWNER TO admin;

--
-- TOC entry 1008 (class 1255 OID 146565519)
-- Dependencies: 4536 8
-- Name: _pkgcmdaftertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _pkgcmdaftertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (TG_OP = 'DELETE') THEN
    RETURN OLD;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._pkgcmdaftertrigger() OWNER TO admin;

--
-- TOC entry 1009 (class 1255 OID 146565520)
-- Dependencies: 4536 8
-- Name: _pkgcmdaltertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _pkgcmdaltertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (pkgMayBeModified(TG_TABLE_SCHEMA)) THEN
    IF (TG_OP = 'DELETE') THEN
      RETURN OLD;
    ELSE
      RETURN NEW;
    END IF;
  END IF;

  IF (TG_OP = 'INSERT') THEN
    RAISE EXCEPTION 'You may not create custom commands in packages except using the xTuple Updater utility';

  ELSIF (TG_OP = 'UPDATE') THEN
    RAISE EXCEPTION 'You may not alter custom commands in packages except using the xTuple Updater utility';

  ELSIF (TG_OP = 'DELETE') THEN
    RAISE EXCEPTION 'You may not delete custom commands from packages. Try deleting or disabling the package.';

  END IF;

  RETURN NEW;
END;

$$;


ALTER FUNCTION public._pkgcmdaltertrigger() OWNER TO admin;

--
-- TOC entry 1010 (class 1255 OID 146565521)
-- Dependencies: 4536 8
-- Name: _pkgcmdargaftertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _pkgcmdargaftertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (TG_OP = 'DELETE') THEN
    RETURN OLD;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION public._pkgcmdargaftertrigger() OWNER TO admin;

--
-- TOC entry 1012 (class 1255 OID 146565522)
-- Dependencies: 4536 8
-- Name: _pkgcmdargaltertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _pkgcmdargaltertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (pkgMayBeModified(TG_TABLE_SCHEMA)) THEN
    IF (TG_OP = 'DELETE') THEN
      RETURN OLD;
    ELSE
      RETURN NEW;
    END IF;
  END IF;

  IF (TG_OP = 'INSERT') THEN
    RAISE EXCEPTION 'You may not create command arguments in packages except using the xTuple Updater utility';

  ELSIF (TG_OP = 'UPDATE') THEN
    RAISE EXCEPTION 'You may not alter command arguments in packages except using the xTuple Updater utility';

  ELSIF (TG_OP = 'DELETE') THEN
    RAISE EXCEPTION 'You may not delete command arguments from packages. Try deleting or disabling the package.';

  END IF;

  RETURN NEW;
END;

$$;


ALTER FUNCTION public._pkgcmdargaltertrigger() OWNER TO admin;

--
-- TOC entry 1013 (class 1255 OID 146565523)
-- Dependencies: 4536 8
-- Name: _pkgcmdargbeforetrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _pkgcmdargbeforetrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _cmdargid     INTEGER;
  _debug        BOOL := false;

BEGIN
  IF (TG_OP = 'UPDATE') THEN
    RETURN NEW;

  ELSIF (TG_OP = 'INSERT') THEN
    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN
    RETURN OLD;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._pkgcmdargbeforetrigger() OWNER TO admin;

--
-- TOC entry 1014 (class 1255 OID 146565524)
-- Dependencies: 4536 8
-- Name: _pkgcmdbeforetrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _pkgcmdbeforetrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _cmdid       INTEGER;
  _debug        BOOL := false;

BEGIN
    IF (TG_OP = 'UPDATE') THEN
      IF (_debug) THEN
        RAISE NOTICE 'OLD.cmd_name %, NEW.cmd_name %',
                     OLD.cmd_name, NEW.cmd_name;
      END IF;

      IF (NEW.cmd_name != OLD.cmd_name) THEN
        SELECT cmd_id INTO _cmdid FROM cmd WHERE cmd_name=NEW.cmd_name;
        IF (FOUND) THEN
          RAISE EXCEPTION 'Cannot change command name % because another command with that name already exists.', NEW.cmd_name;
        END IF;
      END IF;

    ELSIF (TG_OP = 'INSERT') THEN
      IF (_debug) THEN
        RAISE NOTICE 'inserting NEW.cmd_name %', NEW.cmd_name;
      END IF;
      SELECT cmd_id INTO _cmdid FROM cmd WHERE cmd_name=NEW.cmd_name;
      IF (FOUND) THEN
        RAISE EXCEPTION 'Cannot create new command % because another command with that name already exists.', NEW.cmd_name;
      END IF;

    ELSIF (TG_OP = 'DELETE') THEN
      DELETE FROM cmdarg WHERE cmdarg_cmd_id=OLD.cmd_id;

      RETURN OLD;
    END IF;

    RETURN NEW;
  END;
$$;


ALTER FUNCTION public._pkgcmdbeforetrigger() OWNER TO admin;

--
-- TOC entry 1016 (class 1255 OID 146565526)
-- Dependencies: 4536 8
-- Name: _pkgimageaftertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _pkgimageaftertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (TG_OP = 'DELETE') THEN
    RETURN OLD;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._pkgimageaftertrigger() OWNER TO admin;

--
-- TOC entry 1017 (class 1255 OID 146565527)
-- Dependencies: 4536 8
-- Name: _pkgimagealtertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _pkgimagealtertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (pkgMayBeModified(TG_TABLE_SCHEMA)) THEN
    IF (TG_OP = 'DELETE') THEN
      RETURN OLD;
    ELSE
      RETURN NEW;
    END IF;
  END IF;

  IF (TG_OP = 'INSERT') THEN
    RAISE EXCEPTION 'You may not create images in packages except using the xTuple Updater utility';

  ELSIF (TG_OP = 'UPDATE') THEN
    RAISE EXCEPTION 'You may not alter images in packages except using the xTuple Updater utility';

  ELSIF (TG_OP = 'DELETE') THEN
    RAISE EXCEPTION 'You may not delete images from packages. Try deleting or disabling the package.';

  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._pkgimagealtertrigger() OWNER TO admin;

--
-- TOC entry 1018 (class 1255 OID 146565528)
-- Dependencies: 4536 8
-- Name: _pkgimagebeforetrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _pkgimagebeforetrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _imageid     INTEGER;
  _debug       BOOL := false;

BEGIN
  IF (TG_OP = 'UPDATE') THEN
    IF (_debug) THEN
      RAISE NOTICE 'OLD.image_name %, NEW.image_name %',
                   OLD.image_name, NEW.image_name;
    END IF;

    IF (NEW.image_name != OLD.image_name) THEN
      SELECT image_id INTO _imageid FROM image WHERE image_name=NEW.image_name;
      IF (FOUND) THEN
        RAISE EXCEPTION 'Cannot change image named % because another image with that name already exists.', NEW.image_name;
      END IF;
    END IF;

  ELSIF (TG_OP = 'INSERT') THEN
    IF (_debug) THEN
      RAISE NOTICE 'inserting NEW.image_name %', NEW.image_name;
    END IF;
    SELECT image_id INTO _imageid FROM image WHERE image_name=NEW.image_name;
    IF (FOUND) THEN
      RAISE EXCEPTION 'Cannot create new image % because another image with that name already exists.', NEW.image_name;
    END IF;

  ELSIF (TG_OP = 'DELETE') THEN
    RETURN OLD;

  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._pkgimagebeforetrigger() OWNER TO admin;


--
-- TOC entry 1020 (class 1255 OID 146565531)
-- Dependencies: 4536 8
-- Name: _pkgmetasqlaftertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _pkgmetasqlaftertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (TG_OP = 'DELETE') THEN
    RETURN OLD;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._pkgmetasqlaftertrigger() OWNER TO admin;

--
-- TOC entry 1022 (class 1255 OID 146565532)
-- Dependencies: 4536 8
-- Name: _pkgmetasqlaltertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _pkgmetasqlaltertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _isdba        BOOLEAN := false;

BEGIN
  SELECT rolsuper INTO _isdba FROM pg_roles WHERE (rolname=getEffectiveXtUser());

  IF (pkgMayBeModified(TG_TABLE_SCHEMA)) THEN
    IF (TG_OP = 'DELETE') THEN
      RETURN OLD;
    ELSE
      RETURN NEW;
    END IF;
  END IF;

  -- cannot combine IF's because plpgsql does not always evaluate left-to-right
  IF (TG_OP = 'INSERT') THEN
    IF (NEW.metasql_grade <= 0 AND NOT _isdba) THEN
      RAISE EXCEPTION 'You may not create grade 0 MetaSQL statements in packages except using the xTuple Updater utility';
    END IF;

  ELSIF (TG_OP = 'UPDATE') THEN
    IF (NEW.metasql_grade <= 0 AND NOT _isdba) THEN
      RAISE EXCEPTION 'You may not alter grade 0 MetaSQL statements in packages except using the xTuple Updater utility';
    END IF;

  ELSIF (TG_OP = 'DELETE') THEN
    IF (OLD.metasql_grade <= 0 AND NOT _isdba) THEN
      RAISE EXCEPTION 'You may not delete grade 0 MetaSQL statements from packages. Try deleting or disabling the package.';
    ELSE
      RETURN OLD;
    END IF;

  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._pkgmetasqlaltertrigger() OWNER TO admin;

--
-- TOC entry 1023 (class 1255 OID 146565533)
-- Dependencies: 4536 8
-- Name: _pkgmetasqlbeforetrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _pkgmetasqlbeforetrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _metasqlid    INTEGER;
  _isdba        BOOLEAN := false;

BEGIN
  SELECT rolsuper INTO _isdba FROM pg_roles WHERE (rolname=getEffectiveXtUser());

  IF (NOT (_isdba OR checkPrivilege('MaintainMetaSQL'))) THEN
    RAISE EXCEPTION '% does not have privileges to maintain MetaSQL statements in %.% (DBA=%)',
                getEffectiveXtUser(), TG_TABLE_SCHEMA, TG_TABLE_NAME, _isdba;
  END IF;

  IF (TG_OP = 'UPDATE') THEN
    RAISE DEBUG 'update OLD %-%-%, NEW %-%-%',
                 OLD.metasql_group, OLD.metasql_name, OLD.metasql_grade,
                 NEW.metasql_group, NEW.metasql_name, NEW.metasql_grade;

    IF (NEW.metasql_name != OLD.metasql_name OR NEW.metasql_group != OLD.metasql_group OR NEW.metasql_grade != OLD.metasql_grade) THEN
      SELECT metasql_id INTO _metasqlid
      FROM metasql
      WHERE metasql_name=NEW.metasql_name AND metasql_group=NEW.metasql_group AND metasql_grade=NEW.metasql_grade;
      IF (FOUND) THEN
        RAISE EXCEPTION 'Cannot change the MetaSQL statement named %-%-% because another MetaSQL statement with that group, name and grade already exists.', NEW.metasql_group, NEW.metasql_name, NEW.metasql_grade;
      END IF;
    END IF;

  ELSIF (TG_OP = 'INSERT') THEN
    RAISE DEBUG 'insert NEW %-% %',
                 NEW.metasql_group, NEW.metasql_name, NEW.metasql_grade;
    SELECT metasql_id INTO _metasqlid
    FROM metasql
    WHERE metasql_name=NEW.metasql_name AND metasql_group=NEW.metasql_group AND metasql_grade=NEW.metasql_grade;
    IF (FOUND) THEN
      RAISE EXCEPTION 'The new MetaSQL statement %-% % conflicts with an existing statement.',
                      NEW.metasql_group, NEW.metasql_name, NEW.metasql_grade;
    END IF;

  ELSIF (TG_OP = 'DELETE') THEN
    RETURN OLD;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._pkgmetasqlbeforetrigger() OWNER TO admin;

--
-- TOC entry 1024 (class 1255 OID 146565534)
-- Dependencies: 4536 8
-- Name: _pkgprivaftertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _pkgprivaftertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (TG_OP = 'DELETE') THEN
    RETURN OLD;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._pkgprivaftertrigger() OWNER TO admin;

--
-- TOC entry 1025 (class 1255 OID 146565535)
-- Dependencies: 4536 8
-- Name: _pkgprivaltertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _pkgprivaltertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (pkgMayBeModified(TG_TABLE_SCHEMA)) THEN
    IF (TG_OP = 'DELETE') THEN
      RETURN OLD;
    ELSE
      RETURN NEW;
    END IF;
  END IF;

  IF (TG_OP = 'INSERT') THEN
    RAISE EXCEPTION 'You may not create privileges in packages except using the xTuple Updater utility';

  ELSIF (TG_OP = 'UPDATE') THEN
    RAISE EXCEPTION 'You may not alter privileges in packages except using the xTuple Updater utility';

  ELSIF (TG_OP = 'DELETE') THEN
    RAISE EXCEPTION 'You may not delete privileges from packages. Try deleting or disabling the package.';

  END IF;

  RETURN NEW;
END;

$$;


ALTER FUNCTION public._pkgprivaltertrigger() OWNER TO admin;

--
-- TOC entry 1026 (class 1255 OID 146565536)
-- Dependencies: 4536 8
-- Name: _pkgprivbeforetrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _pkgprivbeforetrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _privid       INTEGER;
  _debug        BOOL := false;

BEGIN
  IF (TG_OP = 'UPDATE') THEN
    IF (_debug) THEN
      RAISE NOTICE 'OLD.priv_name %, NEW.priv_name %',
                   OLD.priv_name, NEW.priv_name;
    END IF;

    IF (NEW.priv_name != OLD.priv_name) THEN
      SELECT priv_id INTO _privid FROM priv WHERE priv_name=NEW.priv_name;
      IF (FOUND) THEN
        RAISE EXCEPTION 'Cannot change privilege name % because another privilege with that name already exists.', NEW.priv_name;
      END IF;
    END IF;

  ELSIF (TG_OP = 'INSERT') THEN
    IF (_debug) THEN
      RAISE NOTICE 'inserting NEW.priv_name %', NEW.priv_name;
    END IF;
    SELECT priv_id INTO _privid FROM priv WHERE priv_name=NEW.priv_name;
    IF (FOUND) THEN
      RAISE EXCEPTION 'Cannot create new privilege % because another privilege with that name already exists.', NEW.priv_name;
    END IF;

  ELSIF (TG_OP = 'DELETE') THEN
    IF (_debug) THEN RAISE NOTICE 'deleting pkgpriv_id %', OLD.priv_id; END IF;
    DELETE FROM usrpriv WHERE usrpriv_priv_id=OLD.priv_id;
    DELETE FROM grppriv WHERE grppriv_priv_id=OLD.priv_id;

    RETURN OLD;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._pkgprivbeforetrigger() OWNER TO admin;

--
-- TOC entry 1027 (class 1255 OID 146565537)
-- Dependencies: 4536 8
-- Name: _pkgreportaftertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _pkgreportaftertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (TG_OP = 'DELETE') THEN
    RETURN OLD;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._pkgreportaftertrigger() OWNER TO admin;

--
-- TOC entry 1028 (class 1255 OID 146565538)
-- Dependencies: 4536 8
-- Name: _pkgreportaltertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _pkgreportaltertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (pkgMayBeModified(TG_TABLE_SCHEMA)) THEN
    IF (TG_OP = 'DELETE') THEN
      RETURN OLD;
    ELSE
      RETURN NEW;
    END IF;
  END IF;

  IF (TG_OP = 'INSERT') THEN
    RAISE EXCEPTION 'You may not create report definitions in packages except using the xTuple Updater utility';

  ELSIF (TG_OP = 'UPDATE') THEN
    RAISE EXCEPTION 'You may not alter report definitions in packages except using the xTuple Updater utility';

  ELSIF (TG_OP = 'DELETE') THEN
    RAISE EXCEPTION 'You may not delete report definitions from packages. Try deleting or disabling the package.';

  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._pkgreportaltertrigger() OWNER TO admin;

--
-- TOC entry 1029 (class 1255 OID 146565539)
-- Dependencies: 4536 8
-- Name: _pkgreportbeforetrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _pkgreportbeforetrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _reportid     INTEGER;
  _debug        BOOL := false;

BEGIN
  IF (TG_OP = 'UPDATE') THEN
    IF (_debug) THEN
      RAISE NOTICE 'update OLD % %, NEW % %',
                   OLD.report_name, OLD.report_grade, NEW.report_name, NEW.report_grade;
    END IF;

    IF (NEW.report_name != OLD.report_name) THEN
      SELECT report_id INTO _reportid
      FROM report
      WHERE ((report_name=NEW.report_name)
        AND  (report_grade=NEW.report_grade));
      IF (FOUND) THEN
        RAISE EXCEPTION 'Cannot change report % % because another report with that name and grade already exists.', NEW.report_name, NEW.report_grade;
      END IF;
    END IF;

  ELSIF (TG_OP = 'INSERT') THEN
    IF (_debug) THEN
      RAISE NOTICE 'insert NEW % %', NEW.report_name, NEW.report_grade;
    END IF;
    SELECT report_id INTO _reportid
    FROM report
    WHERE ((report_name=NEW.report_name)
      AND  (report_grade=NEW.report_grade));
    IF (FOUND) THEN
      RAISE EXCEPTION 'Cannot create new report % % because another report with that name and grade already exists.', NEW.report_name, NEW.report_grade;
    END IF;

  ELSIF (TG_OP = 'DELETE') THEN

    RETURN OLD;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._pkgreportbeforetrigger() OWNER TO admin;

--
-- TOC entry 959 (class 1255 OID 146565540)
-- Dependencies: 4536 8
-- Name: _pkgscriptaftertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _pkgscriptaftertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (TG_OP = 'DELETE') THEN
    RETURN OLD;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._pkgscriptaftertrigger() OWNER TO admin;

--
-- TOC entry 983 (class 1255 OID 146565541)
-- Dependencies: 4536 8
-- Name: _pkgscriptaltertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _pkgscriptaltertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (pkgMayBeModified(TG_TABLE_SCHEMA)) THEN
    IF (TG_OP = 'DELETE') THEN
      RETURN OLD;
    ELSE
      RETURN NEW;
    END IF;
  END IF;

  IF (TG_OP = 'INSERT') THEN
    RAISE EXCEPTION 'You may not create scripts in packages except using the xTuple Updater utility';

  ELSIF (TG_OP = 'UPDATE') THEN
    RAISE EXCEPTION 'You may not alter scripts in packages except using the xTuple Updater utility';

  ELSIF (TG_OP = 'DELETE') THEN
    RAISE EXCEPTION 'You may not delete scripts from packages. Try deleting or disabling the package.';

  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._pkgscriptaltertrigger() OWNER TO admin;

--
-- TOC entry 1003 (class 1255 OID 146565542)
-- Dependencies: 4536 8
-- Name: _pkgscriptbeforetrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _pkgscriptbeforetrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _scriptid     INTEGER;
  _debug        BOOL := false;

BEGIN
  IF (TG_OP = 'UPDATE') THEN
    RETURN NEW;

  ELSIF (TG_OP = 'INSERT') THEN
    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN
    RETURN OLD;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._pkgscriptbeforetrigger() OWNER TO admin;

--
-- TOC entry 1011 (class 1255 OID 146565543)
-- Dependencies: 4536 8
-- Name: _pkguiformaftertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _pkguiformaftertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (TG_OP = 'DELETE') THEN
    RETURN OLD;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._pkguiformaftertrigger() OWNER TO admin;

--
-- TOC entry 1021 (class 1255 OID 146565544)
-- Dependencies: 4536 8
-- Name: _pkguiformaltertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _pkguiformaltertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (pkgMayBeModified(TG_TABLE_SCHEMA)) THEN
    IF (TG_OP = 'DELETE') THEN
      RETURN OLD;
    ELSE
      RETURN NEW;
    END IF;
  END IF;

  IF (TG_OP = 'INSERT') THEN
    RAISE EXCEPTION 'You may not create forms in packages except using the xTuple Updater utility';

  ELSIF (TG_OP = 'UPDATE') THEN
    RAISE EXCEPTION 'You may not alter forms in packages except using the xTuple Updater utility';

  ELSIF (TG_OP = 'DELETE') THEN
    RAISE EXCEPTION 'You may not delete forms from packages. Try deleting or disabling the package.';

  END IF;

  RETURN NEW;
END;

$$;


ALTER FUNCTION public._pkguiformaltertrigger() OWNER TO admin;

--
-- TOC entry 945 (class 1255 OID 146565545)
-- Dependencies: 4536 8
-- Name: _pkguiformbeforetrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _pkguiformbeforetrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _uiformid     INTEGER;
  _debug        BOOL := false;

BEGIN
  IF (TG_OP = 'UPDATE') THEN
    RETURN NEW;

  ELSIF (TG_OP = 'INSERT') THEN
    RETURN NEW;

  ELSIF (TG_OP = 'DELETE') THEN
    RETURN OLD;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._pkguiformbeforetrigger() OWNER TO admin;

--
-- TOC entry 1041 (class 1255 OID 146565557)
-- Dependencies: 4536 8
-- Name: _prospectafterdeletetrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _prospectafterdeletetrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF EXISTS(SELECT 1 FROM quhead WHERE quhead_cust_id = OLD.prospect_id) AND
     NOT EXISTS (SELECT 1 FROM custinfo WHERE cust_id = OLD.prospect_id) THEN
    RAISE EXCEPTION '[xtuple: deleteProspect, -1]';
  END IF;

  IF (fetchMetricBool('ProspectChangeLog')) THEN
    PERFORM postComment(cmnttype_id, 'PSPCT', OLD.prospect_id,
                        'Deleted "' || OLD.prospect_number || '"')
      FROM cmnttype
     WHERE (cmnttype_name='ChangeLog');
  END IF;

  RETURN OLD;
END;
$$;


ALTER FUNCTION public._prospectafterdeletetrigger() OWNER TO admin;

--
-- TOC entry 1042 (class 1255 OID 146565558)
-- Dependencies: 4536 8
-- Name: _prospectaftertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _prospectaftertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _cmnttypeid   INTEGER;
  _custid       INTEGER;
  _prospectid   INTEGER;

BEGIN

  IF (TG_OP = 'INSERT') THEN
    SELECT crmacct_cust_id, crmacct_prospect_id INTO _custid, _prospectid
      FROM crmacct
     WHERE crmacct_number=NEW.prospect_number;

    IF (_custid > 0 AND _custid != _prospectid) THEN
      RAISE EXCEPTION '[xtuple: createProspect, -2]';
    END IF;

    IF (_prospectid > 0) THEN
      RAISE EXCEPTION '[xtuple: createProspect, -3]';
    END IF;

    -- http://www.postgresql.org/docs/current/static/plpgsql-control-structures.html#PLPGSQL-UPSERT-EXAMPLE
    LOOP
      UPDATE crmacct SET crmacct_prospect_id=NEW.prospect_id,
                         crmacct_cust_id=NULL,
                         crmacct_name=NEW.prospect_name
       WHERE crmacct_number=NEW.prospect_number;
      IF (FOUND) THEN
        EXIT;
      END IF;
      BEGIN
        INSERT INTO crmacct(crmacct_number,      crmacct_name,
                            crmacct_active,      crmacct_type,
                            crmacct_prospect_id, crmacct_cntct_id_1
                  ) VALUES (NEW.prospect_number, NEW.prospect_name,
                            NEW.prospect_active, 'O',
                            NEW.prospect_id,     NEW.prospect_cntct_id);
        EXIT;
      EXCEPTION WHEN unique_violation THEN
            -- do nothing, and loop to try the UPDATE again
      END;
    END LOOP;

    /* TODO: default characteristic assignments based on what? */

  ELSIF (TG_OP = 'UPDATE') THEN
    UPDATE crmacct SET crmacct_number = NEW.prospect_number
    WHERE ((crmacct_prospect_id=NEW.prospect_id)
      AND  (crmacct_number!=NEW.prospect_number));

    UPDATE crmacct SET crmacct_name = NEW.prospect_name
    WHERE ((crmacct_prospect_id=NEW.prospect_id)
      AND  (crmacct_name!=NEW.prospect_name));

  END IF;

  IF (fetchMetricBool('ProspectChangeLog')) THEN
    SELECT cmnttype_id INTO _cmnttypeid
      FROM cmnttype
     WHERE (cmnttype_name='ChangeLog');

    IF (_cmnttypeid IS NOT NULL) THEN
      IF (TG_OP = 'INSERT') THEN
        PERFORM postComment(_cmnttypeid, 'PSPCT', NEW.prospect_id, 'Created');

      ELSIF (TG_OP = 'UPDATE') THEN
        IF (OLD.prospect_active <> NEW.prospect_active) THEN
          PERFORM postComment(_cmnttypeid, 'PSPCT', NEW.prospect_id,
                              CASE WHEN NEW.prospect_active THEN 'Activated'
                                   ELSE 'Deactivated' END);
        END IF;

        IF (OLD.prospect_number <> NEW.prospect_number) THEN
          PERFORM postComment(_cmnttypeid, 'PSPCT', NEW.prospect_id,
                              'Number changed from "' || OLD.prospect_number ||
                              '" to "' || NEW.prospect_number || '"');
        END IF;

        IF (OLD.prospect_name <> NEW.prospect_name) THEN
          PERFORM postComment(_cmnttypeid, 'PSPCT', NEW.prospect_id,
                              'Name changed from "' || OLD.prospect_name ||
                              '" to "' || NEW.prospect_name || '"');
        END IF;

        IF (OLD.prospect_cntct_id <> NEW.prospect_cntct_id) THEN
          PERFORM postComment(_cmnttypeid, 'PSPCT', NEW.prospect_id,
                              'Contact changed from "' ||
                              formatCntctName(OLD.prospect_cntct_id) || '" to "' ||
                              formatCntctName(NEW.prospect_cntct_id) || '"');
        END IF;

        IF (OLD.prospect_taxauth_id <> NEW.prospect_taxauth_id) THEN
          PERFORM postComment(_cmnttypeid, 'PSPCT', NEW.prospect_id,
                              'Tax Authority changed from "' ||
                              (SELECT taxauth_code FROM taxauth
                                WHERE taxauth_id=OLD.prospect_taxauth_id) ||
                              '" to "' ||
                              (SELECT taxauth_code FROM taxauth
                                WHERE taxauth_id=NEW.prospect_taxauth_id) || '"');
        END IF;

        IF (OLD.prospect_salesrep_id <> NEW.prospect_salesrep_id) THEN
          PERFORM postComment(_cmnttypeid, 'PSPCT', NEW.prospect_id,
                              'Sales Rep changed from "' ||
                              (SELECT salesrep_number FROM salesrep
                               WHERE salesrep_id=OLD.prospect_salesrep_id) ||
                              '" to "' ||
                              (SELECT salesrep_number FROM salesrep
                               WHERE salesrep_id=NEW.prospect_salesrep_id) || '"');
        END IF;

        IF (OLD.prospect_warehous_id <> NEW.prospect_warehous_id) THEN
          PERFORM postComment(_cmnttypeid, 'PSPCT', NEW.prospect_id,
                              'Warehouse changed from "' ||
                              (SELECT warehous_code FROM whsinfo
                                WHERE warehous_id=OLD.prospect_warehous_id) ||
                              '" to "' ||
                              (SELECT warehous_code FROM whsinfo
                                WHERE warehous_id=NEW.prospect_warehous_id) || '"');
        END IF;

        IF (OLD.prospect_taxzone_id <> NEW.prospect_taxzone_id) THEN
          PERFORM postComment(_cmnttypeid, 'PSPCT', NEW.prospect_id,
                              'Tax Zone changed from "' ||
                              (SELECT taxzone_code FROM taxzone
                                WHERE taxzone_id=OLD.prospect_taxzone_id) || '" to "' ||
                              (SELECT taxzone_code FROM taxzone
                                WHERE taxzone_id=NEW.prospect_taxzone_id) || '"');
        END IF;

      END IF;
    END IF;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._prospectaftertrigger() OWNER TO admin;

--
-- TOC entry 1043 (class 1255 OID 146565559)
-- Dependencies: 4536 8
-- Name: _prospectbeforedeletetrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _prospectbeforedeletetrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (NOT checkPrivilege('MaintainProspectMasters')) THEN
    RAISE EXCEPTION 'You do not have privileges to maintain Prospects.';
  END IF;

  UPDATE crmacct SET crmacct_prospect_id = NULL
   WHERE crmacct_prospect_id = OLD.prospect_id;

  RETURN OLD;
END;
$$;


ALTER FUNCTION public._prospectbeforedeletetrigger() OWNER TO admin;

--
-- TOC entry 1044 (class 1255 OID 146565560)
-- Dependencies: 4536 8
-- Name: _prospecttrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _prospecttrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (NOT checkPrivilege('MaintainProspectMasters')) THEN
    RAISE EXCEPTION 'You do not have privileges to maintain Prospects.';
  END IF;

  IF (NEW.prospect_number IS NULL) THEN
    RAISE EXCEPTION 'You must supply a valid Prospect Number.';
  END IF;

  NEW.prospect_number := UPPER(NEW.prospect_number);

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._prospecttrigger() OWNER TO admin;

--
-- TOC entry 1045 (class 1255 OID 146565561)
-- Dependencies: 4536 8
-- Name: _prtrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _prtrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/EULA for the full text of the software license.
BEGIN
  --- clear the number from the issue cache
  PERFORM clearNumberIssue('PrNumber', NEW.pr_number);

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._prtrigger() OWNER TO admin;

--
-- TOC entry 1052 (class 1255 OID 146565568)
-- Dependencies: 4536 8
-- Name: _reporttrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _reporttrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  NEW.report_loaddate = CURRENT_TIMESTAMP;
  RETURN NEW;

END;
$$;


ALTER FUNCTION public._reporttrigger() OWNER TO admin;

--
-- TOC entry 1059 (class 1255 OID 146565573)
-- Dependencies: 4536 8
-- Name: _shipdatasumtrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _shipdatasumtrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  IF (LENGTH(TRIM(NEW.shipdatasum_shiphead_number)) = 0) THEN
    NEW.shipdatasum_shiphead_number = NULL;
  END IF;

  RETURN NEW;

END;
$$;


ALTER FUNCTION public._shipdatasumtrigger() OWNER TO admin;

--
-- TOC entry 1060 (class 1255 OID 146565574)
-- Dependencies: 4536 8
-- Name: _shipdatatrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _shipdatatrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _newShipdata_cohead_number 	INTEGER;
  _shipdatasum_shipper 		TEXT;
  _rows				INTEGER;
  _cohead_id 			INTEGER;
  _shiphead_number 		TEXT;
  _headcount			INTEGER;

BEGIN
  --  This is where the shipper is identified and may need to be changed
  NEW.shipdata_cohead_number := TRIM(NEW.shipdata_cohead_number);

  IF (substring(NEW.shipdata_cosmisc_tracknum from 1 for 2) = '1Z') THEN
    _shipdatasum_shipper := 'UPS';
  ELSE
    _shipdatasum_shipper := 'UNKNOWN';
  END IF;

  IF (LENGTH(TRIM(NEW.shipdata_shiphead_number)) = 0) THEN
    NEW.shipdata_shiphead_number := NULL;
  END IF;

  IF (NEW.shipdata_cosmisc_tracknum = NEW.shipdata_cosmisc_packnum_tracknum) THEN
    IF (NEW.shipdata_void_ind = 'Y') THEN
      --  Delete the current shipdatasum
      DELETE FROM shipdatasum
      WHERE ((shipdatasum_cohead_number = NEW.shipdata_cohead_number)
	AND  (shipdatasum_cosmisc_tracknum = NEW.shipdata_cosmisc_tracknum));

    ELSIF (TG_OP = 'INSERT') THEN

--      RAISE NOTICE 'Getting cohead_id (%)', NEW.shipdata_cohead_number;
      IF (NEW.shipdata_shiphead_number IS NULL) THEN
        SELECT cohead_id INTO _cohead_id FROM cohead WHERE cohead_number = NEW.shipdata_cohead_number;

        IF (FOUND) THEN

--          RAISE NOTICE 'Getting shiphead number (%)', _cohead_id;
          SELECT count(shiphead_order_id), MAX(shiphead_number) INTO _headcount, _shiphead_number
          FROM shiphead
          WHERE ((shiphead_tracknum IS NULL OR shiphead_tracknum = '')
          AND ( shiphead_order_type = 'SO' and shiphead_order_id = _cohead_id) );

          IF (_headcount = 1) THEN
--            RAISE NOTICE 'Updating Shiphead Number (%)', _shiphead_number;
            NEW.shipdata_shiphead_number = _shiphead_number;

          ELSIF (_headcount > 1) THEN
            -- Trap for potential workflow problem.  Can only infer shiphead from sales order number
            -- if shipping one at a time
            RAISE EXCEPTION 'Multiple shipments exist for this order.  Please provide a specific a shipment number.';
          END IF;
        END IF;
      END IF;

      INSERT INTO shipdatasum
	      (shipdatasum_cohead_number, shipdatasum_cosmisc_tracknum,
	       shipdatasum_cosmisc_packnum_tracknum, shipdatasum_weight,
	       shipdatasum_base_freight, shipdatasum_total_freight,
	       shipdatasum_base_freight_curr_id, shipdatasum_total_freight_curr_id,
	       shipdatasum_shipper, shipdatasum_billing_option,
	       shipdatasum_package_type, shipdatasum_shiphead_number)
       VALUES (NEW.shipdata_cohead_number, NEW.shipdata_cosmisc_tracknum,
	       NEW.shipdata_cosmisc_packnum_tracknum, NEW.shipdata_weight,
	       NEW.shipdata_base_freight, NEW.shipdata_total_freight,
	       NEW.shipdata_base_freight_curr_id, NEW.shipdata_total_freight_curr_id,
	       _shipdatasum_shipper, NEW.shipdata_billing_option,
	       NEW.shipdata_package_type, NEW.shipdata_shiphead_number);

    ELSIF (TG_OP = 'UPDATE') THEN
       UPDATE shipdatasum SET
	      shipdatasum_cohead_number=NEW.shipdata_cohead_number,
	      shipdatasum_cosmisc_tracknum=NEW.shipdata_cosmisc_tracknum,
	      shipdatasum_cosmisc_packnum_tracknum=NEW.shipdata_cosmisc_packnum_tracknum,
	      shipdatasum_weight=NEW.shipdata_weight,
	      shipdatasum_base_freight=NEW.shipdata_base_freight,
	      shipdatasum_total_freight=NEW.shipdata_total_freight,
	      shipdatasum_base_freight_curr_id=NEW.shipdata_base_freight_curr_id,
	      shipdatasum_total_freight_curr_id=NEW.shipdata_total_freight_curr_id,
	      shipdatasum_shipper=_shipdatasum_shipper,
	      shipdatasum_billing_option=NEW.shipdata_billing_option,
	      shipdatasum_package_type=NEW.shipdata_package_type,
	      shipdatasum_shiphead_number=NEW.shipdata_shiphead_number
       WHERE ((TRIM(shipdatasum_cohead_number)=TRIM(OLD.shipdata_cohead_number))
	  AND (TRIM(shipdatasum_cosmisc_tracknum)=TRIM(OLD.shipdata_cosmisc_tracknum))
	  AND (TRIM(shipdatasum_cosmisc_packnum_tracknum)=TRIM(OLD.shipdata_cosmisc_packnum_tracknum)));

       GET DIAGNOSTICS _rows = ROW_COUNT;
       IF (_rows <= 0) THEN
	 INSERT INTO shipdatasum
		(shipdatasum_cohead_number, shipdatasum_cosmisc_tracknum,
		 shipdatasum_cosmisc_packnum_tracknum, shipdatasum_weight,
		 shipdatasum_base_freight, shipdatasum_total_freight,
		 shipdatasum_base_freight_curr_id, shipdatasum_total_freight_curr_id,
		 shipdatasum_shipper, shipdatasum_billing_option,
		 shipdatasum_package_type, shipdatasum_shiphead_number)
	 VALUES (NEW.shipdata_cohead_number, NEW.shipdata_cosmisc_tracknum,
		 NEW.shipdata_cosmisc_packnum_tracknum, NEW.shipdata_weight,
		 NEW.shipdata_base_freight, NEW.shipdata_total_freight,
		 NEW.shipdata_base_freight_curr_id, NEW.shipdata_total_freight_curr_id,
		 _shipdatasum_shipper, NEW.shipdata_billing_option,
		 NEW.shipdata_package_type, NEW.shipdata_shiphead_number);
       END IF;
    END IF;
  END IF;

  RETURN NEW;

END;
$$;


ALTER FUNCTION public._shipdatatrigger() OWNER TO admin;

--
-- TOC entry 1061 (class 1255 OID 146565575)
-- Dependencies: 4536 8
-- Name: _shipformafterdeletetrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _shipformafterdeletetrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (fetchMetricValue('DefaultShipFormId') = OLD.shipform_id) THEN
    RAISE EXCEPTION 'Cannot delete the default Shipping Form [xtuple: shipform, -1, %, %]',
                    OLD.shipform_name, OLD.shipform_report_name;
  END IF;

  RETURN OLD;
END;
$$;


ALTER FUNCTION public._shipformafterdeletetrigger() OWNER TO admin;

--
-- TOC entry 1064 (class 1255 OID 146565578)
-- Dependencies: 4536 8
-- Name: _shipviaafterdeletetrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _shipviaafterdeletetrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (SELECT fetchMetricValue('DefaultShipViaId') = OLD.shipvia_id) THEN
    RAISE EXCEPTION 'Cannot delete the default Ship-Via [xtuple: shipvia, -1, %]',
                    OLD.shipvia_code;
  END IF;

  RETURN OLD;
END;
$$;


ALTER FUNCTION public._shipviaafterdeletetrigger() OWNER TO admin;

--
-- TOC entry 1065 (class 1255 OID 146565579)
-- Dependencies: 4536 8
-- Name: _sltransaltertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _sltransaltertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _externalCompany      BOOLEAN := false;
  _updated BOOLEAN := false;
BEGIN
  IF(TG_OP='DELETE') THEN
    RAISE EXCEPTION 'You may not delete Journal Transactions once they have been created.';
  ELSIF (TG_OP = 'UPDATE') THEN
    IF(OLD.sltrans_id != NEW.sltrans_id) THEN
      _updated := true;
    ELSIF(OLD.sltrans_date != NEW.sltrans_date) THEN
      _updated := true;
    ELSIF(OLD.sltrans_accnt_id != NEW.sltrans_accnt_id) THEN
      _updated := true;
    ELSIF(OLD.sltrans_amount != NEW.sltrans_amount) THEN
      _updated := true;
    ELSIF(OLD.sltrans_username != NEW.sltrans_username) THEN
      _updated := true;
    ELSIF( (OLD.sltrans_sequence IS NULL     AND NEW.sltrans_sequence IS NOT NULL)
        OR (OLD.sltrans_sequence IS NOT NULL AND NEW.sltrans_sequence IS NULL)
        OR (COALESCE(OLD.sltrans_sequence,0) != COALESCE(NEW.sltrans_sequence,0)) ) THEN
      _updated := true;
    ELSIF( (OLD.sltrans_created IS NULL     AND NEW.sltrans_created IS NOT NULL)
        OR (OLD.sltrans_created IS NOT NULL AND NEW.sltrans_created IS NULL)
        OR (COALESCE(OLD.sltrans_created,now()) != COALESCE(NEW.sltrans_created,now())) ) THEN
      _updated := true;
    ELSIF( (OLD.sltrans_source IS NULL     AND NEW.sltrans_source IS NOT NULL)
        OR (OLD.sltrans_source IS NOT NULL AND NEW.sltrans_source IS NULL)
        OR (COALESCE(OLD.sltrans_source,'') != COALESCE(NEW.sltrans_source,'')) ) THEN
      _updated := true;
    ELSIF( (OLD.sltrans_docnumber IS NULL     AND NEW.sltrans_docnumber IS NOT NULL)
        OR (OLD.sltrans_docnumber IS NOT NULL AND NEW.sltrans_docnumber IS NULL)
        OR (COALESCE(OLD.sltrans_docnumber,'') != COALESCE(NEW.sltrans_docnumber,'')) ) THEN
      _updated := true;
    ELSIF( (OLD.sltrans_doctype IS NULL     AND NEW.sltrans_doctype IS NOT NULL)
        OR (OLD.sltrans_doctype IS NOT NULL AND NEW.sltrans_doctype IS NULL)
        OR (COALESCE(OLD.sltrans_doctype,'') != COALESCE(NEW.sltrans_doctype,'')) ) THEN
      _updated := true;
    END IF;

    IF(_updated) THEN
      RAISE EXCEPTION 'You may not alter some Journal Transaction fields once they have been created.';
    END IF;
  ELSE
    RAISE EXCEPTION 'trigger for sltrans table called in unexpected state.';
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION public._sltransaltertrigger() OWNER TO admin;

--
-- TOC entry 1047 (class 1255 OID 146565580)
-- Dependencies: 4536 8
-- Name: _sltransinserttrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _sltransinserttrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _reqNotes BOOLEAN;
  _externalCompany      BOOLEAN := false;
BEGIN
  -- Checks
  SELECT company_external INTO _externalCompany
  FROM company JOIN accnt ON (company_number=accnt_company)
  WHERE (accnt_id=NEW.sltrans_accnt_id);
  IF (_externalCompany) THEN
    RAISE EXCEPTION 'Transactions are not allowed for G/L Accounts with External Company segments.';
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._sltransinserttrigger() OWNER TO admin;

--
-- TOC entry 1037 (class 1255 OID 146565596)
-- Dependencies: 4536 8
-- Name: _termsafterdeletetrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _termsafterdeletetrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (fetchMetricValue('DefaultTerms') = OLD.terms_id) THEN
    RAISE EXCEPTION 'Cannot delete the default Terms [xtuple: terms, -1, %]',
                    OLD.terms_code;
  END IF;

  RETURN OLD;
END;
$$;


ALTER FUNCTION public._termsafterdeletetrigger() OWNER TO admin;

--
-- TOC entry 1076 (class 1255 OID 146565597)
-- Dependencies: 4536 8
-- Name: _todoitemtrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _todoitemtrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _recurid     INTEGER;
  _newparentid INTEGER;

BEGIN
  IF (TG_OP = 'DELETE') THEN
    SELECT recur_id INTO _recurid
      FROM recur
     WHERE ((recur_parent_id=OLD.todoitem_id)
       AND  (recur_parent_type='TODO'));

    IF (_recurid IS NOT NULL) THEN
      RAISE DEBUG 'recur_id for deleted todoitem = %', _recurid;

      SELECT todoitem_id INTO _newparentid
        FROM todoitem
       WHERE ((todoitem_recurring_todoitem_id=OLD.todoitem_id)
          AND (todoitem_id!=OLD.todoitem_id))
       ORDER BY todoitem_due_date
       LIMIT 1;

      RAISE DEBUG '_newparentid for deleted todoitem = %', COALESCE(_newparentid, NULL);

      -- client is responsible for warning about deleting a recurring todoitem
      IF (_newparentid IS NULL) THEN
        DELETE FROM recur WHERE recur_id=_recurid;
      ELSE
        UPDATE recur SET recur_parent_id=_newparentid
         WHERE recur_id=_recurid;

        UPDATE todoitem SET todoitem_recurring_todoitem_id=_newparentid
         WHERE todoitem_recurring_todoitem_id=OLD.todoitem_id
           AND todoitem_id != OLD.todoitem_id;

        RAISE DEBUG 'reparented recurrence';
      END IF;
    END IF;

    DELETE FROM alarm
     WHERE ((alarm_source='TODO')
        AND (alarm_source_id=OLD.todoitem_id));

    DELETE FROM docass WHERE docass_source_id = OLD.todoitem_id AND docass_source_type = 'TODO';
    DELETE FROM docass WHERE docass_target_id = OLD.todoitem_id AND docass_target_type = 'TODO';

    RETURN OLD;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._todoitemtrigger() OWNER TO admin;

--
-- TOC entry 1077 (class 1255 OID 146565598)
-- Dependencies: 4536 8
-- Name: _uomconvupdate(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _uomconvupdate() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  UPDATE itemuomconv
  SET itemuomconv_to_value = NEW.uomconv_to_value,
  itemuomconv_from_value = NEW.uomconv_from_value,
  itemuomconv_fractional = NEW.uomconv_fractional
  WHERE((itemuomconv_from_uom_id = NEW.uomconv_from_uom_id)
  AND (itemuomconv_to_uom_id = NEW.uomconv_to_uom_id));

RETURN NEW;

END;
$$;


ALTER FUNCTION public._uomconvupdate() OWNER TO admin;

--
-- TOC entry 1078 (class 1255 OID 146565599)
-- Dependencies: 4536 8
-- Name: _usrprefaftertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _usrprefaftertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN
    -- http://www.postgresql.org/docs/current/static/plpgsql-control-structures.html#PLPGSQL-UPSERT-EXAMPLE
    IF (NEW.usrpref_name='active') THEN
      LOOP
        UPDATE crmacct SET crmacct_usr_username=NEW.usrpref_username
         WHERE crmacct_number=UPPER(NEW.usrpref_username);
        IF (FOUND) THEN
          EXIT;
        END IF;
        BEGIN
          INSERT INTO crmacct(crmacct_number,        crmacct_active,
                              crmacct_type,          crmacct_usr_username
                    ) VALUES (NEW.usrpref_username,  NEW.usrpref_value::BOOL,
                              'I',                   NEW.usrpref_username);
          EXIT;
        EXCEPTION WHEN unique_violation THEN
            -- do nothing, and loop to try the UPDATE again
        END;
      END LOOP;

    ELSIF (NEW.usrpref_name='propername') THEN
      LOOP
        UPDATE crmacct SET crmacct_name=NEW.usrpref_value
         WHERE crmacct_number=UPPER(NEW.usrpref_username);
        IF (FOUND) THEN
          EXIT;
        END IF;
        BEGIN
          INSERT INTO crmacct(crmacct_number,        crmacct_active,
                              crmacct_name,
                              crmacct_type,          crmacct_usr_username
                    ) VALUES (UPPER(NEW.usrpref_username), TRUE,
                              NEW.usrpref_value,
                              'I',                   NEW.usrpref_username);
          EXIT;
        EXCEPTION WHEN unique_violation THEN
            -- do nothing, and loop to try the UPDATE again
        END;
      END LOOP;

    END IF;

  ELSIF (TG_OP = 'DELETE') THEN
    RETURN OLD;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._usrprefaftertrigger() OWNER TO admin;

--
-- TOC entry 1079 (class 1255 OID 146565600)
-- Dependencies: 4536 8
-- Name: _usrprefbeforetrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _usrprefbeforetrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF NOT (checkPrivilege('MaintainUsers') OR
          checkPrivilege('MaintainPreferencesOthers') OR
          (checkPrivilege('MaintainPreferencesSelf'))) THEN
    -- 2 IFs because plpgsql doesn't always evaluate boolean exprs left-to-right
    IF (TG_OP = 'DELETE') THEN
      IF NOT (OLD.usrpref_name LIKE '%/checked' OR OLD.usrpref_name LIKE '%/columnsShown') THEN
        RAISE EXCEPTION 'You do not have privileges to change this User Preference.';
      END IF;
    ELSIF (NEW.usrpref_username = getEffectiveXtUser()) THEN
      IF NOT (NEW.usrpref_name LIKE '%/checked' OR NEW.usrpref_name LIKE '%/columnsShown') THEN
        RAISE EXCEPTION 'You do not have privileges to change this User Preference.';
      END IF;
    END IF;
  END IF;

  IF (TG_OP IN ('INSERT', 'UPDATE')) THEN
    IF (NEW.usrpref_name = 'locale') THEN
      IF NOT EXISTS(SELECT locale_id
                      FROM locale
                     WHERE locale_id = NEW.usrpref_value::INTEGER) THEN
        RAISE EXCEPTION 'You must supply a valid Locale.';
      END IF;

    ELSIF (NEW.usrpref_name IN ('agent', 'active')) THEN
      IF (NEW.usrpref_value NOT IN ('t', 'f')) THEN
        RAISE EXCEPTION '% must be either "t" or "f"', NEW.usrpref_name;
      END IF;
    END IF;

  ELSIF (TG_OP = 'DELETE') THEN
    RETURN OLD;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._usrprefbeforetrigger() OWNER TO admin;

--
-- TOC entry 1080 (class 1255 OID 146565601)
-- Dependencies: 4536 8
-- Name: _usrprivtrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _usrprivtrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _check BOOLEAN;
  _returnVal INTEGER;
BEGIN
  -- This looks like a candidate for a foreign key but isn't.
  -- fkeys don't work if the foreign key value resides in a child of the
  -- table and not the table itself.
  IF ((TG_OP = 'UPDATE' OR TG_OP = 'INSERT') AND
      (NOT EXISTS(SELECT priv_id
                  FROM priv
                  WHERE (priv_id=NEW.usrpriv_priv_id)))) THEN
    RAISE EXCEPTION 'Privilege id % does not exist or is part of a disabled package.',
                NEW.usrpriv_priv_id;
    RETURN OLD;

  ELSIF (TG_OP = 'DELETE') THEN
    RETURN OLD;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._usrprivtrigger() OWNER TO admin;

--
-- TOC entry 1082 (class 1255 OID 146565602)
-- Dependencies: 4536 8
-- Name: _vendaddrtrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _vendaddrtrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _check      BOOLEAN;
  _vendname   TEXT;

BEGIN

--  Checks
  SELECT checkPrivilege('MaintainVendors') INTO _check;
  IF NOT (_check) THEN
    RAISE EXCEPTION 'You do not have privileges to maintain Vendors.';
  END IF;

  IF (TG_OP IN ('INSERT','UPDATE')) THEN

    IF (LENGTH(COALESCE(NEW.vendaddr_code, ''))=0) THEN
      RAISE EXCEPTION 'You must supply a valid Vendor Address Number.';
    END IF;

    IF (LENGTH(COALESCE(NEW.vendaddr_name, ''))=0) THEN
      RAISE EXCEPTION 'You must supply a valid Vendor Address Name.';
    END IF;

    IF (NEW.vendaddr_vend_id IS NULL) THEN
      RAISE EXCEPTION 'You must supply a valid Vendor ID.';
    END IF;

    SELECT vendaddr_code INTO _vendname
    FROM vendaddrinfo
    WHERE ( (vendaddr_vend_id=NEW.vendaddr_vend_id)
      AND (UPPER(vendaddr_code)=UPPER(NEW.vendaddr_code))
      AND (vendaddr_id<>NEW.vendaddr_id) );
    IF (FOUND) THEN
      RAISE EXCEPTION 'The Vendor Address Number entered cannot be used as it is in use.';
    END IF;

  END IF;

  IF (TG_OP = 'DELETE') THEN
    RETURN OLD;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._vendaddrtrigger() OWNER TO admin;

--
-- TOC entry 1091 (class 1255 OID 146565611)
-- Dependencies: 4536 8
-- Name: _voitemaftertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _voitemaftertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _r RECORD;

BEGIN
  IF (TG_OP = 'DELETE') THEN
    RETURN OLD;
  END IF;

-- Cache Voucher Head
  SELECT * INTO _r
  FROM vohead
  WHERE (vohead_id=NEW.voitem_vohead_id);
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Voucher head not found';
  END IF;

-- Calculate Tax
  PERFORM calculateTaxHist( 'voitemtax',
                            NEW.voitem_id,
                            COALESCE(_r.vohead_taxzone_id, -1),
                            NEW.voitem_taxtype_id,
                            COALESCE(_r.vohead_docdate, CURRENT_DATE),
                            COALESCE(_r.vohead_curr_id, -1),
                            COALESCE(SUM(vodist_amount * -1), 0) )
  FROM vodist
  WHERE ( (vodist_vohead_id=_r.vohead_id)
    AND   (vodist_poitem_id=NEW.voitem_poitem_id) );

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._voitemaftertrigger() OWNER TO admin;

--
-- TOC entry 1092 (class 1255 OID 146565612)
-- Dependencies: 4536 8
-- Name: _voitembeforetrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _voitembeforetrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE

BEGIN
  IF (TG_OP = 'DELETE') THEN
    DELETE FROM voitemtax
    WHERE (taxhist_parent_id=OLD.voitem_id);

    RETURN OLD;
  END IF;

  RETURN NEW;
END;
$$;


ALTER FUNCTION public._voitembeforetrigger() OWNER TO admin;

--
-- TOC entry 1093 (class 1255 OID 146565613)
-- Dependencies: 4536 8
-- Name: _warehoustrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _warehoustrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _cmnttypeid INTEGER;
  _check      BOOLEAN;
  _checkId    INTEGER;

BEGIN

  -- Checks
  -- Start with privileges
  IF (TG_OP = 'INSERT') THEN
    SELECT checkPrivilege('MaintainWarehouses') INTO _check;
    IF NOT (_check) THEN
      RAISE EXCEPTION 'You do not have privileges to add new Sites.';
    END IF;
  ELSE
    SELECT checkPrivilege('MaintainWarehouses') OR checkPrivilege('IssueCountTags') INTO _check;
    IF NOT (_check) THEN
      RAISE EXCEPTION 'You do not have privileges to alter a Site.';
    END IF;
  END IF;

  -- Code is required
  IF (LENGTH(COALESCE(NEW.warehous_code,''))=0) THEN
    RAISE EXCEPTION 'You must supply a valid Site Code.';
  END IF;

  -- Sitetype is required
  IF (NEW.warehous_sitetype_id IS NULL) THEN
    RAISE EXCEPTION 'You must supply a valid Site Type.';
  END IF;

  -- Cost Category is required for Transit types
  IF ((NEW.warehous_transit) AND (NEW.warehous_costcat_id IS NULL)) THEN
    RAISE EXCEPTION 'You must supply a valid Cost Category for Transit Sites.';
  END IF;

  -- Code must be unique
  SELECT warehous_id INTO _checkId
  FROM whsinfo
  WHERE ( (UPPER(warehous_code)=UPPER(NEW.warehous_code))
    AND   (warehous_id<>NEW.warehous_id) );
  IF (FOUND) THEN
    RAISE EXCEPTION 'You must supply a unique Site Code.';
  END IF;

  -- Count Tag Prefix must be unique
  IF (TG_OP = 'INSERT') THEN
    SELECT warehous_id INTO _checkId
    FROM whsinfo
    WHERE (warehous_counttag_prefix=NEW.warehous_counttag_prefix);
  ELSE
    SELECT warehous_id INTO _checkId
    FROM whsinfo
    WHERE ( (warehous_counttag_prefix=NEW.warehous_counttag_prefix)
      AND   (warehous_id<>NEW.warehous_id) );
  END IF;
  IF (FOUND) THEN
    RAISE EXCEPTION 'You must supply a unique Count Tag Prefix.';
  END IF;

  -- Check Complete
  -- Change Log
  IF ( SELECT (metric_value='t')
       FROM metric
       WHERE (metric_name='WarehouseChangeLog') ) THEN

--  Cache the cmnttype_id for ChangeLog
    SELECT cmnttype_id INTO _cmnttypeid
    FROM cmnttype
    WHERE (cmnttype_name='ChangeLog');
    IF (FOUND) THEN
      IF (TG_OP = 'INSERT') THEN
        PERFORM postComment(_cmnttypeid, 'WH', NEW.warehous_id, 'Created');

      ELSIF (TG_OP = 'UPDATE') THEN
        IF (OLD.warehous_code <> NEW.warehous_code) THEN
          PERFORM postComment( _cmnttypeid, 'WH', NEW.warehous_id,
                               ('Code Changed from "' || OLD.warehous_code || '" to "' || NEW.warehous_code || '"') );
        END IF;

        IF (OLD.warehous_descrip <> NEW.warehous_descrip) THEN
          PERFORM postComment( _cmnttypeid, 'WH', NEW.warehous_id,
                               ( 'Description Changed from "' || OLD.warehous_descrip ||
                                 '" to "' || NEW.warehous_descrip || '"' ) );
        END IF;

        IF (OLD.warehous_active <> NEW.warehous_active) THEN
          IF (NEW.warehous_active) THEN
            PERFORM postComment(_cmnttypeid, 'WH', NEW.warehous_id, 'Activated');
          ELSE
            PERFORM postComment(_cmnttypeid, 'WH', NEW.warehous_id, 'Deactivated');
          END IF;
        END IF;

      END IF;
    END IF;
  END IF;

  RETURN NEW;

END;
$$;


ALTER FUNCTION public._warehoustrigger() OWNER TO admin;

--
-- TOC entry 1094 (class 1255 OID 146565614)
-- Dependencies: 4536 8
-- Name: _whsezonetrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _whsezonetrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _check      BOOLEAN;
  _checkId    INTEGER;

BEGIN

  -- Checks
  -- Start with privileges
  IF (TG_OP = 'INSERT') THEN
    SELECT checkPrivilege('MaintainWarehouses') INTO _check;
    IF NOT (_check) THEN
      RAISE EXCEPTION 'You do not have privileges to add new Site Zones.';
    END IF;
  ELSE
    SELECT checkPrivilege('MaintainWarehouses') INTO _check;
    IF NOT (_check) THEN
      RAISE EXCEPTION 'You do not have privileges to alter a Site Zone.';
    END IF;
  END IF;

  -- Name is required
  IF (LENGTH(COALESCE(NEW.whsezone_name,''))=0) THEN
    RAISE EXCEPTION 'You must supply a valid Site Zone Name.';
  END IF;

  -- Site is required
  IF (NEW.whsezone_warehous_id IS NULL) THEN
    RAISE EXCEPTION 'You must supply a valid Site.';
  END IF;

  RETURN NEW;

END;
$$;


ALTER FUNCTION public._whsezonetrigger() OWNER TO admin;

--
-- TOC entry 1095 (class 1255 OID 146565615)
-- Dependencies: 4536 8
-- Name: _womatlaftertrigger(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION _womatlaftertrigger() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE

BEGIN

  IF (TG_OP = 'INSERT') THEN

  --  Create any required P/R's
    PERFORM createPr('W', NEW.womatl_id)
       FROM itemsite
      WHERE ((itemsite_id=NEW.womatl_itemsite_id)
        AND  (itemsite_createpr));

  END IF;

  RETURN NEW;

END;
$$;


ALTER FUNCTION public._womatlaftertrigger() OWNER TO admin;

--
-- TOC entry 1098 (class 1255 OID 146565617)
-- Dependencies: 4536 8
-- Name: acknowledgemessage(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION acknowledgemessage(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pMsgid ALIAS FOR $1;

BEGIN

  UPDATE msguser
  SET msguser_viewed=CURRENT_TIMESTAMP
  WHERE ( (msguser_msg_id=pMsgid)
   AND (msguser_username=getEffectiveXtUser()) );

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.acknowledgemessage(integer) OWNER TO admin;

--
-- TOC entry 1099 (class 1255 OID 146565618)
-- Dependencies: 4536 8
-- Name: actcost(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION actcost(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN actCost($1, NULL, baseCurrId());
END;
$_$;


ALTER FUNCTION public.actcost(integer) OWNER TO admin;

--
-- TOC entry 1100 (class 1255 OID 146565619)
-- Dependencies: 4536 8
-- Name: actcost(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION actcost(integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN actCost($1, $2, baseCurrId());
END;
$_$;


ALTER FUNCTION public.actcost(integer, integer) OWNER TO admin;

--
-- TOC entry 1101 (class 1255 OID 146565620)
-- Dependencies: 4536 8
-- Name: actcost(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION actcost(integer, integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pBomitemid ALIAS FOR $2;
  pCurrid ALIAS FOR $3;
  _cost NUMERIC;

BEGIN

  -- Return actual cost in the given currency at the current conversion rate
  SELECT SUM(CASE WHEN (bomitemcost_id IS NOT NULL) THEN
                  ROUND(currToCurr(bomitemcost_curr_id, pCurrid, bomitemcost_actcost, CURRENT_DATE), 6)
                  ELSE
                  ROUND(currToCurr(itemcost_curr_id, pCurrid, itemcost_actcost, CURRENT_DATE), 6)
             END) INTO _cost
  FROM itemcost
    LEFT OUTER JOIN bomitemcost ON (bomitemcost_bomitem_id=pBomitemid AND bomitemcost_costelem_id=itemcost_costelem_id)
  WHERE (itemcost_item_id=pItemid);

  IF (_cost IS NULL) THEN
    RETURN 0;
  ELSE
    RETURN _cost;
  END IF;

END;
$_$;


ALTER FUNCTION public.actcost(integer, integer, integer) OWNER TO admin;

--
-- TOC entry 1102 (class 1255 OID 146565621)
-- Dependencies: 4536 8
-- Name: addrusecount(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION addrusecount(integer) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pAddrId ALIAS FOR $1;
  _fk RECORD;
  _r RECORD;
  _seq INTEGER;
  _col TEXT;
  _qry TEXT;
  _count INTEGER = 0;

BEGIN
  -- Determine where this address is used by analyzing foreign key linkages
  -- TO DO: Can this be rationalized with cntctused(int)?
  FOR _fk IN
    SELECT pg_namespace.nspname AS schemaname, con.relname AS tablename, conkey AS seq, conrelid AS class_id
    FROM pg_constraint, pg_class f, pg_class con, pg_namespace
    WHERE confrelid=f.oid
    AND conrelid=con.oid
    AND f.relname = 'addr'
    AND con.relnamespace=pg_namespace.oid
    AND con.relname NOT IN ('pohead') -- exception(s) where address key doesn't actually drive document information
  LOOP
    -- Validate
    IF (ARRAY_UPPER(_fk.seq,1) > 1) THEN
      RAISE EXCEPTION 'Checks to tables where the address is one of multiple foreign key columns is not supported. Error on Table: %',
        pg_namespace.nspname || '.' || con.relname;
    END IF;

    _seq := _fk.seq[1];

    -- Get the specific column name
    SELECT attname INTO _col
    FROM pg_attribute, pg_class
    WHERE ((attrelid=pg_class.oid)
    AND (pg_class.oid=_fk.class_id)
    AND (attnum=_seq));

    -- See if there are dependencies
    _qry := 'SELECT *
            FROM ' || _fk.schemaname || '.' || _fk.tablename || '
            WHERE ('|| _col || '=' || pAddrId || ');';

    FOR _r IN
      EXECUTE _qry
    LOOP
      _count := _count + 1;
    END LOOP;

  END LOOP;

  RETURN _count;

END;
$_$;


ALTER FUNCTION public.addrusecount(integer) OWNER TO admin;

--
-- TOC entry 1103 (class 1255 OID 146565622)
-- Dependencies: 4536 8
-- Name: addtaxtoglseries(integer, text, text, text, integer, date, date, text, integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION addtaxtoglseries(integer, text, text, text, integer, date, date, text, integer, text) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSequence	ALIAS FOR $1;
  pSource	ALIAS FOR $2;
  pDocType	ALIAS FOR $3;
  pDocNumber	ALIAS FOR $4;
  pCurrId     ALIAS FOR $5;
  pExchDate	ALIAS FOR $6;
  pDistDate	ALIAS FOR $7;
  pTableName	ALIAS FOR $8;
  pParentId	ALIAS FOR $9;
  pNotes	ALIAS FOR $10;

  _count	INTEGER := 0;
  _baseTax	NUMERIC := 0;
  _returnVal	NUMERIC := 0;
  _t		RECORD;
  _test	INTEGER := 0;

BEGIN

-- This is just a fancy select statement on taxhist.
-- Because all tax records tables inherit from taxhist,
-- we can use the same select statement for all.
-- https://www.postgresql.org/docs/8.1/static/ddl-inherit.html
-- pTableName in the where clause narrows down the selection
-- to the correct sub table.

  FOR _t IN SELECT *
            FROM taxhist JOIN tax ON (tax_id = taxhist_tax_id)
                         JOIN pg_class ON (pg_class.oid = taxhist.tableoid)
            WHERE ( (taxhist_parent_id = pParentId)
              AND   (relname = pTableName) ) LOOP

    _count := _count + 1;
    _baseTax := currToBase(pCurrId, _t.taxhist_tax, pExchDate);
    _returnVal := _returnVal + _baseTax;
    PERFORM insertIntoGLSeries( pSequence, pSource, pDocType, pDocNumber,
                                _t.tax_sales_accnt_id, _baseTax,
                                pDistDate, pNotes );

    UPDATE taxhist SET
      taxhist_docdate=pExchDate,
      taxhist_distdate=pDistDate,
      taxhist_curr_id=pCurrId,
      taxhist_curr_rate=curr_rate
    FROM curr_rate
    WHERE ((taxhist_id=_t.taxhist_id)
      AND (pCurrId=curr_id)
      AND ( pExchDate BETWEEN curr_effective
                          AND curr_expires) );

  END LOOP;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.addtaxtoglseries(integer, text, text, text, integer, date, date, text, integer, text) OWNER TO admin;

--
-- TOC entry 1104 (class 1255 OID 146565623)
-- Dependencies: 4536 8
-- Name: addtopackinglistbatch(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION addtopackinglistbatch(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSoheadid	ALIAS FOR $1;
  returnVal	INTEGER;
BEGIN

  -- MIN because error codes are negative
  SELECT MIN(addToPackingListBatch('SO', pSoheadid, shiphead_id)) INTO returnVal
  FROM shiphead
  WHERE ((shiphead_order_id=pSoheadid)
    AND  (NOT shiphead_shipped)
    AND  (shiphead_order_type='SO'));
  IF (NOT FOUND OR returnVal IS NULL) THEN
    returnVal := addToPackingListBatch('SO', pSoheadid, NULL);
  END IF;

  RETURN returnVal;
END;
$_$;


ALTER FUNCTION public.addtopackinglistbatch(integer) OWNER TO admin;

--
-- TOC entry 1057 (class 1255 OID 146565624)
-- Dependencies: 4536 8
-- Name: addtopackinglistbatch(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION addtopackinglistbatch(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN addToPackingListBatch('SO', $1, $2);
END;
$_$;


ALTER FUNCTION public.addtopackinglistbatch(integer, integer) OWNER TO admin;

--
-- TOC entry 1081 (class 1255 OID 146565625)
-- Dependencies: 4536 8
-- Name: addtopackinglistbatch(text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION addtopackinglistbatch(text, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pheadtype	ALIAS FOR $1;
  pheadid	ALIAS FOR $2;
  returnVal	INTEGER;
BEGIN
  -- MIN because error codes are negative
  SELECT MIN(addToPackingListBatch(pheadtype, pheadid, shiphead_id)) INTO returnVal
  FROM shiphead
  WHERE ((shiphead_order_id=pheadid)
    AND  (NOT shiphead_shipped)
    AND  (shiphead_order_type=pheadtype));

  IF (NOT FOUND OR returnVal IS NULL) THEN
    returnVal := addToPackingListBatch(pheadtype, pheadid, NULL);
  END IF;

  RETURN returnVal;
END;
$_$;


ALTER FUNCTION public.addtopackinglistbatch(text, integer) OWNER TO admin;

--
-- TOC entry 1105 (class 1255 OID 146565626)
-- Dependencies: 4536 8
-- Name: addtopackinglistbatch(text, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION addtopackinglistbatch(text, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pheadtype	ALIAS FOR $1;
  pheadid	ALIAS FOR $2;
  pshipheadid	ALIAS FOR $3;
  _check INTEGER;

BEGIN
  SELECT pack_id INTO _check
  FROM pack
  WHERE ((pack_head_id=pheadid)
    AND  ((pack_shiphead_id=pshipheadid) OR
	  (pshipheadid IS NULL AND pack_shiphead_id IS NULL))
    AND  (pack_head_type=pheadtype)
	);

  IF (NOT FOUND) THEN
    INSERT INTO pack
    ( pack_head_type, pack_head_id, pack_shiphead_id, pack_printed )
    VALUES
    ( pheadtype, pheadid, pshipheadid, FALSE );
    -- Auto Firm Sales Orders conditionally based on metric
    IF ( (pheadtype = 'SO') AND (fetchMetricBool('FirmSalesOrderPackingList')) ) THEN
      UPDATE coitem SET coitem_firm=TRUE
      WHERE (coitem_cohead_id=pheadid);
    END IF;
  END IF;

  RETURN pheadid;

END;
$_$;


ALTER FUNCTION public.addtopackinglistbatch(text, integer, integer) OWNER TO admin;

--
-- TOC entry 1106 (class 1255 OID 146565627)
-- Dependencies: 4536 8
-- Name: addtopackinglistbatch(integer, text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION addtopackinglistbatch(integer, text, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pwarehousid	ALIAS FOR $1;
  pheadtype	ALIAS FOR $2;
  pheadid	ALIAS FOR $3;
  returnVal	INTEGER;
BEGIN
  -- MIN because error codes are negative
  SELECT MIN(addToPackingListBatch(pheadtype, pheadid,
                                   getOpenShipmentId(pheadtype, pheadid, pwarehousid))) INTO returnVal;

  IF (NOT FOUND OR returnVal IS NULL) THEN
    returnVal := addToPackingListBatch(pheadtype, pheadid, NULL);
  END IF;

  RETURN returnVal;
END;
$_$;


ALTER FUNCTION public.addtopackinglistbatch(integer, text, integer) OWNER TO admin;

--
-- TOC entry 1107 (class 1255 OID 146565628)
-- Dependencies: 4536 8
-- Name: adjustinvvalue(integer, numeric, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION adjustinvvalue(integer, numeric, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid     ALIAS FOR $1;
  pNewValue       ALIAS FOR $2;
  pAccountid      ALIAS FOR $3;
  _delta          NUMERIC;
  _glreturn       INTEGER;
  _invhistid      INTEGER;
  _itemlocSeries  INTEGER;

BEGIN

  SELECT pNewValue - itemsite_value INTO _delta
  FROM itemsite
  WHERE (itemsite_id=pItemsiteid)
  FOR UPDATE;

  IF (NOT FOUND) THEN
    RETURN -1;
  END IF;

  SELECT insertGLTransaction('I/M', '', 'Post Value',
         'Inventory Value Adjustment for ' || item_number,
         COALESCE (pAccountid, costcat_adjustment_accnt_id),
         costcat_asset_accnt_id, -1,
         _delta, CURRENT_DATE) INTO _glreturn
  FROM itemsite
   JOIN costcat ON (itemsite_costcat_id=costcat_id)
   JOIN item ON (itemsite_item_id=item_id)
  WHERE (itemsite_id=pItemsiteid);

--  Create the AD transaction
  INSERT INTO invhist
   ( invhist_itemsite_id,
     invhist_transdate, invhist_transtype, invhist_invqty,
     invhist_qoh_before, invhist_qoh_after,
     invhist_docnumber, invhist_comments,
     invhist_invuom, invhist_unitcost, invhist_hasdetail,
     invhist_costmethod, invhist_value_before, invhist_value_after,
     invhist_series )
  SELECT itemsite_id,
         CURRENT_TIMESTAMP, 'AD', 0.0,
         itemsite_qtyonhand, itemsite_qtyonhand,
         '', 'Inventory Value Adjustment',
         uom_name, _delta, FALSE,
         itemsite_costmethod, itemsite_value, pNewValue,
         0
  FROM itemsite, item, uom
  WHERE ( (itemsite_item_id=item_id)
   AND (item_inv_uom_id=uom_id)
   AND (itemsite_id=pItemsiteid) );

  UPDATE itemsite SET itemsite_value=pNewValue
  WHERE (itemsite_id=pItemsiteid);

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.adjustinvvalue(integer, numeric, integer) OWNER TO admin;

--
-- TOC entry 1108 (class 1255 OID 146565629)
-- Dependencies: 4536 8
-- Name: adjustments(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION adjustments(text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTransType ALIAS FOR $1;

BEGIN
  IF (pTransType IN ('CC', 'AD')) THEN
    RETURN TRUE;
  ELSE
    RETURN FALSE;
  END IF;

END;
$_$;


ALTER FUNCTION public.adjustments(text) OWNER TO admin;

--
-- TOC entry 1109 (class 1255 OID 146565630)
-- Dependencies: 4536 8
-- Name: allocatedforso(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION allocatedforso(integer, date) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pDate ALIAS FOR $2;

BEGIN

  RETURN allocatedForSo(pItemsiteid, startOfTime(), pDate);

END;
$_$;


ALTER FUNCTION public.allocatedforso(integer, date) OWNER TO admin;

--
-- TOC entry 1110 (class 1255 OID 146565631)
-- Dependencies: 4536 8
-- Name: allocatedforso(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION allocatedforso(integer, integer) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pDate ALIAS FOR $2;

BEGIN

  RETURN allocatedForSo(pItemsiteid, startOfTime(), (CURRENT_DATE + pDate));

END;
$_$;


ALTER FUNCTION public.allocatedforso(integer, integer) OWNER TO admin;

--
-- TOC entry 1111 (class 1255 OID 146565632)
-- Dependencies: 4536 8
-- Name: allocatedforso(integer, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION allocatedforso(integer, date, date) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pStartDate ALIAS FOR $2;
  pEndDate ALIAS FOR $3;
  _qty NUMERIC;

BEGIN

  SELECT COALESCE(SUM(noNeg(itemuomtouom(itemsite_item_id, coitem_qty_uom_id, NULL, coitem_qtyord - (coitem_qtyshipped + qtyAtShipping(coitem_id)) + coitem_qtyreturned))), 0.0) INTO _qty
  FROM coitem, itemsite, item
  WHERE ( (coitem_itemsite_id=itemsite_id)
    AND (itemsite_item_id=item_id)
    AND (coitem_status='O')
    AND (coitem_itemsite_id=pItemsiteid)
    AND (coitem_scheddate BETWEEN pStartDate AND pEndDate) );

  RETURN _qty;

END;
$_$;


ALTER FUNCTION public.allocatedforso(integer, date, date) OWNER TO admin;

--
-- TOC entry 1112 (class 1255 OID 146565633)
-- Dependencies: 4536 8
-- Name: allocatedforwo(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION allocatedforwo(integer, date) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pDate ALIAS FOR $2;

BEGIN

  RETURN allocatedForWo(pItemsiteid, startOfTime(), pDate);

END;
$_$;


ALTER FUNCTION public.allocatedforwo(integer, date) OWNER TO admin;

--
-- TOC entry 1113 (class 1255 OID 146565634)
-- Dependencies: 4536 8
-- Name: allocatedforwo(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION allocatedforwo(integer, integer) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pLookAheadDays ALIAS FOR $2;

BEGIN

  RETURN allocatedForWo(pItemsiteid, startOfTime(), (CURRENT_DATE + pLookaheadDays));

END;
$_$;


ALTER FUNCTION public.allocatedforwo(integer, integer) OWNER TO admin;

--
-- TOC entry 1116 (class 1255 OID 146565635)
-- Dependencies: 4536 8
-- Name: allocatedforwo(integer, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION allocatedforwo(integer, date, date) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pStartDate ALIAS FOR $2;
  pEndDate ALIAS FOR $3;
  _itemtype TEXT;
  _qty NUMERIC;

BEGIN

  SELECT item_type INTO _itemtype
  FROM itemsite JOIN item ON (item_id=itemsite_item_id)
  WHERE (itemsite_id=pItemsiteid);

  IF (_itemtype != 'T') THEN
    SELECT
      COALESCE(SUM(noNeg(itemuomtouom(itemsite_item_id, womatl_uom_id, NULL, womatl_qtyreq - womatl_qtyiss))), 0.0) INTO _qty
    FROM womatl JOIN wo ON (wo_id=womatl_wo_id AND wo_status IN ('E','I','R'))
                JOIN itemsite ON (itemsite_id=womatl_itemsite_id)
    WHERE (womatl_itemsite_id=pItemsiteid)
      AND (womatl_duedate BETWEEN pStartDate AND pEndDate);
  ELSE
    SELECT
      COALESCE(SUM(noNeg(itemuomtouom(itemsite_item_id, womatl_uom_id, NULL, womatl_qtyreq))), 0.0)  -
	(
		SELECT COALESCE(SUM(invhist_invqty),0)
		FROM itemsite, item, wo, womatl
			LEFT OUTER JOIN womatlpost ON (womatl_id=womatlpost_womatl_id)
			LEFT OUTER JOIN invhist ON ((womatlpost_invhist_id=invhist_id)
                            AND (invhist_invqty > 0))
		WHERE ( (womatl_itemsite_id=pItemsiteid)
		AND (womatl_itemsite_id=itemsite_id)
		AND (itemsite_item_id=item_id)
		AND (womatl_duedate BETWEEN pStartDate AND pEndDate)
		AND (wo_id=womatl_wo_id)
		AND (wo_status IN ('E','I','R')) )
	) INTO _qty
    FROM womatl JOIN wo ON (wo_id=womatl_wo_id AND wo_status IN ('E','I','R'))
                JOIN itemsite ON (itemsite_id=womatl_itemsite_id)
    WHERE (womatl_itemsite_id=pItemsiteid)
      AND (womatl_duedate BETWEEN pStartDate AND pEndDate);
  END IF;

  RETURN COALESCE(_qty,0);

END;
$_$;


ALTER FUNCTION public.allocatedforwo(integer, date, date) OWNER TO admin;

--
-- TOC entry 1117 (class 1255 OID 146565636)
-- Dependencies: 4536 8
-- Name: alterencrypt(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION alterencrypt(text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pOldKey ALIAS FOR $1;
  pNewKey ALIAS FOR $2;
  _cc RECORD;
  _ccaud RECORD;
  _metricenc RECORD;
  num_updated INTEGER;

BEGIN

  num_updated := 0;

-- Update ccard

  FOR _cc IN SELECT ccard_id,
             decrypt(setbytea(ccard_name), setbytea(pOldKey), 'bf') AS ccard_name,
             decrypt(setbytea(ccard_address1), setbytea(pOldKey), 'bf') AS ccard_address1,
             decrypt(setbytea(ccard_address2), setbytea(pOldKey), 'bf') AS ccard_address2,
             decrypt(setbytea(ccard_city), setbytea(pOldKey), 'bf') AS ccard_city,
             decrypt(setbytea(ccard_state), setbytea(pOldKey), 'bf') AS ccard_state,
             decrypt(setbytea(ccard_zip), setbytea(pOldKey), 'bf') AS ccard_zip,
             decrypt(setbytea(ccard_country), setbytea(pOldKey), 'bf') AS ccard_country,
             decrypt(setbytea(ccard_number), setbytea(pOldKey), 'bf') AS ccard_number,
             decrypt(setbytea(ccard_month_expired), setbytea(pOldKey), 'bf') AS ccard_month_expired,
             decrypt(setbytea(ccard_year_expired), setbytea(pOldKey), 'bf') AS ccard_year_expired
      FROM ccard LOOP

      UPDATE ccard
             set ccard_name = encrypt(setbytea(_cc.ccard_name), setbytea(pNewKey), 'bf'),
                 ccard_address1 = encrypt(setbytea(_cc.ccard_address1), setbytea(pNewKey), 'bf'),
                 ccard_address2 = encrypt(setbytea(_cc.ccard_address2), setbytea(pNewKey), 'bf'),
                 ccard_city = encrypt(setbytea(_cc.ccard_city), setbytea(pNewKey), 'bf'),
                 ccard_state = encrypt(setbytea(_cc.ccard_state), setbytea(pNewKey), 'bf'),
                 ccard_zip = encrypt(setbytea(_cc.ccard_zip), setbytea(pNewKey), 'bf'),
                 ccard_country = encrypt(setbytea(_cc.ccard_country), setbytea(pNewKey), 'bf'),
                 ccard_number = encrypt(setbytea(_cc.ccard_number), setbytea(pNewKey), 'bf'),
                 ccard_month_expired = encrypt(setbytea(_cc.ccard_month_expired), setbytea(pNewKey), 'bf'),
                 ccard_year_expired = encrypt(setbytea(_cc.ccard_year_expired), setbytea(pNewKey), 'bf')
      WHERE ccard_id = _cc.ccard_id;

      num_updated := num_updated + 1;

  END LOOP;

-- Update ccardaud

  FOR _ccaud IN SELECT ccardaud_id,
             decrypt(setbytea(ccardaud_ccard_name_old), setbytea(pOldKey), 'bf') AS ccardaud_ccard_name_old,
             decrypt(setbytea(ccardaud_ccard_name_new), setbytea(pOldKey), 'bf') AS ccardaud_ccard_name_new,
             decrypt(setbytea(ccardaud_ccard_address1_old), setbytea(pOldKey), 'bf') AS ccardaud_ccard_address1_old,
             decrypt(setbytea(ccardaud_ccard_address1_new), setbytea(pOldKey), 'bf') AS ccardaud_ccard_address1_new,
             decrypt(setbytea(ccardaud_ccard_address2_old), setbytea(pOldKey), 'bf') AS ccardaud_ccard_address2_old,
             decrypt(setbytea(ccardaud_ccard_address2_new), setbytea(pOldKey), 'bf') AS ccardaud_ccard_address2_new,
             decrypt(setbytea(ccardaud_ccard_city_old), setbytea(pOldKey), 'bf') AS ccardaud_ccard_city_old,
             decrypt(setbytea(ccardaud_ccard_city_new), setbytea(pOldKey), 'bf') AS ccardaud_ccard_city_new,
             decrypt(setbytea(ccardaud_ccard_state_old), setbytea(pOldKey), 'bf') AS ccardaud_ccard_state_old,
             decrypt(setbytea(ccardaud_ccard_state_new), setbytea(pOldKey), 'bf') AS ccardaud_ccard_state_new,
             decrypt(setbytea(ccardaud_ccard_zip_old), setbytea(pOldKey), 'bf') AS ccardaud_ccard_zip_old,
             decrypt(setbytea(ccardaud_ccard_zip_new), setbytea(pOldKey), 'bf') AS ccardaud_ccard_zip_new,
             decrypt(setbytea(ccardaud_ccard_country_old), setbytea(pOldKey), 'bf') AS ccardaud_ccard_country_old,
             decrypt(setbytea(ccardaud_ccard_country_new), setbytea(pOldKey), 'bf') AS ccardaud_ccard_country_new,
             decrypt(setbytea(ccardaud_ccard_number_old), setbytea(pOldKey), 'bf') AS ccardaud_ccard_number_old,
             decrypt(setbytea(ccardaud_ccard_number_new), setbytea(pOldKey), 'bf') AS ccardaud_ccard_number_new,
             decrypt(setbytea(ccardaud_ccard_month_expired_old), setbytea(pOldKey), 'bf') AS ccardaud_ccard_month_expired_old,
             decrypt(setbytea(ccardaud_ccard_month_expired_new), setbytea(pOldKey), 'bf') AS ccardaud_ccard_month_expired_new,
             decrypt(setbytea(ccardaud_ccard_year_expired_old), setbytea(pOldKey), 'bf') AS ccardaud_ccard_year_expired_old,
             decrypt(setbytea(ccardaud_ccard_year_expired_new), setbytea(pOldKey), 'bf') AS ccardaud_ccard_year_expired_new
      FROM ccardaud LOOP

      UPDATE ccardaud
             set ccardaud_ccard_name_old = encrypt(setbytea(_ccaud.ccardaud_ccard_name_old), setbytea(pNewKey), 'bf'),
                 ccardaud_ccard_name_new = encrypt(setbytea(_ccaud.ccardaud_ccard_name_new), setbytea(pNewKey), 'bf'),
                 ccardaud_ccard_address1_old = encrypt(setbytea(_ccaud.ccardaud_ccard_address1_old), setbytea(pNewKey), 'bf'),
                 ccardaud_ccard_address1_new = encrypt(setbytea(_ccaud.ccardaud_ccard_address1_new), setbytea(pNewKey), 'bf'),
                 ccardaud_ccard_address2_old = encrypt(setbytea(_ccaud.ccardaud_ccard_address2_old), setbytea(pNewKey), 'bf'),
                 ccardaud_ccard_address2_new = encrypt(setbytea(_ccaud.ccardaud_ccard_address2_new), setbytea(pNewKey), 'bf'),
                 ccardaud_ccard_city_old = encrypt(setbytea(_ccaud.ccardaud_ccard_city_old), setbytea(pNewKey), 'bf'),
                 ccardaud_ccard_city_new = encrypt(setbytea(_ccaud.ccardaud_ccard_city_new), setbytea(pNewKey), 'bf'),
                 ccardaud_ccard_state_old = encrypt(setbytea(_ccaud.ccardaud_ccard_state_old), setbytea(pNewKey), 'bf'),
                 ccardaud_ccard_state_new = encrypt(setbytea(_ccaud.ccardaud_ccard_state_new), setbytea(pNewKey), 'bf'),
                 ccardaud_ccard_zip_old = encrypt(setbytea(_ccaud.ccardaud_ccard_zip_old), setbytea(pNewKey), 'bf'),
                 ccardaud_ccard_zip_new = encrypt(setbytea(_ccaud.ccardaud_ccard_zip_new), setbytea(pNewKey), 'bf'),
                 ccardaud_ccard_country_old = encrypt(setbytea(_ccaud.ccardaud_ccard_country_old), setbytea(pNewKey), 'bf'),
                 ccardaud_ccard_country_new = encrypt(setbytea(_ccaud.ccardaud_ccard_country_new), setbytea(pNewKey), 'bf'),
                 ccardaud_ccard_number_old = encrypt(setbytea(_ccaud.ccardaud_ccard_number_old), setbytea(pNewKey), 'bf'),
                 ccardaud_ccard_number_new = encrypt(setbytea(_ccaud.ccardaud_ccard_number_new), setbytea(pNewKey), 'bf'),
                 ccardaud_ccard_month_expired_old = encrypt(setbytea(_ccaud.ccardaud_ccard_month_expired_old), setbytea(pNewKey), 'bf'),
                 ccardaud_ccard_month_expired_new = encrypt(setbytea(_ccaud.ccardaud_ccard_month_expired_new), setbytea(pNewKey), 'bf'),
                 ccardaud_ccard_year_expired_old = encrypt(setbytea(_ccaud.ccardaud_ccard_year_expired_old), setbytea(pNewKey), 'bf'),
                 ccardaud_ccard_year_expired_new = encrypt(setbytea(_ccaud.ccardaud_ccard_year_expired_new), setbytea(pNewKey), 'bf')
      WHERE ccardaud_id = _ccaud.ccardaud_id;

      num_updated := num_updated + 1;

  END LOOP;

-- Update metricenc

  FOR _metricenc IN SELECT metricenc_id,
             decrypt(setbytea(metricenc_value), setbytea(pOldKey), 'bf') AS metricenc_value
      FROM metricenc LOOP

      UPDATE metricenc
             set metricenc_value = encrypt(setbytea(_metricenc.metricenc_value), setbytea(pNewKey), 'bf')
      WHERE metricenc_id = _metricenc.metricenc_id;

      num_updated := num_updated + 1;

  END LOOP;


  RETURN num_updated;

END;
$_$;


ALTER FUNCTION public.alterencrypt(text, text) OWNER TO admin;

--
-- TOC entry 1118 (class 1255 OID 146565637)
-- Dependencies: 2651 4536 8
-- Name: apaging(date, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION apaging(date, boolean) RETURNS SETOF apaging
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pAsOfDate ALIAS FOR $1;
  pUseDocDate ALIAS FOR $2;
  _row apaging%ROWTYPE;
  _x RECORD;
  _returnVal INTEGER;
  _asOfDate DATE;
BEGIN

  _asOfDate := COALESCE(pAsOfDate,current_date);

  FOR _x IN
        SELECT
        --report uses currency rate snapshot to convert all amounts to base based on apopen_docdate to ensure the same exchange rate

        --today and greater base:
        CASE WHEN((apopen.apopen_duedate >= DATE(_asOfDate)))
        THEN (((apopen.apopen_amount - apopen.apopen_paid +
                COALESCE(SUM(apapply_target_paid * apopen.apopen_curr_rate / target.apopen_curr_rate),0))) / apopen.apopen_curr_rate *
                CASE WHEN (apopen.apopen_doctype IN ('D', 'V')) THEN 1 ELSE -1 END) ELSE 0 END AS cur_val,

        --0 to 30 base
        CASE WHEN((apopen.apopen_duedate >= DATE(_asOfDate)-30) AND (apopen.apopen_duedate < DATE(_asOfDate)))
        THEN (((apopen.apopen_amount - apopen.apopen_paid +
                COALESCE(SUM(apapply_target_paid * apopen.apopen_curr_rate / target.apopen_curr_rate),0))) / apopen.apopen_curr_rate *
                CASE WHEN (apopen.apopen_doctype IN ('D', 'V')) THEN 1 ELSE -1 END) ELSE 0 END AS thirty_val,

        --30-60 base
        CASE WHEN((apopen.apopen_duedate >= DATE(_asOfDate)-60) AND (apopen.apopen_duedate < DATE(_asOfDate) - 30 ))
        THEN (((apopen.apopen_amount - apopen.apopen_paid +
                COALESCE(SUM(apapply_target_paid * apopen.apopen_curr_rate / target.apopen_curr_rate),0))) / apopen.apopen_curr_rate *
                CASE WHEN (apopen.apopen_doctype IN ('D', 'V')) THEN 1 ELSE -1 END) ELSE 0 END AS sixty_val,

        --60-90 base
        CASE WHEN((apopen.apopen_duedate >= DATE(_asOfDate)-90) AND (apopen.apopen_duedate < DATE(_asOfDate) - 60))
        THEN (((apopen.apopen_amount - apopen.apopen_paid +
                COALESCE(SUM(apapply_target_paid * apopen.apopen_curr_rate / target.apopen_curr_rate),0))) / apopen.apopen_curr_rate *
                CASE WHEN (apopen.apopen_doctype IN ('D', 'V')) THEN 1 ELSE -1 END) ELSE 0 END AS ninety_val,

        --greater than 90 base:
        CASE WHEN((apopen.apopen_duedate > DATE(_asOfDate)-10000) AND (apopen.apopen_duedate < DATE(_asOfDate) - 90))
        THEN (((apopen.apopen_amount - apopen.apopen_paid +
                COALESCE(SUM(apapply_target_paid * apopen.apopen_curr_rate / target.apopen_curr_rate),0))) / apopen.apopen_curr_rate *
                CASE WHEN (apopen.apopen_doctype IN ('D', 'V')) THEN 1 ELSE -1 END) ELSE 0 END AS plus_val,

        --total amount base:
        CASE WHEN((apopen.apopen_duedate > DATE(_asOfDate)-10000))
        THEN (((apopen.apopen_amount - apopen.apopen_paid +
                COALESCE(SUM(apapply_target_paid * apopen.apopen_curr_rate / target.apopen_curr_rate),0))) / apopen.apopen_curr_rate *
                CASE WHEN (apopen.apopen_doctype IN ('D', 'V')) THEN 1 ELSE -1 END) ELSE 0 END AS total_val,

        --AP Open Amount base
        CASE WHEN apopen.apopen_doctype IN ('C', 'R')
        THEN (apopen.apopen_amount / apopen.apopen_curr_rate * -1.0)
        ELSE (apopen.apopen_amount / apopen.apopen_curr_rate) END AS apopen_amount,

        apopen.apopen_docdate,
        apopen.apopen_duedate,
        apopen.apopen_ponumber,
        apopen.apopen_invcnumber,
        apopen.apopen_docnumber,
        apopen.apopen_doctype,
        vend_id,
        vend_name,
        vend_number,
        vend_vendtype_id,
        vendtype_code,
        terms_descrip,
        determineDiscountDate(terms_id, apopen.apopen_docdate) AS discdate,
        noNeg(apopen.apopen_discountable_amount *
                     CASE WHEN (CURRENT_DATE <= determineDiscountDate(terms_id, apopen.apopen_docdate)) THEN terms_discprcnt
                     ELSE 0.0 END) AS disc_val,
        terms_discdays AS discdays,
        (terms_discprcnt * 100.0) AS discprcnt

        FROM vendinfo, vendtype, apopen
          LEFT OUTER JOIN terms ON (apopen_terms_id=terms_id)
          LEFT OUTER JOIN apapply ON (((apopen_id=apapply_target_apopen_id)
                                    OR (apopen_id=apapply_source_apopen_id))
                                   AND (apapply_postdate >_asOfDate))
          LEFT OUTER JOIN apopen target ON (target.apopen_id=apapply_target_apopen_id)
        WHERE ( (apopen.apopen_vend_id = vend_id)
        AND (vend_vendtype_id=vendtype_id)
        AND (CASE WHEN (pUseDocDate) THEN apopen.apopen_docdate ELSE apopen.apopen_distdate END <= _asOfDate)
        AND (COALESCE(apopen.apopen_closedate,_asOfDate+1)>_asOfDate) )
        GROUP BY apopen.apopen_id,apopen.apopen_docdate,apopen.apopen_duedate,apopen.apopen_ponumber,
                 apopen.apopen_invcnumber,apopen.apopen_docnumber,apopen.apopen_doctype,apopen.apopen_paid,
                 apopen.apopen_curr_id,apopen.apopen_amount,vend_id,vend_name,vend_number,vend_vendtype_id,vendtype_code,terms_descrip,
                 apopen.apopen_curr_rate, terms_id, terms_discdays, terms_discprcnt, apopen.apopen_discountable_amount
        ORDER BY vend_number, apopen.apopen_duedate
  LOOP
        _row.apaging_docdate := _x.apopen_docdate;
        _row.apaging_duedate := _x.apopen_duedate;
        _row.apaging_ponumber := _x.apopen_ponumber;
        _row.apaging_invcnumber := _x.apopen_invcnumber;
        _row.apaging_docnumber := _x.apopen_docnumber;
        _row.apaging_doctype := _x.apopen_doctype;
        _row.apaging_vend_id := _x.vend_id;
        _row.apaging_vend_number := _x.vend_number;
        _row.apaging_vend_name := _x.vend_name;
        _row.apaging_vend_vendtype_id := _x.vend_vendtype_id;
        _row.apaging_vendtype_code := _x.vendtype_code;
        _row.apaging_terms_descrip := _x.terms_descrip;
        _row.apaging_apopen_amount := _x.apopen_amount;
        _row.apaging_cur_val := _x.cur_val;
        _row.apaging_thirty_val := _x.thirty_val;
        _row.apaging_sixty_val := _x.sixty_val;
        _row.apaging_ninety_val := _x.ninety_val;
        _row.apaging_plus_val := _x.plus_val;
        _row.apaging_total_val := _x.total_val;
        _row.apaging_discdate := _x.discdate;
        _row.apaging_disc_val := _x.disc_val;
        _row.apaging_discdays := _x.discdays;
        _row.apaging_discprcnt := _x.discprcnt;
        RETURN NEXT _row;
  END LOOP;
  RETURN;
END;
$_$;


ALTER FUNCTION public.apaging(date, boolean) OWNER TO admin;

--
-- TOC entry 1119 (class 1255 OID 146565638)
-- Dependencies: 4536 8
-- Name: apapplied(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION apapplied(integer, date) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pApopenid ALIAS FOR $1;
  pDate ALIAS FOR $2;
  _amount NUMERIC;

BEGIN

  -- Return amount applied to an apopen in base currency as of apapply_postdate
  SELECT SUM(currtobase(apapply_curr_id,apapply_amount,apapply_postdate)) INTO _amount
  FROM apapply
  WHERE (((apapply_target_apopen_id = pApopenid) OR (apapply_source_apopen_id = pApopenid))
  AND (((apapply_journalnumber=0) AND (apapply_postdate <= pDate))
  OR EXISTS(SELECT *
             FROM gltrans
             WHERE ((gltrans_journalnumber=apapply_journalnumber)
             AND (gltrans_date <= pDate)))));

  IF (_amount IS NULL) THEN
    RETURN 0;
  ELSE
    RETURN _amount;
  END IF;

END;
$_$;


ALTER FUNCTION public.apapplied(integer, date) OWNER TO admin;

--
-- TOC entry 1120 (class 1255 OID 146565639)
-- Dependencies: 4536 8
-- Name: apcheckpending(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION apcheckpending(integer) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pApopenid	ALIAS FOR $1;
  _qty NUMERIC  := 0.0;

BEGIN

  SELECT SUM(checkitem_amount + checkitem_discount) INTO _qty
    FROM checkitem JOIN checkhead ON (checkitem_checkhead_id=checkhead_id)
   WHERE ((checkitem_apopen_id=pApopenid)
     AND (NOT checkhead_deleted)
     AND (NOT checkhead_replaced)
     AND (NOT checkhead_void)
     AND (NOT checkhead_posted));

  RETURN COALESCE(_qty, 0.0);

END;
$_$;


ALTER FUNCTION public.apcheckpending(integer) OWNER TO admin;

--
-- TOC entry 1121 (class 1255 OID 146565640)
-- Dependencies: 4536 8
-- Name: apcurrgain(integer, integer, numeric, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION apcurrgain(integer, integer, numeric, date) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pApopenId ALIAS FOR $1;
  pCurrId ALIAS FOR $2;
  pValue ALIAS FOR $3;
  pDate ALIAS FOR $4;
  _start DATE;
  _end DATE;
  _gain NUMERIC;
  _r RECORD;

BEGIN
  IF (pApopenId IS NULL OR pValue = 0) THEN
    RETURN 0;
  END IF;

  SELECT apopen_docdate, apopen_curr_rate
    INTO _r
  FROM apopen
  WHERE (apopen_id=pApopenId);

  IF (_r.apopen_docdate > pDate) THEN
    _gain := (currToBase(pCurrId, pValue, pDate) - (pValue / _r.apopen_curr_rate)) * -1;
  ELSE
    _gain := (pValue / _r.apopen_curr_rate) - currToBase(pCurrId, pValue, pDate);
  END IF;

  IF (_gain IS NULL) THEN
    RAISE EXCEPTION 'Error processing currency gain/loss.';
  END IF;

  RETURN _gain;
END;
$_$;


ALTER FUNCTION public.apcurrgain(integer, integer, numeric, date) OWNER TO admin;

--
-- TOC entry 1122 (class 1255 OID 146565641)
-- Dependencies: 4536 8
-- Name: applyapcreditmemotobalance(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION applyapcreditmemotobalance(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pApopenid ALIAS FOR $1;
  _amount NUMERIC;
  _curr_id INTEGER;
  _curr_rate NUMERIC;
  _docdate DATE;
  _applyAmount NUMERIC;
  _r RECORD;
  _p RECORD;

BEGIN

--  Find the balance to apply
  SELECT (apopen_amount - apopen_paid - COALESCE(prepared,0.0) - COALESCE(selected,0.0) - COALESCE(SUM(currToCurr(apcreditapply_curr_id,
                                                  apopen_curr_id,
                                                  apcreditapply_amount,
                                                  apopen_docdate)), 0)),
          apopen_curr_id, apopen_curr_rate, apopen_docdate INTO _amount, _curr_id, _curr_rate, _docdate
  FROM apopen
    LEFT OUTER JOIN apcreditapply ON (apcreditapply_source_apopen_id=apopen_id)
    LEFT OUTER JOIN (SELECT apopen_id AS selected_apopen_id,
                       SUM(currToCurr(apselect_curr_id, apopen_curr_id, apselect_amount + apselect_discount, apselect_date)) AS selected
                     FROM apselect JOIN apopen ON (apselect_apopen_id=apopen_id)
                     GROUP BY apopen_id) AS sub1 ON (apopen_id=selected_apopen_id)
    LEFT OUTER JOIN (SELECT apopen_id AS prepared_apopen_id,
                       SUM(checkitem_amount + checkitem_discount) AS prepared
                     FROM checkhead
                       JOIN checkitem ON (checkitem_checkhead_id=checkhead_id)
                       JOIN apopen ON (checkitem_apopen_id=apopen_id)
                     WHERE ((NOT checkhead_posted)
                       AND  (NOT checkhead_void))
                     GROUP BY apopen_id) AS sub2 ON (prepared_apopen_id=apopen_id)
  WHERE (apopen_id=pApopenid)
  GROUP BY apopen_amount, apopen_paid, apopen_curr_id, apopen_curr_rate, apopen_docdate, prepared, selected;

  IF (_amount < 0) THEN
    RETURN -1;
  END IF;

--  Loop through the apopen items in order of due date
  FOR _r IN SELECT target.apopen_id AS apopenid,
                   currToCurr(target.apopen_curr_id,source.apopen_curr_id,
                     target.apopen_amount - target.apopen_paid - COALESCE(prepared,0.0) - COALESCE(selected,0.0) - COALESCE(applied,0.0),
                     current_date) AS balance
           FROM apopen AS source, apopen AS target
             LEFT OUTER JOIN (SELECT apcreditapply_target_apopen_id AS applied_apopen_id,
                                     SUM(currToCurr(apcreditapply_curr_id, apopen_curr_id, apcreditapply_amount, apopen_docdate)) AS applied
                              FROM apcreditapply JOIN apopen ON (apopen_id=apcreditapply_source_apopen_id)
                              GROUP BY apcreditapply_target_apopen_id) AS sub3
                              ON (target.apopen_id=applied_apopen_id)
             LEFT OUTER JOIN (SELECT apopen_id AS selected_apopen_id,
                                SUM(currToCurr(apselect_curr_id, apopen_curr_id, apselect_amount + apselect_discount, apselect_date)) AS selected
                                    FROM apselect JOIN apopen ON (apselect_apopen_id=apopen_id)
                                GROUP BY apopen_id) AS sub1
                                ON (target.apopen_id=selected_apopen_id)
             LEFT OUTER JOIN (SELECT apopen_id AS prepared_apopen_id,
                                SUM(checkitem_amount + checkitem_discount) AS prepared
                              FROM checkhead
                                JOIN checkitem ON (checkitem_checkhead_id=checkhead_id)
                                JOIN apopen ON (checkitem_apopen_id=apopen_id)
                              WHERE ((NOT checkhead_posted)
                               AND  (NOT checkhead_void))
                              GROUP BY apopen_id) AS sub2 ON (prepared_apopen_id=target.apopen_id)
            WHERE ( (source.apopen_vend_id=target.apopen_vend_id)
             AND (target.apopen_doctype IN ('V', 'D'))
             AND (target.apopen_open)
             AND (source.apopen_id=pApopenid) )
            ORDER BY target.apopen_duedate, (target.apopen_amount - target.apopen_paid) LOOP

--  Determine the amount to apply
    IF (_r.balance <= 0.0) THEN
      CONTINUE;
    ELSEIF (_r.balance > _amount) THEN
      _applyAmount := _amount;
    ELSE
      _applyAmount := _r.balance;
    END IF;

--  Does an apcreditapply record already exist?
    SELECT apcreditapply_id,
              apcreditapply_amount * _curr_rate /
                 currRate(apcreditapply_curr_id,_docdate) AS apcreditapply_amount
      INTO _p
    FROM apcreditapply
    WHERE ( (apcreditapply_target_apopen_id=_r.apopenid)
     AND (apcreditapply_source_apopen_id=pApopenid) );

    IF (FOUND) THEN
--  The following is depreciated, just skip the record
--  Recalculate the amount to apply
--      IF ((_r.balance - _p.apcreditapply_amount) > _amount) THEN
--        _applyAmount := _amount;
--      ELSE
--        _applyAmount := (_r.balance - _p.apcreditapply_amount);
--      END IF;

--  Update the apcreditapply with the new amount to apply
--      UPDATE apcreditapply
--      SET apcreditapply_amount = (apcreditapply_amount +
--          _applyAmount *  currRate(apcreditapply_curr_id,_docdate) / _curr_rate)
--      WHERE (apcreditapply_id=_p.apcreditapply_id);

      CONTINUE;
    ELSE
--  Create a new apcreditapply record
      INSERT INTO apcreditapply
      ( apcreditapply_source_apopen_id, apcreditapply_target_apopen_id,
        apcreditapply_amount, apcreditapply_curr_id )
      VALUES
      ( pApopenid, _r.apopenid, _applyAmount, _curr_id );
    END IF;

    _amount := (_amount - _applyAmount);
    IF (_amount = 0) THEN
      EXIT;
    END IF;

  END LOOP;

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.applyapcreditmemotobalance(integer) OWNER TO admin;

--
-- TOC entry 1123 (class 1255 OID 146565642)
-- Dependencies: 4536 8
-- Name: applyapcredits(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION applyapcredits(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVendId   ALIAS FOR $1;
  _result   INTEGER;
  _apopenid INTEGER;
  _r        RECORD;

BEGIN

  -- Fetch credit memo(s) for the vendor
  FOR _r IN SELECT apopen_id, apopen_duedate
            FROM apopen JOIN vendinfo ON (apopen_vend_id = vend_id)
            WHERE ((apopen_doctype = 'C')
               AND (apopen_status = 'O')
               AND (vend_id = pVendId))
            ORDER BY apopen_duedate
  LOOP
    -- Apply credit memo(s) according to due date
    SELECT applyapcreditmemotobalance(_r.apopen_id) INTO _result;

    -- Post the credit memo if applied
    IF (_result = 1) THEN
      SELECT postapcreditmemoapplication(_r.apopen_id) INTO _apopenid;
      IF (_apopenid < 0) THEN
        RETURN -1;
      END IF;
    ELSE
      RETURN -1;
    END IF;

  END LOOP;

RETURN 1;

END;
$_$;


ALTER FUNCTION public.applyapcredits(integer) OWNER TO admin;

--
-- TOC entry 1124 (class 1255 OID 146565643)
-- Dependencies: 4536 8
-- Name: applyarcreditmemotobalance(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION applyarcreditmemotobalance(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pAropenid ALIAS FOR $1;

BEGIN

  RETURN applyARCreditMemoToBalance(pAropenid, NULL);

END;
$_$;


ALTER FUNCTION public.applyarcreditmemotobalance(integer) OWNER TO admin;

--
-- TOC entry 1125 (class 1255 OID 146565644)
-- Dependencies: 4536 8
-- Name: applyarcreditmemotobalance(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION applyarcreditmemotobalance(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSourceAropenid ALIAS FOR $1;
  pTargetAropenid ALIAS FOR $2;
  _amount NUMERIC;
  _amountcurrid INTEGER;
  _applyAmount NUMERIC;
  _applycurrid  INTEGER;
  _curr_rate NUMERIC;
  _r RECORD;
  _p RECORD;

BEGIN

--  Find the balance to apply
  SELECT (aropen_amount - COALESCE(SUM(currToCurr(arcreditapply_curr_id,
                                                  aropen_curr_id,
                                                  arcreditapply_amount,
                                                  aropen_docdate)), 0) - aropen_paid - COALESCE(prepared,0.0) - COALESCE(cashapplied,0.0)),
         aropen_curr_id, aropen_curr_rate INTO _amount, _amountcurrid, _curr_rate
  FROM aropen LEFT OUTER JOIN arcreditapply ON (arcreditapply_source_aropen_id=aropen_id)
	      LEFT OUTER JOIN (SELECT aropen_id AS prepared_aropen_id,
                                SUM(checkitem_amount + checkitem_discount) AS prepared
                               FROM checkhead JOIN checkitem ON (checkitem_checkhead_id=checkhead_id)
                                              JOIN aropen ON (checkitem_aropen_id=aropen_id)
                               WHERE ((NOT checkhead_posted)
                                AND  (NOT checkhead_void))
                               GROUP BY aropen_id) AS sub1
                      ON (prepared_aropen_id=aropen_id)
             LEFT OUTER JOIN (SELECT aropen_id AS cash_aropen_id,
                                     SUM(cashrcptitem_amount + cashrcptitem_discount) * -1.0 AS cashapplied
                                FROM cashrcpt JOIN cashrcptitem ON (cashrcptitem_cashrcpt_id=cashrcpt_id)
                                              JOIN aropen ON (cashrcptitem_aropen_id=aropen_id)
                               WHERE (NOT cashrcpt_posted) AND (NOT cashrcpt_void)
                               GROUP BY aropen_id ) AS sub2
                      ON (cash_aropen_id=aropen_id)
  WHERE (aropen_id=pSourceAropenid)
  GROUP BY aropen_amount, aropen_paid, aropen_curr_id, aropen_curr_rate, prepared, cashapplied;

  IF (_amount < 0) THEN
    RETURN -1;
  END IF;

--  Loop through the aropen items in order of due date
  FOR _r IN SELECT target.aropen_id AS aropenid,
                   currToCurr(target.aropen_curr_id,source.aropen_curr_id,
                              (target.aropen_amount - target.aropen_paid - calcpendingarapplications(target.aropen_id)),
                              current_date) AS balance,
                   target.aropen_curr_id AS curr_id,
                   target.aropen_docdate AS docdate
            FROM aropen AS target, aropen AS source
            WHERE ( (source.aropen_cust_id=target.aropen_cust_id)
             AND (target.aropen_doctype IN ('D', 'I'))
             AND (target.aropen_open)
             AND (source.aropen_id=pSourceAropenid)
             AND ((pTargetAropenid IS NULL) OR (target.aropen_id=pTargetAropenid)) )
            ORDER BY target.aropen_duedate, target.aropen_docnumber LOOP

--  Determine the amount to apply
    IF (_r.balance > _amount) THEN
      _applyAmount := _amount;
    ELSE
      _applyAmount := _r.balance;
    END IF;
    _applycurrid := _amountcurrid;

--  Does an arcreditapply record already exist?
    SELECT arcreditapply_id,
           arcreditapply_amount,
           arcreditapply_amount * _curr_rate /
                 currRate(arcreditapply_curr_id,_r.docdate) AS
                      arcreditapply_amount_applycurr INTO _p
    FROM arcreditapply
    WHERE ( (arcreditapply_target_aropen_id=_r.aropenid)
     AND (arcreditapply_source_aropen_id=pSourceAropenid) );

    IF (FOUND) THEN
--  Offset the amount to apply by the amount already applied
      _applyAmount := (_applyAmount - _p.arcreditapply_amount_applycurr);
      IF (_applyAmount < 0) THEN
        _applyAmount := 0;
      END IF;

--  Update the arcreditapply with the new amount to apply
      UPDATE arcreditapply
      SET arcreditapply_amount = (arcreditapply_amount +
          _applyAmount *  currRate(arcreditapply_curr_id,_r.docdate) / _curr_rate)
      WHERE (arcreditapply_id=_p.arcreditapply_id);

    ELSE
--  Create a new arcreditapply record
      INSERT INTO arcreditapply
      ( arcreditapply_source_aropen_id, arcreditapply_target_aropen_id,
        arcreditapply_amount, arcreditapply_curr_id )
      VALUES
      ( pSourceAropenid, _r.aropenid, _applyAmount, _applycurrid );
    END IF;

    _amount := _amount - currToCurr(_applycurrid, _amountcurrid, _applyAmount, _r.docdate);
    IF (_amount = 0) THEN
      EXIT;
    END IF;

  END LOOP;

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.applyarcreditmemotobalance(integer, integer) OWNER TO admin;

--
-- TOC entry 1126 (class 1255 OID 146565645)
-- Dependencies: 4536 8
-- Name: applycashreceiptlinebalance(integer, integer, numeric, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION applycashreceiptlinebalance(integer, integer, numeric, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCashrcptId ALIAS FOR $1;
  pAropenid ALIAS FOR $2;
  pAmount ALIAS FOR $3;
  pCurrId ALIAS FOR $4;
  _balance NUMERIC;
  _amount NUMERIC;
  _applyAmount NUMERIC := 0;
  _discount NUMERIC := 0;
  _discprct NUMERIC;
  _docDate DATE;
  _r RECORD;
  _doctype CHAR(1);

BEGIN

--  All calculations performed in currency of Cash Receipt

--  Clear previously applied
  DELETE FROM cashrcptitem WHERE ((cashrcptitem_cashrcpt_id=pCashrcptId) AND (cashrcptitem_aropen_id=pAropenId));

--  Find the balance to apply
  SELECT (pAmount - (COALESCE(SUM(cashrcptitem_amount), 0) ) ),
    COALESCE(cashrcpt_docdate, current_date)
    INTO _amount, _docDate
  FROM cashrcpt LEFT OUTER JOIN cashrcptitem ON (cashrcptitem_cashrcpt_id = cashrcpt_id)
  WHERE (cashrcpt_id=pCashrcptid)
  GROUP BY cashrcpt_curr_id, cashrcpt_distdate, cashrcpt_docdate;

  SELECT (_amount - COALESCE(SUM(cashrcptmisc_amount), 0)) INTO _amount
  FROM cashrcptmisc
  WHERE (cashrcptmisc_cashrcpt_id=pCashrcptid);

  SELECT aropen_doctype INTO _doctype
  FROM aropen
  WHERE (aropen_id=pAropenId);

  RAISE DEBUG 'Amount (%) DocType (%)', _amount, _doctype;

  IF (_amount <= 0 AND _doctype IN ('I','D')) THEN
    RETURN 0;
  END IF;

--  Determine Line balance
  SELECT currToCurr(aropen_curr_id, cashrcpt_curr_id,
         aropen_amount - aropen_paid, cashrcpt_distdate) -
         COALESCE((SELECT (SUM(cashrcptitem_amount) + SUM(cashrcptitem_discount))
                   FROM cashrcptitem, cashrcpt
                   WHERE ((cashrcpt_id=cashrcptitem_cashrcpt_id)
                     AND  (NOT cashrcpt_void)
                     AND  (NOT cashrcpt_posted)
                     AND  (cashrcpt_id != pCashrcptId)
                     AND  (cashrcptitem_aropen_id=pAropenId))), 0)
         INTO _balance
         FROM aropen, cashrcpt
           WHERE ((aropen_id=pAropenId)
           AND (cashrcpt_id=pCashrcptId));

  RAISE DEBUG 'Balance (%)', _balance;

--  If Invoice or Debit Memo, determine Max Discount as per Terms
  IF (_doctype IN ('I','D')) THEN
    SELECT  round(noNeg(_balance *
            CASE WHEN (_docDate <= determineDiscountDate(terms_id, aropen_docdate)) THEN COALESCE(terms_discprcnt, 0.0)
            ELSE 0.00 END - applied),2),
            CASE WHEN (_docDate <= determineDiscountDate(terms_id, aropen_docdate)) THEN COALESCE(terms_discprcnt, 0.0)
            ELSE 0.00 END INTO _discount, _discprct
    FROM aropen LEFT OUTER JOIN terms ON (terms_id=aropen_terms_id),
         (SELECT COALESCE(SUM(arapply_applied), 0.00) AS applied
	  FROM arapply, aropen
          WHERE ((arapply_target_aropen_id=pAropenId)
           AND (arapply_source_aropen_id=pAropenId)
           AND  (aropen_discount) )
             ) AS data
    WHERE (aropen_id=pAropenId);

--  Determine the amount to apply
    IF (_balance <= _amount + _discount) THEN
      _applyAmount := _balance - _discount;
    ELSE
      _discount := round((_amount / (1 - _discprct)) - _amount, 2);
      _applyAmount := _amount;
    END IF;
  ELSIF (_doctype IN ('C', 'R')) THEN
  -- Handle Credits, discounts don't apply here
    _applyAmount := _balance * -1;
  ELSE
    _applyAmount := _amount;
  END IF;

  IF (_applyAmount != 0) THEN
--  Create a new cashrcptitem
      INSERT INTO cashrcptitem
      ( cashrcptitem_aropen_id, cashrcptitem_cashrcpt_id,
        cashrcptitem_amount,cashrcptitem_discount )
      VALUES
      ( pAropenid, pCashrcptid, round(_applyAmount, 2), round(_discount, 2) );
  END IF;

  RETURN abs(_applyAmount);

END;
$_$;


ALTER FUNCTION public.applycashreceiptlinebalance(integer, integer, numeric, integer) OWNER TO admin;

--
-- TOC entry 1127 (class 1255 OID 146565646)
-- Dependencies: 4536 8
-- Name: applycashreceipttobalance(integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION applycashreceipttobalance(integer, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCashrcptid ALIAS FOR $1;
  pAmount ALIAS FOR $2;

BEGIN
  RETURN applyCashReceiptToBalance(pCashrcptid, pAmount, baseCurrId() );
END;
$_$;


ALTER FUNCTION public.applycashreceipttobalance(integer, numeric) OWNER TO admin;

--
-- TOC entry 1128 (class 1255 OID 146565647)
-- Dependencies: 4536 8
-- Name: applycashreceipttobalance(integer, numeric, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION applycashreceipttobalance(integer, numeric, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCashrcptid ALIAS FOR $1;
  pAmount ALIAS FOR $2;
  pCurrId ALIAS FOR $3;

BEGIN

  RETURN applyCashReceiptToBalance(pCashrcptid, pAmount, pCurrId, false);

END;
$_$;


ALTER FUNCTION public.applycashreceipttobalance(integer, numeric, integer) OWNER TO admin;

--
-- TOC entry 1129 (class 1255 OID 146565648)
-- Dependencies: 4536 8
-- Name: applycashreceipttobalance(integer, numeric, integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION applycashreceipttobalance(integer, numeric, integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCashrcptid ALIAS FOR $1;
  pAmount ALIAS FOR $2;
  pCurrId ALIAS FOR $3;
  pInclCredits ALIAS FOR $4;
  _amount NUMERIC;
  _applied NUMERIC := 0;
  _applyAmount NUMERIC;
  _discount NUMERIC;
  _discprct NUMERIC;
  _docDate DATE;
  _r RECORD;
  _toApply NUMERIC;

BEGIN

--  Apply open credits first if applicable
  IF (pInclCredits) THEN
    -- First find total debits unaccounted for by this receipt so we can apply as much credit
    -- as possible to clear, but no more
    SELECT coalesce(noNeg(sum(currToCurr(aropen_curr_id, cashrcpt_curr_id,
         aropen_amount - aropen_paid, cashrcpt_distdate) -
         COALESCE((SELECT (SUM(cashrcptitem_amount) + SUM(cashrcptitem_discount))
                   FROM cashrcptitem, cashrcpt
                   WHERE ((cashrcpt_id=cashrcptitem_cashrcpt_id)
                     AND  (NOT cashrcpt_void)
                     AND  (NOT cashrcpt_posted)
                     AND  (cashrcpt_id != pCashrcptid)
                     AND  (cashrcptitem_aropen_id=aropen_id))), 0)) - pAmount),0)
    INTO _toApply
    FROM cashrcpt
      JOIN custinfo ON (cashrcpt_cust_id=cust_id)
      JOIN aropen ON (cust_id=aropen_cust_id)
    WHERE ((cashrcpt_id=pCashrcptid)
      AND (aropen_open)
      AND (aropen_doctype IN ('I','D')));

    -- Loop through and apply credits until we account for all remaining debits we can
    FOR _r IN
      SELECT aropen_id
      FROM cashrcpt
        JOIN custinfo ON (cashrcpt_cust_id=cust_id)
        JOIN aropen ON (cust_id=aropen_cust_id)
      WHERE ((cashrcpt_id=pCashrcptid)
        AND (aropen_open)
        AND (aropen_doctype IN ('C','R')))
      ORDER BY aropen_duedate, aropen_docnumber
    LOOP
     EXIT WHEN _toApply <= 0;
      _toApply := _toApply - applyCashReceiptLineBalance(pCashrcptid, _r.aropen_id, _toApply, pCurrId);
    END LOOP;
  END IF;

--  Find the balance to apply
  SELECT (currToCurr(pCurrId, cashrcpt_curr_id, pAmount, cashrcpt_distdate) -
              (COALESCE(SUM(cashrcptitem_amount), 0) ) ),
              COALESCE(cashrcpt_docdate, current_date)
              INTO _amount, _docDate
  FROM cashrcpt LEFT OUTER JOIN cashrcptitem ON (cashrcptitem_cashrcpt_id = cashrcpt_id)
  WHERE (cashrcpt_id=pCashrcptid)
  GROUP BY cashrcpt_curr_id, cashrcpt_distdate, cashrcpt_docdate;

  SELECT (_amount - COALESCE(SUM(cashrcptmisc_amount), 0)) INTO _amount
  FROM cashrcptmisc
  WHERE (cashrcptmisc_cashrcpt_id=pCashrcptid);

  IF (_amount = 0) THEN
    RETURN 1;
  END IF;

--  Loop through the aropen item in order of due date, searching only for
--  aropen items that are open, for the current customer and have an outstanding balance
  FOR _r IN SELECT aropen_id,
               currToCurr(aropen_curr_id, cashrcpt_curr_id,
               aropen_amount - aropen_paid, cashrcpt_distdate) -
               COALESCE((SELECT SUM(cashrcptitem_amount) + SUM(cashrcptitem_discount)
                           FROM cashrcptitem, cashrcpt
                           WHERE ((cashrcpt_id=cashrcptitem_cashrcpt_id)
                             AND  (NOT cashrcpt_void)
                             AND  (NOT cashrcpt_posted)
                             AND  (cashrcpt_id != pCashrcptId)
                             AND  (cashrcptitem_aropen_id=aropen_id))), 0) AS balance,
                   s.cashrcptitem_id AS cashrcptitem_id
            FROM cashrcpt, aropen LEFT OUTER JOIN
                 cashrcptitem s ON (s.cashrcptitem_aropen_id=aropen_id AND s.cashrcptitem_cashrcpt_id=pCashrcptId)
                 LEFT OUTER JOIN terms ON (aropen_terms_id=terms_id),
                 (SELECT COALESCE(SUM(arapply_applied), 0.00) AS applied
                  FROM arapply, aropen
                  WHERE ((arapply_target_aropen_id=aropen_id)
                    AND (arapply_source_aropen_id=aropen_id)
                    AND  (aropen_discount) )
                 ) AS data

            WHERE ( (aropen_cust_id=cashrcpt_cust_id)
             AND (aropen_doctype IN ('I', 'D'))
             AND (aropen_open)
             AND (cashrcpt_id=pCashrcptid) )
            ORDER BY aropen_duedate, aropen_amount, balance LOOP

--  Determine Max Discount as per Terms
    SELECT  round(noNeg(_r.balance *
            CASE WHEN (_docDate <= determineDiscountDate(terms_id, aropen_docdate)) THEN terms_discprcnt
            ELSE 0.00 END - applied),2),
            CASE WHEN (_docDate <= determineDiscountDate(terms_id, aropen_docdate)) THEN terms_discprcnt
            ELSE 0.00 END INTO _discount, _discprct
            FROM aropen LEFT OUTER JOIN terms ON (terms_id=aropen_terms_id),
                 (SELECT COALESCE(SUM(arapply_applied), 0.00) AS applied
		          FROM arapply, aropen
                  WHERE ((arapply_target_aropen_id=_r.aropen_id)
                  AND (arapply_source_aropen_id=_r.aropen_id)
                  AND  (aropen_discount) )
                 ) AS data
            WHERE (aropen_id=_r.aropen_id);

--  Determine the amount to apply
    IF (_r.balance <= _amount + _discount) THEN
      _applyAmount := _r.balance - _discount;
    ELSE
      _discount := round((_amount / (1 - _discprct)) - _amount, 2);
      _applyAmount := _amount;
    END IF;

    IF (_applyAmount > 0) THEN
--  Does an cashrcptitem already exist?
      IF (_r.cashrcptitem_id IS NOT NULL) THEN
--  Update the cashrcptitem with the new amount to apply
        UPDATE cashrcptitem
        SET cashrcptitem_amount = round(cashrcptitem_amount + _applyAmount, 2),
            cashrcptitem_discount = round(_discount, 2)
        WHERE (cashrcptitem_id=_r.cashrcptitem_id);
      ELSE
--  Create a new cashrcptitem
        INSERT INTO cashrcptitem
        ( cashrcptitem_aropen_id, cashrcptitem_cashrcpt_id,
          cashrcptitem_amount, cashrcptitem_discount )
        VALUES
        ( _r.aropen_id, pCashrcptid, round(_applyAmount, 2), round(_discount, 2) );
      END IF;

      _amount := (_amount - _applyAmount);
      IF (round(_amount, 2) = 0) THEN
        EXIT;
      END IF;

    END IF;
  END LOOP;

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.applycashreceipttobalance(integer, numeric, integer, boolean) OWNER TO admin;

--
-- TOC entry 1096 (class 1255 OID 146565650)
-- Dependencies: 2654 4536 8
-- Name: araging(date, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION araging(date, boolean) RETURNS SETOF araging
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pAsOfDate ALIAS FOR $1;
  pUseDocDate ALIAS FOR $2;
  _row araging%ROWTYPE;

BEGIN

  FOR _row IN SELECT *
            FROM araging(pAsOfDate, pUseDocDate, true)
  LOOP
    RETURN NEXT _row;
  END LOOP;

  RETURN;
END;
$_$;


ALTER FUNCTION public.araging(date, boolean) OWNER TO admin;

--
-- TOC entry 1130 (class 1255 OID 146565651)
-- Dependencies: 2654 4536 8
-- Name: araging(date, boolean, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION araging(date, boolean, boolean) RETURNS SETOF araging
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pAsOfDate ALIAS FOR $1;
  pUseDocDate ALIAS FOR $2;
  pConvBaseCurr ALIAS FOR $3;
  _row araging%ROWTYPE;
  _x RECORD;
  _returnVal INTEGER;
  _asOfDate DATE;
BEGIN

  _asOfDate := COALESCE(pAsOfDate,current_date);

  FOR _x IN
        SELECT
        aropen_docdate,
        aropen_duedate,
        aropen_ponumber,
        aropen_docnumber,
        aropen_doctype,
        cust_id,
        cust_name,
        cust_number,
        cust_custtype_id,
        custtype_code,
        terms_descrip,

        --if pConvBaseCurr is true then use currtobase to convert all amounts to base based on aropen_docdate to ensure the same exchange rate
        --otherwise use currtocurr to convert all amounts to customer's currency based on aropen_docdate to ensure the same exchange rate

        --today and greater:
        CASE WHEN((aropen_duedate >= DATE(_asOfDate))) THEN balance
             ELSE 0.0 END AS cur_val,

        --0 to 30
        CASE WHEN((aropen_duedate >= DATE(_asOfDate)-30) AND (aropen_duedate < DATE(_asOfDate))) THEN balance
             ELSE 0.0 END AS thirty_val,

        --30-60
        CASE WHEN((aropen_duedate >= DATE(_asOfDate)-60) AND (aropen_duedate < DATE(_asOfDate) - 30 )) THEN balance
             ELSE 0.0 END AS sixty_val,

        --60-90
        CASE WHEN((aropen_duedate >= DATE(_asOfDate)-90) AND (aropen_duedate < DATE(_asOfDate) - 60)) THEN balance
             ELSE 0.0 END AS ninety_val,

        --greater than 90:
        CASE WHEN((aropen_duedate > DATE(_asOfDate)-10000) AND (aropen_duedate < DATE(_asOfDate) - 90)) THEN balance
             ELSE 0.0 END AS plus_val,

        --total amount:
        CASE WHEN((aropen_duedate > DATE(_asOfDate)-10000)) THEN balance
             ELSE 0.0 END AS total_val,

        --AR Open Amount base
        aropen_amount

        FROM (
          SELECT
          (((aropen_amount - aropen_paid + COALESCE(SUM(arapply_target_paid),0))) /
             CASE WHEN (pConvBaseCurr) THEN aropen_curr_rate
                  ELSE currRate(aropen_curr_id, cust_curr_id, aropen_docdate)
             END *
             CASE WHEN (aropen_doctype IN ('C', 'R')) THEN -1.0
                  ELSE 1.0
             END) AS balance,
          ((aropen_amount) /
             CASE WHEN (pConvBaseCurr) THEN aropen_curr_rate
                  ELSE currRate(aropen_curr_id, cust_curr_id, aropen_docdate)
             END *
             CASE WHEN (aropen_doctype IN ('C', 'R')) THEN -1.0
                  ELSE 1.0
             END) AS aropen_amount,
          aropen_docdate,
          aropen_duedate,
          aropen_ponumber,
          aropen_docnumber,
          aropen_doctype,
          cust_id,
          cust_name,
          cust_number,
          cust_custtype_id,
          custtype_code,
          COALESCE(arterms.terms_descrip, custterms.terms_descrip, '') AS terms_descrip

          FROM aropen
            JOIN custinfo ON (cust_id=aropen_cust_id)
            JOIN custtype ON (custtype_id=cust_custtype_id)
            LEFT OUTER JOIN terms arterms ON (arterms.terms_id=aropen_terms_id)
            LEFT OUTER JOIN terms custterms ON (custterms.terms_id=cust_terms_id)
            LEFT OUTER JOIN arapply ON (((aropen_id=arapply_target_aropen_id)
                                      OR (aropen_id=arapply_source_aropen_id))
                                     AND (arapply_distdate>_asOfDate))
          WHERE ( (CASE WHEN (pUseDocDate) THEN aropen_docdate ELSE aropen_distdate END <= _asOfDate)
          AND (COALESCE(aropen_closedate,_asOfDate+1)>_asOfDate) )
          GROUP BY aropen_id,aropen_docdate,aropen_duedate,aropen_ponumber,aropen_docnumber,aropen_doctype,aropen_paid,
                   aropen_curr_id,aropen_amount,cust_id,cust_name,cust_number,cust_custtype_id,custtype_code,
                   arterms.terms_descrip,custterms.terms_descrip, aropen_curr_rate, aropen_curr_id, cust_curr_id
          ORDER BY cust_number, aropen_duedate ) AS data
  LOOP
        _row.araging_docdate := _x.aropen_docdate;
        _row.araging_duedate := _x.aropen_duedate;
        _row.araging_ponumber := _x.aropen_ponumber;
        _row.araging_docnumber := _x.aropen_docnumber;
        _row.araging_doctype := _x.aropen_doctype;
        _row.araging_cust_id := _x.cust_id;
        _row.araging_cust_number := _x.cust_number;
        _row.araging_cust_name := _x.cust_name;
        _row.araging_cust_custtype_id := _x.cust_custtype_id;
        _row.araging_custtype_code := _x.custtype_code;
        _row.araging_terms_descrip := _x.terms_descrip;
        _row.araging_aropen_amount := _x.aropen_amount;
        _row.araging_cur_val := _x.cur_val;
        _row.araging_thirty_val := _x.thirty_val;
        _row.araging_sixty_val := _x.sixty_val;
        _row.araging_ninety_val := _x.ninety_val;
        _row.araging_plus_val := _x.plus_val;
        _row.araging_total_val := _x.total_val;
        RETURN NEXT _row;
  END LOOP;
  RETURN;
END;
$_$;


ALTER FUNCTION public.araging(date, boolean, boolean) OWNER TO admin;

--
-- TOC entry 1131 (class 1255 OID 146565652)
-- Dependencies: 4536 8
-- Name: arapplied(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION arapplied(integer, date) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pAropenid ALIAS FOR $1;
  pDate ALIAS FOR $2;
  _amount NUMERIC;

BEGIN

  -- Return amount applied to an aropen in base currency item as of the parameter date
  SELECT SUM(currtobase(arapply_curr_id,arapply_applied,pDate)) INTO _amount
  FROM arapply
  WHERE (((arapply_target_aropen_id = pAropenid) OR (arapply_source_aropen_id = pAropenid))
  AND (((arapply_journalnumber=0) AND (arapply_postdate <= pDate))
  OR EXISTS(SELECT *
             FROM gltrans
             WHERE ((gltrans_journalnumber=arapply_journalnumber)
             AND (gltrans_date <= pDate)))));

  IF (_amount IS NULL) THEN
    RETURN 0;
  ELSE
    RETURN _amount;
  END IF;

END;
$_$;


ALTER FUNCTION public.arapplied(integer, date) OWNER TO admin;

--
-- TOC entry 1132 (class 1255 OID 146565653)
-- Dependencies: 4536 8
-- Name: archivesaleshistory(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION archivesaleshistory(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSohistid ALIAS FOR $1;

BEGIN

  INSERT INTO asohist ( asohist_id,
                        asohist_cust_id,
                        asohist_itemsite_id,
                        asohist_shipdate,
                        asohist_invcdate,
                        asohist_duedate,
                        asohist_promisedate,
                        asohist_ordernumber,
                        asohist_invcnumber,
                        asohist_qtyshipped,
                        asohist_unitprice,
                        asohist_unitcost,
                        asohist_billtoname,
                        asohist_billtoaddress1,
                        asohist_billtoaddress2,
                        asohist_billtoaddress3,
                        asohist_billtocity,
                        asohist_billtostate,
                        asohist_billtozip,
                        asohist_shiptoname,
                        asohist_shiptoaddress1,
                        asohist_shiptoaddress2,
                        asohist_shiptoaddress3,
                        asohist_shiptocity,
                        asohist_shiptostate,
                        asohist_shiptozip,
                        asohist_shipto_id,
                        asohist_shipvia,
                        asohist_salesrep_id,
                        asohist_misc_type,
                        asohist_misc_descrip,
                        asohist_misc_id,
                        asohist_commission,
                        asohist_commissionpaid,
                        asohist_doctype,
                        asohist_orderdate,
                        asohist_imported,
			asohist_ponumber,
                        asohist_curr_id,
                        asohist_taxtype_id,
                        asohist_taxzone_id )
  SELECT cohist_id,
         cohist_cust_id,
         cohist_itemsite_id,
         cohist_shipdate,
         cohist_invcdate,
         cohist_duedate,
         cohist_promisedate,
         cohist_ordernumber,
         cohist_invcnumber,
         cohist_qtyshipped,
         cohist_unitprice,
         cohist_unitcost,
         cohist_billtoname,
         cohist_billtoaddress1,
         cohist_billtoaddress2,
         cohist_billtoaddress3,
         cohist_billtocity,
         cohist_billtostate,
         cohist_billtozip,
         cohist_shiptoname,
         cohist_shiptoaddress1,
         cohist_shiptoaddress2,
         cohist_shiptoaddress3,
         cohist_shiptocity,
         cohist_shiptostate,
         cohist_shiptozip,
         cohist_shipto_id,
         cohist_shipvia,
         cohist_salesrep_id,
         cohist_misc_type,
         cohist_misc_descrip,
         cohist_misc_id,
         cohist_commission,
         cohist_commissionpaid,
         cohist_doctype,
         cohist_orderdate,
         cohist_imported,
         cohist_ponumber,
	 cohist_curr_id,
         cohist_taxtype_id,
         cohist_taxzone_id
  FROM cohist
  WHERE (cohist_id=pSohistid);

  INSERT INTO asohisttax ( taxhist_id,
                           taxhist_parent_id,
                           taxhist_taxtype_id,
                           taxhist_tax_id,
                           taxhist_basis,
                           taxhist_basis_tax_id,
                           taxhist_sequence,
                           taxhist_percent,
                           taxhist_amount,
                           taxhist_tax,
                           taxhist_docdate,
                           taxhist_distdate,
                           taxhist_curr_id,
                           taxhist_curr_rate,
                           taxhist_journalnumber )
  SELECT taxhist_id,
         taxhist_parent_id,
         taxhist_taxtype_id,
         taxhist_tax_id,
         taxhist_basis,
         taxhist_basis_tax_id,
         taxhist_sequence,
         taxhist_percent,
         taxhist_amount,
         taxhist_tax,
         taxhist_docdate,
         taxhist_distdate,
         taxhist_curr_id,
         taxhist_curr_rate,
         taxhist_journalnumber
  FROM cohisttax
  WHERE (taxhist_parent_id=pSohistid);

  DELETE FROM cohisttax
  WHERE (taxhist_parent_id=pSohistid);

  DELETE FROM cohist
  WHERE (cohist_id=pSohistid);

  RETURN pSohistid;

END;
$_$;


ALTER FUNCTION public.archivesaleshistory(integer) OWNER TO admin;

--
-- TOC entry 1133 (class 1255 OID 146565654)
-- Dependencies: 4536 8
-- Name: arcurrgain(integer, integer, numeric, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION arcurrgain(integer, integer, numeric, date) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pAropenId ALIAS FOR $1;
  pCurrId ALIAS FOR $2;
  pValue ALIAS FOR $3;
  pDate ALIAS FOR $4;
  _start DATE;
  _end DATE;
  _gain NUMERIC;
  _r RECORD;

BEGIN
  IF (pAropenId IS NULL OR pValue = 0) THEN
    RETURN 0;
  END IF;

  SELECT aropen_docdate, aropen_curr_id, aropen_curr_rate
    INTO _r
  FROM aropen
  WHERE (aropen_id=pAropenId);

  IF (_r.aropen_docdate > pDate) THEN
    _gain := (currToBase(pCurrId, pValue, pDate) - currToCurr(pCurrId,_r.aropen_curr_id, pValue, pDate) / _r.aropen_curr_rate) * -1;
  ELSE
    _gain := currToCurr(pCurrId,_r.aropen_curr_id, pValue, pDate) / _r.aropen_curr_rate - currToBase(pCurrId, pValue, pDate);
  END IF;

  IF (_gain IS NULL) THEN
    RAISE EXCEPTION 'Error processing currency gain/loss.';
  END IF;

  RETURN _gain;
END;
$_$;


ALTER FUNCTION public.arcurrgain(integer, integer, numeric, date) OWNER TO admin;

--
-- TOC entry 1134 (class 1255 OID 146565655)
-- Dependencies: 8
-- Name: armor(bytea); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION armor(bytea) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgcrypto', 'pg_armor';


ALTER FUNCTION public.armor(bytea) OWNER TO admin;

--
-- TOC entry 202 (class 1259 OID 146565656)
-- Dependencies: 5936 8
-- Name: invbal; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE invbal (
    invbal_id integer NOT NULL,
    invbal_period_id integer,
    invbal_itemsite_id integer,
    invbal_qoh_beginning numeric(18,6) NOT NULL,
    invbal_qoh_ending numeric(18,6) NOT NULL,
    invbal_qty_in numeric(18,6) NOT NULL,
    invbal_qty_out numeric(18,6) NOT NULL,
    invbal_value_beginning numeric(12,2) NOT NULL,
    invbal_value_ending numeric(12,2) NOT NULL,
    invbal_value_in numeric(12,2) NOT NULL,
    invbal_value_out numeric(12,2) NOT NULL,
    invbal_nn_beginning numeric(18,6) NOT NULL,
    invbal_nn_ending numeric(18,6) NOT NULL,
    invbal_nn_in numeric(18,6) NOT NULL,
    invbal_nn_out numeric(18,6) NOT NULL,
    invbal_nnval_beginning numeric(12,2) NOT NULL,
    invbal_nnval_ending numeric(12,2) NOT NULL,
    invbal_nnval_in numeric(12,2) NOT NULL,
    invbal_nnval_out numeric(12,2) NOT NULL,
    invbal_dirty boolean DEFAULT true NOT NULL
);


ALTER TABLE public.invbal OWNER TO admin;

--
-- TOC entry 1135 (class 1255 OID 146565660)
-- Dependencies: 2770 4536 8
-- Name: asofinvbal(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION asofinvbal(integer, date) RETURNS SETOF invbal
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteId ALIAS FOR $1;
  pAsofDate ALIAS FOR $2;
  _result invbal%ROWTYPE;
  _i RECORD;
  _h RECORD;
  _r RECORD;
  _prevCostmethod TEXT := 'A';
  _prevDate TIMESTAMP WITH TIME ZONE;
  _runningQty NUMERIC := 0;
  _runningNn NUMERIC := 0;
  _runningValue NUMERIC := 0;
  _runningNnval NUMERIC := 0;

BEGIN
  /* This is a base function to gather data.  Because it is STABLE it should only need
  to be calculated once, even though it is likely to be called several times by other
  functions in parent query to present the various data.
  */

  -- First make sure inventory balance is forward updated
  PERFORM forwardUpdateItemsite(pItemsiteId);

  -- Next find the previous period balace to use as a starting point
  SELECT invbal.*, period_start, itemsite_costmethod INTO _i
  FROM invbal
    JOIN itemsite ON (invbal_itemsite_id=itemsite_id)
    JOIN period ON (invbal_period_id=period_id)
  WHERE ((invbal_itemsite_id=pItemsiteId)
    AND  (pAsofDate >= period_start))
  ORDER BY period_start DESC
  LIMIT 1;

  _runningQty := _i.invbal_qoh_beginning;
  _runningNn := _i.invbal_nn_beginning;
  _runningValue := _i.invbal_value_beginning;
  _runningNnval := _i.invbal_nnval_beginning;
  _prevDate := _i.period_start;
  _prevCostmethod := _i.itemsite_costmethod;

  FOR _r IN
    SELECT invhist_id, invhist_created, invhist_invqty, invhist_transtype, invhist_unitcost,
      invhist_costmethod, itemsite_item_id, invhistSense(invhist_id) AS sense
    FROM invhist
      JOIN itemsite ON (itemsite_id=invhist_itemsite_id)
    WHERE ((invhist_itemsite_id=pItemsiteId)
    AND (invhist_transdate::date BETWEEN _i.period_start AND pAsofdate))
    ORDER BY invhist_created, invhist_id
  LOOP
    -- Update balances changed by any standard cost update between transactions
    IF (_prevCostmethod = 'S' AND _runningQty != 0) THEN
      FOR _h IN
        SELECT costhist_oldcost, costhist_newcost
        FROM costhist
          JOIN item ON (costhist_item_id=item_id)
          JOIN itemsite ON (itemsite_item_id=item_id)
        WHERE ((itemsite_id=pItemsiteId)
          AND (costhist_date BETWEEN _prevDate AND _r.invhist_created)
          AND (costhist_type IN ('S','D')))
      LOOP
        _runningValue := _runningValue + round((_h.costhist_newcost-_h.costhist_oldcost) * _runningQty,2);
        _runningNnval := _runningNnval + round((_h.costhist_newcost-_h.costhist_oldcost) * _runningNn,2);
      END LOOP;
    END IF;

    _prevDate := _r.invhist_created;
    _prevCostmethod := _r.invhist_costmethod;
    _runningQty := _runningQty + _r.invhist_invqty * _r.sense;
    _runningValue := _runningValue + round( _r.invhist_invqty * _r.sense * _r.invhist_unitcost,2);
    IF (_r.invhist_transtype = 'NN') THEN
      _runningNn := _runningNn + _r.invhist_invqty * -1;
      _runningNnval := _runningNnval + round( _r.invhist_invqty * -1 * _r.invhist_unitcost,2);
    END IF;

  END LOOP;

  _prevDate := COALESCE(_prevDate, _i.period_start);
  _prevCostmethod := COALESCE(_r.invhist_costmethod, _i.itemsite_costmethod);

  IF (_prevCostmethod = 'S' AND _runningQty != 0) THEN
    FOR _h IN
      SELECT costhist_oldcost, costhist_newcost
      FROM costhist
        JOIN item ON (costhist_item_id=item_id)
        JOIN itemsite ON (itemsite_item_id=item_id)
      WHERE ((itemsite_id=pItemsiteId)
        AND (costhist_date BETWEEN _prevDate AND CAST(pAsofDate + 1 AS TIMESTAMP WITH TIME ZONE))
        AND (costhist_type IN ('S','D')))
    LOOP
      _runningValue := _runningValue + round((_h.costhist_newcost-_h.costhist_oldcost) * _runningQty,2);
      _runningNnval := _runningNnval + round((_h.costhist_newcost-_h.costhist_oldcost) * _runningNn,2);
    END LOOP;
  END IF;

  _result := _i;
  _result.invbal_qoh_ending := _runningQty;
  _result.invbal_value_ending := _runningValue;
  _result.invbal_nn_ending := _runningNn;
  _result.invbal_nnval_ending := _runningNnval;

  RETURN NEXT _result;

  RETURN;

END;
$_$;


ALTER FUNCTION public.asofinvbal(integer, date) OWNER TO admin;

--
-- TOC entry 1136 (class 1255 OID 146565661)
-- Dependencies: 4536 8
-- Name: asofinvnn(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION asofinvnn(integer, date) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteId ALIAS FOR $1;
  pAsofDate ALIAS FOR $2;
  _result NUMERIC;

BEGIN

  SELECT invbal_nn_ending INTO _result
  FROM asofinvbal(pItemsiteId, pAsofDate);

  RETURN COALESCE(_result, 0);

END;
$_$;


ALTER FUNCTION public.asofinvnn(integer, date) OWNER TO admin;

--
-- TOC entry 1137 (class 1255 OID 146565662)
-- Dependencies: 4536 8
-- Name: asofinvqty(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION asofinvqty(integer, date) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteId ALIAS FOR $1;
  pAsofDate ALIAS FOR $2;
  _result NUMERIC;

BEGIN

  SELECT invbal_qoh_ending INTO _result
  FROM asofinvbal(pItemsiteId, pAsofDate);

  RETURN COALESCE(_result, 0);

END;
$_$;


ALTER FUNCTION public.asofinvqty(integer, date) OWNER TO admin;

--
-- TOC entry 1138 (class 1255 OID 146565663)
-- Dependencies: 4536 8
-- Name: assessfinancecharge(integer, date, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION assessfinancecharge(paropenid integer, passessdate date, passessamount numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _fc           RECORD;
  _ar           RECORD;
  _invcheadid   INTEGER;

BEGIN

  -- cache some information
  SELECT * INTO _fc FROM fincharg;
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'assessFinanceCharge, configuration not set.';
  END IF;

  SELECT * INTO _ar FROM aropen WHERE (aropen_id=pAropenid);
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'assessFinanceCharge, aropen not found.';
  END IF;

  -- create invoice head
  INSERT INTO invchead
    ( invchead_cust_id,
      invchead_shipto_id,
      invchead_ordernumber,
      invchead_orderdate,
      invchead_posted,
      invchead_printed,
      invchead_invcnumber,
      invchead_invcdate,
      invchead_shipdate,
      invchead_ponumber,
      invchead_shipvia,
      invchead_fob,
      invchead_billto_name,
      invchead_billto_address1,
      invchead_billto_address2,
      invchead_billto_address3,
      invchead_billto_city,
      invchead_billto_state,
      invchead_billto_zipcode,
      invchead_billto_phone,
      invchead_shipto_name,
      invchead_shipto_address1,
      invchead_shipto_address2,
      invchead_shipto_address3,
      invchead_shipto_city,
      invchead_shipto_state,
      invchead_shipto_zipcode,
      invchead_shipto_phone,
      invchead_salesrep_id,
      invchead_commission,
      invchead_terms_id,
      invchead_freight,
      invchead_misc_amount,
      invchead_misc_descrip,
      invchead_misc_accnt_id,
      invchead_payment,
      invchead_paymentref,
      invchead_notes,
      invchead_billto_country,
      invchead_shipto_country,
      invchead_prj_id,
      invchead_curr_id,
      invchead_gldistdate,
      invchead_recurring,
      invchead_recurring_interval,
      invchead_recurring_type,
      invchead_recurring_until,
      invchead_recurring_invchead_id,
      invchead_shipchrg_id,
      invchead_taxzone_id,
      invchead_void,
      invchead_saletype_id,
      invchead_shipzone_id )
  SELECT
      invchead_cust_id,
      invchead_shipto_id,
      invchead_ordernumber,
      invchead_orderdate,
      FALSE,
      FALSE,
      fetchInvcNumber(),
      pAssessDate,
      invchead_shipdate,
      invchead_ponumber,
      invchead_shipvia,
      invchead_fob,
      invchead_billto_name,
      invchead_billto_address1,
      invchead_billto_address2,
      invchead_billto_address3,
      invchead_billto_city,
      invchead_billto_state,
      invchead_billto_zipcode,
      invchead_billto_phone,
      invchead_shipto_name,
      invchead_shipto_address1,
      invchead_shipto_address2,
      invchead_shipto_address3,
      invchead_shipto_city,
      invchead_shipto_state,
      invchead_shipto_zipcode,
      invchead_shipto_phone,
      invchead_salesrep_id,
      0.0,
      invchead_terms_id,
      0.0,
      0.0,
      NULL,
      NULL,
      0.0,
      NULL,
      '',
      invchead_billto_country,
      invchead_shipto_country,
      invchead_prj_id,
      invchead_curr_id,
      NULL,
      FALSE,
      NULL,
      NULL,
      NULL,
      NULL,
      invchead_shipchrg_id,
      invchead_taxzone_id,
      invchead_void,
      invchead_saletype_id,
      invchead_shipzone_id
  FROM invchead
  WHERE (invchead_invcnumber=_ar.aropen_docnumber)
  RETURNING invchead_id INTO _invcheadid;

  -- create invoice item
  INSERT INTO invcitem
    ( invcitem_invchead_id,
      invcitem_linenumber,
      invcitem_item_id,
      invcitem_warehous_id,
      invcitem_custpn,
      invcitem_number,
      invcitem_descrip,
      invcitem_ordered,
      invcitem_billed,
      invcitem_custprice,
      invcitem_price,
      invcitem_notes,
      invcitem_salescat_id,
      invcitem_taxtype_id,
      invcitem_qty_uom_id,
      invcitem_qty_invuomratio,
      invcitem_price_uom_id,
      invcitem_price_invuomratio,
      invcitem_coitem_id,
      invcitem_updateinv,
      invcitem_rev_accnt_id )
  VALUES
    ( _invcheadid,
      1,
      -1,
      -1,
      NULL,
      _fc.fincharg_markoninvoice,
      'Finance Charge Assessment',
      1.0,
      1.0,
      pAssessAmount,
      pAssessAmount,
      '',
      _fc.fincharg_salescat_id,
      NULL,
      NULL,
      1.0,
      NULL,
      1.0,
      NULL,
      FALSE,
      _fc.fincharg_accnt_id );

  -- update aropen
  UPDATE aropen SET aropen_fincharg_date = pAssessDate,
                    aropen_fincharg_amount = COALESCE(aropen_fincharg_amount, 0.0) + pAssessAmount
  WHERE (aropen_id=pAropenid);


  RETURN 0;

END;
$$;


ALTER FUNCTION public.assessfinancecharge(paropenid integer, passessdate date, passessamount numeric) OWNER TO admin;

--
-- TOC entry 1139 (class 1255 OID 146565664)
-- Dependencies: 4536 8
-- Name: attachcontact(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION attachcontact(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pcntctId    ALIAS FOR $1;
  pcrmacctId  ALIAS FOR $2;
BEGIN
  UPDATE cntct SET cntct_crmacct_id = pcrmacctId
  WHERE cntct_id = pcntctId;

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.attachcontact(integer, integer) OWNER TO admin;

--
-- TOC entry 1140 (class 1255 OID 146565665)
-- Dependencies: 4536 8
-- Name: attachquotetoopportunity(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION attachquotetoopportunity(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pQuheadid	ALIAS FOR $1;
  pOpheadid	ALIAS FOR $2;
BEGIN

-- Check Quote
  IF (NOT EXISTS(SELECT quhead_id
                 FROM quhead
                 WHERE (quhead_id=pQuheadid))) THEN
    RETURN -1;
  END IF;

-- Check Opportunity
  IF (NOT EXISTS(SELECT ophead_id
                 FROM ophead
                 WHERE (ophead_id=pOpheadid))) THEN
    RETURN -2;
  END IF;

-- Cannot attach if already attached
  IF (EXISTS(SELECT quhead_id
	     FROM quhead
	     WHERE ((quhead_id=pQuheadid)
	       AND  (quhead_ophead_id IS NOT NULL)))) THEN
    RETURN -3;
  END IF;

  UPDATE quhead SET quhead_ophead_id=pOpheadid
  WHERE (quhead_id=pQuheadid);

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.attachquotetoopportunity(integer, integer) OWNER TO admin;

--
-- TOC entry 1141 (class 1255 OID 146565666)
-- Dependencies: 4536 8
-- Name: attachsalesordertoopportunity(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION attachsalesordertoopportunity(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSoheadid	ALIAS FOR $1;
  pOpheadid	ALIAS FOR $2;
BEGIN

-- Check Sales Order
  IF (NOT EXISTS(SELECT cohead_id
                 FROM cohead
                 WHERE (cohead_id=pSoheadid))) THEN
    RETURN -1;
  END IF;

-- Check Opportunity
  IF (NOT EXISTS(SELECT ophead_id
                 FROM ophead
                 WHERE (ophead_id=pOpheadid))) THEN
    RETURN -2;
  END IF;

-- Cannot attach if already attached
  IF (EXISTS(SELECT cohead_id
	     FROM cohead
	     WHERE ((cohead_id=pSoheadid)
	       AND  (cohead_ophead_id IS NOT NULL)))) THEN
    RETURN -3;
  END IF;

  UPDATE cohead SET cohead_ophead_id=pOpheadid
  WHERE (cohead_id=pSoheadid);

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.attachsalesordertoopportunity(integer, integer) OWNER TO admin;

--
-- TOC entry 1142 (class 1255 OID 146565667)
-- Dependencies: 4536 8
-- Name: averagesalesprice(integer, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION averagesalesprice(integer, date, date) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pStartDate ALIAS FOR $2;
  pEndDate ALIAS FOR $3;
  _p RECORD;

BEGIN
-- Returns value in base currency
-- ToDo: is cohist_shipdate the right DATE to use?
  SELECT SUM(cohist_qtyshipped * currToBase(cohist_curr_id, cohist_unitprice,
                                            cohist_shipdate)) AS totalsales,
         SUM(cohist_qtyshipped) AS totalship INTO _p
  FROM cohist
  WHERE ( (cohist_itemsite_id=pItemsiteid)
   AND (cohist_invcdate BETWEEN pStartDate AND pEndDate) );

  IF ( (_p.totalship IS NULL) OR
       (_p.totalship = 0) ) THEN
    RETURN 0;
  ELSE
    RETURN (_p.totalsales / _p.totalship);
  END IF;

END;
$_$;


ALTER FUNCTION public.averagesalesprice(integer, date, date) OWNER TO admin;

--
-- TOC entry 1143 (class 1255 OID 146565668)
-- Dependencies: 4536 8
-- Name: avgcost(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION avgcost(pitemsiteid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _value NUMERIC;
  _qoh NUMERIC;
  _qohnn NUMERIC;
BEGIN
  SELECT itemsite_value, itemsite_qtyonhand, itemsite_nnqoh
    INTO _value, _qoh, _qohnn
    FROM itemsite
   WHERE(itemsite_id=pItemsiteid);
  IF (_qoh = 0.0 AND _qohnn = 0.0) THEN
    RETURN 0.0;
  END IF;
  RETURN _value / (_qoh + _qohnn);
END;
$$;


ALTER FUNCTION public.avgcost(pitemsiteid integer) OWNER TO admin;

--
-- TOC entry 1144 (class 1255 OID 146565669)
-- Dependencies: 4536 8
-- Name: balanceitemsite(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION balanceitemsite(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  _itemlocseries INTEGER;
  _balanced NUMERIC;
  _qoh NUMERIC;
  _nnQoh NUMERIC;

BEGIN

--  Make sure that that passed Itemsite is MLC or Lot/Serial controlled
  IF ( ( SELECT (NOT ( (itemsite_loccntrl) OR (itemsite_controlmethod IN ('L', 'S')) ))
         FROM itemsite
         WHERE (itemsite_id=pItemsiteid) ) ) THEN
    RETURN 0;
  END IF;

  IF ( ( SELECT itemsite_freeze
           FROM itemsite
          WHERE(itemsite_id=pItemsiteid) ) ) THEN
    RETURN -1;
  END IF;

--  Calculate the Netable portion
  SELECT COALESCE(SUM(itemloc_qty), 0) INTO _balanced
  FROM itemloc LEFT OUTER JOIN location ON (itemloc_location_id=location_id)
  WHERE ( ( (location_id IS NULL) OR (location_netable) )
   AND (itemloc_itemsite_id=pItemsiteid) );

--  Post an AD Transaction for the Netable portion
  SELECT invAdjustment( itemsite_id, (_balanced - itemsite_qtyonhand),
                        'Balance', 'Inventory Balance' ) INTO _itemlocseries
  FROM itemsite
  WHERE (itemsite_id=pItemsiteid);

--  Post the invtrans records associated with the itemlocdist records
  PERFORM postInvhist(itemlocdist_invhist_id)
     FROM itemlocdist
    WHERE(itemlocdist_series=_itemlocseries);

--  Kill the resultant distribution records
  DELETE FROM itemlocdist
  WHERE (itemlocdist_series=_itemlocseries);

--  Calculate and write the Non-Netable portion directly
  SELECT COALESCE(SUM(itemloc_qty), 0) INTO _nnQoh
  FROM itemloc, location
  WHERE ( (itemloc_location_id=location_id)
   AND (NOT location_netable)
   AND (itemloc_itemsite_id=pItemsiteid) );

  UPDATE itemsite
  SET itemsite_nnqoh = _nnQoh
  WHERE (itemsite_id=pItemsiteid);

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.balanceitemsite(integer) OWNER TO admin;

--
-- TOC entry 1114 (class 1255 OID 146565670)
-- Dependencies: 4536 8
-- Name: bomcontains(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION bomcontains(integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pparentitemid	ALIAS FOR $1;
  pchilditemid	ALIAS FOR $2;
  _bomworksetid	INTEGER;
  _result	BOOLEAN;

BEGIN
  _bomworksetid := indentedWhereUsed(pchilditemid);
  _result := EXISTS(SELECT bomwork_id
		    FROM bomwork
		    WHERE ((bomwork_set_id=_bomworksetid)
		      AND  (bomwork_item_id=pparentitemid) ));

  PERFORM deleteBOMWorkset(_bomworksetid);

  RETURN _result;
END;
$_$;


ALTER FUNCTION public.bomcontains(integer, integer) OWNER TO admin;

--
-- TOC entry 1146 (class 1255 OID 146565671)
-- Dependencies: 4536 8
-- Name: bomhistsequence(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION bomhistsequence(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pHistid ALIAS FOR $1;
  _wid INTEGER;
  _seqnum TEXT;
  _bomhist RECORD;

BEGIN
  _wid := pHistid;

  SELECT bomhist_parent_id AS parent,
         to_char(bomhist_seqnumber, '00009') AS seq INTO _bomhist
    FROM bomhist
   WHERE bomhist_seq_id=_wid;

  IF (FOUND) THEN
    _seqnum := _bomhist.seq;
    _wid := _bomhist.parent;

    WHILE (_wid != -1) LOOP
      SELECT bomhist_parent_id AS parent,
             to_char(bomhist_seqnumber, '00009') AS seq INTO _bomhist
      FROM bomhist
      WHERE bomhist_seq_id=_wid;

      IF (FOUND) THEN
        _seqnum := _bomhist.seq || '-' || _seqnum;
        _wid    := _bomhist.parent;
      ELSE
        _wid := -1;
      END IF;
    END LOOP;
  ELSE
    _seqnum := ''::TEXT;
  END IF;

  RETURN _seqnum;
END;
$_$;


ALTER FUNCTION public.bomhistsequence(integer) OWNER TO admin;

--
-- TOC entry 203 (class 1259 OID 146565672)
-- Dependencies: 5937 5938 5939 5940 5941 5942 5943 8
-- Name: bomitem; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE bomitem (
    bomitem_id integer DEFAULT nextval(('bomitem_bomitem_id_seq'::text)::regclass) NOT NULL,
    bomitem_parent_item_id integer NOT NULL,
    bomitem_seqnumber integer,
    bomitem_item_id integer NOT NULL,
    bomitem_qtyper numeric(20,8) NOT NULL,
    bomitem_scrap numeric(8,4) NOT NULL,
    bomitem_status character(1),
    bomitem_effective date NOT NULL,
    bomitem_expires date NOT NULL,
    bomitem_createwo boolean NOT NULL,
    bomitem_issuemethod character(1) NOT NULL,
    bomitem_schedatwooper boolean NOT NULL,
    bomitem_ecn text,
    bomitem_moddate date,
    bomitem_subtype character(1) NOT NULL,
    bomitem_uom_id integer NOT NULL,
    bomitem_rev_id integer DEFAULT (-1),
    bomitem_booitem_seq_id integer DEFAULT (-1),
    bomitem_char_id integer,
    bomitem_value text,
    bomitem_notes text,
    bomitem_ref text,
    bomitem_qtyfxd numeric(20,8) DEFAULT 0 NOT NULL,
    bomitem_issuewo boolean DEFAULT false NOT NULL,
    CONSTRAINT bomitem_bomitem_issuemethod_check CHECK ((((bomitem_issuemethod = 'M'::bpchar) OR (bomitem_issuemethod = 'S'::bpchar)) OR (bomitem_issuemethod = 'L'::bpchar))),
    CONSTRAINT bomitem_bomitem_subtype_check CHECK ((((bomitem_subtype = 'N'::bpchar) OR (bomitem_subtype = 'I'::bpchar)) OR (bomitem_subtype = 'B'::bpchar)))
);


ALTER TABLE public.bomitem OWNER TO admin;


--
-- TOC entry 1147 (class 1255 OID 146565685)
-- Dependencies: 2773 8
-- Name: bomitem(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION bomitem(integer) RETURNS SETOF bomitem
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT * FROM bomitem WHERE ((bomitem_parent_item_id=$1) AND (bomitem_rev_id=getActiveRevId('BOM',$1)));
$_$;


ALTER FUNCTION public.bomitem(integer) OWNER TO admin;

--
-- TOC entry 1148 (class 1255 OID 146565686)
-- Dependencies: 2773 8
-- Name: bomitem(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION bomitem(integer, integer) RETURNS SETOF bomitem
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT * FROM bomitem WHERE ((bomitem_parent_item_id=$1) AND (bomitem_rev_id=$2));
$_$;


ALTER FUNCTION public.bomitem(integer, integer) OWNER TO admin;

--
-- TOC entry 1149 (class 1255 OID 146565687)
-- Dependencies: 4536 8
-- Name: bomlevelbyitem(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION bomlevelbyitem(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  _cnt INTEGER;
  _result INTEGER;
  _bomitem RECORD;

BEGIN
  _cnt := 0;

  BEGIN
  FOR _bomitem IN SELECT bomitem_parent_item_id
                    FROM bomitem
                   WHERE ((bomitem_item_id=pItemid)
                     AND  (bomitem_rev_id=getActiveRevId('BOM',bomitem_parent_item_id))
                     AND  (CURRENT_DATE BETWEEN bomitem_effective AND (bomitem_expires - 1)))
  LOOP
    SELECT bomLevelByItem(_bomitem.bomitem_parent_item_id) + 1 INTO _result;
    IF (_result > _cnt) THEN
      _cnt := _result;
    END IF;
  END LOOP;
  EXCEPTION WHEN statement_too_complex THEN
      RAISE EXCEPTION 'potential recursive BOM found for item_id %', pItemid;
  END;

  return _cnt;
END;
$_$;


ALTER FUNCTION public.bomlevelbyitem(integer) OWNER TO admin;

--
-- TOC entry 1150 (class 1255 OID 146565688)
-- Dependencies: 4536 8
-- Name: bomlevelbyitem(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION bomlevelbyitem(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pBomrevid ALIAS FOR $2;
  _cnt INTEGER;
  _result INTEGER;
  _bomitem RECORD;

BEGIN
  _cnt := 0;

  BEGIN
  FOR _bomitem IN SELECT bomitem_parent_item_id
                    FROM bomitem
                   WHERE ((bomitem_item_id=pItemid)
                     AND  (bomitem_rev_id=pBomrevid)
                     AND  (CURRENT_DATE BETWEEN bomitem_effective AND (bomitem_expires - 1)))
  LOOP
    SELECT bomLevelByItem(_bomitem.bomitem_parent_item_id, pBomrevid) + 1 INTO _result;
    IF (_result > _cnt) THEN
      _cnt := _result;
    END IF;
  END LOOP;
  EXCEPTION WHEN statement_too_complex THEN
      RAISE EXCEPTION 'potential recursive BOM found for item_id %', pItemid;
  END;

  return _cnt;
END;
$_$;


ALTER FUNCTION public.bomlevelbyitem(integer, integer) OWNER TO admin;

--
-- TOC entry 1151 (class 1255 OID 146565689)
-- Dependencies: 4536 8
-- Name: bomworkeffective(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION bomworkeffective(integer, date) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
    workid ALIAS FOR $1;
    effdate ALIAS FOR $2;
    _wid INTEGER;
    _bomwork RECORD;
BEGIN
    _wid := workid;
    WHILE (_wid != -1) LOOP
        SELECT bomwork_parent_id AS parent,
               bomwork_effective AS effective
          INTO _bomwork
          FROM bomwork
         WHERE bomwork_id=_wid;

         IF (FOUND) THEN
             _wid := _bomwork.parent;
             IF (_bomwork.effective > effdate) THEN
                 RETURN FALSE;
             END IF;
         ELSE
             _wid := -1;
         END IF;
    END LOOP;
    RETURN TRUE;
END;
$_$;


ALTER FUNCTION public.bomworkeffective(integer, date) OWNER TO admin;

--
-- TOC entry 1152 (class 1255 OID 146565690)
-- Dependencies: 4536 8
-- Name: bomworkexpired(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION bomworkexpired(integer, date) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
    workid ALIAS FOR $1;
    expdate ALIAS FOR $2;
    _wid INTEGER;
    _bomwork RECORD;
BEGIN
    _wid := workid;
    WHILE (_wid != -1) LOOP
        SELECT bomwork_parent_id AS parent,
               bomwork_expires AS expires
          INTO _bomwork
          FROM bomwork
         WHERE bomwork_id=_wid;

         IF (FOUND) THEN
             _wid := _bomwork.parent;
             IF (_bomwork.expires <= expdate) THEN
                 RETURN TRUE;
             END IF;
         ELSE
             _wid := -1;
         END IF;
    END LOOP;
    RETURN FALSE;
END;
$_$;


ALTER FUNCTION public.bomworkexpired(integer, date) OWNER TO admin;

--
-- TOC entry 1153 (class 1255 OID 146565691)
-- Dependencies: 4536 8
-- Name: bomworkitemsequence(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION bomworkitemsequence(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWorkid ALIAS FOR $1;
  _wid INTEGER;
  _seqnum TEXT;
  _bomwork RECORD;

BEGIN
  _wid := pWorkid;

  SELECT bomwork_parent_id AS parent,
         item_number AS seq INTO _bomwork
    FROM bomwork, item
   WHERE ((bomwork_id=_wid)
   AND (bomwork_item_id=item_id));

  IF (FOUND) THEN
    _seqnum := _bomwork.seq;
    _wid := _bomwork.parent;

    WHILE (_wid != -1) LOOP
      SELECT bomwork_parent_id AS parent,
             item_number AS seq INTO _bomwork
      FROM bomwork, item
      WHERE ((bomwork_id=_wid)
      AND (bomwork_item_id=item_id));

      IF (FOUND) THEN
        _seqnum := _bomwork.seq || '-' || _seqnum;
        _wid    := _bomwork.parent;
      ELSE
        _wid := -1;
      END IF;
    END LOOP;
  ELSE
    _seqnum := ''::TEXT;
  END IF;

  RETURN _seqnum;
END;
$_$;


ALTER FUNCTION public.bomworkitemsequence(integer) OWNER TO admin;

--
-- TOC entry 1154 (class 1255 OID 146565692)
-- Dependencies: 4536 8
-- Name: bomworksequence(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION bomworksequence(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWorkid ALIAS FOR $1;
  _wid INTEGER;
  _seqnum TEXT;
  _bomwork RECORD;

BEGIN
  _wid := pWorkid;

  SELECT bomwork_parent_id AS parent,
         to_char(bomwork_seqnumber, '00009') AS seq INTO _bomwork
    FROM bomwork
   WHERE bomwork_id=_wid;

  IF (FOUND) THEN
    _seqnum := _bomwork.seq;
    _wid := _bomwork.parent;

    WHILE (_wid != -1) LOOP
      SELECT bomwork_parent_id AS parent,
             to_char(bomwork_seqnumber, '00009') AS seq INTO _bomwork
      FROM bomwork
      WHERE bomwork_id=_wid;

      IF (FOUND) THEN
        _seqnum := _bomwork.seq || '-' || _seqnum;
        _wid    := _bomwork.parent;
      ELSE
        _wid := -1;
      END IF;
    END LOOP;
  ELSE
    _seqnum := ''::TEXT;
  END IF;

  RETURN _seqnum;
END;
$_$;


ALTER FUNCTION public.bomworksequence(integer) OWNER TO admin;

--
-- TOC entry 1155 (class 1255 OID 146565693)
-- Dependencies: 4536 8
-- Name: buildinvbal(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION buildinvbal(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteId ALIAS FOR $1;
  _r RECORD;
  _prevCostmethod TEXT := 'A';
  _prevDate TIMESTAMP WITH TIME ZONE;
  _runningQty NUMERIC := 0;
  _runningNn NUMERIC := 0;

BEGIN
  -- Validate
  IF (SELECT (count(invhist_id) > 0)
      FROM invhist
      WHERE ((invhist_itemsite_id=pItemsiteId)
      AND (NOT invhist_posted))) THEN

    SELECT item_number, warehous_code INTO _r
    FROM itemsite
      JOIN item ON (item_id=itemsite_item_id)
      JOIN whsinfo ON (itemsite_warehous_id=warehous_id)
    WHERE (itemsite_id=pItemsiteId);

    RAISE EXCEPTION 'Unposted inventory transactions exist for % at % [xtuple: buildInvBal, -1, %, %]',
                    _r.item_number, _r.warehous_code,
                    _r.item_number, _r.warehous_code;
  END IF;

  -- Remove any old records
  DELETE FROM invbal WHERE invbal_itemsite_id=pItemsiteId;

  FOR _r IN
    SELECT invhist.*,
      itemsite_item_id, invhistSense(invhist_id) AS sense,
      item_number, warehous_code
    FROM invhist
      JOIN itemsite ON (itemsite_id=invhist_itemsite_id)
      JOIN item ON (itemsite_item_id=item_id)
      JOIN whsinfo ON (itemsite_warehous_id=warehous_id)
    WHERE (invhist_itemsite_id=pItemsiteId)
    ORDER BY invhist_created, invhist_id
  LOOP
    RAISE NOTICE 'Calculating balances for Item % at Site % against transaction %, transtype %, sense %, qty %, %', _r.item_number, _r.warehous_code, _r.invhist_id, _r.invhist_transtype, _r.sense, _r.invhist_invqty, _r.invhist_comments;
    -- Update balances changed by any standard cost update between transactions
    IF (_prevCostmethod = 'S' AND _runningQty != 0) THEN
      PERFORM postValueintoInvBalance(pItemsiteid, costhist_date::date, _runningQty, _runningNn, costhist_oldcost, costhist_newcost )
      FROM costhist
      WHERE ((costhist_item_id=_r.itemsite_item_id)
        AND (costhist_date BETWEEN _prevDate AND _r.invhist_created)
        AND (costhist_type IN ('S','D')));
    END IF;

    -- Post transaction into inventory balance table
    PERFORM postIntoInvBalance(_r.invhist_id);

    _prevDate := _r.invhist_created;
    _prevCostmethod := _r.invhist_costmethod;
    _runningQty := _runningQty + _r.invhist_invqty * _r.sense;
    IF (_r.invhist_transtype = 'NN') THEN
      _runningNn := _runningNn + _r.invhist_invqty * -1;
    END IF;

  END LOOP;

  -- Update balances changed by any standard cost since last transaction
  IF (_prevCostmethod = 'S' AND _runningQty != 0) THEN
    PERFORM postValueintoInvBalance(pItemsiteid, costhist_date::date, _runningQty, _runningNn, costhist_oldcost, costhist_newcost )
    FROM costhist
    WHERE ((costhist_item_id=_r.itemsite_item_id)
      AND (costhist_date > _prevDate)
      AND (costhist_type IN ('S','D')));
  END IF;

  -- Forward update changes through all the balances
  PERFORM forwardupdateitemsite(pItemsiteId);

  RETURN 1;
END;
$_$;


ALTER FUNCTION public.buildinvbal(integer) OWNER TO admin;

--
-- TOC entry 1156 (class 1255 OID 146565694)
-- Dependencies: 4536 8
-- Name: buildsearchpath(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION buildsearchpath() RETURNS text
    LANGUAGE plpgsql
    AS $_$
DECLARE
  _path   TEXT    := '';
  _schema TEXT;
  _seq    INTEGER;
BEGIN
  -- get the schemas as ordered by the administrator
  SELECT concatagg(quote_ident(schemaord_name) || ',') INTO _path
    FROM (SELECT schemaord_name
            FROM schemaord
            LEFT OUTER JOIN pkghead ON (schemaord_name=pkghead_name)
           WHERE (pkghead_id IS NULL
               OR (pkghead_id IS NOT NULL AND packageisenabled(pkghead_id)))
           ORDER BY schemaord_order
         ) AS xtspq;

  -- add others that we think/know we need
  -- TODO: is there a reason not to include public, api, or packages?
  FOR _schema, _seq IN
      SELECT pkghead_name AS schema, 0 AS seq
        FROM pkghead
       WHERE packageisenabled(pkghead_id)
      UNION ALL
      SELECT 'public', 1
      UNION ALL
      SELECT 'api', 2
      ORDER BY seq, schema
  LOOP
    IF (_path !~* (E'(^|\\W)' || _schema || E'(\\W|$)')) THEN
      _path := _path || ',' || quote_ident(_schema);
    END IF;
  END LOOP;

  -- remove extraneous spaces and commas
  _path = BTRIM(REGEXP_REPLACE(_path, '( ?, ?)+', ',', 'g'),
                ', ');

  RAISE DEBUG 'buildSearchPath() returning %', _path;

  RETURN _path;
END;
$_$;


ALTER FUNCTION public.buildsearchpath() OWNER TO admin;

--
-- TOC entry 8947 (class 0 OID 0)
-- Dependencies: 1156
-- Name: FUNCTION buildsearchpath(); Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON FUNCTION buildsearchpath() IS 'buildSearchPath() examines the schemaord and pkghead tables to build a search
path string. It ensures that public, api, and all enabled packages are included
even if they are not listed in the schemaord table.
It returns the constructed search_path but does not set it.';


--
-- TOC entry 1157 (class 1255 OID 146565695)
-- Dependencies: 4536 8
-- Name: calccashbudget(integer, integer, character); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calccashbudget(integer, integer, character) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pAccntId ALIAS FOR $1;
  pPeriodId ALIAS FOR $2;
  pInterval ALIAS FOR $3;
  _accntType CHAR;
  _currentBudget NUMERIC;
  _priorBudget NUMERIC;
  _result NUMERIC;
BEGIN

        SELECT accnt_type INTO _accntType
        FROM accnt
        WHERE (accnt_id=pAccntId);

        SELECT COALESCE(SUM(budget_amount),0) INTO _currentBudget
        FROM budget
        WHERE ((budget_accnt_id=pAccntId)
        AND (budget_period_id=pPeriodId));

        IF (pInterval='M') THEN
        SELECT (COALESCE(SUM(budget_amount),0)) INTO _priorBudget
                FROM budget,
                (SELECT COALESCE(pp.period_id,-1) AS prior_period_id
                        FROM period cp, period pp
                        WHERE ((cp.period_id=pPeriodId)
                        AND (cp.period_start > pp.period_start))
                        ORDER BY pp.period_start DESC LIMIT 1) AS data
                WHERE ((budget_accnt_id=pAccntId)
                AND (budget_period_id=prior_period_id));

                ELSE IF (pInterval='Q') THEN
                        SELECT (COALESCE(SUM(budget_amount),0)) INTO _priorBudget
                        FROM budget,
                                (SELECT COALESCE(pp.period_id,-1) AS prior_period_id
                                FROM period cp, period pp
                                WHERE ((cp.period_id=pPeriodId)
                                AND (cp.period_start > pp.period_start)
                                AND (pp.period_quarter=
                                CASE WHEN cp.period_quarter > 1 THEN
                                        cp.period_quarter - 1
                                ELSE 4 END)
                                AND (pp.period_start >= cp.period_start - interval '1 year'))
                                ORDER BY pp.period_start DESC LIMIT 1) AS data
                        WHERE ((budget_accnt_id=pAccntId)
                        AND (budget_period_id=prior_period_id));


                ELSE
                        SELECT (COALESCE(SUM(budget_amount),0)) INTO _priorBudget
                        FROM budget,
                                (SELECT pp.period_id AS prior_period_id
                        FROM period cp, period pp, yearperiod cy, yearperiod py
                        WHERE ((cp.period_id=pPeriodId)
                        AND (cp.period_yearperiod_id=cy.yearperiod_id)
                        AND (pp.period_yearperiod_id=py.yearperiod_id)
                        AND (cy.yearperiod_start > py.yearperiod_start))
                        ORDER BY pp.period_start DESC LIMIT 1) AS data
                        WHERE ((budget_accnt_id=pAccntId)
                        AND (budget_period_id=prior_period_id));

                END IF;
        END IF;

        IF _accntType='A' THEN
                _result := ((_priorBudget-_currentBudget) * -1 );

        ELSE IF (_accntType IN ('L','Q')) THEN
                _result := ((_priorBudget-_currentBudget) *-1);

        ELSE RETURN -1;
        END IF;
  END IF;


  RETURN _result;


END;
$_$;


ALTER FUNCTION public.calccashbudget(integer, integer, character) OWNER TO admin;

--
-- TOC entry 1158 (class 1255 OID 146565696)
-- Dependencies: 4536 8
-- Name: calccmheadamt(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calccmheadamt(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCmheadid ALIAS FOR $1;
  _amount NUMERIC := 0;

BEGIN

  SELECT SUM(COALESCE(extprice, 0)) INTO _amount
  FROM cmhead JOIN creditmemoitem ON (cmhead_id=cmitem_cmhead_id)
  WHERE (cmhead_id=pCmheadid);

  RETURN _amount;

END;
$_$;


ALTER FUNCTION public.calccmheadamt(integer) OWNER TO admin;

--
-- TOC entry 1159 (class 1255 OID 146565697)
-- Dependencies: 4536 8
-- Name: calccmheadtax(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calccmheadtax(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCmheadid ALIAS FOR $1;
  _headamount NUMERIC := 0;
  _itemamount NUMERIC := 0;
  _amount NUMERIC := 0;

BEGIN

  SELECT COALESCE(SUM(taxhist_tax), 0) INTO _headamount
  FROM cmhead JOIN cmheadtax ON (taxhist_parent_id=cmhead_id)
  WHERE (cmhead_id=pCmheadid);

  SELECT SUM(COALESCE(tax, 0)) INTO _itemamount
  FROM cmhead JOIN creditmemoitem ON (cmhead_id=cmitem_cmhead_id)
  WHERE (cmhead_id=pCmheadid);

  _amount := _headamount + _itemamount;
  RETURN (_amount * -1.0);

END;
$_$;


ALTER FUNCTION public.calccmheadtax(integer) OWNER TO admin;

--
-- TOC entry 1160 (class 1255 OID 146565698)
-- Dependencies: 4536 8
-- Name: calccobillamt(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calccobillamt(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCobillid ALIAS FOR $1;
  _amount NUMERIC := 0;

BEGIN

  SELECT COALESCE(round((cobill_qty * coitem_qty_invuomratio) *
                        (coitem_price / coitem_price_invuomratio), 2), 0) INTO _amount
  FROM cobill JOIN coitem ON (coitem_id=cobill_coitem_id)
  WHERE (cobill_id=pCobillid);

  RETURN _amount;

END;
$_$;


ALTER FUNCTION public.calccobillamt(integer) OWNER TO admin;

--
-- TOC entry 1161 (class 1255 OID 146565699)
-- Dependencies: 4536 8
-- Name: calccobilltax(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calccobilltax(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCobillid ALIAS FOR $1;
  _amount NUMERIC := 0;

BEGIN

  SELECT COALESCE(calculateTax(cobmisc_taxzone_id,
                               cobill_taxtype_id,
                               cobmisc_shipdate,
                               cobmisc_curr_id,
                               calcCobillAmt(cobill_id)), 0) INTO _amount
  FROM cobill JOIN coitem ON (coitem_id=cobill_coitem_id)
              JOIN cobmisc ON (cobmisc_id=cobill_cobmisc_id)
  WHERE (cobill_id=pCobillid);

  RETURN _amount;

END;
$_$;


ALTER FUNCTION public.calccobilltax(integer) OWNER TO admin;

--
-- TOC entry 1162 (class 1255 OID 146565700)
-- Dependencies: 4536 8
-- Name: calccobmiscamt(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calccobmiscamt(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCobmiscid ALIAS FOR $1;
  _amount NUMERIC := 0;

BEGIN

  SELECT SUM(COALESCE(calcCobillAmt(cobill_id), 0)) INTO _amount
  FROM cobmisc JOIN cobill ON (cobmisc_id=cobill_cobmisc_id)
  WHERE (cobmisc_id=pCobmiscid);

  RETURN _amount;

END;
$_$;


ALTER FUNCTION public.calccobmiscamt(integer) OWNER TO admin;

--
-- TOC entry 1164 (class 1255 OID 146565701)
-- Dependencies: 4536 8
-- Name: calccobmisctax(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calccobmisctax(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCobmiscid ALIAS FOR $1;
  _amount NUMERIC := 0;

BEGIN

  SELECT SUM(
         COALESCE(calculateTax(cobmisc_taxzone_id,
                               cobill_taxtype_id,
                               cobmisc_shipdate,
                               cobmisc_curr_id,
                               COALESCE(round((cobill_qty * coitem_qty_invuomratio) * (coitem_price / coitem_price_invuomratio), 2), 0))
                 , 0)
            ) INTO _amount
  FROM cobmisc JOIN cobill ON (cobmisc_id=cobill_cobmisc_id)
               JOIN coitem ON (coitem_id=cobill_coitem_id)
  WHERE (cobmisc_id=pCobmiscid);

  RETURN _amount;

END;
$_$;


ALTER FUNCTION public.calccobmisctax(integer) OWNER TO admin;

--
-- TOC entry 1165 (class 1255 OID 146565702)
-- Dependencies: 4536 8
-- Name: calcinvoiceamt(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calcinvoiceamt(pinvcheadid integer) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  RETURN calcInvoiceAmt(pInvcheadid, 'T');

END;
$$;


ALTER FUNCTION public.calcinvoiceamt(pinvcheadid integer) OWNER TO admin;

--
-- TOC entry 1166 (class 1255 OID 146565703)
-- Dependencies: 4536 8
-- Name: calcinvoiceamt(integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calcinvoiceamt(pinvcheadid integer, ptype text) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2012 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _subtotal NUMERIC := 0.0;
  _cost NUMERIC := 0.0;
  _tax NUMERIC := 0.0;
  _freight NUMERIC := 0.0;
  _misc NUMERIC := 0.0;
  _amount NUMERIC := 0.0;

BEGIN

  -- pType: S = line item subtotal
  --        T = total
  --        X = tax
  --        M = margin

  SELECT COALESCE(SUM(ROUND((invcitem_billed * invcitem_qty_invuomratio) *
                            (invcitem_price / COALESCE(invcitem_price_invuomratio, 1.0)), 2)), 0.0),
         COALESCE(SUM(ROUND((invcitem_billed * invcitem_qty_invuomratio) *
                            COALESCE(coitem_unitcost, itemCost(itemsite_id), 0.0), 2)), 0.0)
         INTO _subtotal, _cost
  FROM invcitem LEFT OUTER JOIN coitem ON (coitem_id=invcitem_coitem_id)
                LEFT OUTER JOIN itemsite ON (itemsite_item_id=invcitem_item_id AND itemsite_warehous_id=invcitem_warehous_id)
  WHERE (invcitem_invchead_id=pInvcheadid);

  IF (pType IN ('T', 'X')) THEN
    SELECT COALESCE(ROUND(SUM(taxdetail_tax), 2), 0.0) INTO _tax
    FROM calculateTaxDetailSummary('I', pInvcheadid, 'T');
  END IF;

  IF (pType = 'T') THEN
    SELECT COALESCE(invchead_freight, 0), COALESCE(invchead_misc_amount, 0)
           INTO _freight, _misc
    FROM invchead
    WHERE (invchead_id=pinvcheadid);
  END IF;

  _amount := CASE pType WHEN 'S' THEN (_subtotal)
                        WHEN 'T' THEN (_subtotal + _tax + _freight + _misc)
                        WHEN 'X' THEN (_tax)
                        WHEN 'M' THEN (_subtotal - _cost)
                        ELSE 0.0
             END;

  RETURN _amount;

END;
$$;


ALTER FUNCTION public.calcinvoiceamt(pinvcheadid integer, ptype text) OWNER TO admin;

--
-- TOC entry 1167 (class 1255 OID 146565704)
-- Dependencies: 4536 8
-- Name: calcpendingarapplications(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calcpendingarapplications(integer) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  paropenid     ALIAS FOR $1;
  _arcreditsum  NUMERIC;
  _aropencurrid INTEGER;
  _cashrcptsum  NUMERIC;
  _sense INTEGER;

BEGIN
  SELECT aropen_curr_id,
    (CASE WHEN aropen_doctype IN ('I','D') THEN 1 ELSE -1 END)
    INTO _aropencurrid, _sense
  FROM aropen
  WHERE (aropen_id=paropenid);

  SELECT SUM(currToCurr(cashrcpt_curr_id, _aropencurrid,
                        cashrcptitem_amount + cashrcptitem_discount, coalesce(cashrcpt_applydate, cashrcpt_distdate))) * _sense INTO _cashrcptsum
  FROM cashrcptitem, cashrcpt
  WHERE ((cashrcptitem_cashrcpt_id=cashrcpt_id)
    AND  (NOT cashrcpt_posted)
    AND  (NOT cashrcpt_void)
    AND  (cashrcptitem_aropen_id=paropenid)
    );

  SELECT SUM(currToCurr(arcreditapply_curr_id, _aropencurrid,
                        arcreditapply_amount, CURRENT_DATE)) INTO _arcreditsum
  FROM arcreditapply
  WHERE ((arcreditapply_target_aropen_id=paropenid)
    );

  RETURN round(COALESCE(_cashrcptsum, 0) + COALESCE(_arcreditsum, 0),2);
END;
$_$;


ALTER FUNCTION public.calcpendingarapplications(integer) OWNER TO admin;

--
-- TOC entry 1168 (class 1255 OID 146565705)
-- Dependencies: 4536 8
-- Name: calcpurchaseorderamt(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calcpurchaseorderamt(ppoheadid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  RETURN calcPurchaseOrderAmt(pPoheadid, 'T');

END;
$$;


ALTER FUNCTION public.calcpurchaseorderamt(ppoheadid integer) OWNER TO admin;

--
-- TOC entry 1169 (class 1255 OID 146565706)
-- Dependencies: 4536 8
-- Name: calcpurchaseorderamt(integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calcpurchaseorderamt(ppoheadid integer, ptype text) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _subtotal NUMERIC := 0;
  _freightsub NUMERIC := 0;
  _tax NUMERIC := 0;
  _freight NUMERIC := 0;
  _currid INTEGER := 0;
  _effdate DATE := CURRENT_DATE;
  _amount NUMERIC := 0;

BEGIN

  -- pType: S = line item subtotal
  --        T = total
  --        X = tax

  SELECT COALESCE(SUM(ROUND(poitem_qty_ordered * poitem_unitprice, 2)), 0),
         COALESCE(SUM(ROUND(poitem_freight, 2)), 0)
         INTO _subtotal, _freightsub
  FROM poitem
  WHERE (poitem_pohead_id=pPoheadid);

  SELECT COALESCE(SUM(tax), 0) INTO _tax
  FROM ( SELECT COALESCE(ROUND(SUM(taxdetail_tax), 2), 0.0) AS tax
         FROM tax JOIN calculateTaxDetailSummary('PO', pPoheadid, 'T') ON (taxdetail_tax_id=tax_id)
         GROUP BY tax_id ) AS data;

  SELECT COALESCE(pohead_freight, 0), pohead_curr_id, pohead_orderdate
         INTO _freight, _currid, _effdate
  FROM pohead
  WHERE (pohead_id=pPoheadid);

  _amount := currToBase(_currid,
                        CASE pType WHEN 'S' THEN (_subtotal)
                                   WHEN 'T' THEN (_subtotal + _tax + _freight + _freightsub)
                                   WHEN 'X' THEN (_tax)
                                   ELSE 0.0
                        END,
                        _effdate);

  RETURN _amount;

END;
$$;


ALTER FUNCTION public.calcpurchaseorderamt(ppoheadid integer, ptype text) OWNER TO admin;

--
-- TOC entry 1170 (class 1255 OID 146565707)
-- Dependencies: 4536 8
-- Name: calcpurchaseorderduedate(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calcpurchaseorderduedate(ppoheadid integer) RETURNS date
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _result DATE;
BEGIN

  SELECT MIN(poitem_duedate) INTO _result
  FROM poitem
  WHERE (poitem_pohead_id=pPoheadid);

  RETURN _result;

END;
$$;


ALTER FUNCTION public.calcpurchaseorderduedate(ppoheadid integer) OWNER TO admin;

--
-- TOC entry 1171 (class 1255 OID 146565708)
-- Dependencies: 4536 8
-- Name: calcquoteamt(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calcquoteamt(pquheadid integer) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  RETURN calcQuoteAmt(pQuheadid, 'T');

END;
$$;


ALTER FUNCTION public.calcquoteamt(pquheadid integer) OWNER TO admin;

--
-- TOC entry 1173 (class 1255 OID 146565709)
-- Dependencies: 4536 8
-- Name: calcquoteamt(integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calcquoteamt(pquheadid integer, ptype text) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _subtotal NUMERIC := 0.0;
  _cost NUMERIC := 0.0;
  _tax NUMERIC := 0.0;
  _freight NUMERIC := 0.0;
  _misc NUMERIC := 0.0;
  _amount NUMERIC := 0.0;

BEGIN

  -- pType: S = line item subtotal
  --        T = total
  --        X = tax
  --        M = margin

  SELECT COALESCE(SUM(ROUND((quitem_qtyord * quitem_qty_invuomratio) *
                            (quitem_price / quitem_price_invuomratio), 2)), 0.0),
         COALESCE(SUM(ROUND((quitem_qtyord * quitem_qty_invuomratio) *
                            quitem_unitcost, 2)), 0.0)
         INTO _subtotal, _cost
  FROM quitem
  WHERE (quitem_quhead_id=pQuheadid);

  IF (pType IN ('T', 'X')) THEN
    SELECT COALESCE(ROUND(SUM(taxdetail_tax), 2), 0.0) INTO _tax
    FROM calculateTaxDetailSummary('Q', pQuheadid, 'T');
  END IF;

  IF (pType = 'T') THEN
    SELECT COALESCE(quhead_freight, 0), COALESCE(quhead_misc, 0) INTO _freight, _misc
    FROM quhead
    WHERE (quhead_id=pQuheadid);
  END IF;

  _amount := CASE pType WHEN 'S' THEN (_subtotal)
                        WHEN 'T' THEN (_subtotal + _tax + _freight + _misc)
                        WHEN 'X' THEN (_tax)
                        WHEN 'M' THEN (_subtotal - _cost)
                        ELSE 0.0
             END;

  RETURN _amount;

END;
$$;


ALTER FUNCTION public.calcquoteamt(pquheadid integer, ptype text) OWNER TO admin;

--
-- TOC entry 1174 (class 1255 OID 146565710)
-- Dependencies: 4536 8
-- Name: calcsalesorderamt(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calcsalesorderamt(pcoheadid integer) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  RETURN calcSalesOrderAmt(pCoheadid, 'T');

END;
$$;


ALTER FUNCTION public.calcsalesorderamt(pcoheadid integer) OWNER TO admin;

--
-- TOC entry 1175 (class 1255 OID 146565711)
-- Dependencies: 4536 8
-- Name: calcsalesorderamt(integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calcsalesorderamt(pcoheadid integer, ptype text) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _subtotal NUMERIC := 0.0;
  _cost NUMERIC := 0.0;
  _tax NUMERIC := 0.0;
  _freight NUMERIC := 0.0;
  _misc NUMERIC := 0.0;
  _credit NUMERIC := 0.0;
  _amount NUMERIC := 0.0;

BEGIN

  -- pType: S = line item subtotal
  --        T = total
  --        B = balance due
  --        C = allocated credits
  --        X = tax
  --        M = margin

  SELECT COALESCE(SUM(ROUND((coitem_qtyord * coitem_qty_invuomratio) *
                            (coitem_price / coitem_price_invuomratio), 2)), 0.0),
         COALESCE(SUM(ROUND((coitem_qtyord * coitem_qty_invuomratio) *
                            coitem_unitcost, 2)), 0.0)
         INTO _subtotal, _cost
  FROM coitem
  WHERE (coitem_cohead_id=pCoheadid)
    AND (coitem_status != 'X');

  IF (pType IN ('T', 'B', 'X')) THEN
    SELECT COALESCE(ROUND(SUM(taxdetail_tax), 2), 0.0) INTO _tax
    FROM calculateTaxDetailSummary('S', pCoheadid, 'T');
  END IF;

  IF (pType IN ('T', 'B', 'C')) THEN
    SELECT COALESCE(cohead_freight, 0), COALESCE(cohead_misc, 0),
           COALESCE(SUM(currToCurr(aropenalloc_curr_id, cohead_curr_id,
                                   aropenalloc_amount, CURRENT_DATE)),0)
           INTO _freight, _misc, _credit
    FROM cohead
         LEFT OUTER JOIN aropenalloc ON (aropenalloc_doctype='S' AND aropenalloc_doc_id=cohead_id)
    WHERE (cohead_id=pCoheadid)
    GROUP BY cohead_freight, cohead_misc, cohead_curr_id;
  END IF;

  _amount := CASE pType WHEN 'S' THEN (_subtotal)
                        WHEN 'T' THEN (_subtotal + _tax + _freight + _misc)
                        WHEN 'B' THEN (_subtotal + _tax + _freight + _misc - _credit)
                        WHEN 'C' THEN (_credit)
                        WHEN 'X' THEN (_tax)
                        WHEN 'M' THEN (_subtotal - _cost)
                        ELSE 0.0
             END;

  RETURN _amount;

END;
$$;


ALTER FUNCTION public.calcsalesorderamt(pcoheadid integer, ptype text) OWNER TO admin;

--
-- TOC entry 1176 (class 1255 OID 146565712)
-- Dependencies: 4536 8
-- Name: calcshipfreight(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calcshipfreight(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pShipheadId ALIAS FOR $1;
  _result NUMERIC := 0;
  _order RECORD;
  _shipment RECORD;
  _weights RECORD;
  _price RECORD;
  _sales RECORD;
  _freightid INTEGER;
  _totalprice NUMERIC;
  _includepkgweight BOOLEAN := FALSE;
  _freight RECORD;
  _debug BOOLEAN := false;
BEGIN
  --Get shipment
  SELECT shiphead_order_id, shiphead_order_type, shiphead_freight
  INTO _shipment
  FROM shiphead
  WHERE (shiphead_id=pShipheadId);

  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Shipment not found';
  END IF;

  IF (_shipment.shiphead_order_type = 'SO') THEN
  --Sales Orders

  --Get the order header information
    SELECT cust_id AS cust_id,
           custtype_id,
           custtype_code,
           shipto_id,
           shipto_num,
           cohead_orderdate AS orderdate,
           cohead_shipvia AS shipvia,
           shipto_shipzone_id AS shipzone_id,
           cohead_curr_id AS curr_id,
           currConcat(cohead_curr_id) AS currAbbr,
           cohead_calcfreight,
           cohead_freight
    INTO _order
    FROM cohead
      JOIN custinfo ON (cust_id=cohead_cust_id)
      JOIN custtype ON (custtype_id=cust_custtype_id)
      LEFT OUTER JOIN shiptoinfo ON (shipto_id=cohead_shipto_id)
    WHERE (cohead_id=_shipment.shiphead_order_id);

    IF (NOT FOUND) THEN
      RAISE EXCEPTION 'Order not found';
    END IF;

    IF (_debug) THEN
      RAISE NOTICE 'cust_id = %', _order.cust_id;
      RAISE NOTICE 'custtype_id = %', _order.custtype_id;
      RAISE NOTICE 'shipto_id = %', _order.shipto_id;
      RAISE NOTICE 'shipto_num = %', _order.shipto_num;
      RAISE NOTICE 'orderdate = %', _order.orderdate;
      RAISE NOTICE 'shipvia = %', _order.shipvia;
      RAISE NOTICE 'shipzone_id = %', _order.shipzone_id;
      RAISE NOTICE 'curr_id = %', _order.curr_id;
      RAISE NOTICE 'currAbbr = %', _order.currAbbr;
      RAISE NOTICE 'calcfreight = %', _order.cohead_calcfreight;
      RAISE NOTICE 'freight = %', _order.cohead_freight;
    END IF;

    IF (NOT _order.cohead_calcfreight) THEN
      SELECT noNeg( _order.cohead_freight -
                    COALESCE((SELECT SUM(shiphead_freight)
                              FROM shiphead
                              WHERE (shiphead_order_id = _shipment.shiphead_order_id)
                                AND (shiphead_shipped='true')), 0) ) INTO _result;
      RETURN _result;
    END IF;

    SELECT fetchMetricBool('IncludePackageWeight') INTO _includepkgweight;

    --Calculate Sales Order freight
    --Get a list of aggregated weights from sites and
    --freight classes used on order lines
    FOR _weights IN
      SELECT CASE WHEN (_includePkgWeight) THEN
                        SUM(shipitem_qty * (item_prodweight + item_packweight))
                  ELSE  SUM(shipitem_qty * item_prodweight)
             END AS weight,
             itemsite_warehous_id, item_freightclass_id
      FROM shiphead
        JOIN shipitem ON (shipitem_shiphead_id=shiphead_id)
        JOIN coitem ON (shipitem_orderitem_id=coitem_id)
        JOIN itemsite ON (itemsite_id=coitem_itemsite_id)
        JOIN item ON (item_id=itemsite_item_id)
      WHERE ( (shiphead_id=pShipheadId)
        AND   (item_freightclass_id IS NOT NULL) )
      GROUP BY itemsite_warehous_id, item_freightclass_id LOOP

    IF (_debug) THEN
      RAISE NOTICE '_weights.weight - %', _weights.weight;
      RAISE NOTICE '_weights.itemsite_warehous_id = %', _weights.itemsite_warehous_id;
      RAISE NOTICE '_weights.item_freightclass_id = %', _weights.item_freightclass_id;
    END IF;

    -- First get a sales price if any so we when we find other prices
    -- we can determine if we want that price or this price.
    --  Check for a Sale Price
    SELECT ipsfreight_id,
           CASE WHEN (ipsfreight_type='F') THEN currToCurr(ipshead_curr_id, _order.curr_id,
                                                           ipsfreight_price, _order.orderdate)
                ELSE currToCurr(ipshead_curr_id, _order.curr_id,
                                (_weights.weight * ipsfreight_price), _order.orderdate)
           END AS price
           INTO _sales
    FROM ipsfreight JOIN ipshead ON (ipshead_id=ipsfreight_ipshead_id)
                    JOIN sale ON (sale_ipshead_id=ipshead_id)
    WHERE ( (ipsfreight_qtybreak <= _weights.weight)
      AND   ((ipsfreight_warehous_id IS NULL) OR (ipsfreight_warehous_id=_weights.itemsite_warehous_id))
      AND   ((ipsfreight_freightclass_id IS NULL) OR (ipsfreight_freightclass_id=_weights.item_freightclass_id))
      AND   ((ipsfreight_shipzone_id IS NULL) OR (ipsfreight_shipzone_id=_order.shipzone_id))
      AND   ((ipsfreight_shipvia IS NULL) OR (ipsfreight_shipvia=_order.shipvia))
      AND   (CURRENT_DATE BETWEEN sale_startdate AND sale_enddate) )
    ORDER BY ipsfreight_qtybreak DESC, price ASC
    LIMIT 1;

    IF (_debug) THEN
      IF (_sales.price IS NOT NULL) THEN
        RAISE NOTICE 'Sales Price found, %', _sales.price;
      END IF;
    END IF;

    --  Check for a Customer Shipto Price
    SELECT ipsfreight_id,
           CASE WHEN (ipsfreight_type='F') THEN currToCurr(ipshead_curr_id, _order.curr_id,
                                                           ipsfreight_price, _order.orderdate)
                ELSE currToCurr(ipshead_curr_id, _order.curr_id,
                                (_weights.weight * ipsfreight_price), _order.orderdate)
           END AS price
           INTO _price
    FROM ipsfreight JOIN ipshead ON (ipshead_id=ipsfreight_ipshead_id)
                    JOIN ipsass ON (ipsass_ipshead_id=ipshead_id)
    WHERE ( (ipsfreight_qtybreak <= _weights.weight)
      AND   ((ipsfreight_warehous_id IS NULL) OR (ipsfreight_warehous_id=_weights.itemsite_warehous_id))
      AND   ((ipsfreight_freightclass_id IS NULL) OR (ipsfreight_freightclass_id=_weights.item_freightclass_id))
      AND   ((ipsfreight_shipzone_id IS NULL) OR (ipsfreight_shipzone_id=_order.shipzone_id))
      AND   ((ipsfreight_shipvia IS NULL) OR (ipsfreight_shipvia=_order.shipvia))
      AND   (CURRENT_DATE BETWEEN ipshead_effective AND (ipshead_expires - 1))
      AND   (ipsass_cust_id=_order.cust_id)
      AND   (ipsass_shipto_id != -1)
      AND   (ipsass_shipto_id=_order.shipto_id) )
    ORDER BY ipsfreight_qtybreak DESC, price ASC
    LIMIT 1;

    IF (_debug) THEN
      IF (_price.price IS NOT NULL) THEN
        RAISE NOTICE 'Customer Shipto Price found, %', _price.price;
      END IF;
    END IF;

    IF (_price.price IS NULL) THEN
    --  Check for a Customer Shipto Pattern Price
      SELECT ipsfreight_id,
             CASE WHEN (ipsfreight_type='F') THEN currToCurr(ipshead_curr_id, _order.curr_id,
                                                             ipsfreight_price, _order.orderdate)
                  ELSE currToCurr(ipshead_curr_id, _order.curr_id,
                                  (_weights.weight * ipsfreight_price), _order.orderdate)
             END AS price
             INTO _price
      FROM ipsfreight JOIN ipshead ON (ipshead_id=ipsfreight_ipshead_id)
                      JOIN ipsass ON (ipsass_ipshead_id=ipshead_id)
      WHERE ( (ipsfreight_qtybreak <= _weights.weight)
        AND   (CURRENT_DATE BETWEEN ipshead_effective AND (ipshead_expires - 1))
        AND   (ipsass_cust_id=_order.cust_id)
        AND   (COALESCE(LENGTH(ipsass_shipto_pattern), 0) > 0)
        AND   (_order.shipto_num ~ ipsass_shipto_pattern)
        AND   ((ipsfreight_warehous_id IS NULL) OR (ipsfreight_warehous_id=_weights.itemsite_warehous_id))
        AND   ((ipsfreight_freightclass_id IS NULL) OR (ipsfreight_freightclass_id=_weights.item_freightclass_id))
        AND   ((ipsfreight_shipzone_id IS NULL) OR (ipsfreight_shipzone_id=_order.shipzone_id))
        AND   ((ipsfreight_shipvia IS NULL) OR (ipsfreight_shipvia=_order.shipvia)) )
      ORDER BY ipsfreight_qtybreak DESC, price ASC
      LIMIT 1;

      IF (_debug) THEN
        IF (_price.price IS NOT NULL) THEN
          RAISE NOTICE 'Customer Shipto Pattern Price found, %', _price.price;
        END IF;
      END IF;

    END IF;

    IF (_price.price IS NULL) THEN
    --  Check for a Customer Price
      SELECT ipsfreight_id,
             CASE WHEN (ipsfreight_type='F') THEN currToCurr(ipshead_curr_id, _order.curr_id,
                                                             ipsfreight_price, _order.orderdate)
                  ELSE currToCurr(ipshead_curr_id, _order.curr_id,
                                  (_weights.weight * ipsfreight_price), _order.orderdate)
             END AS price
             INTO _price
      FROM ipsfreight JOIN ipshead ON (ipshead_id=ipsfreight_ipshead_id)
                      JOIN ipsass ON (ipsass_ipshead_id=ipshead_id)
      WHERE ( (ipsfreight_qtybreak <= _weights.weight)
        AND   ((ipsfreight_warehous_id IS NULL) OR (ipsfreight_warehous_id=_weights.itemsite_warehous_id))
        AND   ((ipsfreight_freightclass_id IS NULL) OR (ipsfreight_freightclass_id=_weights.item_freightclass_id))
        AND   ((ipsfreight_shipzone_id IS NULL) OR (ipsfreight_shipzone_id=_order.shipzone_id))
        AND   ((ipsfreight_shipvia IS NULL) OR (ipsfreight_shipvia=_order.shipvia))
        AND   (CURRENT_DATE BETWEEN ipshead_effective AND (ipshead_expires - 1))
        AND   (ipsass_cust_id=_order.cust_id)
        AND   (COALESCE(LENGTH(ipsass_shipto_pattern), 0) = 0) )
      ORDER BY ipsfreight_qtybreak DESC, price ASC
      LIMIT 1;

      IF (_debug) THEN
        IF (_price.price IS NOT NULL) THEN
          RAISE NOTICE 'Customer Price found, %', _price.price;
        END IF;
      END IF;

    END IF;

    IF (_price.price IS NULL) THEN
    --  Check for a Customer Type Price
      SELECT ipsfreight_id,
             CASE WHEN (ipsfreight_type='F') THEN currToCurr(ipshead_curr_id, _order.curr_id,
                                                             ipsfreight_price, _order.orderdate)
                  ELSE currToCurr(ipshead_curr_id, _order.curr_id,
                                  (_weights.weight * ipsfreight_price), _order.orderdate)
             END AS price
             INTO _price
      FROM ipsfreight JOIN ipshead ON (ipshead_id=ipsfreight_ipshead_id)
                      JOIN ipsass ON (ipsass_ipshead_id=ipshead_id)
      WHERE ( (ipsfreight_qtybreak <= _weights.weight)
        AND   ((ipsfreight_warehous_id IS NULL) OR (ipsfreight_warehous_id=_weights.itemsite_warehous_id))
        AND   ((ipsfreight_freightclass_id IS NULL) OR (ipsfreight_freightclass_id=_weights.item_freightclass_id))
        AND   ((ipsfreight_shipzone_id IS NULL) OR (ipsfreight_shipzone_id=_order.shipzone_id))
        AND   ((ipsfreight_shipvia IS NULL) OR (ipsfreight_shipvia=_order.shipvia))
        AND   (CURRENT_DATE BETWEEN ipshead_effective AND (ipshead_expires - 1))
        AND   (ipsass_custtype_id=_order.custtype_id) )
      ORDER BY ipsfreight_qtybreak DESC, price ASC
      LIMIT 1;

      IF (_debug) THEN
        IF (_price.price IS NOT NULL) THEN
          RAISE NOTICE 'Customer Type Price found, %', _price.price;
        END IF;
      END IF;

    END IF;

    IF (_price.price IS NULL) THEN
    --  Check for a Customer Type Pattern Price
      SELECT ipsfreight_id,
             CASE WHEN (ipsfreight_type='F') THEN currToCurr(ipshead_curr_id, _order.curr_id,
                                                             ipsfreight_price, _order.orderdate)
                  ELSE currToCurr(ipshead_curr_id, _order.curr_id,
                                  (_weights.weight * ipsfreight_price), _order.orderdate)
             END AS price
             INTO _price
      FROM ipsfreight JOIN ipshead ON (ipshead_id=ipsfreight_ipshead_id)
                      JOIN ipsass ON (ipsass_ipshead_id=ipshead_id)
      WHERE ( (ipsfreight_qtybreak <= _weights.weight)
        AND   ((ipsfreight_warehous_id IS NULL) OR (ipsfreight_warehous_id=_weights.itemsite_warehous_id))
        AND   ((ipsfreight_freightclass_id IS NULL) OR (ipsfreight_freightclass_id=_weights.item_freightclass_id))
        AND   ((ipsfreight_shipzone_id IS NULL) OR (ipsfreight_shipzone_id=_order.shipzone_id))
        AND   ((ipsfreight_shipvia IS NULL) OR (ipsfreight_shipvia=_order.shipvia))
        AND   (CURRENT_DATE BETWEEN ipshead_effective AND (ipshead_expires - 1))
        AND   (COALESCE(LENGTH(ipsass_custtype_pattern), 0) > 0)
        AND   (_order.custtype_code ~ ipsass_custtype_pattern) )
      ORDER BY ipsfreight_qtybreak DESC, price ASC
      LIMIT 1;

      IF (_debug) THEN
        IF (_price.price IS NOT NULL) THEN
          RAISE NOTICE 'Customer Type Pattern Price found, %', _price.price;
        END IF;
      END IF;

    END IF;

    -- Select the lowest price
    IF ( (_price.price IS NOT NULL) AND ((_sales.price IS NULL) OR (_price.price < _sales.price)) ) THEN
      _freightid := _price.ipsfreight_id;
      _totalprice := _price.price;
    ELSE
      IF ( (_sales.price IS NOT NULL) AND ((_price.price IS NULL) OR (_sales.price <= _price.price)) ) THEN
        _freightid := _sales.ipsfreight_id;
        _totalprice := _sales.price;
      END IF;
    END IF;

    -- Total
    IF (_freightid IS NOT NULL) THEN
      _result := _result + _totalprice;
    END IF;

    END LOOP;
    RETURN ROUND(_result,2);
  END IF;

  IF (_shipment.shiphead_order_type = 'TO') THEN
  --Transfer Orders

    SELECT noNeg( (SELECT SUM(toitem_freight) + tohead_freight
                   FROM tohead, toitem
                   WHERE (toitem_tohead_id=tohead_id)
                     AND (tohead_id = _shipment.shiphead_order_id)
                   GROUP BY tohead_freight) -
                  COALESCE((SELECT SUM(shiphead_freight)
                            FROM shiphead
                            WHERE (shiphead_order_id = _shipment.shiphead_order_id)
                              AND (shiphead_shipped='true')), 0) ) INTO _result;
    RETURN _result;
  END IF;

  RETURN _result;

END;
$_$;


ALTER FUNCTION public.calcshipfreight(integer) OWNER TO admin;

--
-- TOC entry 1177 (class 1255 OID 146565714)
-- Dependencies: 4536 8
-- Name: calctotalslipqty(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calctotalslipqty(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTagid ALIAS FOR $1;
  _qty NUMERIC := 0;

BEGIN

  SELECT SUM(COALESCE(cntslip_qty, 0.0)) INTO _qty
  FROM cntslip
  WHERE (cntslip_cnttag_id=pTagid);

  RETURN _qty;

END;
$_$;


ALTER FUNCTION public.calctotalslipqty(integer) OWNER TO admin;

--
-- TOC entry 1178 (class 1255 OID 146565715)
-- Dependencies: 2681 4536 8
-- Name: calculatefreightdetail(integer, integer, text, integer, integer, text, date, text, integer, character varying, integer, integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calculatefreightdetail(integer, integer, text, integer, integer, text, date, text, integer, character varying, integer, integer, numeric) RETURNS SETOF freightdata
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCustId ALIAS FOR $1;
  pCustTypeId ALIAS FOR $2;
  pCustTypeCode ALIAS FOR $3;
  pShiptoId ALIAS FOR $4;
  pShipZoneId ALIAS FOR $5;
  pShiptoNum ALIAS FOR $6;
  pOrderDate ALIAS FOR $7;
  pShipVia ALIAS FOR $8;
  pCurrId ALIAS FOR $9;
  pCurrAbbr ALIAS FOR $10;
  pItemSiteWhsId ALIAS FOR $11;
  pItemFreightclassId ALIAS FOR $12;
  pWeight ALIAS FOR $13;

  _row freightData%ROWTYPE;
  _price RECORD;
  _sales RECORD;
  _freightid INTEGER;
  _totalprice NUMERIC;
  _asof DATE;
  _debug BOOLEAN := FALSE;

BEGIN

  --Get pricing effectivity metric
  IF (SELECT fetchMetricText('soPriceEffective') = 'OrderDate') THEN
    _asof := pOrderDate;
  ELSE
    _asof := CURRENT_DATE;
  END IF;

  _freightid := NULL;
  _totalprice := 0.0;

  IF (_debug) THEN
    RAISE NOTICE 'pWeight - %', pWeight;
    RAISE NOTICE 'pItemSiteWhsId = %', pItemSiteWhsId;
    RAISE NOTICE 'pItemFreightclassId = %', pItemFreightclassId;
  END IF;

-- First get a sales price if any so when we find other prices
-- we can determine if we want that price or this sales price.
--  Check for a Sale Price
  SELECT ipsfreight_id,
    CASE WHEN (ipsfreight_type='F') THEN currToCurr(ipshead_curr_id, pCurrId,
        ipsfreight_price, pOrderDate)
      ELSE currToCurr(ipshead_curr_id, pCurrId,
        (pWeight * ipsfreight_price), pOrderDate)
    END AS price
  INTO _sales
  FROM ipsfreight
  JOIN ipshead ON (ipshead_id=ipsfreight_ipshead_id)
  JOIN sale ON (sale_ipshead_id=ipshead_id)
  WHERE ( (ipsfreight_qtybreak <= pWeight)
    AND ((ipsfreight_warehous_id IS NULL) OR (ipsfreight_warehous_id=pItemSiteWhsId))
    AND ((ipsfreight_freightclass_id IS NULL) OR (ipsfreight_freightclass_id=pItemFreightclassId))
    AND ((ipsfreight_shipzone_id IS NULL) OR (ipsfreight_shipzone_id=pShipZoneId))
    AND ((ipsfreight_shipvia IS NULL) OR (ipsfreight_shipvia=pShipVia))
    AND (_asof BETWEEN sale_startdate AND sale_enddate)
    AND (pCustId IS NOT NULL) )
  ORDER BY ipsfreight_qtybreak DESC, price ASC
  LIMIT 1;

  IF (_debug) THEN
    IF (_sales.price IS NOT NULL) THEN
      RAISE NOTICE 'Sales Price found, %', _sales.price;
    END IF;
  END IF;

--  Check for a Customer Shipto Price
  SELECT ipsfreight_id,
    CASE WHEN (ipsfreight_type='F') THEN currToCurr(ipshead_curr_id, pCurrId,
        ipsfreight_price, pOrderDate)
      ELSE currToCurr(ipshead_curr_id, pCurrId,
        (pWeight * ipsfreight_price), pOrderDate)
    END AS price
  INTO _price
  FROM ipsfreight
  JOIN ipshead ON (ipshead_id=ipsfreight_ipshead_id)
  JOIN ipsass ON (ipsass_ipshead_id=ipshead_id)
  WHERE ( (ipsfreight_qtybreak <= pWeight)
    AND ((ipsfreight_warehous_id IS NULL) OR (ipsfreight_warehous_id=pItemSiteWhsId))
    AND ((ipsfreight_freightclass_id IS NULL) OR (ipsfreight_freightclass_id=pItemFreightclassId))
    AND ((ipsfreight_shipzone_id IS NULL) OR (ipsfreight_shipzone_id=pShipZoneId))
    AND ((ipsfreight_shipvia IS NULL) OR (ipsfreight_shipvia=pShipVia))
    AND (_asof BETWEEN ipshead_effective AND (ipshead_expires - 1))
    AND   (ipsass_shipto_id != -1)
    AND   (ipsass_shipto_id=pShiptoId) )
  ORDER BY ipsfreight_qtybreak DESC, price ASC
  LIMIT 1;

  IF (_debug) THEN
    IF (_price.price IS NOT NULL) THEN
      RAISE NOTICE 'Customer Shipto Price found, %', _price.price;
    END IF;
  END IF;

  IF (_price.price IS NULL) THEN
--  Check for a Customer Shipto Pattern Price
  SELECT ipsfreight_id,
    CASE WHEN (ipsfreight_type='F') THEN currToCurr(ipshead_curr_id, pCurrId,
        ipsfreight_price, pOrderDate)
      ELSE currToCurr(ipshead_curr_id, pCurrId,
        (pWeight * ipsfreight_price), pOrderDate)
    END AS price
  INTO _price
  FROM ipsfreight
  JOIN ipshead ON (ipshead_id=ipsfreight_ipshead_id)
  JOIN ipsass ON (ipsass_ipshead_id=ipshead_id)
  WHERE ( (ipsfreight_qtybreak <= pWeight)
    AND (_asof BETWEEN ipshead_effective AND (ipshead_expires - 1))
    AND (ipsass_cust_id=pCustId)
    AND (COALESCE(LENGTH(ipsass_shipto_pattern), 0) > 0)
    AND (pShiptoNum ~ ipsass_shipto_pattern)
    AND ((ipsfreight_warehous_id IS NULL) OR (ipsfreight_warehous_id=pItemSiteWhsId))
    AND ((ipsfreight_freightclass_id IS NULL) OR (ipsfreight_freightclass_id=pItemFreightclassId))
    AND ((ipsfreight_shipzone_id IS NULL) OR (ipsfreight_shipzone_id=pShipZoneId))
    AND ((ipsfreight_shipvia IS NULL) OR (ipsfreight_shipvia=pShipVia)) )
  ORDER BY ipsfreight_qtybreak DESC, price ASC
  LIMIT 1;

  IF (_debug) THEN
    IF (_price.price IS NOT NULL) THEN
      RAISE NOTICE 'Customer Shipto Pattern Price found, %', _price.price;
    END IF;
  END IF;

  END IF;

  IF (_price.price IS NULL) THEN
--  Check for a Customer Price
  SELECT ipsfreight_id,
    CASE WHEN (ipsfreight_type='F') THEN currToCurr(ipshead_curr_id, pCurrId,
        ipsfreight_price, pOrderDate)
      ELSE currToCurr(ipshead_curr_id, pCurrId,
        (pWeight * ipsfreight_price), pOrderDate)
    END AS price
  INTO _price
  FROM ipsfreight
  JOIN ipshead ON (ipshead_id=ipsfreight_ipshead_id)
  JOIN ipsass ON (ipsass_ipshead_id=ipshead_id)
  WHERE ( (ipsfreight_qtybreak <= pWeight)
    AND((ipsfreight_warehous_id IS NULL) OR (ipsfreight_warehous_id=pItemSiteWhsId))
    AND ((ipsfreight_freightclass_id IS NULL) OR (ipsfreight_freightclass_id=pItemFreightclassId))
    AND ((ipsfreight_shipzone_id IS NULL) OR (ipsfreight_shipzone_id=pShipZoneId))
    AND ((ipsfreight_shipvia IS NULL) OR (ipsfreight_shipvia=pShipVia))
    AND (_asof BETWEEN ipshead_effective AND (ipshead_expires - 1))
    AND (ipsass_cust_id=pCustId)
    AND (COALESCE(LENGTH(ipsass_shipto_pattern), 0) = 0) )
  ORDER BY ipsfreight_qtybreak DESC, price ASC
  LIMIT 1;

  IF (_debug) THEN
    IF (_price.price IS NOT NULL) THEN
      RAISE NOTICE 'Customer Price found, %', _price.price;
    END IF;
  END IF;

  END IF;

  IF (_price.price IS NULL) THEN
--  Check for a Customer Type Price
  SELECT ipsfreight_id,
    CASE WHEN (ipsfreight_type='F') THEN currToCurr(ipshead_curr_id, pCurrId,
        ipsfreight_price, pOrderDate)
      ELSE currToCurr(ipshead_curr_id, pCurrId,
        (pWeight * ipsfreight_price), pOrderDate)
    END AS price
  INTO _price
  FROM ipsfreight JOIN ipshead ON (ipshead_id=ipsfreight_ipshead_id)
                  JOIN ipsass ON (ipsass_ipshead_id=ipshead_id)
  WHERE ( (ipsfreight_qtybreak <= pWeight)
    AND ((ipsfreight_warehous_id IS NULL) OR (ipsfreight_warehous_id=pItemSiteWhsId))
    AND ((ipsfreight_freightclass_id IS NULL) OR (ipsfreight_freightclass_id=pItemFreightclassId))
    AND ((ipsfreight_shipzone_id IS NULL) OR (ipsfreight_shipzone_id=pShipZoneId))
    AND ((ipsfreight_shipvia IS NULL) OR (ipsfreight_shipvia=pShipVia))
    AND (_asof BETWEEN ipshead_effective AND (ipshead_expires - 1))
    AND (ipsass_custtype_id=pCustTypeId) )
  ORDER BY ipsfreight_qtybreak DESC, price ASC
  LIMIT 1;

  IF (_debug) THEN
    IF (_price.price IS NOT NULL) THEN
      RAISE NOTICE 'Customer Type Price found, %', _price.price;
    END IF;
  END IF;

  END IF;

  IF (_price.price IS NULL) THEN
--  Check for a Customer Type Pattern Price
  SELECT ipsfreight_id,
    CASE WHEN (ipsfreight_type='F') THEN currToCurr(ipshead_curr_id, pCurrId,
        ipsfreight_price, pOrderDate)
      ELSE currToCurr(ipshead_curr_id, pCurrId,
        (pWeight * ipsfreight_price), pOrderDate)
    END AS price
  INTO _price
  FROM ipsfreight JOIN ipshead ON (ipshead_id=ipsfreight_ipshead_id)
                  JOIN ipsass ON (ipsass_ipshead_id=ipshead_id)
  WHERE ( (ipsfreight_qtybreak <= pWeight)
    AND ((ipsfreight_warehous_id IS NULL) OR (ipsfreight_warehous_id=pItemSiteWhsId))
    AND ((ipsfreight_freightclass_id IS NULL) OR (ipsfreight_freightclass_id=pItemFreightclassId))
    AND ((ipsfreight_shipzone_id IS NULL) OR (ipsfreight_shipzone_id=pShipZoneId))
    AND ((ipsfreight_shipvia IS NULL) OR (ipsfreight_shipvia=pShipVia))
    AND (_asof BETWEEN ipshead_effective AND (ipshead_expires - 1))
    AND (COALESCE(LENGTH(ipsass_custtype_pattern), 0) > 0)
    AND (pCustTypeCode ~ ipsass_custtype_pattern) )
  ORDER BY ipsfreight_qtybreak DESC, price ASC
  LIMIT 1;

  IF (_debug) THEN
    IF (_price.price IS NOT NULL) THEN
      RAISE NOTICE 'Customer Type Pattern Price found, %', _price.price;
    END IF;
  END IF;

  END IF;

  -- Select the lowest price
  IF ( (_price.price IS NOT NULL) AND ((_sales.price IS NULL) OR (_price.price < _sales.price)) ) THEN
    _freightid := _price.ipsfreight_id;
    _totalprice := _price.price;
  ELSE
    IF ( (_sales.price IS NOT NULL) AND ((_price.price IS NULL) OR (_sales.price <= _price.price)) ) THEN
      _freightid := _sales.ipsfreight_id;
      _totalprice := _sales.price;
    END IF;
  END IF;

  IF (_debug) THEN
    RAISE NOTICE '_freightid = %', _freightid;
    RAISE NOTICE '_totalprice = %', _totalprice;
  END IF;

  -- Get information for the selected ipsfreight
  -- and return
  IF (_freightid IS NULL) THEN
    _row.freightdata_schedule := 'N/A';
    _row.freightdata_from := '';
    _row.freightdata_to := '';
    _row.freightdata_shipvia := '';
    _row.freightdata_freightclass := '';
    _row.freightdata_weight := 0;
    _row.freightdata_uom := '';
    _row.freightdata_price := 0;
    _row.freightdata_type := '';
    _row.freightdata_total := 0;
    _row.freightdata_currency := '';
    RETURN NEXT _row;
  ELSE
    SELECT ipshead_name AS freightdata_schedule,
      COALESCE(warehous_code, 'Any') AS freightdata_from,
      COALESCE(shipzone_name, 'Any') AS freightdata_to,
      COALESCE(ipsfreight_shipvia, 'Any') AS freightdata_shipvia,
      COALESCE(freightclass_code, 'Any') AS freightdata_freightclass,
      pWeight AS freightdata_weight,
      uom_name AS freightdata_uom,
      currToCurr(ipshead_curr_id, pCurrId, ipsfreight_price, pOrderDate) AS freightdata_price,
      CASE WHEN (ipsfreight_type='F') THEN 'Flat Rate'
        ELSE 'Per UOM'
      END AS freightdata_type,
      _totalprice AS freightdata_total,
      pCurrAbbr AS freightdata_currency
    INTO _row
    FROM ipsfreight
      JOIN ipshead ON (ipshead_id=ipsfreight_ipshead_id)
      LEFT OUTER JOIN uom ON (uom_item_weight)
      LEFT OUTER JOIN whsinfo ON (warehous_id=ipsfreight_warehous_id)
      LEFT OUTER JOIN shipzone ON (shipzone_id=ipsfreight_shipzone_id)
      LEFT OUTER JOIN freightclass ON (freightclass_id=ipsfreight_freightclass_id)
    WHERE (ipsfreight_id=_freightid);

    RETURN NEXT _row;
  END IF;

  RETURN;
END;
$_$;


ALTER FUNCTION public.calculatefreightdetail(integer, integer, text, integer, integer, text, date, text, integer, character varying, integer, integer, numeric) OWNER TO admin;

--
-- TOC entry 1179 (class 1255 OID 146565717)
-- Dependencies: 2708 4536 8
-- Name: calculatesubtax(integer, date, integer, numeric, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calculatesubtax(integer, date, integer, numeric, integer) RETURNS SETOF taxdetail
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTaxCodeId ALIAS FOR $1;
  pDate ALIAS FOR $2;
  pCurrId ALIAS FOR $3;
  pAmount ALIAS FOR $4;
  pLevel ALIAS FOR $5;
  _row taxdetail%ROWTYPE;
  _rownumber INTEGER := 1;
  _calc_tax Numeric :=0;
  _x RECORD;
  _y RECORD;

BEGIN
  FOR _x IN

  SELECT tax_id, tax_code, tax_descrip, tax_basis_tax_id,
    taxrate_id, taxrate_percent, taxrate_curr_id, taxrate_amount,
    taxclass_id, taxclass_code, COALESCE(taxclass_sequence,0) AS taxclass_sequence,
    curr_id, curr_abbr
  FROM tax, taxrate, taxclass, curr_symbol
  WHERE ((tax_id = taxrate_tax_id)
  AND (tax_taxclass_id = taxclass_id)
  AND (taxrate_curr_id = curr_id)
  AND (tax_basis_tax_id = pTaxCodeId)
  AND (pDate BETWEEN taxrate_effective AND taxrate_expires)
  AND (taxrate_curr_id = pCurrId))

  LOOP
    SELECT
      ROUND((_x.taxrate_percent * pAmount + currToCurr(_x.curr_id, pCurrId, _x.taxrate_amount, pDate)), 6)
    INTO _calc_tax;

    _row.taxdetail_tax_id = _x.tax_id;
    _row.taxdetail_tax_code = _x.tax_code;
    _row.taxdetail_tax_descrip = _x.tax_descrip;
    _row.taxdetail_tax_basis_tax_id = _x.tax_basis_tax_id ;
    _row.taxdetail_taxrate_percent = _x.taxrate_percent;
    _row.taxdetail_taxrate_amount = _x.taxrate_amount;
    _row.taxdetail_level = pLevel + 1;
    _row.taxdetail_taxclass_id = _x.taxclass_id ;
    _row.taxdetail_taxclass_code = _x.taxclass_code;
    _row.taxdetail_taxclass_sequence = _x.taxclass_sequence;
    _row.taxdetail_tax = _calc_tax;
    _row.taxdetail_curr_id = _x.curr_id;
    _row.taxdetail_curr_abbr = _x.curr_abbr;

    RETURN NEXT _row;
    _rownumber := _rownumber + 1;

    FOR _y IN
    SELECT *
    FROM calculateSubTax( _x.tax_id, pDate, pCurrId, _calc_tax, pLevel + 1)
    LOOP
      _row.taxdetail_tax_id = _y.taxdetail_tax_id;
      _row.taxdetail_tax_code = _y.taxdetail_tax_code;
      _row.taxdetail_tax_descrip = _y.taxdetail_tax_descrip;
      _row.taxdetail_tax_basis_tax_id = _y.taxdetail_tax_basis_tax_id ;
      _row.taxdetail_taxrate_percent = _y.taxdetail_taxrate_percent;
      _row.taxdetail_taxrate_amount = _y.taxdetail_taxrate_amount;
      _row.taxdetail_level = _y.taxdetail_level + 1;
      _row.taxdetail_taxclass_id = _y.taxdetail_taxclass_id ;
      _row.taxdetail_taxclass_code = _y.taxdetail_taxclass_code;
      _row.taxdetail_taxclass_sequence = _y.taxdetail_taxclass_sequence;
      _row.taxdetail_tax = _y.taxdetail_tax;
      _row.taxdetail_curr_id = _y.taxdetail_curr_id;
      _row.taxdetail_curr_abbr = _y.taxdetail_curr_abbr;

      RETURN NEXT _row;
      _rownumber := _rownumber + 1;

    END LOOP;

  END LOOP;

END;
$_$;


ALTER FUNCTION public.calculatesubtax(integer, date, integer, numeric, integer) OWNER TO admin;

--
-- TOC entry 1180 (class 1255 OID 146565718)
-- Dependencies: 4536 8
-- Name: calculatetax(integer, integer, date, integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calculatetax(integer, integer, date, integer, numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTaxZoneId ALIAS FOR  $1;
  pTaxTypeId ALIAS FOR  $2;
  pDate ALIAS FOR  $3;
  pCurrId ALIAS FOR $4;
  pAmount ALIAS FOR $5;
  _tottax numeric := 0;  -- total tax

BEGIN

  SELECT COALESCE(ROUND(SUM(taxdetail_tax),6),0)
    INTO _tottax
  FROM calculateTaxDetail(pTaxZoneId, pTaxTypeId, pDate, pCurrId, pAmount);

  RETURN _tottax;

END;
$_$;


ALTER FUNCTION public.calculatetax(integer, integer, date, integer, numeric) OWNER TO admin;

--
-- TOC entry 1181 (class 1255 OID 146565719)
-- Dependencies: 2708 4536 8
-- Name: calculatetaxdetail(integer, integer, date, integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calculatetaxdetail(integer, integer, date, integer, numeric) RETURNS SETOF taxdetail
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTaxZoneId ALIAS FOR  $1;
  pTaxTypeId ALIAS FOR  $2;
  pDate ALIAS FOR  $3;
  pCurrId ALIAS FOR $4;
  pAmount ALIAS FOR $5;
  _row taxdetail%ROWTYPE;
  _x RECORD;
  _y RECORD;
  _z RECORD;
  _currcum numeric := 0;  -- Current cumulative tax
  _currseq numeric := 0;  -- Current group sequence
  _prevcum numeric := 0;  -- Previous cumulative tax
  _tax numeric := 0;      -- Calculated tax amount
  _taxbasis numeric := 0;  -- Used for calculating sub taxes

BEGIN

  IF ((COALESCE(pTaxTypeId,-1) = -1) OR (COALESCE(pTaxZoneId,-1) = -1)) THEN
    RETURN;
  END IF;

  SELECT DISTINCT
    COALESCE(taxass_taxzone_id, -1) AS taxzone_id,
    COALESCE(taxass_taxtype_id, -1) AS taxtype_id,
    taxass_tax_id,
    CASE
      WHEN ((taxass_taxzone_id IS NOT NULL) AND (taxass_taxtype_id IS NOT NULL)) THEN
        0
      WHEN ((taxass_taxzone_id IS NOT NULL) AND (taxass_taxtype_id IS NULL)) THEN
        1
      WHEN ((taxass_taxzone_id IS NULL) AND (taxass_taxtype_id IS NOT NULL)) THEN
        2
      ELSE
        3
    END AS sequence
    INTO _x
  FROM taxass
  WHERE  ((COALESCE(taxass_taxzone_id, pTaxZoneId, -1) = COALESCE(pTaxZoneId,-1))
  AND    (COALESCE(taxass_taxtype_id, pTaxTypeId, -1) = COALESCE(pTaxTypeId,-1)))
  ORDER BY sequence LIMIT 1;

  --Now loop through each tax detail record and return calculated result
  FOR _y IN
    SELECT  --the data required by taxdetail type.  Coalesce group sequence to 0 if no class.
    tax_id
    ,tax_code
    ,tax_descrip
    ,tax_basis_tax_id
    ,taxrate_percent
    ,taxrate_amount
    ,0 as taxdetail_level
    ,taxclass_id
    ,taxclass_code
    ,COALESCE(taxclass_sequence, 0) AS taxclass_sequence
    ,0 as taxdetail_tax
    ,curr_id
    ,curr_abbr
    FROM taxass, taxclass RIGHT OUTER JOIN tax
      LEFT OUTER JOIN taxrate ON (taxrate_tax_id=tax_id)
    ON (tax_taxclass_id=taxclass_id),
    curr_symbol
    WHERE
    taxass_tax_id=tax_id
    AND taxrate_curr_id=curr_id
    AND COALESCE(taxass_taxzone_id, -1) = _x.taxzone_id
    AND COALESCE(taxass_taxtype_id, -1) = _x.taxtype_id
    AND pDate BETWEEN COALESCE(taxrate_effective, startoftime()) AND COALESCE(taxrate_expires, endoftime())
    ORDER BY COALESCE(taxclass_sequence, 0)
  LOOP
    -- If sequence has changed, cache the previous cumulative tax
    IF (_currseq != _x.sequence) THEN
      _prevcum := _currcum;
    END IF;

    -- Calculate the tax amount.  Convert currency for flat rate amounts
    SELECT
    ROUND((_y.taxrate_percent * (pAmount + _prevcum) + currToCurr(_y.curr_id, pCurrId, _y.taxrate_amount, pDate)), 6)
    INTO _tax
    FROM tax JOIN  taxrate ON (tax_id = taxrate_tax_id)
    WHERE (tax_id=_x.taxass_tax_id)
    AND (pDate BETWEEN COALESCE(taxrate_effective, startoftime()) AND COALESCE(taxrate_expires, endoftime()));

    --Map fields to _row

    _row.taxdetail_tax_id := _y.tax_id;
    _row.taxdetail_tax_code := _y.tax_code;
    _row.taxdetail_tax_descrip := _y.tax_descrip;
    _row.taxdetail_tax_basis_tax_id := _y.tax_basis_tax_id;
    _row.taxdetail_taxrate_percent := _y.taxrate_percent;
    _row.taxdetail_taxrate_amount := _y.taxrate_amount;
    _row.taxdetail_level := _y.taxdetail_level;
    _row.taxdetail_taxclass_id := _y.taxclass_id;
    _row.taxdetail_taxclass_code := _y.taxclass_code;
    _row.taxdetail_taxclass_sequence := _y.taxclass_sequence;
    _row.taxdetail_tax := _tax;
    _row.taxdetail_curr_id := _y.curr_id;
    _row.taxdetail_curr_abbr := _y.curr_abbr;

    RETURN NEXT _row;

    -- Increment cumulative balance and sequence number
    IF(_y.taxclass_sequence <> 0) THEN
      _currcum := _currcum + _tax;
    END IF;
    _currseq := _y.taxclass_sequence;

    -- Loop to Calculate sub taxes
    FOR _z IN
    SELECT *
    FROM calculateSubTax(_y.tax_id,pDate, pCurrId, _tax, 0)
    LOOP
     --Mapping of data
    _row.taxdetail_tax_id := _z.taxdetail_tax_id;
    _row.taxdetail_tax_code := _z.taxdetail_tax_code;
    _row.taxdetail_tax_descrip := _z.taxdetail_tax_descrip;
    _row.taxdetail_tax_basis_tax_id := _z.taxdetail_tax_basis_tax_id;
    _row.taxdetail_taxrate_percent := _z.taxdetail_taxrate_percent;
    _row.taxdetail_taxrate_amount := _z.taxdetail_taxrate_amount;
    _row.taxdetail_level := _z.taxdetail_level;
    _row.taxdetail_taxclass_id := _z.taxdetail_taxclass_id;
    _row.taxdetail_taxclass_code := _z.taxdetail_taxclass_code;
    _row.taxdetail_taxclass_sequence := _z.taxdetail_taxclass_sequence;
    _row.taxdetail_tax := _z.taxdetail_tax;
    _row.taxdetail_curr_id := _z.taxdetail_curr_id;
    _row.taxdetail_curr_abbr := _z.taxdetail_curr_abbr;

     RETURN NEXT _row;
     --Add to cumulative counter (_curcum)
     _currcum := _currcum + _z.taxdetail_tax ;

    END LOOP;

   END LOOP;

END;
 $_$;


ALTER FUNCTION public.calculatetaxdetail(integer, integer, date, integer, numeric) OWNER TO admin;

--
-- TOC entry 1182 (class 1255 OID 146565720)
-- Dependencies: 2708 4536 8
-- Name: calculatetaxdetailline(text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calculatetaxdetailline(text, integer) RETURNS SETOF taxdetail
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pOrderType ALIAS FOR $1;
  pOrderId ALIAS FOR $2;
  _row taxdetail%ROWTYPE;
  _qry text;
  _totaltax numeric;
  _y RECORD;
  _table text;

BEGIN
   _totaltax=0.0;

   IF pOrderType = 'II' THEN
     _table := 'invcitemtax';
   ELSIF pOrderType = 'BI' THEN
     _table := 'cobilltax';
   ELSIF pOrderType = 'CI' THEN
     _table := 'cmitemtax';
   ELSIF pOrderType = 'VI' THEN
     _table := 'voitemtax';
   ELSIF pOrderType = 'TI' THEN
     _table := 'toitemtax';
   ELSIF pOrderType = 'AR' THEN
     _table := 'aropentax';
   ELSIF pOrderType = 'AP' THEN
     _table := 'apopentax';
   END IF;

   _qry := 'SELECT taxhist_tax_id as tax_id, tax_code, tax_descrip, taxhist_tax, COALESCE(taxhist_sequence,0) AS taxhist_sequence
            FROM taxhist
             JOIN tax ON (taxhist_tax_id=tax_id)
             JOIN pg_class ON (pg_class.oid=taxhist.tableoid)
            WHERE ( (taxhist_parent_id = ' || pOrderId || ')
             AND (relname=''' || _table || ''') );';

   FOR _y IN  EXECUTE _qry
   LOOP
     _row.taxdetail_tax_id=_y.tax_id;
     _row.taxdetail_tax_code = _y.tax_code;
     _row.taxdetail_tax_descrip = _y.tax_descrip;
     _row.taxdetail_tax = _y.taxhist_tax;
     _row.taxdetail_level= 0 ;
     _row.taxdetail_taxclass_sequence= _y.taxhist_sequence;
     _totaltax = _totaltax + _y.taxhist_tax;
     RETURN NEXT _row;
   END LOOP;
 END;
$_$;


ALTER FUNCTION public.calculatetaxdetailline(text, integer) OWNER TO admin;

--
-- TOC entry 1183 (class 1255 OID 146565721)
-- Dependencies: 2708 4536 8
-- Name: calculatetaxdetailsummary(text, integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calculatetaxdetailsummary(text, integer, text) RETURNS SETOF taxdetail
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pOrderType ALIAS FOR $1;
  pOrderId ALIAS FOR $2;
  pDisplayType ALIAS FOR $3;
  _row taxdetail%ROWTYPE;
  _qry text := '';
  _qry1 text;
  _totaltax numeric;
  _x RECORD;
  _y RECORD;
  _table text;

BEGIN
 _totaltax=0.0;
 IF pOrderType IN ('S','Q','RA','PO') THEN

   IF pOrderType = 'S' THEN
     _qry := 'SELECT ' || 'COALESCE(cohead_taxzone_id, -1) AS taxzone_id, cohead_orderdate AS order_date,
                cohead_curr_id AS curr_id, COALESCE(coitem_taxtype_id, -1) AS taxtype_id,
                ROUND((coitem_qtyord * coitem_qty_invuomratio) * (coitem_price / coitem_price_invuomratio),2) AS amount
              FROM cohead, coitem
              WHERE ( (coitem_cohead_id = ' || pOrderId || ')
               AND (' || 'cohead_id = coitem_cohead_id)
               AND ( coitem_status != ''X'') )';
   ELSEIF  pOrderType = 'Q' THEN
     _qry := 'SELECT ' || 'COALESCE(quhead_taxzone_id, -1) AS taxzone_id, quhead_quotedate AS order_date,
                quhead_curr_id AS curr_id, COALESCE(quitem_taxtype_id, -1) AS taxtype_id,
                ROUND((quitem_qtyord * quitem_qty_invuomratio) * (quitem_price / quitem_price_invuomratio),2) AS amount
              FROM quhead, quitem
              WHERE ( (quitem_quhead_id = ' || pOrderId || ')
               AND (quhead_id = quitem_quhead_id) )';
   ELSEIF  pOrderType = 'RA' THEN
     _qry := 'SELECT ' || 'COALESCE(rahead_taxzone_id, -1) AS taxzone_id, rahead_authdate AS order_date,
                rahead_curr_id AS curr_id, COALESCE(raitem_taxtype_id, -1) AS taxtype_id,
                ROUND((raitem_qtyauthorized * raitem_qty_invuomratio) * (raitem_unitprice / raitem_price_invuomratio),2) AS amount
              FROM rahead, raitem
              WHERE ( (raitem_rahead_id = ' || pOrderId || ')
               AND (rahead_id = raitem_rahead_id) )';
   ELSEIF  pOrderType = 'PO' THEN
     _qry := 'SELECT ' || 'COALESCE(pohead_taxzone_id, -1) AS taxzone_id, pohead_orderdate AS order_date,
                pohead_curr_id AS curr_id, COALESCE(poitem_taxtype_id, -1) AS taxtype_id,
                ROUND(poitem_qty_ordered * poitem_unitprice, 2) AS amount
              FROM pohead, poitem
              WHERE ( (poitem_pohead_id = ' || pOrderId || ')
               AND (pohead_id = poitem_pohead_id) )';
  END IF;

  FOR _x IN EXECUTE _qry
  LOOP
    _qry1 := 'SELECT * from calculatetaxdetail(' || _x.taxzone_id || ',' || _x.taxtype_id || ',''' || _x.order_date || ''',' || _x.curr_id  || ',' || _x.amount || ')';
    FOR _y IN  EXECUTE _qry1
    LOOP
      _row.taxdetail_tax_id=_y.taxdetail_tax_id;
      _row.taxdetail_tax_code = _y.taxdetail_tax_code;
      _row.taxdetail_tax_descrip = _y.taxdetail_tax_descrip;
      _row.taxdetail_tax = _y.taxdetail_tax;
      _row.taxdetail_level=_y.taxdetail_level;
      _row.taxdetail_taxclass_sequence= _y.taxdetail_taxclass_sequence;
      _totaltax = _totaltax + _y.taxdetail_tax;
      RETURN NEXT _row;
    END LOOP;
  END LOOP;

  IF pDisplayType = 'T' AND pOrderType <> 'PO' THEN
   IF pOrderType = 'S' THEN
    _qry := 'SELECT COALESCE(cohead_taxzone_id, -1) AS taxzone_id, cohead_orderdate AS order_date,
               cohead_curr_id AS curr_id, cohead_freight AS freight
             FROM cohead WHERE cohead_id = ' || pOrderId ;
   ELSEIF  pOrderType = 'Q' THEN
    _qry := 'SELECT COALESCE(quhead_taxzone_id, -1) AS taxzone_id, quhead_quotedate AS order_date,
               quhead_curr_id AS curr_id, COALESCE(quhead_freight,0) AS freight
             FROM quhead WHERE quhead_id = ' || pOrderId;
   ELSEIF pOrderType = 'RA' THEN
    _qry := 'SELECT COALESCE(rahead_taxzone_id, -1) AS taxzone_id, COALESCE(rahead_authdate,CURRENT_DATE) AS order_date,
               rahead_curr_id AS curr_id, COALESCE(rahead_freight,0) AS freight
             FROM rahead WHERE rahead_id = ' || pOrderId;
   END IF;

  FOR _x IN EXECUTE _qry
  LOOP
     _qry1 := 'SELECT * from calculatetaxdetail(' || _x.taxzone_id || ', getfreighttaxtypeid(),''' || _x.order_date || ''',' || _x.curr_id  || ',' || _x.freight || ')';
    FOR _y IN  EXECUTE _qry1
    LOOP
       _row.taxdetail_tax_id=_y.taxdetail_tax_id;
       _row.taxdetail_tax_code = _y.taxdetail_tax_code;
       _row.taxdetail_tax_descrip = _y.taxdetail_tax_descrip;
       _row.taxdetail_tax = _y.taxdetail_tax;
       _row.taxdetail_level=_y.taxdetail_level;
       _row.taxdetail_taxclass_sequence= _y.taxdetail_taxclass_sequence;
       _totaltax = _totaltax + _y.taxdetail_tax;
       RETURN NEXT _row;
     END LOOP;
   END LOOP;
  END IF;

 ELSEIF pOrderType IN ('I','B','CM', 'VO','TO') THEN
   IF (pOrderType='I') THEN
     _table := 'invcheadtax';
   ELSIF (pOrderType='B') THEN
     _table := 'cobmisctax';
   ELSIF (pOrderType='CM') THEN
     _table := 'cmheadtax';
   ELSIF (pOrderType='VO') THEN
     _table := 'voheadtax';
   ELSIF (pOrderType='TO') THEN
     _table := 'tohead';
   END IF;

   IF pOrderType = 'I' AND (pDisplayType IN ('L','T')) THEN
     _qry := 'SELECT taxhist_tax_id as tax_id, tax_code, tax_descrip, taxhist_tax, taxhist_sequence
              FROM invchead, invcitemtax LEFT OUTER JOIN tax ON (taxhist_tax_id=tax_id)
               LEFT OUTER JOIN invcitem ON (invcitem_id=taxhist_parent_id)
              WHERE invcitem_invchead_id = ' || pOrderId || '
               AND invchead_id = invcitem_invchead_id ';
   ELSIF pOrderType = 'B' AND (pDisplayType IN ('L','T')) THEN
    _qry := 'SELECT taxhist_tax_id as tax_id, tax_code, tax_descrip, taxhist_tax, taxhist_sequence
             FROM cobmisc, cobilltax LEFT OUTER JOIN tax ON (taxhist_tax_id=tax_id)
             LEFT OUTER JOIN cobill ON (cobill_id=taxhist_parent_id)
             WHERE cobill_cobmisc_id = ' || pOrderId || '
             AND cobmisc_id = cobill_cobmisc_id ';
   ELSIF pOrderType = 'CM' AND (pDisplayType IN ('L','T')) THEN
    _qry := 'SELECT taxhist_tax_id as tax_id, tax_code, tax_descrip, taxhist_tax, taxhist_sequence
             FROM cmhead, cmitemtax LEFT OUTER JOIN tax ON (taxhist_tax_id=tax_id)
             LEFT OUTER JOIN cmitem ON (cmitem_id=taxhist_parent_id)
             WHERE cmitem_cmhead_id = ' || pOrderId || '
             AND cmhead_id = cmitem_cmhead_id ';
   ELSIF pOrderType = 'VO' AND (pDisplayType IN ('L','T')) THEN
    _qry := 'SELECT taxhist_tax_id as tax_id, tax_code, tax_descrip, taxhist_tax, taxhist_sequence
             FROM vohead, voitemtax LEFT OUTER JOIN tax ON (taxhist_tax_id=tax_id)
             LEFT OUTER JOIN voitem ON (voitem_id=taxhist_parent_id)
             WHERE voitem_vohead_id = ' || pOrderId || '
             AND vohead_id = voitem_vohead_id ';
   ELSIF pOrderType = 'TO' AND (pDisplayType IN ('L','T')) THEN
    _qry := 'SELECT taxhist_tax_id as tax_id, tax_code, tax_descrip, taxhist_tax, taxhist_sequence
             FROM tohead, toitemtax LEFT OUTER JOIN tax ON (taxhist_tax_id=tax_id)
             LEFT OUTER JOIN toitem ON (toitem_id=taxhist_parent_id)
             WHERE toitem_tohead_id = ' || pOrderId || '
             AND tohead_id = toitem_tohead_id ';
   END IF;
   IF pDisplayType IN ('F','T') AND pOrderType <> 'VO' THEN
     IF (length(_qry) > 0) THEN
       _qry := _qry || ' UNION ALL ';
     END IF;
     _qry := _qry || 'SELECT taxhist_tax_id as tax_id, tax_code, tax_descrip, taxhist_tax, taxhist_sequence
              FROM taxhist
               JOIN tax ON (taxhist_tax_id=tax_id)
               JOIN pg_class ON (pg_class.oid=taxhist.tableoid)
              WHERE ( (taxhist_parent_id = ' || pOrderId || ')
               AND (taxhist_taxtype_id=getfreighttaxtypeid())
               AND (relname=''' || _table || ''') )';
   END IF;
   IF pDisplayType IN ('A','T') THEN
     IF (length(_qry) > 0) THEN
       _qry := _qry || ' UNION ALL ';
     END IF;
     _qry := _qry || 'SELECT taxhist_tax_id as tax_id, tax_code, tax_descrip, taxhist_tax, taxhist_sequence
              FROM taxhist
               JOIN tax ON (taxhist_tax_id=tax_id)
               JOIN pg_class ON (pg_class.oid=taxhist.tableoid)
              WHERE ( (taxhist_parent_id = ' || pOrderId || ')
               AND (taxhist_taxtype_id=getadjustmenttaxtypeid())
               AND (relname=''' || _table || ''') )';

   END IF;
   FOR _y IN  EXECUTE _qry
   LOOP
     _row.taxdetail_tax_id=_y.tax_id;
     _row.taxdetail_tax_code = _y.tax_code;
     _row.taxdetail_tax_descrip = _y.tax_descrip;
     _row.taxdetail_tax = _y.taxhist_tax;
     _row.taxdetail_level= 0 ;
     _row.taxdetail_taxclass_sequence= COALESCE(_y.taxhist_sequence,0);
     _totaltax = _totaltax + _y.taxhist_tax;
     RETURN NEXT _row;
   END LOOP;
 END IF;
 END;
$_$;


ALTER FUNCTION public.calculatetaxdetailsummary(text, integer, text) OWNER TO admin;

--
-- TOC entry 1184 (class 1255 OID 146565723)
-- Dependencies: 4536 8
-- Name: calculatetaxhist(text, integer, integer, integer, date, integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calculatetaxhist(text, integer, integer, integer, date, integer, numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTableName ALIAS FOR $1;
  pParentId  ALIAS FOR $2;
  pTaxZoneId ALIAS FOR $3;
  pTaxTypeId ALIAS FOR $4;
  pDate      ALIAS FOR $5;
  pCurrId    ALIAS FOR $6;
  pAmount    ALIAS FOR $7;
  _qry TEXT;

BEGIN
  IF (pTableName IS NULL) THEN
    RAISE EXCEPTION 'A table name is required to calculate tax history';
  ELSEIF (pParentId IS NULL) THEN
    RAISE EXCEPTION 'A parent ID is required to calculate tax history';
  ELSEIF (pDate IS NULL) THEN
    RAISE EXCEPTION 'A date is required to calculate tax history';
  ELSEIF (pAmount IS NULL) THEN
     RAISE EXCEPTION 'An amount is required to calculate tax history';
  END IF;

  -- Build a query that deletes any previous tax history for this document record
  _qry := 'DELETE FROM ' || pTableName || ' WHERE taxhist_parent_id = ' || pParentId || ' AND taxhist_taxtype_id <> getadjustmenttaxtypeid();';
  EXECUTE _qry;

  -- Next, build and execute query that inserts new rows.
  _qry := 'INSERT INTO ' || pTableName || ' (
             taxhist_parent_id, taxhist_taxtype_id, taxhist_tax_id, taxhist_basis,
             taxhist_basis_tax_id, taxhist_sequence, taxhist_percent,
             taxhist_amount, taxhist_tax, taxhist_docdate)
           SELECT ' || pParentId || ',';
  IF (pTaxTypeId IS NULL) THEN
    _qry := _qry || 'NULL';
  ELSE
    _qry := _qry || pTaxTypeId;
  END If;
  _qry := _qry || ', taxdetail_tax_id,' || pAmount || ',
             taxdetail_tax_basis_tax_id, taxdetail_taxclass_sequence, taxdetail_taxrate_percent,
             taxdetail_taxrate_amount, taxdetail_tax, ''' || pDate || '''
           FROM calculatetaxdetail(' || COALESCE(pTaxZoneId,-1) || ',' || COALESCE(pTaxTypeId,-1) ||',''' || pDate || ''',' || pCurrId || ',' || pAmount || ');';
  EXECUTE _qry;

  RETURN true;
END;
$_$;


ALTER FUNCTION public.calculatetaxhist(text, integer, integer, integer, date, integer, numeric) OWNER TO admin;

--
-- TOC entry 1185 (class 1255 OID 146565724)
-- Dependencies: 4536 8
-- Name: calcvoucheramt(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calcvoucheramt(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVoucherid ALIAS FOR $1;
  _amount NUMERIC := 0;

BEGIN

  SELECT SUM(COALESCE(vodist_amount, 0)) INTO _amount
  FROM vodist
  WHERE (vodist_vohead_id=pVoucherid);

  RETURN _amount;

END;
$_$;


ALTER FUNCTION public.calcvoucheramt(integer) OWNER TO admin;

--
-- TOC entry 1186 (class 1255 OID 146565725)
-- Dependencies: 4536 8
-- Name: calcvoucherfreight(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calcvoucherfreight(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVoucherid ALIAS FOR $1;
  _amount NUMERIC := 0;

BEGIN

  SELECT SUM(COALESCE(voitem_freight, 0)) INTO _amount
  FROM voitem
  WHERE (voitem_vohead_id=pVoucherid);

  RETURN _amount;

END;
$_$;


ALTER FUNCTION public.calcvoucherfreight(integer) OWNER TO admin;

--
-- TOC entry 1187 (class 1255 OID 146565726)
-- Dependencies: 4536 8
-- Name: calcvouchertax(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calcvouchertax(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVoucherid ALIAS FOR $1;
  _amount NUMERIC := 0;

BEGIN

  SELECT COALESCE(calculateTax(vohead_taxzone_id,
                               vohead_taxtype_id,
                               vohead_docdate,
                               vohead_curr_id,
                               calcVoucherAmt(vohead_id)), 0) INTO _amount
  FROM vohead
  WHERE (vohead_id=pVoucherid);

  RETURN _amount;

END;
$_$;


ALTER FUNCTION public.calcvouchertax(integer) OWNER TO admin;

--
-- TOC entry 1188 (class 1255 OID 146565727)
-- Dependencies: 4536 8
-- Name: calcwooperstartstub(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION calcwooperstartstub(integer, integer) RETURNS date
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoId         ALIAS FOR $1;
  pBooitemSeqId ALIAS FOR $2;
  _result       DATE;
BEGIN

  IF ( SELECT ((metric_value='t') AND packageIsEnabled('xtmfg'))
         FROM metric
        WHERE(metric_name='Routings') ) THEN
    RETURN xtmfg.calcWooperStart(pWoId, pBooitemSeqId);
  END IF;
  RETURN null;
END;
$_$;


ALTER FUNCTION public.calcwooperstartstub(integer, integer) OWNER TO admin;

--
-- TOC entry 1189 (class 1255 OID 146565728)
-- Dependencies: 4536 8
-- Name: cancelbillingselection(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION cancelbillingselection(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCobmiscid ALIAS FOR $1;

BEGIN

  IF ( ( SELECT cobmisc_posted
         FROM cobmisc
         WHERE (cobmisc_id=pCobmiscid) ) ) THEN
    RETURN -1;
  END IF;

  DELETE FROM cobill
  WHERE (cobill_cobmisc_id=pCobmiscid);

  DELETE FROM cobmisc
  WHERE (cobmisc_id=pCobmiscid);

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.cancelbillingselection(integer) OWNER TO admin;

--
-- TOC entry 1190 (class 1255 OID 146565729)
-- Dependencies: 4536 8
-- Name: changeaccountingperioddates(integer, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION changeaccountingperioddates(integer, date, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPeriodid ALIAS FOR $1;
  pStartDate ALIAS FOR $2;
  pEndDate ALIAS FOR $3;
  _check INTEGER;
  _r RECORD;

BEGIN

--  Check to make sure that the passed period is not closed
  IF ( ( SELECT period_closed
         FROM period
         WHERE (period_id=pPeriodid) ) ) THEN
    RETURN -1;
  END IF;

--  Check to make sure that the passed start date does not fall
--  into another period
  SELECT period_id INTO _check
  FROM period
  WHERE ( (pStartDate BETWEEN period_start AND period_end)
    AND (period_id <> pPeriodid) )
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -2;
  END IF;

--  Check to make sure that the passed end date does not fall
--  into another period
  SELECT period_id INTO _check
  FROM period
  WHERE ( (pEndDate BETWEEN period_start AND period_end)
    AND (period_id <> pPeriodid) )
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -3;
  END IF;

--  Check to make sure that the new passed start and end dates do not
--  orphan a posted G/L Transaction
  SELECT gltrans_id INTO _check
  FROM gltrans, period
  WHERE ( (gltrans_date BETWEEN period_start AND period_end)
   AND (gltrans_posted)
   AND (NOT (gltrans_date BETWEEN pStartDate AND pEndDate))
   AND (period_id=pPeriodid) )
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -4;
  END IF;

--  Alter the start and end dates of the pass period
  UPDATE period
  SET period_start=pStartDate, period_end=pEndDate
  WHERE (period_id=pPeriodid);

--  Post any unposted G/L Transactions into the period
  FOR _r IN SELECT DISTINCT gltrans_sequence
            FROM gltrans
            WHERE ( (NOT gltrans_posted)
             AND (gltrans_date BETWEEN pStartDate AND pEndDate) ) LOOP
    PERFORM postIntoTrialBalance(_r.gltrans_sequence);
  END LOOP;

--  All done
  RETURN 1;

END;
$_$;


ALTER FUNCTION public.changeaccountingperioddates(integer, date, date) OWNER TO admin;

--
-- TOC entry 1192 (class 1255 OID 146565730)
-- Dependencies: 4536 8
-- Name: changeaccountingyearperioddates(integer, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION changeaccountingyearperioddates(integer, date, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPeriodid ALIAS FOR $1;
  pStartDate ALIAS FOR $2;
  pEndDate ALIAS FOR $3;
  _check INTEGER;
  _checkBool BOOLEAN;
  _r RECORD;

BEGIN

--  Check to make sure that the passed yearperiod is not closed
  IF ( ( SELECT yearperiod_closed
         FROM yearperiod
         WHERE (yearperiod_id=pPeriodid) ) ) THEN
    RETURN -1;
  END IF;

--  Check to make sure that the passed start date does not fall
--  into another yearperiod
  SELECT yearperiod_id INTO _check
  FROM yearperiod
  WHERE ( (pStartDate BETWEEN yearperiod_start AND yearperiod_end)
    AND (yearperiod_id <> pPeriodid) )
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -2;
  END IF;

--  Check to make sure that the passed end date does not fall
--  into another yearperiod
  SELECT yearperiod_id INTO _check
  FROM yearperiod
  WHERE ( (pEndDate BETWEEN yearperiod_start AND yearperiod_end)
    AND (yearperiod_id <> pPeriodid) )
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -3;
  END IF;

--  Check to make sure that the passed yearperiod is not closed
  IF ( ( SELECT (count(period_id) > 0)
         FROM period
         WHERE ((period_yearperiod_id=pPeriodid)
          AND (period_start < pStartDate OR period_end > pEndDate)) ) ) THEN
    RETURN -4;
  END IF;

--  Make sure that the passed start is prior to the end date
  SELECT (pStartDate > pEndDate) INTO _checkBool;
  IF (_checkBool) THEN
    RETURN -5;
  END IF;


--  Alter the start and end dates of the pass period
  UPDATE yearperiod
  SET yearperiod_start=pStartDate, yearperiod_end=pEndDate
  WHERE (yearperiod_id=pPeriodid);

--  All done
  RETURN 1;

END;
$_$;


ALTER FUNCTION public.changeaccountingyearperioddates(integer, date, date) OWNER TO admin;

--
-- TOC entry 1193 (class 1255 OID 146565731)
-- Dependencies: 4536 8
-- Name: changefkeypointers(text, text, integer, integer, text[], boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION changefkeypointers(text, text, integer, integer, text[], boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSchema       ALIAS FOR $1;
  pTable        ALIAS FOR $2;
  pSourceId     ALIAS FOR $3;
  pTargetId     ALIAS FOR $4;
  pIgnore       ALIAS FOR $5;
  _purge        BOOLEAN := COALESCE($6, FALSE);

  _counter      INTEGER := 0;
  _count1       INTEGER := 0;
  _fk           RECORD;
  _pk           TEXT[];

BEGIN
  -- for all foreign keys that point to pSchema.pTable
  FOR _fk IN
    EXECUTE 'SELECT fkeyns.nspname AS schemaname, fkeytab.relname AS tablename,
                    conkey, attname, typname
               FROM pg_constraint
               JOIN pg_class     basetab ON (confrelid=basetab.oid)
               JOIN pg_namespace basens  ON (basetab.relnamespace=basens.oid)
               JOIN pg_class     fkeytab ON (conrelid=fkeytab.oid)
               JOIN pg_namespace fkeyns  ON (fkeytab.relnamespace=fkeyns.oid)
               JOIN pg_attribute         ON (attrelid=conrelid AND attnum=conkey[1])
               JOIN pg_type              ON (atttypid=pg_type.oid)
              WHERE basetab.relname = ' || quote_literal(pTable)  || '
                AND basens.nspname  = ' || quote_literal(pSchema) || '
                AND fkeytab.relname NOT IN (''' || ARRAY_TO_STRING(pIgnore, ''', ''') || ''')'
  LOOP
    IF (ARRAY_UPPER(_fk.conkey, 1) > 1) THEN
      RAISE EXCEPTION 'Cannot change the foreign key in %.% that refers to %.% because the foreign key constraint has multiple columns. [xtuple: changefkeypointers, -1, %.%, %.%]',
        _fk.schemaname, _fk.tablename, pSchema, pTable,
        _fk.schemaname, _fk.tablename, pSchema, pTable;
    END IF;

    -- optionally make a backup copy of the data
    IF (NOT _purge) THEN
      -- determine the primary key column of the fkey table
      _pk := primaryKeyFields(_fk.schemaname, _fk.tablename);
      IF (ARRAY_UPPER(_pk, 1) > 1) THEN
        RAISE EXCEPTION 'Cannot change foreign key references in %.% because it has a composite primary key. Try setting the purge option. [xtuple: changefkeypointers, -4, %.%]',
                        _fk.schemaname, _fk.tablename, _fk.schemaname, _fk.tablename;
      END IF;

      -- make the backup copy
      EXECUTE 'INSERT INTO mrgundo (
                     mrgundo_schema,      mrgundo_table,
                     mrgundo_pkey_col,    mrgundo_pkey_id,
                     mrgundo_col,         mrgundo_value,      mrgundo_type,
                     mrgundo_base_schema, mrgundo_base_table, mrgundo_base_id
             ) SELECT ' || quote_literal(_fk.schemaname) || ', '
                        || quote_literal(_fk.tablename)  || ', '
                        || quote_literal(_pk[1])         || ', '
                        || _pk[1]                        || ', '
                        || quote_literal(_fk.attname)    || ', '
                        || _fk.attname                   || ', '
                        || quote_literal(_fk.typname)    || ', '
                        || quote_literal(pSchema)        || ', '
                        || quote_literal(pTable)         || ', '
                        || pTargetId                     || '
                 FROM ' || _fk.schemaname || '.' || _fk.tablename ||
              ' WHERE ('|| _fk.attname    || '=' || pSourceId || ');';
    END IF;

    -- actually change the foreign keys to point to the desired base table record
    EXECUTE 'UPDATE '  || _fk.schemaname || '.' || _fk.tablename ||
              ' SET '  || _fk.attname    || '=' || pTargetId ||
            ' WHERE (' || _fk.attname    || '=' || pSourceId || ');';

    GET DIAGNOSTICS _count1 = ROW_COUNT;
    _counter := _counter + _count1;
  END LOOP;

  RETURN _counter;
END;
$_$;


ALTER FUNCTION public.changefkeypointers(text, text, integer, integer, text[], boolean) OWNER TO admin;

--
-- TOC entry 8948 (class 0 OID 0)
-- Dependencies: 1193
-- Name: FUNCTION changefkeypointers(text, text, integer, integer, text[], boolean); Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON FUNCTION changefkeypointers(text, text, integer, integer, text[], boolean) IS 'Change the data in all tables with foreign key relationships so they point to the pSchema.pTable record with primary key pTargetId instead of the record with primary key pSourceId. Ignore any tables listed in pIgnore. If the final arg is TRUE, make a backup copy of the original data in the mrgundo table.';


--
-- TOC entry 1194 (class 1255 OID 146565732)
-- Dependencies: 4536 8
-- Name: changepoitemduedate(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION changepoitemduedate(ppoitemid integer, pdate date) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  RETURN changePoitemDueDate(pPoitemid, pDate, false);

END;
$$;


ALTER FUNCTION public.changepoitemduedate(ppoitemid integer, pdate date) OWNER TO admin;

--
-- TOC entry 1195 (class 1255 OID 146565733)
-- Dependencies: 4536 8
-- Name: changepoitemduedate(integer, date, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION changepoitemduedate(ppoitemid integer, pdate date, pbyso boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  IF ( ( SELECT (poitem_status IN ('C'))
         FROM poitem
         WHERE (poitem_id=pPoitemid) ) ) THEN
    RETURN -1;
  END IF;

  UPDATE poitem
  SET poitem_duedate=pDate
  WHERE (poitem_id=pPoitemid);

  IF (pBySO) THEN
    --Generate the PoItemUpdatedBySo event
    PERFORM postEvent('PoItemUpdatedBySo', 'P', poitem_id,
                      itemsite_warehous_id,
                      (pohead_number || '-'|| poitem_linenumber || ': ' || item_number),
                      NULL, NULL, NULL, NULL)
    FROM poitem JOIN pohead ON (pohead_id=poitem_pohead_id)
                JOIN itemsite ON (itemsite_id=poitem_itemsite_id)
                JOIN item ON (item_id=itemsite_item_id)
    WHERE (poitem_id=pPoitemid)
      AND (poitem_duedate <= (CURRENT_DATE + itemsite_eventfence));
  END IF;

  RETURN pPoitemid;

END;
$$;


ALTER FUNCTION public.changepoitemduedate(ppoitemid integer, pdate date, pbyso boolean) OWNER TO admin;

--
-- TOC entry 1196 (class 1255 OID 146565734)
-- Dependencies: 4536 8
-- Name: changepoitemqty(integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION changepoitemqty(ppoitemid integer, pqty numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  RETURN changePoitemQty(pPoitemid, pQty, false);

END;
$$;


ALTER FUNCTION public.changepoitemqty(ppoitemid integer, pqty numeric) OWNER TO admin;

--
-- TOC entry 1197 (class 1255 OID 146565735)
-- Dependencies: 4536 8
-- Name: changepoitemqty(integer, numeric, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION changepoitemqty(ppoitemid integer, pqty numeric, pbyso boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE

BEGIN

  IF ( ( SELECT (poitem_status IN ('C'))
         FROM poitem
         WHERE (poitem_id=pPoitemid) ) ) THEN
    RETURN -1;
  END IF;

  UPDATE poitem
  SET poitem_qty_ordered=pQty
  WHERE (poitem_id=pPoitemid);

  IF (pBySO) THEN
    --Generate the PoItemUpdatedBySo event
    PERFORM postEvent('PoItemUpdatedBySo', 'P', poitem_id,
                      itemsite_warehous_id,
                      (pohead_number || '-'|| poitem_linenumber || ': ' || item_number),
                      NULL, NULL, NULL, NULL)
    FROM poitem JOIN pohead ON (pohead_id=poitem_pohead_id)
                JOIN itemsite ON (itemsite_id=poitem_itemsite_id)
                JOIN item ON (item_id=itemsite_item_id)
    WHERE (poitem_id=pPoitemid)
      AND (poitem_duedate <= (CURRENT_DATE + itemsite_eventfence));
  END IF;

  RETURN pPoitemid;

END;
$$;


ALTER FUNCTION public.changepoitemqty(ppoitemid integer, pqty numeric, pbyso boolean) OWNER TO admin;

--
-- TOC entry 1198 (class 1255 OID 146565736)
-- Dependencies: 4536 8
-- Name: changeprdate(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION changeprdate(integer, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPrid ALIAS FOR $1;
  pDueDate ALIAS FOR $2;

BEGIN

  UPDATE pr
  SET pr_duedate=pDueDate
  WHERE (pr_id=pPrid);

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.changeprdate(integer, date) OWNER TO admin;

--
-- TOC entry 1199 (class 1255 OID 146565737)
-- Dependencies: 4536 8
-- Name: changeprqty(integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION changeprqty(integer, numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPrid ALIAS FOR $1;
  pQty ALIAS FOR $2;

BEGIN

  UPDATE pr
  SET pr_qtyreq=pQty
  WHERE (pr_id=pPrid);

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.changeprqty(integer, numeric) OWNER TO admin;

--
-- TOC entry 1200 (class 1255 OID 146565738)
-- Dependencies: 4536 8
-- Name: changeprqty(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION changeprqty(integer, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
  pPrid ALIAS FOR $1;
  pDueDate ALIAS FOR $2;

BEGIN

  UPDATE pr
  SET pr_duedate=pDueDate
  WHERE (pr_id=pPrid);

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.changeprqty(integer, date) OWNER TO admin;

--
-- TOC entry 1201 (class 1255 OID 146565739)
-- Dependencies: 4536 8
-- Name: changepseudofkeypointers(text, text, text, integer, text, text, integer, text, text, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION changepseudofkeypointers(text, text, text, integer, text, text, integer, text, text, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSchema       ALIAS FOR $1;
  pTable        ALIAS FOR $2;
  pFkeyCol      ALIAS FOR $3;
  pSourceId     ALIAS FOR $4;
  pBaseSchema   ALIAS FOR $5;
  pBaseTable    ALIAS FOR $6;
  pTargetId     ALIAS FOR $7;
  pTypeCol      ALIAS FOR $8;
  pType         ALIAS FOR $9;
  _purge        BOOLEAN := COALESCE($10, FALSE);

  _counter      INTEGER := 0;
  _coltype      TEXT;
  _pk           TEXT[];

BEGIN
  IF (NOT _purge) THEN
    EXECUTE 'SELECT typname
               FROM pg_type
               JOIN pg_attribute ON (pg_type.oid=atttypid)
               JOIN pg_class     ON (attrelid=pg_class.oid)
               JOIN pg_namespace ON (relnamespace=pg_namespace.oid)
              WHERE (relname=' || quote_literal(pTable)   || ')
                AND (nspname=' || quote_literal(pSchema)  || ')
                AND (attname=' || quote_literal(pFkeyCol) || ')' INTO _coltype;

    _pk := primaryKeyFields(pSchema, pTable);
    IF (ARRAY_UPPER(_pk, 1) > 1) THEN
       RAISE EXCEPTION 'Cannot change pseudo-foreign key references in %.% because it has a composite primary key. Try setting the purge option. [xtuple: changepseudofkeypointers, -1, %.%',
                        pSchema, pTable, pSchema, pTable;
    END IF;

    EXECUTE 'INSERT INTO mrgundo (
                     mrgundo_schema,      mrgundo_table,
                     mrgundo_pkey_col,    mrgundo_pkey_id,
                     mrgundo_col,         mrgundo_value,      mrgundo_type,
                     mrgundo_base_schema, mrgundo_base_table, mrgundo_base_id
           ) SELECT ' || quote_literal(pSchema)     || ', '
                      || quote_literal(pTable)      || ', '
                      || quote_literal(_pk[1])      || ', '
                      || quote_ident(_pk[1])        || ', '
                      || quote_literal(pFkeyCol)    || ', '
                      || quote_ident(pFkeyCol)      || ', '
                      || quote_literal(_coltype)    || ', '
                      || quote_literal(pBaseSchema) || ', '
                      || quote_literal(pBaseTable)  || ', '
                      || pTargetId                  || '
               FROM '  || quote_ident(pSchema)  || '.' || quote_ident(pTable) || '
              WHERE (('|| quote_ident(pFkeyCol) || '=' || pSourceId || ')
                 AND ('|| quote_ident(pTypeCol) || '=' || quote_literal(pType) || '));';
  END IF;

  -- actually change the foreign keys to point to the desired base table record
  EXECUTE 'UPDATE '  || quote_ident(pSchema)  || '.' || quote_ident(pTable) ||
            ' SET '  || quote_ident(pFkeyCol) || '=' || pTargetId ||
          ' WHERE ((' || quote_ident(pFkeyCol) || '=' || pSourceId || ')
               AND (' || quote_ident(pTypeCol) || '=' || quote_literal(pType) || '));';

  GET DIAGNOSTICS _counter = ROW_COUNT;

  RETURN _counter;
END;
$_$;


ALTER FUNCTION public.changepseudofkeypointers(text, text, text, integer, text, text, integer, text, text, boolean) OWNER TO admin;

--
-- TOC entry 8949 (class 0 OID 0)
-- Dependencies: 1201
-- Name: FUNCTION changepseudofkeypointers(text, text, text, integer, text, text, integer, text, text, boolean); Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON FUNCTION changepseudofkeypointers(text, text, text, integer, text, text, integer, text, text, boolean) IS 'Change the data in pSchema.pTable with a pseudo-foreign key relationship to another (unnamed) table. Make pSchema.pTable point to the record with primary key pTargetId instead of the record with primary key pSourceId. pSchema.pTable cannot have a true foreign key relationship because it holds data that can point to any of several tables. The pType value in the pTypeCol column describes which table the data refer to (e.g. "T" may indicate that the current record refers to a "cntct"). If the final arg is TRUE, make a backup copy of the data in the mrgundo table.';


--
-- TOC entry 1202 (class 1255 OID 146565740)
-- Dependencies: 4536 8
-- Name: changepurchasedropship(integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION changepurchasedropship(pcoitemid integer, ppoitemid integer, pdropship boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _s RECORD;
  _w RECORD;
  _p RECORD;
  _result INTEGER;
  _poitemid INTEGER;

BEGIN

  -- Check for existing poitem for this coitem
  SELECT * INTO _p
  FROM poitem JOIN pohead ON (pohead_id=poitem_pohead_id)
  WHERE (poitem_id=pPoitemId)
    AND (poitem_order_id=pCoitemId)
    AND (poitem_order_type='S');
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Change Purchase Drop Ship PO not found';
  END IF;

  SELECT * INTO _s
  FROM coitem JOIN cohead ON (cohead_id = coitem_cohead_id)
    LEFT OUTER JOIN shiptoinfo ON (cohead_shipto_id = shipto_id)
    LEFT OUTER JOIN cntct ON (shipto_cntct_id = cntct_id)
    LEFT OUTER JOIN addr ON (shipto_addr_id = addr_id)
  WHERE (coitem_id = pCoitemId);
  IF (NOT FOUND) THEN
    RETURN -1;
  END IF;

  IF (_p.pohead_status != 'U') THEN
    RETURN -3;
  END IF;

  SELECT deletePoitem(_p.poitem_id) INTO _result;
  IF (_result < 0) THEN
    RETURN _result;
  END IF;

  SELECT createPurchaseToSale(_s.coitem_id, _p.poitem_itemsrc_id,
                              pDropShip, _s.coitem_qtyord,
                              _s.coitem_scheddate, _p.poitem_unitprice)
     INTO _poitemid;

  RETURN _poitemid;

END;
$$;


ALTER FUNCTION public.changepurchasedropship(pcoitemid integer, ppoitemid integer, pdropship boolean) OWNER TO admin;

--
-- TOC entry 1203 (class 1255 OID 146565741)
-- Dependencies: 4536 8
-- Name: changewodates(integer, date, date, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION changewodates(integer, date, date, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoid ALIAS FOR $1;
  pStartDate ALIAS FOR $2;
  pDueDate ALIAS FOR $3;
  changeChildren ALIAS FOR $4;
  _p RECORD;
  returnCode INTEGER;
  _vtemp NUMERIC;

BEGIN

  SELECT wo_status, wo_startdate, itemsite_warehous_id INTO _p
  FROM wo
  Inner Join itemsite on
      wo_itemsite_id=itemsite_id
  WHERE (wo_id=pWoid);

  IF (_p.wo_status = 'C') THEN
    returnCode := 0;

  ELSIF (_p.wo_status IN ('R','I')) THEN
    PERFORM postEvent('RWoDueDateRequestChange', 'W', wo_id,
                      itemsite_warehous_id, formatWoNumber(wo_id),
                      NULL, NULL, pDueDate, wo_duedate)
    FROM wo JOIN itemsite ON (itemsite_id=wo_itemsite_id)
            JOIN item ON (item_id=itemsite_item_id)
    WHERE (wo_id=pWoid);

     returnCode := 0;

  END IF;

--  Reschedule operations if routings enabled
  IF (fetchMetricBool('Routings')) THEN

--    Reschedule wooper
    IF (fetchMetricBool('UseSiteCalendar')) THEN
      UPDATE xtmfg.wooper
      SET wooper_scheduled = calculatenextworkingdate(itemsite_warehous_id,DATE(pStartDate),
                             CAST(calculateworkdays(itemsite_warehous_id, DATE(wo_startdate), DATE(wooper_scheduled)) as INTEGER))
      FROM wo JOIN itemsite ON (wo_itemsite_id=itemsite_id)
      WHERE ( (wooper_wo_id=wo_id)
        AND   (wo_id=pWoid) );
    ELSE
      UPDATE xtmfg.wooper
      SET wooper_scheduled = (wooper_scheduled::DATE + (pStartDate - wo_startdate))
      FROM wo
      WHERE ( (wooper_wo_id=wo_id)
        AND   (wo_id=pWoid) );
    END IF;

--    Reschedule any womatl that is linked to wooper items
--    and is set to be scheduled with the wooper in question
    UPDATE womatl
    SET womatl_duedate=wooper_scheduled
    FROM xtmfg.wooper
    WHERE ( (womatl_schedatwooper)
     AND (womatl_wooper_id=wooper_id)
     AND (womatl_wo_id=pWoid) );

  END IF;

-- Reschedule any womatl that is not linked to wooper items
  UPDATE womatl
  SET womatl_duedate=pStartDate
  WHERE ( (NOT womatl_schedatwooper)
   AND (womatl_wo_id=pWoid) );

--  Reschedule the W/O
  UPDATE wo
  SET wo_startdate=pStartDate,
      wo_duedate=pDueDate
  WHERE (wo_id=pWoid);

--  Do the same for the children
  IF (changeChildren) THEN
    SELECT MAX(changeWoDates(wo_id, (pStartDate - itemsite_leadtime), pStartDate, TRUE)) INTO returnCode
    FROM wo, itemsite
    WHERE ( (wo_itemsite_id=itemsite_id)
     AND (wo_ordtype='W')
     AND (wo_ordid=pWoid) );
  END IF;

  IF (returnCode IS NULL) THEN
    returnCode := 0;
  END IF;

  RETURN returnCode;

END;
$_$;


ALTER FUNCTION public.changewodates(integer, date, date, boolean) OWNER TO admin;

--
-- TOC entry 1204 (class 1255 OID 146565742)
-- Dependencies: 4536 8
-- Name: changewoproject(integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION changewoproject(integer, integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoid ALIAS FOR $1;
  pPrjid ALIAS FOR $2;
  changeChildren ALIAS FOR $3;
  woStatus CHAR(1);
  _result INTEGER;

BEGIN

  SELECT wo_status INTO woStatus
  FROM wo
  WHERE (wo_id=pWoid);

  UPDATE wo
  SET wo_prj_id=pPrjid
  WHERE (wo_id=pWoid);

  IF (woStatus = 'E' AND changeChildren) THEN
    _result := ( SELECT MIN(changeWoProject(wo_id, pPrjid, TRUE))
                   FROM womatl, wo
                  WHERE ((womatl_itemsite_id=wo_itemsite_id)
                    AND (wo_ordtype='W')
                    AND (womatl_wo_id=pWoid)
                    AND (wo_ordid=pWoid)) );

    UPDATE pr SET pr_prj_id=pPrjid
      FROM womatl
     WHERE ((womatl_wo_id=pWoid)
       AND  (pr_order_type='W')
       AND  (pr_order_id=womatl_id));
  ELSE
    _result = 1;
  END IF;

  RETURN _result;
END;
$_$;


ALTER FUNCTION public.changewoproject(integer, integer, boolean) OWNER TO admin;

--
-- TOC entry 1205 (class 1255 OID 146565743)
-- Dependencies: 4536 8
-- Name: changewoqty(integer, numeric, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION changewoqty(integer, numeric, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoid ALIAS FOR $1;
  pQty ALIAS FOR $2;
  changeChildren ALIAS FOR $3;
  _r RECORD;
  _result INTEGER := 1;

BEGIN

  SELECT wo_qtyord, wo_status, item_fractional INTO _r
  FROM wo JOIN itemsite ON (itemsite_id=wo_itemsite_id)
          JOIN item ON (item_id=itemsite_item_id)
  WHERE (wo_id=pWoid);

  IF (_r.wo_qtyord = pQty) THEN
    RETURN 0;
  END IF;

  IF (NOT _r.wo_status IN ('O','E','R','I')) THEN
    RETURN 1;
  END IF;

  IF (_r.wo_status IN ('R','I')) THEN
    PERFORM postEvent('RWoQtyRequestChange', 'W', wo_id,
                      itemsite_warehous_id, formatWoNumber(wo_id),
                      pQty, wo_qtyord, NULL, NULL)
    FROM wo JOIN itemsite ON (itemsite_id=wo_itemsite_id)
            JOIN item ON (item_id=itemsite_item_id)
    WHERE (wo_id=pWoid);

     _result = 0;
  END IF;

  UPDATE wo
  SET wo_qtyord=roundQty(_r.item_fractional, pQty)
  WHERE (wo_id=pWoid);

  UPDATE womatl
  SET womatl_qtyreq=(womatl_qtyfxd + wo_qtyord * womatl_qtyper) * (1 + womatl_scrap)
  FROM wo, itemsite
  WHERE ((womatl_wo_id=wo_id)
    AND  (womatl_itemsite_id=itemsite_id)
    AND  (wo_id=pWoid));

  IF (fetchMetricBool('Routings')) THEN

      UPDATE xtmfg.wooper
         SET wooper_rntime = CASE WHEN ((booitem_rnqtyper = 0) OR (booitem_invproduomratio = 0)) THEN 0
                                  WHEN (NOT booitem_rnrpt) THEN 0
                                  ELSE ( ( booitem_rntime /
                                           booitem_rnqtyper /
                                           booitem_invproduomratio ) * wo_qtyord )
                             END
        FROM xtmfg.booitem, wo
       WHERE ((wooper_wo_id=wo_id)
         AND  (wooper_booitem_id=booitem_id)
         AND  (wo_id=pWoid));
  END IF;

  IF (changeChildren) THEN
    _result := ( SELECT MIN(changeWoQty(wo_id, womatl_qtyreq, TRUE))
                 FROM womatl, wo
                 WHERE ((womatl_itemsite_id=wo_itemsite_id)
                  AND (wo_ordtype='W')
                  AND (womatl_wo_id=pWoid)
                  AND (wo_ordid=pWoid)) );
  END IF;

  RETURN _result;
END;
$_$;


ALTER FUNCTION public.changewoqty(integer, numeric, boolean) OWNER TO admin;

--
-- TOC entry 1206 (class 1255 OID 146565744)
-- Dependencies: 4536 8
-- Name: characteristicstostring(text, integer, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION characteristicstostring(text, integer, text, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTargetType ALIAS FOR $1;
  pTargetId ALIAS FOR $2;
  pValKeySep ALIAS FOR $3;
  pPairSep ALIAS FOR $4;
  _string TEXT := '';
  _extra BOOLEAN := false;
  _r RECORD;
BEGIN
  FOR _r IN SELECT char_name, charass_value
              FROM charass, char
             WHERE ((charass_char_id=char_id)
               AND  (charass_target_type=pTargetType)
               AND  (charass_target_id=pTargetId)) LOOP
    IF(_extra) THEN
      _string := _string || pPairSep;
    END IF;
    _extra := true;

    _string := _string || _r.char_name || pValKeySep || _r.charass_value;
  END LOOP;

  RETURN _string;
END;
$_$;


ALTER FUNCTION public.characteristicstostring(text, integer, text, text) OWNER TO admin;

--
-- TOC entry 1191 (class 1255 OID 146565745)
-- Dependencies: 4536 8
-- Name: checkcreditmemositeprivs(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION checkcreditmemositeprivs(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCmheadid ALIAS FOR $1;
  _check    BOOLEAN;
  _result   INTEGER;

BEGIN

  IF (NOT fetchMetricBool('MultiWhs')) THEN
    RETURN true;
  END IF;

  IF (NOT fetchUsrPrefBool('selectedSites')) THEN
    RETURN true;
  END IF;

  SELECT COALESCE(COUNT(*), 0) INTO _result
    FROM ( SELECT cmitem_id
             FROM cmitem JOIN itemsite ON (itemsite_id=cmitem_itemsite_id)
            WHERE ( (cmitem_cmhead_id=pCmheadid)
              AND   (itemsite_warehous_id NOT IN (SELECT usrsite_warehous_id
                                                    FROM usrsite
                                                   WHERE (usrsite_username=getEffectiveXtUser()))) )
         ) AS data;
  IF (_result > 0) THEN
    RETURN false;
  END IF;

  RETURN true;
END;
$_$;


ALTER FUNCTION public.checkcreditmemositeprivs(integer) OWNER TO admin;

--
-- TOC entry 1207 (class 1255 OID 146565746)
-- Dependencies: 2660 4536 8
-- Name: checkdetailformatted(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION checkdetailformatted(integer, integer) RETURNS SETOF checkdata
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCheckheadid ALIAS FOR $1;
  pMaxLines ALIAS FOR $2;
  _row checkdata%ROWTYPE;
  _checkhead RECORD;
  _checkdetail RECORD;
  _rowcount INTEGER := 0;
  _page INTEGER := 1;
  _docnumber TEXT := '';
  _docreference TEXT := '';
  _docdate TEXT := '';
  _docamount TEXT := '';
  _docdiscount TEXT := '';
  _docnetamount TEXT := '';
BEGIN

-- Check header information
  SELECT checkhead_number AS checknumber,
         INITCAP(spellAmount(checkhead_amount, curr_id)) AS checkwords,
         formatDate(checkhead_checkdate) AS checkdate,
         formatMoney(checkhead_amount) AS checkamount,
         curr_symbol AS checkcurrsymbol,
         curr_abbr AS checkcurrabbr,
         curr_name AS checkcurrname,
         CASE WHEN checkhead_recip_type = 'C' THEN (SELECT cust_name
                                                      FROM custinfo
                                                     WHERE cust_id=checkhead_recip_id)
              WHEN checkhead_recip_type = 'T' THEN (SELECT taxauth_name
                                                      FROM taxauth
                                                     WHERE taxauth_id=checkhead_recip_id)
              WHEN checkhead_recip_type = 'V' THEN
                                  COALESCE((SELECT vendaddr_name
                                              FROM vendaddrinfo
                                             WHERE((UPPER(vendaddr_code)='REMIT')
                                               AND (vendaddr_vend_id=checkhead_recip_id))),
                                           (SELECT vend_name
                                              FROM vendinfo
                                             WHERE(vend_id=checkhead_recip_id)))
         END AS checkpayto,
         formatAddr(CASE WHEN checkhead_recip_type = 'C' THEN
                                                  (SELECT cntct_addr_id
                                                   FROM cntct, custinfo
                                                    WHERE((cust_cntct_id=cntct_id)
                                                      AND (cust_id=checkhead_recip_id)))
                         WHEN checkhead_recip_type = 'T' THEN
                                                  (SELECT taxauth_addr_id
                                                     FROM taxauth
                                                    WHERE(taxauth_id=checkhead_recip_id))
                         WHEN checkhead_recip_type = 'V' THEN
                                 COALESCE((SELECT vendaddr_addr_id
                                             FROM vendaddrinfo
                                            WHERE((UPPER(vendaddr_code)='REMIT')
                                              AND (vendaddr_vend_id=checkhead_recip_id))),
                                          (SELECT vend_addr_id
                                             FROM vendinfo
                                            WHERE(vend_id=checkhead_recip_id)))
                    END) AS checkaddress,
         checkhead_for AS checkmemo
    INTO _checkhead
    FROM checkhead, curr_symbol
   WHERE((checkhead_curr_id = curr_id)
     AND (checkhead_id=pCheckheadid) );
  IF (NOT FOUND) THEN
    RETURN;
  END IF;

  _row.checkdata_page := _page;
  _row.checkdata_checknumber := _checkhead.checknumber;
  _row.checkdata_checkwords := _checkhead.checkwords;
  _row.checkdata_checkdate := _checkhead.checkdate;
  _row.checkdata_checkamount := _checkhead.checkamount;
  _row.checkdata_checkcurrsymbol := _checkhead.checkcurrsymbol;
  _row.checkdata_checkcurrabbr := _checkhead.checkcurrabbr;
  _row.checkdata_checkcurrname := _checkhead.checkcurrname;
  _row.checkdata_checkpayto := _checkhead.checkpayto;
  _row.checkdata_checkaddress := _checkhead.checkaddress;
  _row.checkdata_checkmemo := _checkhead.checkmemo;

-- Check item details
  FOR _checkdetail IN
  SELECT  --VOUCHER-------------
    1 AS ord,
    1 AS sequence_value,
    checkitem_invcnumber,
    checkitem_ponumber,
    formatMoney(checkitem_amount) AS docnetamount,
    'Invoice#: ' || vohead_invcnumber AS docnumber,
    formatDate(vohead_docdate) AS docdate,
    vohead_reference AS docreference,
    'Voucher: ' || checkitem_vouchernumber AS vouchernumber,
    formatMoney(apopen_amount) AS docamount,
    formatMoney(checkitem_discount) AS docdiscount
  FROM checkitem, vohead, apopen
  WHERE ((checkitem_checkhead_id=pCheckheadid)
    AND  (checkitem_vouchernumber = vohead_number)
    AND  (apopen_docnumber = checkitem_vouchernumber)
    AND  (apopen_doctype = 'V'))

  UNION

  SELECT --DEBIT MEMO -------------------------
    2 AS ord,
    1 AS sequence_value,
    checkitem_invcnumber,
    checkitem_ponumber,
    formatMoney(checkitem_amount) AS f_amount,
    'Debit Memo PO#: ' || checkitem_ponumber AS doc_number,
    ''  AS f_docdate,
    'Debit Memo: ' || checkitem_vouchernumber AS doc_reference,
    checkitem_vouchernumber AS vouchernumber,
    formatMoney(apopen_amount) AS amount,
    formatMoney(checkitem_discount) AS disc_cred
  FROM checkitem, apopen
  WHERE ((checkitem_checkhead_id=pCheckheadid)
    AND  (checkitem_apopen_id = apopen_id)
    AND  (apopen_doctype = 'D'))

  UNION

  SELECT --CREDIT MEMO -------------------------
    2 AS ord,
    1 AS sequence_value,
    checkitem_invcnumber,
    checkitem_ponumber,
    formatMoney(checkitem_amount * -1.0) AS f_amount,
    'Credit Memo PO#: ' || checkitem_ponumber AS doc_number,
    ''  AS f_docdate,
    'Credit Memo: ' || checkitem_vouchernumber AS doc_reference,
    checkitem_vouchernumber AS vouchernumber,
    '' AS amount,
    formatMoney(checkitem_amount) AS disc_cred
  FROM checkitem, apopen
  WHERE ((checkitem_checkhead_id=pCheckheadid)
    AND  (checkitem_apopen_id = apopen_id)
    AND  (apopen_doctype = 'C'))

  UNION

  SELECT --CREDITs FOR VOUCHERS-----------------
    3 AS ord,
    1 AS sequence_value,
    checkitem_invcnumber,
    checkitem_ponumber,
    formatMoney(checkitem_amount) AS f_amount,
    'Invoice#: ' || vohead_invcnumber AS doc_number,
    formatDate(vohead_docdate) AS f_docdate,
    'Credit Applied: ' || apapply_source_doctype || ' ' ||
                          apapply_source_docnumber AS doc_reference,
    'Voucher: ' || checkitem_vouchernumber AS vouchernumber,
    '' AS amount,
    formatMoney((apapply_amount)) AS disc_cred
  FROM checkitem, vohead, apapply
  WHERE ((checkitem_checkhead_id=pCheckheadid)
    AND  (checkitem_vouchernumber = vohead_number)
    AND  (apapply_target_docnumber = checkitem_vouchernumber)
    AND  (apapply_target_doctype = 'V')
    AND  (apapply_source_doctype = 'C'))

  UNION

  SELECT --CREDITs FOR DEBIT MEMOS-----------
    3 AS ord,
    1 AS sequence_value,
    checkitem_invcnumber,
    checkitem_ponumber,
    formatMoney(checkitem_amount) AS f_amount,
    'Debit Memo PO#: ' || checkitem_ponumber AS doc_number,
    '' AS f_docdate,
    'Credit Applied: ' || apapply_source_doctype || ' ' ||
                          apapply_source_docnumber AS doc_reference,
    'Debit Memo: ' || checkitem_vouchernumber AS vouchernumber,
    '' AS amount,
    formatMoney((apapply_amount)) AS disc_cred
  FROM checkitem, apopen, apapply
  WHERE ((checkitem_checkhead_id=pCheckheadid)
    AND  (checkitem_vouchernumber = apopen_docnumber)
    AND  (apopen_doctype = 'D')
    AND  (apapply_target_docnumber = checkitem_vouchernumber)
    AND  (apapply_target_doctype = 'D')
    AND  (apapply_source_doctype = 'C'))

  UNION

  SELECT --NON-VENDOR-----------------------
    4 AS ord,
    1 AS sequence_value,
    checkitem_invcnumber,
    checkitem_ponumber,
    formatMoney(checkitem_amount) AS f_amount,
    checkitem_invcnumber AS doc_number,
    formatDate(checkitem_docdate) AS f_docdate,
    '' AS doc_reference,
    '' AS vouchernumber,
    '' AS amount,
    '' AS disc_cred
  FROM checkhead LEFT OUTER JOIN
       checkitem ON (checkitem_checkhead_id=checkhead_id)
  WHERE ((checkhead_id=pCheckheadid)
    AND  (checkhead_recip_type != 'V')) LOOP
    IF (_rowcount = pMaxLines) THEN
      _row.checkdata_docnumber := _docnumber;
      _row.checkdata_docreference := _docreference;
      _row.checkdata_docdate := _docdate;
      _row.checkdata_docamount := _docamount;
      _row.checkdata_docdiscount := _docdiscount;
      _row.checkdata_docnetamount := _docnetamount;
      RETURN NEXT _row;

-- update/reset some variables
      _rowcount = 0;
      _page := _page + 1;
      _docnumber := '';
      _docreference := '';
      _docdate := '';
      _docamount := '';
      _docdiscount := '';
      _docnetamount := '';

      _row.checkdata_page := _page;
      _row.checkdata_checknumber := _checkhead.checknumber;
      _row.checkdata_checkwords := 'VOID VOID PAGE '||_page||' OF CHECK #'||_checkhead.checknumber||' VOID VOID';
      _row.checkdata_checkdate := 'VOID VOID VOID';
      _row.checkdata_checkamount := 'VOID VOID VOID';
      --_row.checkdata_checkcurrsymbol := _checkhead.checkcurrsymbol;
      --_row.checkdata_checkcurrabbr := _checkhead.checkcurrabbr;
      --_row.checkdata_checkcurrname := _checkhead.checkcurrname;
      _row.checkdata_checkpayto := 'VOID VOID VOID';
      --_row.checkdata_checkaddress := _checkhead.checkaddress;
      _row.checkdata_checkmemo := 'VOID VOID PAGE '||_page||' OF CHECK #'||_checkhead.checknumber||' VOID VOID';
    END IF;

    _rowcount := _rowcount + 1;
    _docnumber := _docnumber || _checkdetail.docnumber || E'\n';
    _docreference := _docreference || _checkdetail.docreference || E'\n';
    _docdate := _docdate || _checkdetail.docdate || E'\n';
    _docamount := _docamount || _checkdetail.docamount || E'\n';
    _docdiscount := _docdiscount || _checkdetail.docdiscount || E'\n';
    _docnetamount := _docnetamount || _checkdetail.docnetamount || E'\n';
  END LOOP;

  _row.checkdata_docnumber := _docnumber;
  _row.checkdata_docreference := _docreference;
  _row.checkdata_docdate := _docdate;
  _row.checkdata_docamount := _docamount;
  _row.checkdata_docdiscount := _docdiscount;
  _row.checkdata_docnetamount := _docnetamount;

  RETURN NEXT _row;
  RETURN;
END;
$_$;


ALTER FUNCTION public.checkdetailformatted(integer, integer) OWNER TO admin;

--
-- TOC entry 1208 (class 1255 OID 146565748)
-- Dependencies: 4536 8
-- Name: checkinvoicesiteprivs(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION checkinvoicesiteprivs(integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pInvcheadid ALIAS FOR $1;
  _check    BOOLEAN;
  _result   INTEGER;

BEGIN

  IF (NOT fetchMetricBool('MultiWhs')) THEN
    RETURN true;
  END IF;

  IF (NOT fetchUsrPrefBool('selectedSites')) THEN
    RETURN true;
  END IF;

  SELECT COALESCE(COUNT(*), 0) INTO _result
    FROM ( SELECT invcitem_id
             FROM invcitem
            WHERE ( (invcitem_invchead_id=pInvcheadid)
              AND   (invcitem_warehous_id <> -1)
              AND   (invcitem_warehous_id NOT IN (SELECT usrsite_warehous_id
                                                    FROM usrsite
                                                   WHERE (usrsite_username=getEffectiveXtUser()))) )
         ) AS data;
  IF (_result > 0) THEN
    RETURN false;
  END IF;

  RETURN true;
END;
$_$;


ALTER FUNCTION public.checkinvoicesiteprivs(integer) OWNER TO admin;

--
-- TOC entry 1209 (class 1255 OID 146565749)
-- Dependencies: 4536 8
-- Name: checkpositeprivs(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION checkpositeprivs(integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPoheadid ALIAS FOR $1;
  _check    BOOLEAN;
  _result   INTEGER;

BEGIN

  IF (NOT fetchMetricBool('MultiWhs')) THEN
    RETURN true;
  END IF;

  IF (NOT fetchUsrPrefBool('selectedSites')) THEN
    RETURN true;
  END IF;

  SELECT COALESCE(COUNT(*), 0) INTO _result
    FROM ( SELECT poitem_id
             FROM poitem, itemsite
            WHERE ( (poitem_pohead_id=pPoheadid)
              AND   (poitem_itemsite_id=itemsite_id)
              AND   (itemsite_warehous_id NOT IN (SELECT usrsite_warehous_id
                                                    FROM usrsite
                                                   WHERE (usrsite_username=getEffectiveXtUser()))) )
           UNION
           SELECT pohead_warehous_id
             FROM pohead
            WHERE ( (pohead_id=pPoheadid)
              AND   (pohead_warehous_id NOT IN (SELECT usrsite_warehous_id
                                                  FROM usrsite
                                                 WHERE (usrsite_username=getEffectiveXtUser()))) )
         ) AS data;
  IF (_result > 0) THEN
    RETURN false;
  END IF;

  RETURN true;
END;
$_$;


ALTER FUNCTION public.checkpositeprivs(integer) OWNER TO admin;

--
-- TOC entry 1210 (class 1255 OID 146565750)
-- Dependencies: 4536 8
-- Name: checkprivilege(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION checkprivilege(text) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPrivilege ALIAS FOR $1;
  _result TEXT;
BEGIN
  SELECT priv_id INTO _result
    FROM priv, grppriv, usrgrp
   WHERE((usrgrp_grp_id=grppriv_grp_id)
     AND (grppriv_priv_id=priv_id)
     AND (priv_name=pPrivilege)
     AND (usrgrp_username=getEffectiveXtUser()));
  IF (FOUND) THEN
    RETURN true;
  END IF;

  SELECT priv_id INTO _result
  FROM priv, usrpriv
  WHERE ((priv_id=usrpriv_priv_id)
  AND (priv_name=pPrivilege)
  AND (usrpriv_username=getEffectiveXtUser()));

  IF (FOUND) THEN
    RETURN true;
  ELSE
    RETURN false;
  END IF;
END;
$_$;


ALTER FUNCTION public.checkprivilege(text) OWNER TO admin;

--
-- TOC entry 1211 (class 1255 OID 146565751)
-- Dependencies: 4536 8
-- Name: checkquotesiteprivs(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION checkquotesiteprivs(integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pQuheadid ALIAS FOR $1;

BEGIN

  RETURN checkQuoteSitePrivs(pQuheadid, NULL);

END;
$_$;


ALTER FUNCTION public.checkquotesiteprivs(integer) OWNER TO admin;

--
-- TOC entry 1212 (class 1255 OID 146565752)
-- Dependencies: 4536 8
-- Name: checkquotesiteprivs(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION checkquotesiteprivs(integer, integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pQuheadid ALIAS FOR $1;
  pWarehousid ALIAS FOR $2;
  _result   INTEGER := 0;

BEGIN

--  RAISE NOTICE 'checkQuoteSitePrivs, pQuheadid = %', pQuheadid;
--  RAISE NOTICE 'checkQuoteSitePrivs, pWarehousid = %', pWarehousid;

  IF (NOT fetchMetricBool('MultiWhs')) THEN
    RETURN true;
  END IF;

  IF ( (NOT fetchUsrPrefBool('selectedSites')) AND (pWarehousid IS NULL) ) THEN
    RETURN true;
  END IF;

  IF (pWarehousid IS NULL) THEN
    SELECT COALESCE(COUNT(*), 0) INTO _result
    FROM quitem JOIN itemsite ON (itemsite_id=quitem_itemsite_id)
                JOIN site() ON (warehous_id=itemsite_warehous_id)
    WHERE (quitem_quhead_id=pQuheadid);
  ELSE
    SELECT COALESCE(COUNT(*), 0) INTO _result
    FROM quitem JOIN itemsite ON (itemsite_id=quitem_itemsite_id)
                JOIN site() ON (warehous_id=itemsite_warehous_id)
    WHERE ( (quitem_quhead_id=pQuheadid)
      AND   (itemsite_warehous_id=pWarehousid) );
  END IF;

  IF (_result > 0) THEN
    RETURN true;
  END IF;

  RETURN false;

END;
$_$;


ALTER FUNCTION public.checkquotesiteprivs(integer, integer) OWNER TO admin;

--
-- TOC entry 1213 (class 1255 OID 146565753)
-- Dependencies: 4536 8
-- Name: checkrasiteprivs(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION checkrasiteprivs(integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pRaheadid ALIAS FOR $1;
  _check    BOOLEAN;
  _result   INTEGER;

BEGIN

  IF (NOT fetchMetricBool('MultiWhs')) THEN
    RETURN true;
  END IF;

  IF (NOT fetchUsrPrefBool('selectedSites')) THEN
    RETURN true;
  END IF;

  SELECT COALESCE(COUNT(*), 0) INTO _result
    FROM ( SELECT raitem_id
             FROM raitem, itemsite
            WHERE ( (raitem_rahead_id=pRaheadid)
              AND   (raitem_itemsite_id=itemsite_id)
              AND   (itemsite_warehous_id NOT IN (SELECT usrsite_warehous_id
                                                    FROM usrsite
                                                   WHERE (usrsite_username=getEffectiveXtUser()))) )
           UNION
           SELECT raitem_id
             FROM raitem, itemsite
            WHERE ( (raitem_rahead_id=pRaheadid)
              AND   (raitem_coitem_itemsite_id=itemsite_id)
              AND   (itemsite_warehous_id NOT IN (SELECT usrsite_warehous_id
                                                  FROM usrsite
                                                 WHERE (usrsite_username=getEffectiveXtUser()))) )
         ) AS data;
  IF (_result > 0) THEN
    RETURN false;
  END IF;

  RETURN true;
END;
$_$;


ALTER FUNCTION public.checkrasiteprivs(integer) OWNER TO admin;

--
-- TOC entry 1216 (class 1255 OID 146565754)
-- Dependencies: 4536 8
-- Name: checkshipmentsiteprivs(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION checkshipmentsiteprivs(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pShipheadid ALIAS FOR $1;
  _check    BOOLEAN;
  _result   INTEGER;

BEGIN

  IF (NOT fetchMetricBool('MultiWhs')) THEN
    RETURN true;
  END IF;

  IF (NOT fetchUsrPrefBool('selectedSites')) THEN
    RETURN true;
  END IF;

  SELECT COALESCE(COUNT(*), 0) INTO _result
    FROM ( SELECT coitem_id
             FROM shipitem, coitem, itemsite
            WHERE ( (shipitem_shiphead_id=pShipheadid)
              AND   (coitem_id=shipitem_orderitem_id)
              AND   (coitem_itemsite_id=itemsite_id)
              AND   (itemsite_warehous_id NOT IN (SELECT usrsite_warehous_id
                                                    FROM usrsite
                                                   WHERE (usrsite_username=getEffectiveXtUser()))) )
           UNION
           SELECT cohead_warehous_id
             FROM shipitem, coitem, cohead
            WHERE ( (shipitem_shiphead_id=pShipheadid)
              AND   (coitem_id=shipitem_orderitem_id)
              AND   (cohead_id=coitem_cohead_id)
              AND   (cohead_warehous_id NOT IN (SELECT usrsite_warehous_id
                                                  FROM usrsite
                                                 WHERE (usrsite_username=getEffectiveXtUser()))) )
         ) AS data;
  IF (_result > 0) THEN
    RETURN false;
  END IF;

  RETURN true;
END;
$_$;


ALTER FUNCTION public.checkshipmentsiteprivs(integer) OWNER TO admin;

--
-- TOC entry 1217 (class 1255 OID 146565755)
-- Dependencies: 4536 8
-- Name: checksositeprivs(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION checksositeprivs(integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSoheadid ALIAS FOR $1;
  _check    BOOLEAN;
  _result   INTEGER;

BEGIN

  IF (NOT fetchMetricBool('MultiWhs')) THEN
    RETURN true;
  END IF;

  IF (NOT fetchUsrPrefBool('selectedSites')) THEN
    RETURN true;
  END IF;

  SELECT COALESCE(COUNT(*), 0) INTO _result
    FROM ( SELECT coitem_id
             FROM coitem, itemsite
            WHERE ( (coitem_cohead_id=pSoheadid)
              AND   (coitem_itemsite_id=itemsite_id)
              AND   (itemsite_warehous_id NOT IN (SELECT usrsite_warehous_id
                                                    FROM usrsite
                                                   WHERE (usrsite_username=getEffectiveXtUser()))) )
           UNION
           SELECT cohead_warehous_id
             FROM cohead
            WHERE ( (cohead_id=pSoheadid)
              AND   (cohead_warehous_id NOT IN (SELECT usrsite_warehous_id
                                                  FROM usrsite
                                                 WHERE (usrsite_username=getEffectiveXtUser()))) )
         ) AS data;
  IF (_result > 0) THEN
    RETURN false;
  END IF;

  RETURN true;
END;
$_$;


ALTER FUNCTION public.checksositeprivs(integer) OWNER TO admin;

--
-- TOC entry 1218 (class 1255 OID 146565756)
-- Dependencies: 4536 8
-- Name: checkvouchersiteprivs(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION checkvouchersiteprivs(integer) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVoheadid ALIAS FOR $1;
  _check    BOOLEAN;
  _result   INTEGER;

BEGIN

  IF (NOT fetchMetricBool('MultiWhs')) THEN
    RETURN true;
  END IF;

  IF (NOT fetchUsrPrefBool('selectedSites')) THEN
    RETURN true;
  END IF;

  SELECT COALESCE(COUNT(*), 0) INTO _result
    FROM ( SELECT voitem_id
             FROM voitem, poitem, itemsite
            WHERE ( (voitem_vohead_id=pVoheadid)
              AND   (poitem_id=voitem_poitem_id)
              AND   (poitem_itemsite_id=itemsite_id)
              AND   (itemsite_warehous_id NOT IN (SELECT usrsite_warehous_id
                                                    FROM usrsite
                                                   WHERE (usrsite_username=getEffectiveXtUser()))) )
           UNION
           SELECT pohead_warehous_id
             FROM vohead, pohead
            WHERE ( (vohead_id=pVoheadid)
              AND   (pohead_id=vohead_pohead_id)
              AND   (pohead_warehous_id NOT IN (SELECT usrsite_warehous_id
                                                  FROM usrsite
                                                 WHERE (usrsite_username=getEffectiveXtUser()))) )
         ) AS data;
  IF (_result > 0) THEN
    RETURN false;
  END IF;

  RETURN true;
END;
$_$;


ALTER FUNCTION public.checkvouchersiteprivs(integer) OWNER TO admin;

--
-- TOC entry 1219 (class 1255 OID 146565757)
-- Dependencies: 4536 8
-- Name: clearnumberissue(text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION clearnumberissue(psequence text, pnumber integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  __seqiss	seqiss[];
  __newiss	seqiss[] := ARRAY[]::seqiss[];
  _i		INTEGER;
  _result	BOOLEAN := FALSE;
  _interval	TEXT := fetchMetricText('NumberIssueResetIntervalDays') || ' day';
  _number	INTEGER;
BEGIN
  -- get the sequence to update
  SELECT orderseq_seqiss INTO __seqiss
  FROM orderseq
  WHERE (orderseq_name=psequence);

  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Invalid orderseq_name %', psequence;
  END IF;

  IF(ARRAY_LENGTH(COALESCE(__seqiss,__newiss),1) IS NULL) THEN
    RETURN FALSE;
  END IF;

  -- build a new array sans the number we are releasing
  FOR _i IN 1..ARRAY_LENGTH(__seqiss,1)
  LOOP
    IF((__seqiss[_i]).seqiss_number = pnumber) THEN
      _result = TRUE;
    -- don't bother re-adding stale numbers
    ELSIF (now() - _interval::INTERVAL > (__seqiss[_i]).seqiss_time) THEN
      IF (_number IS NULL) THEN
        _number := (__seqiss[_i]).seqiss_number;
      ELSE
        _number := LEAST((__seqiss[_i]).seqiss_number, _number);
      END IF;
    ELSE
      __newiss := __newiss || __seqiss[_i];
    END IF;
  END LOOP;

  -- update the order sequence with the result
  UPDATE orderseq SET
    orderseq_seqiss = __newiss
  WHERE (orderseq_name=psequence);

  -- reset to any cleared stale number
  IF(_number IS NOT NULL) THEN
    UPDATE orderseq SET
      orderseq_number = _number
    WHERE (orderseq_name=psequence);
  END IF;

  RETURN _result;
END;
$$;


ALTER FUNCTION public.clearnumberissue(psequence text, pnumber integer) OWNER TO admin;

--
-- TOC entry 1220 (class 1255 OID 146565758)
-- Dependencies: 4536 8
-- Name: clearnumberissue(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION clearnumberissue(psequence text, pnumber text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _castpnumber  INTEGER;
BEGIN
  -- for now, order numbers in the database are text but usually
  -- string representations of integers. allow for the occasional non-integer.
  BEGIN
    _castpnumber  := CAST(pnumber AS INTEGER);
  EXCEPTION WHEN cannot_coerce OR
                 invalid_text_representation
  THEN
    RAISE DEBUG 'clearNumberIssue(%, %) received an unexpected pnumber',
                  psequence, pnumber;
    RETURN FALSE;
  END;

  RETURN clearNumberIssue(psequence, _castpnumber);
END;
$$;


ALTER FUNCTION public.clearnumberissue(psequence text, pnumber text) OWNER TO admin;

--
-- TOC entry 1221 (class 1255 OID 146565759)
-- Dependencies: 4536 8
-- Name: clearpayment(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION clearpayment(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pApselectid ALIAS FOR $1;

BEGIN

  DELETE FROM apselect
  WHERE (apselect_id=pApselectid);

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.clearpayment(integer) OWNER TO admin;

--
-- TOC entry 1223 (class 1255 OID 146565760)
-- Dependencies: 4536 8
-- Name: closeaccountingperiod(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION closeaccountingperiod(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPeriodid ALIAS FOR $1;
  _r RECORD;
  _nextPeriodid INTEGER;
  _trialbalid INTEGER;
  _ending NUMERIC;
  _currYear INTEGER;
  _nextYear INTEGER;
BEGIN

--  Bypass error checking is this the the initial period
  IF ( NOT ( SELECT period_initial
             FROM period
             WHERE (period_id=pPeriodid) ) ) THEN

--  Check to make use that the period is not already closed
    IF ( ( SELECT period_closed
           FROM period
           WHERE (period_id=pPeriodid) ) ) THEN
      RETURN -1;
    END IF;

--  Make sure that the day before this period belongs to another period
    SELECT prev.period_id AS periodid, prev.period_closed AS closed INTO _r
    FROM period AS prev, period AS curr
    WHERE ( (prev.period_end = (curr.period_start - 1))
     AND (curr.period_id=pPeriodid) );
    IF (NOT FOUND) THEN
      RETURN -2;
    END IF;

--  Make sure that the previous period is closed
    IF (NOT _r.closed) THEN
      RETURN -3;
    END IF;

  END IF;

--  Make sure that there the next period is defined
  SELECT next.period_id INTO _nextPeriodid
  FROM period AS next, period AS curr
  WHERE ( (next.period_start = (curr.period_end + 1))
   AND (curr.period_id=pPeriodid) );
  IF (NOT FOUND) THEN
    RETURN -4;
  END IF;

--  Make sure that the user is not trying to prematurely close the Period
  IF ( ( SELECT (period_end >= CURRENT_DATE)
         FROM period
         WHERE (period_id=pPeriodid) ) ) THEN
    RETURN -5;
  END IF;

  SELECT yearperiod_id INTO _currYear
    FROM yearperiod, period
   WHERE ((period_end BETWEEN yearperiod_start and yearperiod_end)
     AND  (period_id=pPeriodid));
  IF (NOT FOUND) THEN
    _currYear := -1;
  END IF;

  SELECT yearperiod_id INTO _nextYear
    FROM yearperiod, period
   WHERE ((period_end BETWEEN yearperiod_start and yearperiod_end)
     AND  (period_id=_nextPeriodid));
  IF (NOT FOUND) THEN
    RETURN -6;
  END IF;

--  Walk through the entire COA, calculating the ending balance and pushing
--  it to the beginning balance for the next period
  FOR _r IN SELECT accnt_id, accnt_type IN ('E', 'R') AS revexp,
                   trialbal_id, trialbal_beginning,
                   trialbal_credits, trialbal_debits
            FROM accnt LEFT OUTER JOIN trialbal ON ( (trialbal_accnt_id=accnt_id) AND (trialbal_period_id=pPeriodid) )
            ORDER BY accnt_id LOOP
    IF (_r.trialbal_id IS NULL) THEN
      _ending = 0;

      INSERT INTO trialbal
      ( trialbal_period_id, trialbal_accnt_id,
        trialbal_beginning, trialbal_ending, trialbal_dirty,
        trialbal_credits, trialbal_debits )
      VALUES
      ( pPeriodid, _r.accnt_id,
        0, 0, FALSE,
        0, 0 );
    ELSE
      _ending = (_r.trialbal_beginning - _r.trialbal_debits + _r.trialbal_credits);

      UPDATE trialbal
      SET trialbal_ending=_ending,
          trialbal_dirty = FALSE
      WHERE (trialbal_id=_r.trialbal_id);

      PERFORM forwardUpdateTrialBalance(_r.trialbal_id);
    END IF;

    IF (_r.revexp AND _currYear != _nextYear) THEN
      _ending := 0;
    END IF;

--  Find the trialbal record for the next period
    SELECT trialbal_id INTO _trialbalid
    FROM trialbal
    WHERE ( (trialbal_period_id=_nextPeriodid)
     AND (trialbal_accnt_id=_r.accnt_id) );
    IF (FOUND) THEN
      UPDATE trialbal
      SET trialbal_beginning = (_ending + trialbal_yearend),
          trialbal_ending = (_ending + trialbal_yearend - trialbal_debits + trialbal_credits)
      WHERE (trialbal_id=_trialbalid);
    ELSE
      INSERT INTO trialbal
      ( trialbal_period_id, trialbal_accnt_id,
        trialbal_beginning, trialbal_ending, trialbal_dirty,
        trialbal_credits, trialbal_debits )
      VALUES(_nextPeriodid, _r.accnt_id,
             _ending, _ending, TRUE,
             0, 0 );
    END IF;

  END LOOP;

--  Set the period_closed flag
  UPDATE period
  SET period_closed=TRUE
  WHERE (period_id=pPeriodid);

  RETURN pPeriodid;

END;
$_$;


ALTER FUNCTION public.closeaccountingperiod(integer) OWNER TO admin;

--
-- TOC entry 1224 (class 1255 OID 146565761)
-- Dependencies: 4536 8
-- Name: closeaccountingyearperiod(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION closeaccountingyearperiod(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pYearPeriodid ALIAS FOR $1;
  _result INTEGER;
BEGIN

--  Check to make sure that the yearperiod is not already closed
  IF ( ( SELECT yearperiod_closed
           FROM yearperiod
          WHERE (yearperiod_id=pYearPeriodid) ) ) THEN
    RETURN -1;
  END IF;

  IF ( ( SELECT (count(period_id) > 0)
           FROM period
          WHERE ((period_yearperiod_id=pYearPeriodid)
           AND (NOT period_closed)) ) ) THEN
    RETURN -10;
  END IF;

  IF ( ( SELECT (count(yearperiod_id) > 0)
           FROM yearperiod
          WHERE ((yearperiod_end< (
            SELECT yearperiod_end
            FROM yearperiod
            WHERE (yearperiod_id=pYearPeriodId))
          )
           AND (NOT yearperiod_closed)) ) ) THEN
    RETURN -11;
  END IF;

--  Should we check for a previous yearperiod existing already ?
--  If so then we should return -2 if one does not.

--  If we did the previous yearperiod we should check to make sure that
--  it is also closed. Returning -3 if it is not.

--  Make sure that the user is not trying to prematurely close the YearPeriod
  IF ( ( SELECT (yearperiod_end >= CURRENT_DATE)
           FROM yearperiod
          WHERE (yearperiod_id=pYearPeriodid) ) ) THEN
    RETURN -5;
  END IF;

--  Update the year end Retained Earnings
  SELECT updateRetainedEarnings(pYearPeriodid) INTO _result;
  IF (_result < 0) THEN
    RETURN _result;
  END IF;

  UPDATE yearperiod
    SET yearperiod_closed = TRUE
  WHERE yearperiod_id = pYearPeriodid;

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.closeaccountingyearperiod(integer) OWNER TO admin;

--
-- TOC entry 1225 (class 1255 OID 146565762)
-- Dependencies: 4536 8
-- Name: closepo(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION closepo(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPoheadid ALIAS FOR $1;

BEGIN

  UPDATE poitem
  SET poitem_status='C'
  WHERE (poitem_pohead_id=pPoheadid);

-- _poitemTrigger will close pohead when the last poitem is closed
--  UPDATE pohead
--  SET pohead_status='C'
--  WHERE (pohead_id=pPoheadid);

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.closepo(integer) OWNER TO admin;

--
-- TOC entry 1226 (class 1255 OID 146565763)
-- Dependencies: 4536 8
-- Name: closewo(integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION closewo(integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoid ALIAS FOR $1;
  pPostMaterialVariances ALIAS FOR $2;

BEGIN

  RETURN closeWo(pWoid, pPostMaterialVariances, CURRENT_DATE);
END;
$_$;


ALTER FUNCTION public.closewo(integer, boolean) OWNER TO admin;

--
-- TOC entry 1227 (class 1255 OID 146565764)
-- Dependencies: 4536 8
-- Name: closewo(integer, boolean, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION closewo(integer, boolean, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoid ALIAS FOR $1;
  pPostMaterialVariances ALIAS FOR $2;
  pTransDate ALIAS FOR $3;
  _woNumber TEXT;
  _check CHAR;
  _itemlocSeries INTEGER := 0;

BEGIN

  --Comment this out
  --In addition to IssueToShipping driving PostProduction,
  --not PostProduction can drive IssueToShipping.
  --Must allow closing of Job items

  --If this is item type Job then we cannot close here
  --SELECT itemsite_costmethod INTO _check
  --FROM wo,itemsite
  --WHERE ((wo_id=pWoid)
  --AND (wo_itemsite_id=itemsite_id)
  --AND (itemsite_costmethod = 'J'));
  --IF (FOUND) THEN
  --  RAISE EXCEPTION 'Work orders for Job items are closed when all quantities are shipped';
  --END IF;

  SELECT formatWoNumber(pWoid) INTO _woNumber;

-- If there are any tools issued on this job then we cannot close here
  IF ( SELECT (count(*) > 0)
       FROM womatl
       JOIN itemsite ON (womatl_itemsite_id=itemsite_id)
       JOIN item ON ((itemsite_item_id=item_id) AND (item_type='T'))
       WHERE ((womatl_wo_id=pWoid)
         AND  (womatl_qtyiss > 0)) ) THEN
    RAISE EXCEPTION 'All Tools must be returned before the W/O can be closed';
  END IF;

--  Distribute any remaining wo_wipvalue to G/L - debit Inventory Cost, credit WIP
  PERFORM insertGLTransaction( 'W/O', 'WO', _woNumber, ('Manufacturing Inventory Cost Variance for ' || item_number),
                               getPrjAccntId(wo_prj_id, costcat_wip_accnt_id),
                               getPrjAccntId(wo_prj_id, costcat_invcost_accnt_id), -1,
                               COALESCE(wo_wipvalue, 0), pTransDate )
  FROM wo, itemsite, item, costcat
  WHERE ( (wo_itemsite_id=itemsite_id)
   AND (itemsite_item_id=item_id)
   AND (itemsite_costcat_id=costcat_id)
   AND (wo_id=pWoid) );

--  Distribute any remaining wo_brdvalue to G/L - debit Inventory Cost, credit WIP
  PERFORM insertGLTransaction( 'W/O', 'WO', _woNumber, ('Breeder Inventory Cost Variance for ' || item_number),
                               getPrjAccntId(wo_prj_id, costcat_wip_accnt_id),
                               CASE WHEN(itemsite_costmethod='A') THEN costcat_asset_accnt_id
                                    ELSE getPrjAccntId(wo_prj_id, costcat_invcost_accnt_id)
                               END,
                               -1,
                               COALESCE(wo_brdvalue, 0), pTransDate )
  FROM wo, itemsite, item, costcat
  WHERE ( (wo_itemsite_id=itemsite_id)
   AND (itemsite_item_id=item_id)
   AND (itemsite_costcat_id=costcat_id)
   AND (wo_id=pWoid) );

--  Don't bother with posting variances if the qtyrcv is 0 as
--  they are meaningless.
  IF ( ( SELECT wo_qtyrcv
         FROM wo
         WHERE (wo_id=pWoid) ) > 0 ) THEN

    IF (pPostMaterialVariances) THEN
--  Post womatl variances
    INSERT INTO womatlvar ( womatlvar_number, womatlvar_subnumber, womatlvar_posted,
        womatlvar_parent_itemsite_id, womatlvar_component_itemsite_id,
        womatlvar_qtyord, womatlvar_qtyrcv,
        womatlvar_qtyiss, womatlvar_qtyfxd, womatlvar_qtyper,
        womatlvar_scrap, womatlvar_wipscrap, womatlvar_bomitem_id,
        womatlvar_notes, womatlvar_ref )
      SELECT wo_number, wo_subnumber, pTransDate,
             wo_itemsite_id, womatl_itemsite_id,
             wo_qtyord, wo_qtyrcv,
             itemuomtouom(itemsite_item_id, womatl_uom_id, NULL, womatl_qtyiss),
             itemuomtouom(itemsite_item_id, womatl_uom_id, NULL, womatl_qtyfxd),
             itemuomtouom(itemsite_item_id, womatl_uom_id, NULL, womatl_qtyper),
             womatl_scrap,
             itemuomtouom(itemsite_item_id, womatl_uom_id, NULL, womatl_qtywipscrap),
             womatl_bomitem_id,
             womatl_notes, womatl_ref
      FROM wo, womatl, itemsite, item
      WHERE ((womatl_wo_id=wo_id)
       AND (womatl_itemsite_id=itemsite_id)
       AND (itemsite_item_id=item_id)
       AND (item_type <> 'T')
       AND (wo_id=pWoid));
    END IF;
  END IF;

--  Delete any P/R's created for this W/O
  PERFORM deletePr('W', womatl_id)
  FROM womatl
  WHERE (womatl_wo_id=pWoid);

  UPDATE wo
  SET wo_wipvalue = 0, wo_brdvalue=0,
      wo_status='C'
  WHERE (wo_id=pWoid);

  RETURN 1;
END;
$_$;


ALTER FUNCTION public.closewo(integer, boolean, date) OWNER TO admin;

--
-- TOC entry 204 (class 1259 OID 146565765)
-- Dependencies: 5945 8
-- Name: cntct; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE cntct (
    cntct_id integer NOT NULL,
    cntct_crmacct_id integer,
    cntct_addr_id integer,
    cntct_first_name text,
    cntct_last_name text,
    cntct_honorific text,
    cntct_initials text,
    cntct_active boolean DEFAULT true,
    cntct_phone text,
    cntct_phone2 text,
    cntct_fax text,
    cntct_email text,
    cntct_webaddr text,
    cntct_notes text,
    cntct_title text,
    cntct_number text NOT NULL,
    cntct_middle text,
    cntct_suffix text,
    cntct_owner_username text,
    cntct_name text
);


ALTER TABLE public.cntct OWNER TO admin;


--
-- TOC entry 1228 (class 1255 OID 146565772)
-- Dependencies: 2777 4536 8
-- Name: cntct(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION cntct() RETURNS SETOF cntct
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _row cntct%ROWTYPE;
  _priv TEXT;
  _grant BOOLEAN;

BEGIN
  -- This query will give us the most permissive privilege the user has been granted
  SELECT privilege, granted INTO _priv, _grant
  FROM privgranted
  WHERE privilege IN ('MaintainAllContacts','ViewAllContacts','MaintainPersonalContacts','ViewPersonalContacts')
  ORDER BY granted DESC, sequence
  LIMIT 1;

  -- If have an 'All' privilege return all results
  IF (_priv ~ 'All' AND _grant) THEN
    FOR _row IN
      SELECT * FROM cntct
    LOOP
      RETURN NEXT _row;
    END LOOP;
  -- Otherwise if have any other grant, must be personal privilege.
  ELSIF (_grant) THEN
    FOR _row IN
      SELECT * FROM cntct
      WHERE cntct_owner_username = getEffectiveXtUser()
    LOOP
      RETURN NEXT _row;
    END LOOP;
  END IF;

  RETURN;

END;
$$;


ALTER FUNCTION public.cntct() OWNER TO admin;

--
-- TOC entry 8952 (class 0 OID 0)
-- Dependencies: 1228
-- Name: FUNCTION cntct(); Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON FUNCTION cntct() IS 'A table function that returns Contact results according to privilege settings.';


--
-- TOC entry 1229 (class 1255 OID 146565773)
-- Dependencies: 2663 4536 8
-- Name: cntctdups(text, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION cntctdups(text, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean) RETURNS SETOF cntctdup
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSearchText ALIAS FOR $1;
  pSearchContactName ALIAS FOR $2;
  pSearchPhone ALIAS FOR $3;
  pSearchEmail ALIAS FOR $4;
  pSearchNumber ALIAS FOR $5;
  pSearchName ALIAS FOR $6;
  pShowInactive ALIAS FOR $7;
  pIgnoreBlanks ALIAS FOR $8;
  pIndentedDups ALIAS FOR $9;
  pCheckHnfc ALIAS FOR $10;
  pCheckFirst ALIAS FOR $11;
  pCheckMiddle ALIAS FOR $12;
  pCheckLast ALIAS FOR $13;
  pCheckSuffix ALIAS FOR $14;
  pCheckPhone ALIAS FOR $15;
  pCheckEmail ALIAS FOR $16;
  _cntct cntctdup%ROWTYPE;
  _cntctdup cntctdup%ROWTYPE;
  _rec RECORD;
  _operator TEXT := '';
  _clause TEXT;
  _qry  TEXT := '';
  _return BOOLEAN := true;
  _text TEXT;
  _first BOOLEAN := true;

BEGIN
  -- Validate
  IF (pIndentedDups AND NOT pCheckHnfc AND NOT pCheckFirst AND NOT pCheckMiddle AND
      NOT pCheckLast AND NOT pCheckSuffix AND NOT pCheckEmail AND NOT pCheckPhone) THEN
    RETURN;
  END IF;

  _text = quote_literal(pSearchText);

  IF (pIndentedDups) THEN
    _qry := 'SELECT
	-1 AS cntct_id,
	-1 AS cntct_crmacct_id,
	-1 AS cntct_addr_id,';
    IF (NOT pCheckFirst) THEN
      _qry := _qry || ''''' AS ';
    END IF;
    _qry := _qry || ' cntct_first_name,';
    IF (NOT pCheckLast) THEN
      _qry := _qry || ''''' AS ';
    END IF;
    _qry := _qry || ' cntct_last_name,';
    IF (NOT pCheckHnfc) THEN
      _qry := _qry || ''''' AS ';
    END IF;
    _qry := _qry || ' cntct_honorific,';
    _qry := _qry || ' '''' AS cntct_initials,';
    _qry := _qry || ' NULL AS cntct_active,';
    IF (NOT pCheckPhone) THEN
      _qry := _qry || ''''' AS ';
    END IF;
    _qry := _qry || ' cntct_phone,';
    IF (NOT pCheckPhone) THEN
      _qry := _qry || ''''' AS ';
    END IF;
    _qry := _qry || ' cntct_phone2,';
    _qry := _qry || ' '''' AS cntct_fax,';
    IF (NOT pCheckEmail) THEN
      _qry := _qry || ''''' AS ';
    END IF;
    _qry := _qry || ' cntct_email,';
    _qry := _qry || ' '''' AS cntct_webaddr,';
    _qry := _qry || ' '''' AS cntct_notes,';
    _qry := _qry || ' '''' AS cntct_title,';
    _qry := _qry || ' '''' AS cntct_number,';
    IF (NOT pCheckMiddle) THEN
      _qry := _qry || ''''' AS ';
    END IF;
    _qry := _qry || ' cntct_middle,';
    IF (NOT pCheckSuffix) THEN
      _qry := _qry || ''''' AS ';
    END IF;
    _qry := _qry || ' cntct_suffix,';
    _qry := _qry || ' '''' AS cntct_owner_username,';
    _qry := _qry || ' '''' AS cntct_name,';
    _qry := _qry || ' '''' AS crmacct_number, ';
    _qry := _qry || ' '''' AS crmacct_name, ';
    _qry := _qry || ' NULL AS addr_id,
		NULL AS addr_active,
		'''' AS addr_line1,
		'''' AS addr_line2,
		'''' AS addr_line3,
		'''' AS addr_city,
		'''' AS addr_state,
		'''' AS addr_postalcode,
		'''' AS addr_country,
		'''' AS addr_notes,
		'''' AS addr_number,
		cntctdup_level FROM (';
  END IF;
    _clause := 'SELECT
		cntct_id,
		cntct_crmacct_id,
		cntct_addr_id,
		UPPER(cntct_first_name) AS cntct_first_name,
		UPPER(cntct_last_name) AS cntct_last_name,
		UPPER(cntct_honorific) AS cntct_honorific,
		cntct_initials,
		cntct_active,
		cntct_phone,
		cntct_phone2,
		cntct_fax,
		UPPER(cntct_email) AS cntct_email,
		cntct_webaddr,
		cntct_notes,
		cntct_title,
		cntct_number,
		UPPER(cntct_middle) AS cntct_middle,
		UPPER(cntct_suffix) AS cntct_suffix,
		cntct_owner_username,
                cntct_name,
		crmacct_number,
		crmacct_name,
		addr.*,
		0 AS cntctdup_level
             FROM cntct()
               LEFT OUTER JOIN crmacct ON (cntct_crmacct_id=crmacct_id)
               LEFT OUTER JOIN addr ON (cntct_addr_id=addr_id)
	     WHERE ';

  IF (NOT pIndentedDups) THEN
    WHILE position('UPPER' in _clause) > 0
    LOOP
      _clause := regexp_replace(_clause, 'UPPER', '');
    END LOOP;
  END IF;

  _qry := _qry || _clause;

  IF (NOT pShowInactive) THEN
    _qry := _qry || ' cntct_active AND ';
  END IF;

  IF (pIgnoreBlanks) THEN
    _qry := _qry || ' (COALESCE(LENGTH(cntct_first_name || cntct_last_name),0) > 0) AND ';
  END IF;

    _qry := _qry || '(false ';

  IF (pSearchNumber) THEN
    _qry := _qry || ' OR (crmacct_number ~* ' || quote_literal(pSearchText) || ') ';
  END IF;

  IF (pSearchName) THEN
    _qry := _qry || ' OR (crmacct_name ~* ' || quote_literal(pSearchText) || ') ';
  END IF;

  IF (pSearchContactName) THEN
    _qry := _qry || ' OR (cntct_first_name || '' '' || cntct_last_name ~* ' || quote_literal(pSearchText) || ') ';
  END IF;

  IF (pSearchPhone) THEN
    _qry := _qry || ' OR (cntct_phone || '' '' || cntct_phone2 || '' '' || cntct_fax ~* ' || quote_literal(pSearchText) || ') ';
  END IF;

  IF (pSearchEmail) THEN
    _qry := _qry || ' OR (cntct_email ~* ' || quote_literal(pSearchText) || ') ';
  END IF;

  _qry := _qry || ' ) ';

  IF (pIndentedDups) THEN
    _qry := _qry || ') data';
    _clause := ' GROUP BY cntctdup_level';
    IF (pCheckHnfc) THEN
      _clause := _clause || ',cntct_honorific';
    END IF;
    IF (pCheckFirst) THEN
      _clause := _clause || ',cntct_first_name';
    END IF;
    IF (pCheckMiddle) THEN
      _clause := _clause || ',cntct_middle';
    END IF;
    IF (pCheckLast) THEN
      _clause := _clause || ',cntct_last_name';
    END IF;
    IF (pCheckSuffix) THEN
      _clause := _clause || ',cntct_suffix';
    END IF;
    IF (pCheckEmail) THEN
      _clause := _clause || ',cntct_email';
    END IF;
    IF (pCheckPhone) THEN
      _clause := _clause || ',cntct_phone';
      _clause := _clause || ',cntct_phone2';
    END IF;

    _qry := _qry || _clause;

    _clause := ' HAVING(';
    IF (pCheckHnfc) THEN
      _clause := _clause || 'OR COUNT(cntct_honorific) > 1 ';
    END IF;
    IF (pCheckFirst) THEN
      _clause := _clause || 'OR COUNT(cntct_first_name) > 1 ';
    END IF;
    IF (pCheckMiddle) THEN
      _clause := _clause || 'OR COUNT(cntct_middle) > 1 ';
    END IF;
    IF (pCheckLast) THEN
      _clause := _clause || 'OR COUNT(cntct_last_name) > 1 ';
    END IF;
    IF (pCheckSuffix) THEN
      _clause := _clause || 'OR COUNT(cntct_suffix) > 1 ';
    END IF;
    IF (pCheckEmail) THEN
      _clause := _clause || 'OR COUNT(cntct_email) > 1 ';
    END IF;
    IF (pCheckPhone) THEN
      _clause := _clause || 'OR (COUNT(cntct_phone) > 1 AND LENGTH(cntct_phone) > 0) ';
      _clause := _clause || 'OR (COUNT(cntct_phone2) > 1 AND LENGTH(cntct_phone2) > 0) ';
    END IF;
    _clause := _clause || ') ';
    _clause := overlay(_clause placing '' from 9 for 2);

    IF (pCheckHnfc) THEN
      _clause := _clause || 'AND LENGTH(cntct_honorific) > 0 ';
    END IF;
    IF (pCheckFirst) THEN
      _clause := _clause || 'AND LENGTH(cntct_first_name) > 0  ';
    END IF;
    IF (pCheckMiddle) THEN
      _clause := _clause || 'AND LENGTH(cntct_middle) > 0  ';
    END IF;
    IF (pCheckLast) THEN
      _clause := _clause || 'AND LENGTH(cntct_last_name) > 0  ';
    END IF;
    IF (pCheckSuffix) THEN
      _clause := _clause || 'AND LENGTH(cntct_suffix) > 0  ';
    END IF;
    IF (pCheckEmail) THEN
      _clause := _clause || 'AND LENGTH(cntct_email) > 0  ';
    END IF;

    _qry := _qry || _clause;
  END IF;

  _qry := _qry || ' ORDER BY cntct_last_name, cntct_first_name;';

-- raise exception '%',_qry;
  FOR _cntct IN
    EXECUTE _qry
  LOOP

    RETURN NEXT _cntct;

    -- If duplicates, get duplicates
    IF (pIndentedDups) THEN

      _qry := 'SELECT
                 cntct.*,
                 crmacct_number,
                 crmacct_name,
                 addr.*,
                 1 AS cntctdup_level
               FROM cntct()
                 LEFT OUTER JOIN crmacct ON (cntct_crmacct_id=crmacct_id)
                 LEFT OUTER JOIN addr ON (cntct_addr_id=addr_id)
               WHERE (true) ';

      IF (pCheckHnfc) THEN
        _qry := _qry || ' AND (UPPER(cntct_honorific)=' || quote_literal(_cntct.cntct_honorific) || ')';
      END IF;

      IF (pCheckFirst) THEN
        _qry := _qry || ' AND (UPPER(cntct_first_name)=' || quote_literal(_cntct.cntct_first_name) || ')';
      END IF;

      IF (pCheckMiddle) THEN
        _qry := _qry || ' AND (UPPER(cntct_middle)=' || quote_literal(_cntct.cntct_middle) || ')';
      END IF;

      IF (pCheckLast) THEN
        _qry := _qry || ' AND (UPPER(cntct_last_name)=' || quote_literal(_cntct.cntct_last_name) || ')';
      END IF;

      IF (pCheckSuffix) THEN
        _qry := _qry || ' AND (UPPER(cntct_suffix)=' ||  quote_literal(_cntct.cntct_suffix) || ')';
      END IF;

      IF (pCheckPhone) THEN
        _qry := _qry || ' AND (cntct_phone=' || quote_literal(_cntct.cntct_phone)  || ')';
      END IF;

      IF (pCheckEmail) THEN
        _qry := _qry || ' AND (UPPER(cntct_email)=' || quote_literal(_cntct.cntct_email) || ')';
      END IF;

-- raise exception '%',_qry;
      FOR _cntctdup IN
        EXECUTE _qry
      LOOP
        RETURN NEXT _cntctdup;
      END LOOP;

    END IF;

  END LOOP;

  RETURN;
END;
$_$;


ALTER FUNCTION public.cntctdups(text, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean) OWNER TO admin;

--
-- TOC entry 1230 (class 1255 OID 146565775)
-- Dependencies: 4536 8
-- Name: cntctmerge(integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION cntctmerge(integer, integer, boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSourceCntctId ALIAS FOR $1;
  pTargetCntctId ALIAS FOR $2;
  pPurge ALIAS FOR $3;
  _fk		RECORD;
  _pk   	RECORD;
  _sel		RECORD;
  _seq  	INTEGER;
  _col		TEXT;
  _pkcol  	TEXT;
  _qry  	TEXT;
  _multi	BOOLEAN;

BEGIN
  -- Validate
  IF (pSourceCntctId IS NULL) THEN
    RAISE EXCEPTION 'Source contact id can not be null';
  ELSIF (pTargetCntctId IS NULL) THEN
    RAISE EXCEPTION 'Target contact id can not be null';
  ELSIF (pPurge IS NULL) THEN
    RAISE EXCEPTION 'Purge flag can not be null';
  END IF;

  -- Determine where this contact is used by analyzing foreign key linkages and update each
  FOR _fk IN
    SELECT pg_namespace.nspname AS schemaname, con.relname AS tablename, conkey AS seq, conrelid AS class_id
    FROM pg_constraint, pg_class f, pg_class con, pg_namespace
    WHERE confrelid=f.oid
    AND conrelid=con.oid
    AND f.relname = 'cntct'
    AND con.relnamespace=pg_namespace.oid
    AND con.relname NOT IN ('cntctsel', 'cntctmrgd', 'mrghist','trgthist')
  LOOP
    -- Validate
    IF (ARRAY_UPPER(_fk.seq,1) > 1) THEN
      RAISE EXCEPTION 'Updates to tables where the contact is one of multiple foreign key columns is not supported. Error on Table: %',
        pg_namespace.nspname || '.' || con.relname;
    END IF;

    _seq := _fk.seq[1];

    -- Get the specific column name
    SELECT attname INTO _col
    FROM pg_attribute, pg_class
    WHERE ((attrelid=pg_class.oid)
    AND (pg_class.oid=_fk.class_id)
    AND (attnum=_seq));

    IF (NOT pPurge) THEN
    -- Cache what we're going to do so we can restore if need be.
    -- Start by determining the primary key column for this table.
      _multi := false;
      _qry := 'SELECT pg_attribute.attname AS key
               FROM pg_attribute, pg_class
               WHERE pg_class.relnamespace = (
                 SELECT oid
                 FROM pg_namespace
                 WHERE pg_namespace.nspname = ''' || _fk.schemaname || ''')
                AND  pg_class.oid IN (
                 SELECT indexrelid
                 FROM pg_index
                 WHERE indisprimary = true
                  AND indrelid IN (
                    SELECT oid
                    FROM pg_class
                    WHERE lower(relname) = ''' || _fk.tablename || '''))
                AND pg_attribute.attrelid = pg_class.oid
                AND pg_attribute.attisdropped = false
               ORDER BY pg_attribute.attnum;';

      FOR _pk IN
        EXECUTE _qry
      LOOP
        IF (_multi) THEN
          RAISE EXCEPTION 'Reference tables with composite primary keys not supported.  Try the merge and purge option.';
        END IF;
        _pkcol := _pk.key;
        _multi := true;
      END LOOP;

      -- Gather and store the history
      _qry := 'INSERT INTO mrghist
               SELECT ' || pSourceCntctId || ', '''
                        || _fk.schemaname || '.' || _fk.tablename || ''', '''
                        || _pkcol || ''', '
                        || _pkcol || ', '''
                        || _col || '''
               FROM ' || _fk.schemaname || '.' || _fk.tablename || '
               WHERE (' || _col || '=' || pSourceCntctId || ');';
                   --           raise exception '%',_qry;
      EXECUTE _qry;

    END IF;

    -- Merge references
    _qry := 'UPDATE ' || _fk.schemaname || '.' || _fk.tablename ||
            ' SET ' || _col || '=' || pTargetCntctId ||
            ' WHERE (' || _col || '=' || pSourceCntctId || ');';

    EXECUTE _qry;

  END LOOP;

  -- Merge cases with no foreign key
  IF (NOT pPurge) THEN
    INSERT INTO mrghist
    SELECT pSourceCntctId,
      'comment',
      'comment_id',
      comment_id,
      'comment_source_id'
    FROM comment
    WHERE ((comment_source_id= pSourceCntctId)
    AND (comment_source='T'));

    INSERT INTO mrghist
    SELECT pSourceCntctId,
      'docass',
      'docass_id',
      docass_id,
      'docass_source_id'
    FROM docass
    WHERE ((docass_source_id= pSourceCntctId)
    AND (docass_source_type='T'));

    INSERT INTO mrghist
    SELECT pSourceCntctId,
      'docass',
      'docass_id',
      docass_id,
      'docass_target_id'
    FROM docass
    WHERE ((docass_target_id= pSourceCntctId)
    AND (docass_target_type='T'));

    INSERT INTO mrghist
    SELECT pSourceCntctId,
      'vendinfo',
      'vend_id',
      vend_id,
      'vend_cntct1_id'
    FROM vendinfo
    WHERE (vend_cntct1_id=pSourceCntctId);

    INSERT INTO mrghist
    SELECT pSourceCntctId,
      'vendinfo',
      'vend_id',
      vend_id,
      'vend_cntct2_id'
    FROM vendinfo
    WHERE (vend_cntct2_id=pSourceCntctId);

    IF (fetchMetricBool('EnableBatchManager') AND packageIsEnabled('xtbatch')) THEN
      INSERT INTO mrghist
      SELECT pSourceCntctId,
      'xtbatch.emlassc',
      'emlassc_id',
      emlassc_id,
      'emlassc_assc_id'
      FROM xtbatch.emlassc
      WHERE ((emlassc_assc_id= pSourceCntctId)
      AND (emlassc_type='T'));
    END IF;
  END IF;

  UPDATE comment
  SET comment_source_id = pTargetCntctId
  WHERE ((comment_source = 'T')
   AND (comment_source_id = pSourceCntctId));

  UPDATE docass
  SET docass_source_id = pTargetCntctId
  WHERE ((docass_source_type = 'T')
   AND (docass_source_id = pSourceCntctId));

  UPDATE docass
  SET docass_target_id = pTargetCntctId
  WHERE ((docass_target_type = 'T')
   AND (docass_target_id = pSourceCntctId));

  UPDATE vendinfo
  SET vend_cntct1_id = pTargetCntctId
  WHERE (vend_cntct1_id = pSourceCntctId);

  UPDATE vendinfo
  SET vend_cntct2_id = pTargetCntctId
  WHERE (vend_cntct2_id = pSourceCntctId);

  IF (fetchMetricBool('EnableBatchManager') AND packageIsEnabled('xtbatch')) THEN
    UPDATE xtbatch.emlassc
    SET emlassc_assc_id = pTargetCntctId
    WHERE ((emlassc_type = 'T')
     AND (emlassc_assc_id = pSourceCntctId));
  END IF;

  IF (NOT pPurge) THEN
  -- Record that this has been merged if not already
    IF (SELECT (COUNT(cntctmrgd_cntct_id) = 0)
        FROM cntctmrgd
        WHERE (cntctmrgd_cntct_id=pSourceCntctId)) THEN
      INSERT INTO cntctmrgd VALUES (pSourceCntctId,false);
    END IF;
  END IF;

 -- Merge field detail to target
  SELECT * INTO _sel
  FROM cntctsel
    JOIN cntct ON (cntctsel_cntct_id=cntct_id)
  WHERE (cntctsel_cntct_id=pSourceCntctId);

  IF (FOUND) THEN
    IF (_sel.cntctsel_mrg_crmacct_id) THEN
      IF (NOT pPurge) THEN
        INSERT INTO trgthist
        SELECT pSourceCntctId,pTargetCntctId,'cntct_crmacct_id', cntct_crmacct_id::text || '::integer'
        FROM cntct
        WHERE (cntct_id=pTargetCntctId);
      END IF;
      UPDATE cntct SET cntct_crmacct_id=_sel.cntct_crmacct_id WHERE (cntct_id=pTargetCntctId);
    END IF;
    IF (_sel.cntctsel_mrg_addr_id) THEN
      IF (NOT pPurge) THEN
        INSERT INTO trgthist
        SELECT pSourceCntctId,pTargetCntctId,'cntct_addr_id', cntct_addr_id::text || '::integer'
        FROM cntct
        WHERE (cntct_id=pTargetCntctId);
      END IF;
      UPDATE cntct SET cntct_addr_id=_sel.cntct_addr_id WHERE (cntct_id=pTargetCntctId);
    END IF;
    IF (_sel.cntctsel_mrg_first_name) THEN
      IF (NOT pPurge) THEN
        INSERT INTO trgthist
        SELECT pSourceCntctId,pTargetCntctId,'cntct_first_name', '''' || cntct_first_name || ''''
        FROM cntct
        WHERE (cntct_id=pTargetCntctId);
      END IF;
      UPDATE cntct SET cntct_first_name=_sel.cntct_first_name WHERE (cntct_id=pTargetCntctId);
    END IF;
    IF (_sel.cntctsel_mrg_last_name) THEN
      IF (NOT pPurge) THEN
        INSERT INTO trgthist
        SELECT pSourceCntctId,pTargetCntctId,'cntct_last_name', '''' || cntct_last_name || ''''
        FROM cntct
        WHERE (cntct_id=pTargetCntctId);
      END IF;
      UPDATE cntct SET cntct_last_name=_sel.cntct_last_name WHERE (cntct_id=pTargetCntctId);
    END IF;
    IF (_sel.cntctsel_mrg_honorific) THEN
      IF (NOT pPurge) THEN
        INSERT INTO trgthist
        SELECT pSourceCntctId,pTargetCntctId,'cntct_honorific', '''' || cntct_honorific || ''''
        FROM cntct
        WHERE (cntct_id=pTargetCntctId);
      END IF;
      UPDATE cntct SET cntct_honorific=_sel.cntct_honorific WHERE (cntct_id=pTargetCntctId);
    END IF;
    IF (_sel.cntctsel_mrg_initials) THEN
      IF (NOT pPurge) THEN
        INSERT INTO trgthist
        SELECT pSourceCntctId,pTargetCntctId,'cntct_initials', '''' || cntct_initials || ''''
        FROM cntct
        WHERE (cntct_id=pTargetCntctId);
      END IF;
      UPDATE cntct SET cntct_initials=_sel.cntct_initials WHERE (cntct_id=pTargetCntctId);
    END IF;
    IF (_sel.cntctsel_mrg_phone) THEN
      IF (NOT pPurge) THEN
        INSERT INTO trgthist
        SELECT pSourceCntctId,pTargetCntctId,'cntct_phone', '''' || cntct_phone || ''''
        FROM cntct
        WHERE (cntct_id=pTargetCntctId);
      END IF;
      UPDATE cntct SET cntct_phone=_sel.cntct_phone WHERE (cntct_id=pTargetCntctId);
    END IF;
    IF (_sel.cntctsel_mrg_phone2) THEN
      IF (NOT pPurge) THEN
        INSERT INTO trgthist
        SELECT pSourceCntctId,pTargetCntctId,'cntct_phone2', '''' || cntct_phone2 || ''''
        FROM cntct
        WHERE (cntct_id=pTargetCntctId);
      END IF;
      UPDATE cntct SET cntct_phone2=_sel.cntct_phone2 WHERE (cntct_id=pTargetCntctId);
    END IF;
    IF (_sel.cntctsel_mrg_fax)  THEN
      IF (NOT pPurge) THEN
        INSERT INTO trgthist
        SELECT pSourceCntctId,pTargetCntctId,'cntct_fax', '''' || cntct_fax || ''''
        FROM cntct
        WHERE (cntct_id=pTargetCntctId);
      END IF;
      UPDATE cntct SET cntct_fax=_sel.cntct_fax WHERE (cntct_id=pTargetCntctId);
    END IF;
    IF (_sel.cntctsel_mrg_email)  THEN
      IF (NOT pPurge) THEN
        INSERT INTO trgthist
        SELECT pSourceCntctId,pTargetCntctId,'cntct_email', '''' || cntct_email || ''''
        FROM cntct
        WHERE (cntct_id=pTargetCntctId);
      END IF;
      UPDATE cntct SET cntct_email=_sel.cntct_email WHERE (cntct_id=pTargetCntctId);
    END IF;
    IF (_sel.cntctsel_mrg_webaddr) THEN
      IF (NOT pPurge) THEN
        INSERT INTO trgthist
        SELECT pSourceCntctId,pTargetCntctId,'cntct_webaddr', '''' || cntct_webaddr || ''''
        FROM cntct
        WHERE (cntct_id=pTargetCntctId);
      END IF;
      UPDATE cntct SET cntct_webaddr=_sel.cntct_webaddr WHERE (cntct_id=pTargetCntctId);
    END IF;
    IF (_sel.cntctsel_mrg_notes) THEN
      IF (NOT pPurge) THEN
        INSERT INTO trgthist
        SELECT pSourceCntctId,pTargetCntctId,'cntct_notes', '''' || cntct_notes || ''''
        FROM cntct
        WHERE (cntct_id=pTargetCntctId);
      END IF;
      UPDATE cntct SET cntct_notes=cntct_notes || '

      ' || _sel.cntct_notes WHERE (cntct_id=pTargetCntctId);
    END IF;
    IF (_sel.cntctsel_mrg_title) THEN
      IF (NOT pPurge) THEN
        INSERT INTO trgthist
        SELECT pSourceCntctId,pTargetCntctId,'cntct_title', '''' || cntct_title || ''''
        FROM cntct
        WHERE (cntct_id=pTargetCntctId);
      END IF;
      UPDATE cntct SET cntct_title=_sel.cntct_title WHERE (cntct_id=pTargetCntctId);
    END IF;
    IF (_sel.cntctsel_mrg_middle) THEN
      IF (NOT pPurge) THEN
        INSERT INTO trgthist
        SELECT pSourceCntctId,pTargetCntctId,'cntct_middle', '''' || cntct_middle || ''''
        FROM cntct
        WHERE (cntct_id=pTargetCntctId);
      END IF;
      UPDATE cntct SET cntct_middle=_sel.cntct_middle WHERE (cntct_id=pTargetCntctId);
    END IF;
    IF (_sel.cntctsel_mrg_suffix) THEN
      IF (NOT pPurge) THEN
        INSERT INTO trgthist
        SELECT pSourceCntctId,pTargetCntctId,'cntct_suffix', '''' || cntct_suffix || ''''
        FROM cntct
        WHERE (cntct_id=pTargetCntctId);
      END IF;
      UPDATE cntct SET cntct_suffix=_sel.cntct_suffix WHERE (cntct_id=pTargetCntctId);
    END IF;
    IF (_sel.cntctsel_mrg_owner_username) THEN
      IF (NOT pPurge) THEN
        INSERT INTO trgthist
        SELECT pSourceCntctId,pTargetCntctId,'cntct_owner_username', '''' || cntct_owner_username || ''''
        FROM cntct
        WHERE (cntct_id=pTargetCntctId);
      END IF;
      UPDATE cntct SET cntct_owner_username=_sel.cntct_owner_username WHERE (cntct_id=pTargetCntctId);
    END IF;
  ELSE
    RAISE EXCEPTION 'Source Contact not Found';
  END IF;

  -- Disposition source contact
  IF (pPurge) THEN
    DELETE FROM cntct WHERE cntct_id = pSourceCntctId;
  END IF;

  -- Deactivate contact
  UPDATE cntct SET cntct_active = false WHERE (cntct_id=pSourceCntctId);

  -- Clean up
  DELETE FROM cntctsel WHERE (cntctsel_cntct_id=pSourceCntctId);

  RETURN true;
END;
$_$;


ALTER FUNCTION public.cntctmerge(integer, integer, boolean) OWNER TO admin;

--
-- TOC entry 1231 (class 1255 OID 146565777)
-- Dependencies: 4536 8
-- Name: cntctrestore(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION cntctrestore(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCntctId ALIAS FOR $1;
  _r RECORD;
  _qry TEXT;

BEGIN
  -- Validate
  SELECT * INTO _r FROM cntctmrgd WHERE (cntctmrgd_cntct_id=pCntctId);
  IF (NOT FOUND) THEN
    RETURN false;
  END IF;

  -- Gather the list of affected records
  FOR _r IN
    SELECT * FROM mrghist
    WHERE (mrghist_cntct_id=pCntctId)
  LOOP
    -- Restore the old references
    _qry := 'UPDATE ' || _r.mrghist_table ||
            ' SET ' || _r.mrghist_cntct_col || '=' || pCntctId ||
            ' WHERE (' || _r.mrghist_pkey_col || '=' || _r.mrghist_pkey_id || ');';

   EXECUTE _qry;

  END LOOP;

  -- Gather the list of affected fields
  FOR _r IN
    SELECT * FROM trgthist
    WHERE (trgthist_src_cntct_id=pCntctId)
  LOOP
    -- Restore the old values
    _qry := 'UPDATE cntct
              SET ' || _r.trgthist_col || '=' || _r.trgthist_value ||
            ' WHERE (cntct_id=' || _r.trgthist_trgt_cntct_id || ');';

   EXECUTE _qry;

  END LOOP;

  -- Clean up
  UPDATE cntct SET cntct_active=true WHERE (cntct_id=pCntctId);
  DELETE FROM mrghist WHERE (mrghist_cntct_id=pCntctId);
  DELETE FROM trgthist WHERE (trgthist_src_cntct_id=pCntctId);
  DELETE FROM cntctmrgd WHERE (cntctmrgd_cntct_id=pCntctId);

  RETURN true;

END;
$_$;


ALTER FUNCTION public.cntctrestore(integer) OWNER TO admin;

--
-- TOC entry 1232 (class 1255 OID 146565778)
-- Dependencies: 4536 8
-- Name: cntctselect(integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION cntctselect(integer, boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCntctId ALIAS FOR $1;
  pTarget ALIAS FOR $2;

BEGIN
  -- If target, delete any other targets
  IF (pTarget) THEN
    DELETE FROM cntctsel WHERE cntctsel_target;
  END IF;

  -- Delete any previous selection of this contact
  DELETE FROM cntctsel WHERE cntctsel_cntct_id=pCntctId;

  -- Add this contact in appropriate selection state
  INSERT INTO cntctsel VALUES (pCntctId,pTarget);

  RETURN true;
END;
$_$;


ALTER FUNCTION public.cntctselect(integer, boolean) OWNER TO admin;

--
-- TOC entry 1233 (class 1255 OID 146565779)
-- Dependencies: 4536 8
-- Name: cntctselectcol(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION cntctselectcol(integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCntctId ALIAS FOR $1;
  pColNumber ALIAS FOR $2;

BEGIN

  IF (pColNumber = 2 OR pColNumber = 3) THEN
    UPDATE cntctsel SET cntctsel_mrg_crmacct_id=false WHERE (cntctsel_mrg_crmacct_id AND cntctsel_cntct_id != pCntctId);
    UPDATE cntctsel SET cntctsel_mrg_crmacct_id=true WHERE (cntctsel_cntct_id = pCntctId);
    RETURN true;
  ELSIF (pColNumber = 4) THEN
    UPDATE cntctsel SET cntctsel_mrg_honorific=false WHERE (cntctsel_mrg_honorific AND cntctsel_cntct_id != pCntctId);
    UPDATE cntctsel SET cntctsel_mrg_honorific=true WHERE (cntctsel_cntct_id = pCntctId);
    RETURN true;
  ELSIF (pColNumber = 5) THEN
    UPDATE cntctsel SET cntctsel_mrg_first_name=false WHERE (cntctsel_mrg_first_name AND cntctsel_cntct_id != pCntctId);
    UPDATE cntctsel SET cntctsel_mrg_first_name=true WHERE (cntctsel_cntct_id = pCntctId);
    RETURN true;
  ELSIF (pColNumber = 6) THEN
    UPDATE cntctsel SET cntctsel_mrg_middle=false WHERE (cntctsel_mrg_middle AND cntctsel_cntct_id != pCntctId);
    UPDATE cntctsel SET cntctsel_mrg_middle=true WHERE (cntctsel_cntct_id = pCntctId);
    RETURN true;
  ELSIF (pColNumber = 7) THEN
    UPDATE cntctsel SET cntctsel_mrg_last_name=false WHERE (cntctsel_mrg_last_name AND cntctsel_cntct_id != pCntctId);
    UPDATE cntctsel SET cntctsel_mrg_last_name=true WHERE (cntctsel_cntct_id = pCntctId);
    RETURN true;
  ELSIF (pColNumber = 8) THEN
    UPDATE cntctsel SET cntctsel_mrg_suffix=false WHERE (cntctsel_mrg_suffix AND cntctsel_cntct_id != pCntctId);
    UPDATE cntctsel SET cntctsel_mrg_suffix=true WHERE (cntctsel_cntct_id = pCntctId);
    RETURN true;
  ELSIF (pColNumber = 9) THEN
    UPDATE cntctsel SET cntctsel_mrg_initials=false WHERE (cntctsel_mrg_initials AND cntctsel_cntct_id != pCntctId);
    UPDATE cntctsel SET cntctsel_mrg_initials=true WHERE (cntctsel_cntct_id = pCntctId);
    RETURN true;
  ELSIF (pColNumber = 10) THEN
    UPDATE cntctsel SET cntctsel_mrg_phone=false WHERE (cntctsel_mrg_phone AND cntctsel_cntct_id != pCntctId);
    UPDATE cntctsel SET cntctsel_mrg_phone=true WHERE (cntctsel_cntct_id = pCntctId);
    RETURN true;
  ELSIF (pColNumber = 11) THEN
    UPDATE cntctsel SET cntctsel_mrg_phone2=false WHERE (cntctsel_mrg_phone2 AND cntctsel_cntct_id != pCntctId);
    UPDATE cntctsel SET cntctsel_mrg_phone2=true WHERE (cntctsel_cntct_id = pCntctId);
    RETURN true;
  ELSIF (pColNumber = 12) THEN
    UPDATE cntctsel SET cntctsel_mrg_fax=false WHERE (cntctsel_mrg_fax AND cntctsel_cntct_id != pCntctId);
    UPDATE cntctsel SET cntctsel_mrg_fax=true WHERE (cntctsel_cntct_id = pCntctId);
    RETURN true;
  ELSIF (pColNumber = 13) THEN
    UPDATE cntctsel SET cntctsel_mrg_email=false WHERE (cntctsel_mrg_email AND cntctsel_cntct_id != pCntctId);
    UPDATE cntctsel SET cntctsel_mrg_email=true WHERE (cntctsel_cntct_id = pCntctId);
    RETURN true;
  ELSIF (pColNumber = 14) THEN
    UPDATE cntctsel SET cntctsel_mrg_webaddr=false WHERE (cntctsel_mrg_webaddr AND cntctsel_cntct_id != pCntctId);
    UPDATE cntctsel SET cntctsel_mrg_webaddr=true WHERE (cntctsel_cntct_id = pCntctId);
    RETURN true;
  ELSIF (pColNumber = 15) THEN
    UPDATE cntctsel SET cntctsel_mrg_title=false WHERE (cntctsel_mrg_title AND cntctsel_cntct_id != pCntctId);
    UPDATE cntctsel SET cntctsel_mrg_title=true WHERE (cntctsel_cntct_id = pCntctId);
    RETURN true;
  ELSIF (pColNumber = 16) THEN
    UPDATE cntctsel SET cntctsel_mrg_owner_username=false WHERE (cntctsel_mrg_owner_username AND cntctsel_cntct_id != pCntctId);
    UPDATE cntctsel SET cntctsel_mrg_owner_username=true WHERE (cntctsel_cntct_id = pCntctId);
    RETURN true;
  ELSIF (pColNumber = 17) THEN
    UPDATE cntctsel SET cntctsel_mrg_notes=false WHERE (cntctsel_mrg_notes AND cntctsel_cntct_id != pCntctId);
    UPDATE cntctsel SET cntctsel_mrg_notes=true WHERE (cntctsel_cntct_id = pCntctId);
    RETURN true;
  ELSIF (pColNumber >= 18) THEN
    UPDATE cntctsel SET cntctsel_mrg_addr_id=false WHERE (cntctsel_mrg_addr_id AND cntctsel_cntct_id != pCntctId);
    UPDATE cntctsel SET cntctsel_mrg_addr_id=true WHERE (cntctsel_cntct_id = pCntctId);
    RETURN true;
  END IF;

  RETURN false;
END;
$_$;


ALTER FUNCTION public.cntctselectcol(integer, integer) OWNER TO admin;

--
-- TOC entry 1234 (class 1255 OID 146565780)
-- Dependencies: 4536 8
-- Name: cntctused(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION cntctused(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCntctId ALIAS FOR $1;
  _fk RECORD;
  _r RECORD;
  _seq INTEGER;
  _col TEXT;
  _qry TEXT;

BEGIN
  -- Determine where this contact is used by analyzing foreign key linkages
  -- but ignore child tables and those with impermanent relationships
  FOR _fk IN
    SELECT pg_namespace.nspname AS schemaname, con.relname AS tablename, conkey AS seq, conrelid AS class_id
    FROM pg_constraint, pg_class f, pg_class con, pg_namespace
    WHERE confrelid=f.oid
    AND conrelid=con.oid
    AND f.relname = 'cntct'
    AND con.relnamespace=pg_namespace.oid
    AND con.relname NOT IN ('cntctaddr', 'cntctdata', 'cntcteml',
                            'cohead',    'pohead',    'quhead',   'tohead',
                            'cntctsel',  'cntctmrgd', 'mrghist',  'trgthist')
  LOOP
    -- Validate
    IF (ARRAY_UPPER(_fk.seq,1) > 1) THEN
      RAISE EXCEPTION 'Cannot check dependencies when the contact is one of multiple foreign key columns (%.%) [xtuple: fkeycheck, -1, %, %]',
        _fk.nspname, _fk.relname, _fk.nspname, _fk.relname;
    END IF;

    _seq := _fk.seq[1];

    -- Get the specific column name
    SELECT attname INTO _col
    FROM pg_attribute, pg_class
    WHERE ((attrelid=pg_class.oid)
    AND (pg_class.oid=_fk.class_id)
    AND (attnum=_seq));

    -- See if there are dependencies
    _qry := 'SELECT *
            FROM ' || _fk.schemaname || '.' || _fk.tablename || '
            WHERE ('|| _col || '=' || pCntctId || ');';

    FOR _r IN
      EXECUTE _qry
    LOOP
      RETURN true;
    END LOOP;

  END LOOP;

  RETURN false;

END;
$_$;


ALTER FUNCTION public.cntctused(integer) OWNER TO admin;

--
-- TOC entry 1235 (class 1255 OID 146565781)
-- Dependencies: 4536 8
-- Name: coheadstatecolor(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION coheadstatecolor(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCoheadId	ALIAS FOR $1;
  _shipheadid	INTEGER;
  _result	TEXT := '';

BEGIN

  IF (pCoheadid IS NULL) THEN
    RAISE EXCEPTION 'Customer Id is required.';
  END IF;

  SELECT
    shiphead_id INTO _shipheadid
  FROM cohead
    JOIN shiphead ON ((shiphead_order_id=cohead_id)
                  AND (shiphead_order_type='SO'))
    JOIN shipitem ON (shiphead_id=shipitem_shiphead_id)
  WHERE ((cohead_id=pCoheadId)
    AND (NOT shipitem_invoiced))
  ORDER BY shiphead_id DESC
  LIMIT 1;

  IF (FOUND) THEN
    SELECT
      CASE
        WHEN ((shiphead_shipped)
         AND (COALESCE(shiphead_order_id,0) > 0)
         AND (SUM(noNeg(coitem_qtyord - coitem_qtyshipped + coitem_qtyreturned)) <= 0)) THEN
           'altemphasis'
        WHEN ((COALESCE(cobmisc_cohead_id,0) > 0)
         AND (SUM(noNeg(coitem_qtyord - coitem_qtyshipped + coitem_qtyreturned)) > 0)) THEN
           'error'
        WHEN (NOT shiphead_shipped) THEN
          'emphasis'
       END INTO _result
    FROM cohead
      JOIN coitem ON (cohead_id=coitem_cohead_id)
      JOIN shiphead ON ((shiphead_order_id=cohead_id)
                    AND (shiphead_order_type='SO'))
      JOIN shipitem ON (shiphead_id=shipitem_shiphead_id)
      LEFT OUTER JOIN (SELECT DISTINCT cobmisc_cohead_id FROM cobmisc) AS cobmisc ON (cobmisc_cohead_id=cohead_id)
    WHERE (shiphead_id=_shipheadid)
    GROUP BY shiphead_id,shiphead_shipped,shiphead_order_id,cobmisc_cohead_id
    ORDER BY shiphead_id DESC;
  ELSE
    _result := '';
  END IF;

  RETURN _result;

END;
$_$;


ALTER FUNCTION public.coheadstatecolor(integer) OWNER TO admin;

--
-- TOC entry 1237 (class 1255 OID 146565782)
-- Dependencies: 4536 8
-- Name: compareversion(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION compareversion(text, text DEFAULT split_part(version(), ' '::text, 2)) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $_$
DECLARE
  _leftVersion ALIAS FOR $1;
  _rightVersion ALIAS FOR $2;
  _leftMajor SMALLINT;
  _leftMinor SMALLINT;
  _leftPatch SMALLINT;
  _rightMajor SMALLINT;
  _rightMinor SMALLINT;
  _rightPatch SMALLINT;
  _returnCode SMALLINT;
  DEBUG BOOLEAN := false;
BEGIN

-- left
SELECT  substring(_leftVersion FROM $$(\d+)\.\d+\.\d+$$)::SMALLINT,
	substring(_leftVersion FROM $$\d+\.(\d+)\.\d+$$)::SMALLINT,
	substring(_leftVersion FROM $$\d+\.\d+\.(\d+)$$)::SMALLINT
	INTO _leftMajor, _leftMinor, _leftPatch;

IF (DEBUG)
  THEN RAISE NOTICE 'Left Version --> % Major --> % Minor --> % Patch --> % ', _leftVersion, _leftMajor, _leftMinor, _leftPatch;
END IF;

-- right
SELECT  substring(_rightVersion FROM $$(\d+)\.\d+\.\d+$$)::SMALLINT,
	substring(_rightVersion FROM $$\d+\.(\d+)\.\d+$$)::SMALLINT,
	substring(_rightVersion FROM $$\d+\.\d+\.(\d+)$$)::SMALLINT
	INTO _rightMajor, _rightMinor, _rightPatch;

IF (DEBUG)
 THEN RAISE NOTICE 'Right Version --> % Major --> % Minor --> % Patch --> % ', _rightVersion, _rightMajor, _rightMinor, _rightPatch;
END IF;

-- check major version
IF (_leftMajor > _rightMajor) THEN _returnCode := 1;
ELSIF (_leftMajor < _rightMajor) THEN _returnCode := -1;
ELSIF (_leftMajor = _rightMajor) THEN
  -- if major is equal, check minor version
  IF (_leftMinor > _rightMinor) THEN _returnCode := 1;
  ELSIF (_leftMinor < _rightMinor) THEN _returnCode := -1;
  ELSIF (_leftMinor = _rightMinor) THEN
    -- if major and minor are equal, check patch version
    IF (_leftPatch > _rightPatch) THEN _returnCode := 1;
    ELSIF (_leftPatch < _rightPatch) THEN _returnCode := -1;
    ELSIF (_leftPatch = _rightPatch) THEN _returnCode := 0;
    END IF;
  END IF;
-- if we somehow don't match those three operators it probably means someone passed in a version that wasn't in numerical major.minor.patch format
ELSE RAISE EXCEPTION 'One or more of the version parameters is invalid. Expected numerical Major.Minor.Patch version string. Left --> % Right --> %', _leftVersion, _rightVersion;
END IF;

RETURN _returnCode;

END;
$_$;


ALTER FUNCTION public.compareversion(text, text) OWNER TO admin;

--
-- TOC entry 1238 (class 1255 OID 146565783)
-- Dependencies: 4536 8
-- Name: concataggsfunc(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION concataggsfunc(text, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  prevstate     ALIAS FOR $1;
  newval        ALIAS FOR $2;
BEGIN
  RETURN prevstate || newval;
END;
$_$;


ALTER FUNCTION public.concataggsfunc(text, text) OWNER TO admin;

--
-- TOC entry 1239 (class 1255 OID 146565784)
-- Dependencies: 4536 8
-- Name: consolidatelocations(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION consolidatelocations(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  _r RECORD;

BEGIN

  UPDATE itemloc
  SET itemloc_consolflag = TRUE
  WHERE (itemloc_itemsite_id=pItemsiteid);

  FOR _r IN SELECT itemloc_location_id, SUM(itemloc_qty) AS qty
            FROM itemloc
            WHERE (itemloc_itemsite_id=pItemsiteid)
            GROUP BY itemloc_location_id LOOP
    INSERT INTO itemloc
    ( itemloc_itemsite_id, itemloc_location_id,
      itemloc_expiration, itemloc_qty, itemloc_consolflag )
    VALUES
    ( pItemsiteid, _r.itemloc_location_id,
      endOfTime(), _r.qty, FALSE );
  END LOOP;

  DELETE FROM itemloc
  WHERE ( (itemloc_itemsite_id=pItemsiteid)
   AND (itemloc_consolflag) );

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.consolidatelocations(integer) OWNER TO admin;

--
-- TOC entry 1240 (class 1255 OID 146565785)
-- Dependencies: 4536 8
-- Name: convertcustomertoprospect(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION convertcustomertoprospect(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCustId     ALIAS FOR $1;
  _c          RECORD;
BEGIN
  SELECT * INTO _c
  FROM custinfo
  WHERE (cust_id=pCustId);

  INSERT INTO prospect (
        prospect_id, prospect_active, prospect_number,
        prospect_name, prospect_cntct_id, prospect_taxzone_id,
        prospect_salesrep_id, prospect_warehous_id, prospect_comments
  ) VALUES (
       _c.cust_id, _c.cust_active, _c.cust_number,
       _c.cust_name, _c.cust_cntct_id, _c.cust_taxzone_id,
       CASE WHEN(_c.cust_salesrep_id > 0) THEN _c.cust_salesrep_id
            ELSE NULL
       END,
       CASE WHEN(_c.cust_preferred_warehous_id > 0) THEN _c.cust_preferred_warehous_id
            ELSE NULL
       END,
       _c.cust_comments);

  DELETE FROM custinfo WHERE (cust_id=pCustId);

  RETURN pCustId;
END;
$_$;


ALTER FUNCTION public.convertcustomertoprospect(integer) OWNER TO admin;

--
-- TOC entry 1241 (class 1255 OID 146565786)
-- Dependencies: 4536 8
-- Name: convertprospecttocustomer(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION convertprospecttocustomer(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN convertProspectToCustomer($1, FALSE);
END;
$_$;


ALTER FUNCTION public.convertprospecttocustomer(integer) OWNER TO admin;

--
-- TOC entry 1242 (class 1255 OID 146565787)
-- Dependencies: 4536 8
-- Name: convertprospecttocustomer(integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION convertprospecttocustomer(integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pProspectId ALIAS FOR $1;
  pdoquotes   ALIAS FOR $2;
  _p          RECORD;
  _q          RECORD;

BEGIN
  SELECT * INTO _p
  FROM prospect
  WHERE (prospect_id=pProspectId);

  IF (EXISTS(SELECT cust_id FROM custinfo WHERE cust_id=pProspectId)) THEN
    RAISE EXCEPTION '[xtuple: convertProspectToCustomer, -10]';
  END IF;

  INSERT INTO custinfo (
        cust_id, cust_active, cust_number,
        cust_name, cust_cntct_id, cust_taxzone_id,
        cust_comments, cust_creditstatus,
        cust_salesrep_id, cust_preferred_warehous_id,
        cust_terms_id,
        cust_custtype_id, cust_shipform_id,
        cust_shipvia, cust_balmethod,
        cust_ffshipto, cust_backorder,
        cust_partialship, cust_creditlmt,
        cust_creditrating, cust_commprcnt,
        cust_discntprcnt, cust_blanketpos,
        cust_shipchrg_id, cust_ffbillto,
        cust_usespos, cust_emaildelivery,
        cust_autoupdatestatus,cust_autoholdorders,
        cust_soemaildelivery)
  SELECT
      _p.prospect_id, _p.prospect_active, _p.prospect_number,
      _p.prospect_name, _p.prospect_cntct_id, _p.prospect_taxzone_id,
      _p.prospect_comments, 'G',
      COALESCE(_p.prospect_salesrep_id, salesrep_id),
      COALESCE(_p.prospect_warehous_id, -1),
      FetchMetricValue('DefaultTerms'),
      FetchMetricValue('DefaultCustType'),
      FetchMetricValue('DefaultShipFormId'),
      COALESCE(FetchMetricValue('DefaultShipViaId'),-1),
      FetchMetricText('DefaultBalanceMethod'),
      FetchMetricBool('DefaultFreeFormShiptos'),
      FetchMetricBool('DefaultBackOrders'),
      FetchMetricBool('DefaultPartialShipments'),
      FetchMetricValue('SOCreditLimit'),
      FetchMetricText('SOCreditRate'),
      salesrep_commission,
      0, false, -1,false,false,false,false,
      false, false
  FROM salesrep WHERE (salesrep_id=FetchMetricValue('DefaultSalesRep'));

  DELETE FROM prospect WHERE (prospect_id=pprospectId);

  IF (pdoquotes) THEN
    BEGIN
      FOR _q IN SELECT quhead_number, convertQuote(quhead_id) AS err
                  FROM quhead
                 WHERE ((COALESCE(quhead_expire, endOfTime()) >= CURRENT_DATE)
                    AND (quhead_cust_id=pProspectId)) LOOP
        IF (_q.err < 0) THEN
          RAISE NOTICE 'Quote % for % didn''t convert to a Sales Order [xtuple: convertQuote, %]',
                       _q.quhead_number, _p.prospect_number, _q.err;
        END IF;
      END LOOP;
    EXCEPTION WHEN OTHERS THEN
      RAISE NOTICE 'Ignored errors convering quotes: % %', SQLSTATE, SQLERRM;
    END;
  END IF;

  RETURN pProspectId;
END;
$_$;


ALTER FUNCTION public.convertprospecttocustomer(integer, boolean) OWNER TO admin;

--
-- TOC entry 1243 (class 1255 OID 146565788)
-- Dependencies: 4536 8
-- Name: convertquote(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION convertquote(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pQuheadid ALIAS FOR $1;
  _soheadid INTEGER;
  _soitemid INTEGER;
  _orderid INTEGER;
  _ordertype CHARACTER(1);
  _creditstatus	TEXT;
  _usespos BOOLEAN := false;
  _blanketpos BOOLEAN := true;
  _showConvertedQuote BOOLEAN := false;
  _prospectid	INTEGER;
  _r RECORD;
  _soNum TEXT;

BEGIN

-- Check to make sure the quote has not expired
  IF (SELECT COALESCE(quhead_expire, endOfTime()) < CURRENT_DATE
        FROM quhead
       WHERE(quhead_id=pQuheadid)) THEN
    RETURN -6;
  END IF;

--  Check to make sure that all of the quote items have a valid itemsite
  SELECT quitem_id INTO _r
    FROM quitem LEFT OUTER JOIN itemsite ON (quitem_itemsite_id=itemsite_id)
   WHERE ((itemsite_id IS NULL)
     AND  (quitem_quhead_id=pQuheadid));
  IF (FOUND) THEN
    PERFORM postEvent('CannotConvertQuote', 'Q', quhead_id,
                      quhead_warehous_id, quhead_number,
                      NULL, NULL, NULL, NULL)
    FROM quhead
    WHERE (quhead_id=pQuheadid);

    RETURN -1;
  END IF;

  SELECT cust_creditstatus, cust_usespos, cust_blanketpos
    INTO _creditstatus, _usespos, _blanketpos
  FROM quhead, custinfo
  WHERE ((quhead_cust_id=cust_id)
    AND  (quhead_id=pQuheadid));

  IF (NOT FOUND) THEN
    SELECT prospect_id INTO _prospectid
    FROM quhead, prospect
    WHERE ((quhead_cust_id=prospect_id)
      AND  (quhead_id=pQuheadid));
    IF (NOT FOUND) THEN
      RETURN -2;
    ELSE
      RETURN -3;
    END IF;
  ELSIF (_creditstatus = 'H' AND NOT checkPrivilege('CreateSOForHoldCustomer')) THEN
    RETURN -4;
  ELSIF (_creditstatus = 'W' AND NOT checkPrivilege('CreateSOForWarnCustomer')) THEN
    RETURN -5;
  END IF;

  IF ( (_usespos) AND (NOT _blanketpos) ) THEN
    PERFORM cohead_id
    FROM quhead JOIN cohead ON ( (cohead_cust_id=quhead_cust_id) AND
                                 (UPPER(cohead_custponumber)=UPPER(quhead_custponumber)) )
    WHERE (quhead_id=pQuheadid);
    IF (FOUND) THEN
      RAISE EXCEPTION 'Duplicate Customer PO';
    END IF;
  END IF;

  PERFORM quhead_number, cohead_id
  FROM quhead, cohead
  WHERE quhead_id = pQuheadid
  AND cohead_number = quhead_number;

  IF (FOUND) THEN
    SELECT fetchSoNumber() INTO _soNum;
  ELSE
    SELECT quhead_number INTO _soNum
    FROM quhead
    WHERE quhead_id = pQuheadid;
  END IF;

  SELECT NEXTVAL('cohead_cohead_id_seq') INTO _soheadid;
  INSERT INTO cohead
  ( cohead_id, cohead_number, cohead_cust_id,
    cohead_orderdate, cohead_packdate,
    cohead_custponumber, cohead_warehous_id,
    cohead_billtoname, cohead_billtoaddress1,
    cohead_billtoaddress2, cohead_billtoaddress3,
    cohead_billtocity, cohead_billtostate, cohead_billtozipcode,
    cohead_billtocountry,
    cohead_shipto_id, cohead_shiptoname, cohead_shiptoaddress1,
    cohead_shiptoaddress2, cohead_shiptoaddress3,
    cohead_shiptocity, cohead_shiptostate, cohead_shiptozipcode,
    cohead_shiptocountry,
    cohead_salesrep_id, cohead_commission,
    cohead_terms_id, cohead_shipchrg_id, cohead_shipform_id,
    cohead_fob, cohead_shipvia,
    cohead_ordercomments, cohead_shipcomments,
    cohead_freight, cohead_misc, cohead_misc_accnt_id, cohead_misc_descrip,
    cohead_holdtype, cohead_wasquote, cohead_quote_number, cohead_prj_id,
    cohead_curr_id, cohead_taxzone_id, cohead_taxtype_id,
    cohead_shipto_cntct_id, cohead_shipto_cntct_honorific, cohead_shipto_cntct_first_name,
    cohead_shipto_cntct_middle, cohead_shipto_cntct_last_name, cohead_shipto_cntct_suffix,
    cohead_shipto_cntct_phone, cohead_shipto_cntct_title, cohead_shipto_cntct_fax,
    cohead_shipto_cntct_email,
    cohead_billto_cntct_id, cohead_billto_cntct_honorific,
    cohead_billto_cntct_first_name, cohead_billto_cntct_middle, cohead_billto_cntct_last_name,
    cohead_billto_cntct_suffix, cohead_billto_cntct_phone, cohead_billto_cntct_title,
    cohead_billto_cntct_fax, cohead_billto_cntct_email, cohead_ophead_id,
    cohead_calcfreight, cohead_saletype_id, cohead_shipzone_id )
  SELECT _soheadid, _soNum, quhead_cust_id,
         CURRENT_DATE, quhead_packdate,
         quhead_custponumber, quhead_warehous_id,
         quhead_billtoname, quhead_billtoaddress1,
         quhead_billtoaddress2, quhead_billtoaddress3,
         quhead_billtocity, quhead_billtostate, quhead_billtozip,
         quhead_billtocountry,
         quhead_shipto_id, quhead_shiptoname, quhead_shiptoaddress1,
         quhead_shiptoaddress2, quhead_shiptoaddress3,
         quhead_shiptocity, quhead_shiptostate, quhead_shiptozipcode,
         quhead_shiptocountry,
         quhead_salesrep_id, quhead_commission,
         quhead_terms_id, cust_shipchrg_id, cust_shipform_id,
         quhead_fob, quhead_shipvia,
         quhead_ordercomments, quhead_shipcomments,
         quhead_freight, quhead_misc, quhead_misc_accnt_id, quhead_misc_descrip,
         'N', TRUE, quhead_number, quhead_prj_id,
	 quhead_curr_id, quhead_taxzone_id, quhead_taxtype_id,
	 quhead_shipto_cntct_id, quhead_shipto_cntct_honorific,
	 quhead_shipto_cntct_first_name, quhead_shipto_cntct_middle, quhead_shipto_cntct_last_name,
	 quhead_shipto_cntct_suffix, quhead_shipto_cntct_phone, quhead_shipto_cntct_title,
	 quhead_shipto_cntct_fax, quhead_shipto_cntct_email, quhead_billto_cntct_id,
	 quhead_billto_cntct_honorific, quhead_billto_cntct_first_name, quhead_billto_cntct_middle,
	 quhead_billto_cntct_last_name, quhead_billto_cntct_suffix, quhead_billto_cntct_phone,
	 quhead_billto_cntct_title, quhead_billto_cntct_fax, quhead_billto_cntct_email, quhead_ophead_id,
         quhead_calcfreight, quhead_saletype_id, quhead_shipzone_id
  FROM quhead JOIN custinfo ON (cust_id=quhead_cust_id)
  WHERE (quhead_id=pQuheadid);

  UPDATE url SET url_source_id = _soheadid,
                 url_source = 'S'
  WHERE ((url_source='Q') AND (url_source_id = pQuheadid));

  UPDATE imageass SET imageass_source_id = _soheadid,
                      imageass_source = 'S'
  WHERE ((imageass_source='Q') AND (imageass_source_id = pQuheadid));

  UPDATE docass SET docass_source_id = _soheadid,
                    docass_source_type = 'S'
  WHERE ((docass_source_type='Q') AND (docass_source_id = pQuheadid));

  -- Copy Comments
  INSERT INTO comment
  ( comment_cmnttype_id, comment_source, comment_source_id, comment_date, comment_user, comment_text, comment_public )
  SELECT comment_cmnttype_id, 'S', _soheadid, comment_date, comment_user, ('Quote-' || comment_text), comment_public
  FROM comment
  WHERE ( (comment_source='Q')
    AND   (comment_source_id=pQuheadid) );

  FOR _r IN SELECT quitem.*,
                   quhead_number, quhead_prj_id,
                   itemsite_item_id, itemsite_leadtime,
                   itemsite_createsopo, itemsite_createsopr,
                   item_type, COALESCE(quitem_itemsrc_id, itemsrc_id, -1) AS itemsrcid
            FROM quhead JOIN quitem ON (quitem_quhead_id=quhead_id)
                        JOIN itemsite ON (itemsite_id=quitem_itemsite_id)
                        JOIN item ON (item_id=itemsite_item_id)
                        LEFT OUTER JOIN itemsrc ON ( (itemsrc_item_id=item_id) AND
                                                     (itemsrc_default) )
            WHERE (quhead_id=pQuheadid)
            ORDER BY quitem_linenumber LOOP

    SELECT NEXTVAL('coitem_coitem_id_seq') INTO _soitemid;

    INSERT INTO coitem
    ( coitem_id, coitem_cohead_id, coitem_linenumber, coitem_itemsite_id,
      coitem_status, coitem_scheddate, coitem_promdate,
      coitem_price, coitem_custprice,
      coitem_qtyord, coitem_qtyshipped, coitem_qtyreturned,
      coitem_qty_uom_id, coitem_qty_invuomratio,
      coitem_price_uom_id, coitem_price_invuomratio,
      coitem_unitcost, coitem_prcost,
      coitem_custpn, coitem_memo, coitem_taxtype_id, coitem_order_id )
    VALUES
    ( _soitemid, _soheadid, _r.quitem_linenumber, _r.quitem_itemsite_id,
      'O', _r.quitem_scheddate, _r.quitem_promdate,
      _r.quitem_price, _r.quitem_custprice,
      _r.quitem_qtyord, 0, 0,
      _r.quitem_qty_uom_id, _r.quitem_qty_invuomratio,
      _r.quitem_price_uom_id, _r.quitem_price_invuomratio,
      stdcost(_r.itemsite_item_id), _r.quitem_prcost,
      _r.quitem_custpn, _r.quitem_memo, _r.quitem_taxtype_id, -1 );

    IF (fetchMetricBool('enablextcommissionission')) THEN
      PERFORM xtcommission.getSalesReps(quhead_cust_id, quhead_shipto_id,
                                        _r.itemsite_item_id, _r.quitem_price,
                                        _soitemid, 'SalesItem')
      FROM quhead
      WHERE (quhead_id=pQuheadid);
    END IF;

    INSERT INTO charass
          (charass_target_type, charass_target_id, charass_char_id, charass_value, charass_default, charass_price)
    SELECT 'SI', _soitemid, charass_char_id, charass_value, charass_default, charass_price
      FROM charass
     WHERE ((charass_target_type='QI')
       AND  (charass_target_id=_r.quitem_id));

    -- Copy Comments
    INSERT INTO comment
    ( comment_cmnttype_id, comment_source, comment_source_id, comment_date, comment_user, comment_text )
    SELECT comment_cmnttype_id, 'SI', _soitemid, comment_date, comment_user, ('Quote-' || comment_text)
    FROM comment
    WHERE ( (comment_source='QI')
      AND   (comment_source_id=_r.quitem_id) );

    _orderid := -1;
    _ordertype := '';
    IF (_r.quitem_createorder) THEN

      IF (_r.item_type IN ('M')) THEN
        SELECT createWo( CAST(_r.quhead_number AS INTEGER), supply.itemsite_id, 1, (_r.quitem_qtyord * _r.quitem_qty_invuomratio),
                         _r.itemsite_leadtime, _r.quitem_scheddate, _r.quitem_memo, 'S', _soitemid, _r.quhead_prj_id ) INTO _orderId
        FROM itemsite sold, itemsite supply
        WHERE ((sold.itemsite_item_id=supply.itemsite_item_id)
         AND (supply.itemsite_warehous_id=_r.quitem_order_warehous_id)
         AND (sold.itemsite_id=_r.quitem_itemsite_id) );
        _orderType := 'W';

        INSERT INTO charass
              (charass_target_type, charass_target_id, charass_char_id, charass_value)
        SELECT 'W', _orderId, charass_char_id, charass_value
          FROM charass
         WHERE ((charass_target_type='QI')
           AND  (charass_target_id=_r.quitem_id));

      ELSIF ( (_r.item_type IN ('P', 'O')) AND (_r.itemsite_createsopr) ) THEN
        SELECT createPr( CAST(_r.quhead_number AS INTEGER), _r.quitem_itemsite_id, (_r.quitem_qtyord * _r.quitem_qty_invuomratio),
                         _r.quitem_scheddate, '', 'S', _soitemid ) INTO _orderId;
        _orderType := 'R';
        UPDATE pr SET pr_prj_id=_r.quhead_prj_id WHERE pr_id=_orderId;
      ELSIF ( (_r.item_type IN ('P', 'O')) AND (_r.itemsite_createsopo) ) THEN
        IF (_r.quitem_prcost=0) THEN
          SELECT createPurchaseToSale(_soitemid, _r.itemsrcid, _r.quitem_dropship) INTO _orderId;
        ELSE
          SELECT createPurchaseToSale(_soitemid, _r.itemsrcid, _r.quitem_dropship, _r.quitem_prcost) INTO _orderId;
        END IF;
        _orderType := 'P';
      END IF;

      UPDATE coitem SET coitem_order_type=_ordertype, coitem_order_id=_orderid
      WHERE (coitem_id=_soitemid);

    END IF;

  END LOOP;

  SELECT metric_value INTO _showConvertedQuote
  FROM metric WHERE metric_name = 'ShowQuotesAfterSO';

  IF (_showConvertedQuote) THEN
    UPDATE quhead
    SET quhead_status= 'C'
    WHERE (quhead_id = pQuheadid);
  ELSE
  PERFORM deleteQuote(pQuheadid);
  END IF;

  RETURN _soheadid;

END;
$_$;


ALTER FUNCTION public.convertquote(integer) OWNER TO admin;

--
-- TOC entry 1244 (class 1255 OID 146565790)
-- Dependencies: 4536 8
-- Name: convertquotetoinvoice(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION convertquotetoinvoice(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pQuheadid ALIAS FOR $1;
  _iheadid INTEGER;
  _iitemid INTEGER;
  _orderid INTEGER;
  _ordertype CHARACTER(1);
  _creditstatus	TEXT;
  _usespos BOOLEAN := false;
  _blanketpos BOOLEAN := true;
  _showConvertedQuote BOOLEAN := false;
  _prospectid	INTEGER;
  _r RECORD;
  _inNum TEXT;

BEGIN

-- Check to make sure the quote has not expired
  IF (SELECT COALESCE(quhead_expire, endOfTime()) < CURRENT_DATE
        FROM quhead
       WHERE(quhead_id=pQuheadid)) THEN
    RETURN -6;
  END IF;

--  Check to make sure that all of the quote items have a valid itemsite
  SELECT quitem_id INTO _r
    FROM quitem LEFT OUTER JOIN itemsite ON (quitem_itemsite_id=itemsite_id)
   WHERE ((itemsite_id IS NULL)
     AND  (quitem_quhead_id=pQuheadid));
  IF (FOUND) THEN
    PERFORM postEvent('CannotConvertQuote', 'Q', quhead_id,
                      quhead_warehous_id, quhead_number,
                      NULL, NULL, NULL, NULL)
    FROM quhead
    WHERE (quhead_id=pQuheadid);

    RETURN -1;
  END IF;

-- Get Credit Stat, Uses POs and Blanket POs

  SELECT cust_creditstatus, cust_usespos, cust_blanketpos
    INTO _creditstatus, _usespos, _blanketpos
  FROM quhead, custinfo
  WHERE ((quhead_cust_id=cust_id)
    AND  (quhead_id=pQuheadid));

-- Check to see if customer or prospect

  IF (NOT FOUND) THEN
    SELECT prospect_id INTO _prospectid
    FROM quhead, prospect
    WHERE ((quhead_cust_id=prospect_id)
      AND  (quhead_id=pQuheadid));
    IF (NOT FOUND) THEN
      RETURN -2;
    ELSE
      RETURN -3;
    END IF;
  ELSIF (_creditstatus = 'H' AND NOT hasPriv('CreateSOForHoldCustomer')) THEN
    RETURN -4;
  ELSIF (_creditstatus = 'W' AND NOT hasPriv('CreateSOForWarnCustomer')) THEN
    RETURN -5;
  END IF;

-- PO/blanket PO checks

  IF ( (_usespos) AND (NOT _blanketpos) ) THEN
    PERFORM invchead_id
    FROM quhead JOIN invchead ON ( (invchead_cust_id=quhead_cust_id) AND
                                 (UPPER(invchead_custponumber)=UPPER(quhead_custponumber)) )
    WHERE (quhead_id=pQuheadid);
    IF (FOUND) THEN
      RAISE EXCEPTION 'Duplicate Customer PO';
    END IF;
  END IF;

--Check to see if an invoice exists with the quote number

  PERFORM quhead_number, invchead_id
  FROM quhead, invchead
  WHERE quhead_id = pQuheadid
  AND invchead_invcnumber = quhead_number;

-- If it does then get a new Invoice number otherwise use the quote number as the invoice number

  IF (FOUND) THEN
    SELECT fetchinvcnumber() INTO _inNum;
  ELSE
    SELECT quhead_number INTO _inNum
    FROM quhead
    WHERE quhead_id = pQuheadid;
  END IF;

--Insert quote info into invoice tables

  SELECT NEXTVAL('invchead_invchead_id_seq') INTO _iheadid;
  INSERT INTO invchead
  ( invchead_ordernumber, invchead_shipdate, invchead_recurring,
    invchead_id, invchead_invcnumber, invchead_cust_id,
    invchead_orderdate, invchead_ponumber,
    invchead_billto_name, invchead_billto_address1,
    invchead_billto_address2, invchead_billto_address3,
    invchead_billto_city, invchead_billto_state, invchead_billto_zipcode, invchead_billto_country,
    invchead_shipto_id, invchead_shipto_name, invchead_shipto_address1,
    invchead_shipto_address2, invchead_shipto_address3,
    invchead_shipto_city, invchead_shipto_state, invchead_shipto_zipcode, invchead_shipto_country,
    invchead_salesrep_id, invchead_commission,
    invchead_terms_id, invchead_shipchrg_id, invchead_fob, invchead_shipvia,
    invchead_notes, invchead_freight,
    invchead_misc_amount, invchead_misc_accnt_id, invchead_misc_descrip,
    invchead_prj_id, invchead_curr_id, invchead_taxzone_id,
    invchead_posted, invchead_printed, invchead_invcdate,
    invchead_saletype_id, invchead_shipzone_id
    --invchead_taxtype_id,
    --invchead_shipto_cntct_id, invchead_shipto_cntct_honorific, invchead_shipto_cntct_first_name,
    --invchead_shipto_cntct_middle, invchead_shipto_cntct_last_name, invchead_shipto_cntct_suffix,
    --invchead_shipto_cntct_phone, invchead_shipto_cntct_title, invchead_shipto_cntct_fax,
    --invchead_shipto_cntct_email,
    --invchead_billto_cntct_id, invchead_billto_cntct_honorific,
    --invchead_billto_cntct_first_name, invchead_billto_cntct_middle, invchead_billto_cntct_last_name,
    --invchead_billto_cntct_suffix, invchead_billto_cntct_phone, invchead_billto_cntct_title,
    --invchead_billto_cntct_fax, invchead_billto_cntct_email,
    --invchead_ophead_id,
    --invchead_calcfreight
    )
  SELECT quhead_number, quhead_packdate, 'f',
         _iheadid, _inNum, quhead_cust_id,
         CURRENT_DATE, quhead_custponumber,
         quhead_billtoname, quhead_billtoaddress1,
         quhead_billtoaddress2, quhead_billtoaddress3,
         quhead_billtocity, quhead_billtostate, quhead_billtozip, quhead_billtocountry,
         quhead_shipto_id, quhead_shiptoname, quhead_shiptoaddress1,
         quhead_shiptoaddress2, quhead_shiptoaddress3,
         quhead_shiptocity, quhead_shiptostate, quhead_shiptozipcode, quhead_shiptocountry,
         quhead_salesrep_id, quhead_commission,
         quhead_terms_id, cust_shipchrg_id, quhead_fob, quhead_shipvia,
         quhead_ordercomments,  quhead_freight,
         quhead_misc, quhead_misc_accnt_id, quhead_misc_descrip,
         quhead_prj_id, quhead_curr_id, quhead_taxzone_id,
         'f','f',current_date,
         quhead_saletype_id, quhead_shipzone_id
         --quhead_shipto_cntct_id, quhead_shipto_cntct_honorific,
	 --quhead_shipto_cntct_first_name, quhead_shipto_cntct_middle, quhead_shipto_cntct_last_name,
	 --quhead_shipto_cntct_suffix, quhead_shipto_cntct_phone, quhead_shipto_cntct_title,
	 --quhead_shipto_cntct_fax, quhead_shipto_cntct_email, quhead_billto_cntct_id,
	 --quhead_billto_cntct_honorific, quhead_billto_cntct_first_name, quhead_billto_cntct_middle,
	 --quhead_billto_cntct_last_name, quhead_billto_cntct_suffix, quhead_billto_cntct_phone,
	 --quhead_billto_cntct_title, quhead_billto_cntct_fax, quhead_billto_cntct_email, quhead_ophead_id,
         --quhead_calcfreight
  FROM quhead JOIN custinfo ON (cust_id=quhead_cust_id)
  WHERE (quhead_id=pQuheadid);

-- Attachments on Invoice not supported but leaving this in for future use:
/*
  UPDATE url SET url_source_id = _iheadid,
                 url_source = 'I'
  WHERE ((url_source='Q') AND (url_source_id = pQuheadid));

  UPDATE imageass SET imageass_source_id = _iheadid,
                      imageass_source = 'I'
  WHERE ((imageass_source='Q') AND (imageass_source_id = pQuheadid));

  UPDATE docass SET docass_source_id = _iheadid,
                    docass_source_type = 'I'
  WHERE ((docass_source_type='Q') AND (docass_source_id = pQuheadid));
*/


-- Comments not supported on Invoice but leaving this in for future use:

/*
  INSERT INTO comment
  ( comment_cmnttype_id, comment_source, comment_source_id, comment_date, comment_user, comment_text, comment_public )
  SELECT comment_cmnttype_id, 'I', _iheadid, comment_date, comment_user, ('Quote-' || comment_text), comment_public
  FROM comment
  WHERE ( (comment_source='Q')
    AND   (comment_source_id=pQuheadid) );
*/

  FOR _r IN SELECT quitem.*,
                   quhead_number, quhead_prj_id,
                   itemsite_item_id, itemsite_leadtime,
                   itemsite_createsopo, itemsite_createsopr,
                   item_type, COALESCE(quitem_itemsrc_id, itemsrc_id, -1) AS itemsrcid
            FROM quhead JOIN quitem ON (quitem_quhead_id=quhead_id)
                        JOIN itemsite ON (itemsite_id=quitem_itemsite_id)
                        JOIN item ON (item_id=itemsite_item_id)
                        LEFT OUTER JOIN itemsrc ON ( (itemsrc_item_id=item_id) AND
                                                     (itemsrc_default) )
            WHERE (quhead_id=pQuheadid) LOOP

    SELECT NEXTVAL('invcitem_invcitem_id_seq') INTO _iitemid;

    INSERT INTO invcitem
    ( invcitem_id, invcitem_invchead_id, invcitem_linenumber,
      invcitem_item_id,
      invcitem_warehous_id,
      --invcitem_status,
      --invcitem_scheddate, invcitem_promdate,
      invcitem_price, invcitem_custprice,
      invcitem_ordered, invcitem_billed,
      invcitem_qty_uom_id, invcitem_qty_invuomratio,
      invcitem_price_uom_id, invcitem_price_invuomratio,
      invcitem_custpn, invcitem_notes, invcitem_taxtype_id )
    VALUES
    ( _iitemid, _iheadid, _r.quitem_linenumber,
      (SELECT itemsite_item_id FROM itemsite WHERE itemsite_id = _r.quitem_itemsite_id),
      (SELECT itemsite_warehous_id FROM itemsite WHERE itemsite_id = _r.quitem_itemsite_id),
      --'O',
      --_r.quitem_scheddate, _r.quitem_promdate,
      _r.quitem_price, _r.quitem_custprice,
      _r.quitem_qtyord, _r.quitem_qtyord,
      _r.quitem_qty_uom_id, _r.quitem_qty_invuomratio,
      _r.quitem_price_uom_id, _r.quitem_price_invuomratio,
      _r.quitem_custpn, _r.quitem_memo, _r.quitem_taxtype_id );

    IF (fetchMetricBool('enablextcommissionission')) THEN
      PERFORM xtcommission.getSalesReps(quhead_cust_id, quhead_shipto_id,
                                        _r.itemsite_item_id, _r.quitem_price,
                                        _iitemid, 'InvoiceItem')
      FROM quhead
      WHERE (quhead_id=pQuheadid);
    END IF;

-- Chracteristics not supported on Invoice but leaving in for future use:

/*
    INSERT INTO charass
          (charass_target_type, charass_target_id, charass_char_id, charass_value, charass_default, charass_price)
    SELECT 'SI', _iitemid, charass_char_id, charass_value, charass_default, charass_price
      FROM charass
     WHERE ((charass_target_type='QI')
       AND  (charass_target_id=_r.quitem_id));
*/


-- Comments not supported but leaving in for future use

/*
    INSERT INTO comment
    ( comment_cmnttype_id, comment_source, comment_source_id, comment_date, comment_user, comment_text )
    SELECT comment_cmnttype_id, 'SI', _iitemid, comment_date, comment_user, ('Quote-' || comment_text)
    FROM comment
    WHERE ( (comment_source='QI')
      AND   (comment_source_id=_r.quitem_id) );
*/

    _orderid := -1;
    _ordertype := '';
    IF (_r.quitem_createorder) THEN

      IF (_r.item_type IN ('M')) THEN
        SELECT createWo( CAST(_r.quhead_number AS INTEGER), supply.itemsite_id, 1, (_r.quitem_qtyord * _r.quitem_qty_invuomratio),
                         _r.itemsite_leadtime, _r.quitem_scheddate, _r.quitem_memo, 'Q', _iitemid, _r.quhead_prj_id ) INTO _orderId
        FROM itemsite sold, itemsite supply
        WHERE ((sold.itemsite_item_id=supply.itemsite_item_id)
         AND (supply.itemsite_warehous_id=_r.quitem_order_warehous_id)
         AND (sold.itemsite_id=_r.quitem_itemsite_id) );
        _orderType := 'W';

        INSERT INTO charass
              (charass_target_type, charass_target_id, charass_char_id, charass_value)
        SELECT 'W', _orderId, charass_char_id, charass_value
          FROM charass
         WHERE ((charass_target_type='QI')
           AND  (charass_target_id=_r.quitem_id));

      ELSIF ( (_r.item_type IN ('P', 'O')) AND (_r.itemsite_createsopr) ) THEN
        SELECT createPr( CAST(_r.quhead_number AS INTEGER), _r.quitem_itemsite_id, (_r.quitem_qtyord * _r.quitem_qty_invuomratio),
                         _r.quitem_scheddate, '', 'S', _iitemid ) INTO _orderId;
        _orderType := 'R';
        UPDATE pr SET pr_prj_id=_r.quhead_prj_id WHERE pr_id=_orderId;
      ELSIF ( (_r.item_type IN ('P', 'O')) AND (_r.itemsite_createsopo) ) THEN
        IF (_r.quitem_prcost=0) THEN
-- For now quote to invoice/dropship will not be supported but with the creation of a createPurchaseToQuote() version of createPurchaseToSale()
-- it can be
--          SELECT createPurchaseToSale(_iitemid, _r.itemsrcid, _r.quitem_dropship) INTO _orderId;
            RAISE EXCEPTION 'Quote contains one or more dropship items that may not be converted from a Quote to an Invoice';
        ELSE
-- For now quote to invoice/dropship will not be supported but with the creation of a createPurchaseToQuote() version of createPurchaseToSale()
-- it can be
--          SELECT createPurchaseToSale(_iitemid, _r.itemsrcid, _r.quitem_dropship, _r.quitem_prcost) INTO _orderId;
            RAISE EXCEPTION 'Quote contains one or more dropship items that may not be converted from a Quote to an Invoice';
        END IF;
        _orderType := 'P';
      END IF;

--      UPDATE invcitem SET invcitem_order_type=_ordertype, invcitem_order_id=_orderid
--      WHERE (invcitem_id=_iitemid);

    END IF;

  END LOOP;

  SELECT metric_value INTO _showConvertedQuote
  FROM metric WHERE metric_name = 'ShowQuotesAfterSO';

  IF (_showConvertedQuote) THEN
    UPDATE quhead
    SET quhead_status= 'C'
    WHERE (quhead_id = pQuheadid);
  ELSE
     PERFORM deleteQuote(pQuheadid);
  END IF;

  RETURN _iheadid;

END;
$_$;


ALTER FUNCTION public.convertquotetoinvoice(integer) OWNER TO admin;

--
-- TOC entry 1245 (class 1255 OID 146565792)
-- Dependencies: 4536 8
-- Name: copybom(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION copybom(psitemid integer, ptitemid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _result INTEGER;

BEGIN

  SELECT copyBOM (pSItemid, PTItemid, FALSE) into _result;

  RETURN _result;

END;
$$;


ALTER FUNCTION public.copybom(psitemid integer, ptitemid integer) OWNER TO admin;

--
-- TOC entry 1248 (class 1255 OID 146565793)
-- Dependencies: 4536 8
-- Name: copybom(integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION copybom(psitemid integer, ptitemid integer, pcopyusedat boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _bh RECORD;
  _bi RECORD;
  _bomheadfound BOOLEAN := FALSE;
  _bomheadid INTEGER;
  _bomitemid INTEGER;
  _bomworksetid INTEGER;
  _temp INTEGER;
  _schedatwooper BOOLEAN;
  _booitemseqid INTEGER;

BEGIN

--  Cache source bomhead
  SELECT * INTO _bh
  FROM bomhead
  WHERE ((bomhead_item_id=pSItemid)
    AND  (bomhead_rev_id=getActiveRevID('BOM', pSItemid)));

--  bomhead may not exist
--  IF (NOT FOUND) THEN
--    RETURN -1;
--  END IF;
    IF (FOUND) THEN
      _bomheadfound := TRUE;
    END IF;

--  Make sure that source bomitems exist
  SELECT bomitem_id INTO _bomitemid
  FROM bomitem
  WHERE ((bomitem_parent_item_id=pSItemid)
    AND  (bomitem_rev_id=getActiveRevID('BOM', pSItemid)))
  LIMIT 1;

  IF (NOT FOUND) THEN
    RETURN -2;
  END IF;

--  Make sure that target bomitems do not exist
  SELECT bomitem_id INTO _bomitemid
  FROM bomitem
  WHERE ((bomitem_parent_item_id=pTItemid)
    AND  (bomitem_rev_id= -1))
  LIMIT 1;

  IF (FOUND) THEN
    RETURN -3;
  END IF;

--  Make sure that the parent is not used in the component at some level
  IF ( SELECT (item_type IN ('M', 'F'))
       FROM item
       WHERE (item_id=pSItemid) ) THEN
    SELECT indentedWhereUsed(pTItemid) INTO _bomworksetid;
    SELECT bomwork_id INTO _temp
    FROM bomwork
    WHERE ( (bomwork_set_id=_bomworksetid)
     AND (bomwork_item_id=pSItemid) )
    LIMIT 1;
    IF (FOUND) THEN
      PERFORM deleteBOMWorkset(_bomworksetid);
      RETURN -4;
    END IF;
    PERFORM deleteBOMWorkset(_bomworksetid);
  END IF;

--  Check for existing target bomhead
  SELECT bomhead_id INTO _bomheadid
  FROM bomhead
  WHERE ((bomhead_item_id=pTItemid)
    AND  (bomhead_rev_id= -1));

  IF (NOT FOUND) THEN
    IF (_bomheadfound) THEN
      INSERT INTO bomhead
      ( bomhead_item_id, bomhead_serial, bomhead_docnum,
        bomhead_batchsize, bomhead_requiredqtyper )
      VALUES
      ( pTItemid, _bh.bomhead_serial, _bh.bomhead_docnum,
        _bh.bomhead_batchsize, _bh.bomhead_requiredqtyper );
    END IF;
  END IF;

  FOR _bi IN SELECT bomitem.*
             FROM bomitem(pSItemid)
             WHERE (bomitem_expires>CURRENT_DATE) LOOP

    SELECT NEXTVAL('bomitem_bomitem_id_seq') INTO _bomitemid;

    IF (pCopyUsedAt) THEN
      _schedatwooper := _bi.bomitem_schedatwooper;
      _booitemseqid := _bi.bomitem_booitem_seq_id;
    ELSE
      _schedatwooper := FALSE;
      _booitemseqid := -1;
    END IF;

    INSERT INTO bomitem
    ( bomitem_id, bomitem_parent_item_id, bomitem_seqnumber, bomitem_item_id,
      bomitem_uom_id, bomitem_qtyfxd, bomitem_qtyper, bomitem_scrap, bomitem_schedatwooper,
      bomitem_booitem_seq_id,
      bomitem_effective, bomitem_expires, bomitem_ecn,
      bomitem_createwo, bomitem_issuemethod, bomitem_moddate, bomitem_subtype,
      bomitem_notes, bomitem_ref )
    VALUES
    ( _bomitemid, pTItemid, _bi.bomitem_seqnumber, _bi.bomitem_item_id,
      _bi.bomitem_uom_id, _bi.bomitem_qtyfxd, _bi.bomitem_qtyper, _bi.bomitem_scrap, _schedatwooper,
      _booitemseqid,
      CURRENT_DATE, _bi.bomitem_expires, _bi.bomitem_ecn,
      _bi.bomitem_createwo, _bi.bomitem_issuemethod, CURRENT_DATE, _bi.bomitem_subtype,
      _bi.bomitem_notes, _bi.bomitem_ref );

    INSERT INTO bomitemsub
    ( bomitemsub_bomitem_id, bomitemsub_item_id,
      bomitemsub_uomratio, bomitemsub_rank )
    SELECT _bomitemid, bomitemsub_item_id,
           bomitemsub_uomratio, bomitemsub_rank
    FROM bomitemsub
    WHERE (bomitemsub_bomitem_id=_bi.bomitem_id);

  END LOOP;

  RETURN pTItemid;

END;
$$;


ALTER FUNCTION public.copybom(psitemid integer, ptitemid integer, pcopyusedat boolean) OWNER TO admin;

--
-- TOC entry 1249 (class 1255 OID 146565794)
-- Dependencies: 4536 8
-- Name: copybudget(integer, text, text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION copybudget(integer, text, text, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pBudgheadid ALIAS FOR $1;
  pName ALIAS FOR $2;
  pDescrip ALIAS FOR $3;
  pInterval ALIAS FOR $4;
  _budgheadid INTEGER;
  _periodid INTEGER;
  _result INTEGER;

BEGIN
  SELECT 1 INTO _result
    FROM budgitem
   WHERE ((budgitem_budghead_id=pBudgheadid)
     AND  (nextPeriodByInterval(budgitem_period_id, pInterval)=-1))
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -1;
  END IF;

  SELECT nextval('budghead_budghead_id_seq') INTO _budgheadid;
  INSERT INTO budghead
        (budghead_id, budghead_name, budghead_descrip)
  VALUES(_budgheadid, pName, pDescrip);

  INSERT INTO budgitem (budgitem_budghead_id, budgitem_period_id,
                        budgitem_accnt_id, budgitem_amount)
  SELECT _budgheadid, nextPeriodByInterval(budgitem_period_id, pInterval),
         budgitem_accnt_id, budgitem_amount
    FROM budgitem
   WHERE (budgitem_budghead_id=pBudgheadid);

  RETURN _budgheadid;
END;
$_$;


ALTER FUNCTION public.copybudget(integer, text, text, integer) OWNER TO admin;

--
-- TOC entry 1250 (class 1255 OID 146565795)
-- Dependencies: 4536 8
-- Name: copycmd(integer, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION copycmd(integer, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCmdId	ALIAS FOR $1;
  pModule	ALIAS FOR $2;
  pTitle	ALIAS FOR $3;
  _cmdId	INTEGER;
BEGIN
    SELECT nextval('cmd_cmd_id_seq') INTO _cmdId;

    INSERT INTO cmd
      SELECT _cmdId, pModule, pTitle, cmd_descrip, cmd_privname, cmd_executable
      FROM cmd
      WHERE (cmd_id=pCmdId);

    INSERT INTO cmdarg (cmdarg_cmd_id, cmdarg_order, cmdarg_arg)
      SELECT _cmdId, cmdarg_order, cmdarg_arg
      FROM cmdarg
      WHERE (cmdarg_cmd_id=pCmdId);

    RETURN 1;
END;
$_$;


ALTER FUNCTION public.copycmd(integer, text, text) OWNER TO admin;

--
-- TOC entry 1251 (class 1255 OID 146565796)
-- Dependencies: 4536 8
-- Name: copycontract(integer, text, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION copycontract(pcontrctid integer, pnumber text, peffective date, pexpires date) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _contrctid INTEGER;
  _itemsrcid INTEGER;
  _r RECORD;

BEGIN

  INSERT INTO contrct
  ( contrct_number,
    contrct_vend_id,
    contrct_descrip,
    contrct_effective,
    contrct_expires,
    contrct_note )
  SELECT
    pNumber,
    contrct_vend_id,
    contrct_descrip,
    pEffective,
    pExpires,
    contrct_note
  FROM contrct
  WHERE (contrct_id=pContrctid)
  RETURNING contrct_id INTO _contrctid;

  FOR _r IN
  SELECT * FROM itemsrc WHERE (itemsrc_contrct_id=pContrctid)
  LOOP
  INSERT INTO itemsrc
    ( itemsrc_item_id,
      itemsrc_vend_id,
      itemsrc_vend_item_number,
      itemsrc_vend_item_descrip,
      itemsrc_comments,
      itemsrc_vend_uom,
      itemsrc_invvendoruomratio,
      itemsrc_minordqty,
      itemsrc_multordqty,
      itemsrc_leadtime,
      itemsrc_ranking,
      itemsrc_active,
      itemsrc_manuf_name,
      itemsrc_manuf_item_number,
      itemsrc_manuf_item_descrip,
      itemsrc_default,
      itemsrc_upccode,
      itemsrc_effective,
      itemsrc_expires,
      itemsrc_contrct_id )
    VALUES
    ( _r.itemsrc_item_id,
      _r.itemsrc_vend_id,
      _r.itemsrc_vend_item_number,
      _r.itemsrc_vend_item_descrip,
      _r.itemsrc_comments,
      _r.itemsrc_vend_uom,
      _r.itemsrc_invvendoruomratio,
      _r.itemsrc_minordqty,
      _r.itemsrc_multordqty,
      _r.itemsrc_leadtime,
      _r.itemsrc_ranking,
      _r.itemsrc_active,
      _r.itemsrc_manuf_name,
      _r.itemsrc_manuf_item_number,
      _r.itemsrc_manuf_item_descrip,
      _r.itemsrc_default,
      _r.itemsrc_upccode,
      pEffective,
      pExpires,
      _contrctid )
    RETURNING itemsrc_id INTO _itemsrcid;

  INSERT INTO itemsrcp
    ( itemsrcp_itemsrc_id,
      itemsrcp_qtybreak,
      itemsrcp_price,
      itemsrcp_updated,
      itemsrcp_curr_id,
      itemsrcp_dropship,
      itemsrcp_warehous_id,
      itemsrcp_type,
      itemsrcp_discntprcnt,
      itemsrcp_fixedamtdiscount )
    SELECT
      _itemsrcid,
      itemsrcp_qtybreak,
      itemsrcp_price,
      CURRENT_DATE,
      itemsrcp_curr_id,
      itemsrcp_dropship,
      itemsrcp_warehous_id,
      itemsrcp_type,
      itemsrcp_discntprcnt,
      itemsrcp_fixedamtdiscount
    FROM itemsrcp
    WHERE (itemsrcp_itemsrc_id=_r.itemsrc_id);

  END LOOP;

  RETURN _contrctid;

END;
$$;


ALTER FUNCTION public.copycontract(pcontrctid integer, pnumber text, peffective date, pexpires date) OWNER TO admin;

--
-- TOC entry 1252 (class 1255 OID 146565797)
-- Dependencies: 4536 8
-- Name: copyfinancialgroup(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION copyfinancialgroup(integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSourceGroup ALIAS FOR $1;
  pFlheadid ALIAS FOR $2;
  pParentFlgrpid ALIAS FOR $3;

  _flgrpid INTEGER;

BEGIN

  SELECT nextval('flgrp_flgrp_id_seq') INTO _flgrpid;

-- Copy the group item
  INSERT INTO flgrp
         (flgrp_id, flgrp_flhead_id, flgrp_flgrp_id,
          flgrp_order, flgrp_name, flgrp_descrip,
          flgrp_subtotal, flgrp_summarize, flgrp_subtract,
          flgrp_showstart, flgrp_showend,
          flgrp_showdelta, flgrp_showbudget, flgrp_showdiff, flgrp_showcustom,
          flgrp_showstartprcnt, flgrp_showendprcnt,
          flgrp_showdeltaprcnt, flgrp_showbudgetprcnt, flgrp_showdiffprcnt, flgrp_showcustomprcnt,
          flgrp_usealtsubtotal, flgrp_altsubtotal,flgrp_prcnt_flgrp_id)
  SELECT _flgrpid, pFlheadid, pParentFlgrpid,
         flgrp_order, flgrp_name, flgrp_descrip,
         flgrp_subtotal, flgrp_summarize, flgrp_subtract,
         flgrp_showstart, flgrp_showend,
         flgrp_showdelta, flgrp_showbudget, flgrp_showdiff, flgrp_showcustom,
         flgrp_showstartprcnt, flgrp_showendprcnt,
         flgrp_showdeltaprcnt, flgrp_showbudgetprcnt, flgrp_showdiffprcnt, flgrp_showcustomprcnt,
         flgrp_usealtsubtotal, flgrp_altsubtotal,flgrp_prcnt_flgrp_id
    FROM flgrp
   WHERE (flgrp_id=pSourceGroup);

-- Store temporary cross ref info

   EXECUTE ' INSERT INTO tmp_flgrpxref' || getEffectiveXtUser() || ' (flgrpxref_oldid,flgrpxref_newid) VALUES (' || pSourceGroup || ',' || _flgrpid || ');';

-- Copy any children flitems
  INSERT INTO flitem
         (flitem_flhead_id, flitem_flgrp_id,
          flitem_order, flitem_accnt_id, flitem_showstart,
          flitem_showend, flitem_showdelta, flitem_showbudget, flitem_showdiff, flitem_showcustom,
          flitem_subtract, flitem_showstartprcnt,
          flitem_showendprcnt, flitem_showdeltaprcnt,
          flitem_showbudgetprcnt, flitem_showdiffprcnt, flitem_showcustomprcnt,
          flitem_custom_source, flitem_company, flitem_profit, flitem_number,
          flitem_sub, flitem_type, flitem_subaccnttype_code, flitem_prcnt_flgrp_id)
  SELECT pFlheadid, _flgrpid,
         flitem_order, flitem_accnt_id, flitem_showstart,
         flitem_showend, flitem_showdelta, flitem_showbudget, flitem_showdiff, flitem_showcustom,
         flitem_subtract, flitem_showstartprcnt,
         flitem_showendprcnt, flitem_showdeltaprcnt,
         flitem_showbudgetprcnt, flitem_showdiffprcnt, flitem_showcustomprcnt,
         flitem_custom_source, flitem_company, flitem_profit, flitem_number,
          flitem_sub, flitem_type, flitem_subaccnttype_code, flitem_prcnt_flgrp_id
    FROM flitem
   WHERE (flitem_flgrp_id=pSourceGroup);

-- Copy any children flspecs
  INSERT INTO flspec
         (flspec_flhead_id, flspec_flgrp_id,
          flspec_order, flspec_name, flspec_type, flspec_showstart,
          flspec_showend, flspec_showdelta, flspec_showbudget, flspec_showdiff, flspec_showcustom,
          flspec_subtract, flspec_showstartprcnt,
          flspec_showendprcnt, flspec_showdeltaprcnt,
          flspec_showbudgetprcnt, flspec_showdiffprcnt, flspec_showcustomprcnt,
          flspec_custom_source, flspec_prcnt_flgrp_id)
  SELECT pFlheadid, _flgrpid,
         flspec_order, flspec_name, flspec_type, flspec_showstart,
         flspec_showend, flspec_showdelta, flspec_showbudget, flspec_showdiff, flspec_showcustom,
         flspec_subtract, flspec_showstartprcnt,
         flspec_showendprcnt, flspec_showdeltaprcnt,
         flspec_showbudgetprcnt, flspec_showdiffprcnt, flspec_showcustomprcnt,
         flspec_custom_source, flspec_prcnt_flgrp_id
    FROM flspec
   WHERE (flspec_flgrp_id=pSourceGroup);

-- Copy the groups
  PERFORM copyFinancialGroup(flgrp_id, pFlheadid, _flgrpid)
     FROM flgrp
    WHERE (flgrp_flgrp_id=pSourceGroup);

  RETURN _flgrpid;
END;
$_$;


ALTER FUNCTION public.copyfinancialgroup(integer, integer, integer) OWNER TO admin;

--
-- TOC entry 1253 (class 1255 OID 146565798)
-- Dependencies: 4536 8
-- Name: copyfinanciallayout(integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION copyfinanciallayout(integer, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSourceFlheadid ALIAS FOR $1;
  pDestName ALIAS FOR $2;

  _flheadid INTEGER;
  _tblName TEXT;

BEGIN

-- Check for the flhead to be copy that it exists
  PERFORM flhead_id
     FROM flhead
    WHERE (flhead_id=pSourceFlheadid);
  IF (NOT FOUND) THEN
    RETURN -1;
  END IF;

-- Check that the name is valid
  IF (pDestName IS NULL OR pDestName = '') THEN
    RETURN -2;
  END IF;

-- Check for the name to copy to does not exist
  PERFORM flhead_id
     FROM flhead
    WHERE (flhead_name=pDestName);
  IF (FOUND) THEN
    RETURN -3;
  END IF;

-- Copy the flhead record
  SELECT nextval('flhead_flhead_id_seq') INTO _flheadid;
  INSERT INTO flhead
         (flhead_id, flhead_name, flhead_descrip,
          flhead_showtotal, flhead_showstart,
          flhead_showend, flhead_showdelta, flhead_showbudget,
          flhead_showdiff, flhead_showcustom,
          flhead_custom_label,
          flhead_usealttotal, flhead_alttotal,
          flhead_usealtbegin, flhead_altbegin,
          flhead_usealtend, flhead_altend,
          flhead_usealtdebits, flhead_altdebits,
          flhead_usealtcredits, flhead_altcredits,
          flhead_usealtbudget, flhead_altbudget,
          flhead_usealtdiff, flhead_altdiff,
          flhead_type, flhead_active, flhead_sys
)
  SELECT _flheadid, pDestName, flhead_descrip,
         flhead_showtotal, flhead_showstart,
         flhead_showend, flhead_showdelta, flhead_showbudget,
         flhead_showdiff, flhead_showcustom,
         flhead_custom_label,
         flhead_usealttotal, flhead_alttotal,
         flhead_usealtbegin, flhead_altbegin,
         flhead_usealtend, flhead_altend,
         flhead_usealtdebits, flhead_altdebits,
         flhead_usealtcredits, flhead_altcredits,
         flhead_usealtbudget, flhead_altbudget,
         flhead_usealtdiff, flhead_altdiff,
         flhead_type, flhead_active, false
    FROM flhead
   WHERE (flhead_id=pSourceFlheadid);

-- Create temporary table so old and new group ids can be stored
 SELECT relname FROM pg_class INTO _tblName
 WHERE relname = 'tmp_flgrpxref';
 IF (_tblName IS NULL) THEN
  EXECUTE 'CREATE TEMPORARY TABLE tmp_flgrpxref' || getEffectiveXtUser() || '
  (
	flgrpxref_oldid int4,
	flgrpxref_newid int4
  ) ON COMMIT DROP;';
  END IF;

-- Copy the top level groups
  PERFORM copyFinancialGroup(flgrp_id, _flheadid, -1)
     FROM flgrp
    WHERE ((flgrp_flhead_id=pSourceFlheadid)
      AND  (flgrp_flgrp_id=-1));

-- Update Group Percent settings
  EXECUTE 'UPDATE flgrp
  SET flgrp_prcnt_flgrp_id=flgrpxref_newid
  FROM tmp_flgrpxref' || getEffectiveXtUser() || '
  WHERE ((flgrp_flhead_id=' || _flheadid || ')
  AND (flgrp_prcnt_flgrp_id=flgrpxref_oldid));';

  EXECUTE 'UPDATE flitem
  SET flitem_prcnt_flgrp_id=flgrpxref_newid
  FROM tmp_flgrpxref' || getEffectiveXtUser() || '
  WHERE ((flitem_flhead_id=' || _flheadid || ')
  AND (flitem_prcnt_flgrp_id=flgrpxref_oldid));';

  EXECUTE 'UPDATE flspec
  SET flspec_prcnt_flgrp_id=flgrpxref_newid
  FROM tmp_flgrpxref' || getEffectiveXtUser() || '
  WHERE ((flspec_flhead_id=' || _flheadid || ')
  AND (flspec_prcnt_flgrp_id=flgrpxref_oldid));';

-- Copy Column Layounts
  INSERT INTO flcol
        (flcol_flhead_id,
        flcol_name,
        flcol_descrip,
        flcol_report_id,
        flcol_month,
        flcol_quarter,
        flcol_year,
        flcol_showdb,
        flcol_prcnt,
        flcol_priortype,
        flcol_priormonth,
        flcol_priorquarter,
        flcol_prioryear,
        flcol_priorprcnt,
        flcol_priordiff,
        flcol_priordiffprcnt,
        flcol_budget,
        flcol_budgetprcnt,
        flcol_budgetdiff,
        flcol_budgetdiffprcnt
)
SELECT
        _flheadid,flcol_name,flcol_descrip,
        flcol_report_id,flcol_month,flcol_quarter,
        flcol_year,flcol_showdb,flcol_prcnt,
        flcol_priortype,flcol_priormonth,flcol_priorquarter,
        flcol_prioryear,flcol_priorprcnt,flcol_priordiff,
        flcol_priordiffprcnt,flcol_budget,flcol_budgetprcnt,
        flcol_budgetdiff,flcol_budgetdiffprcnt
FROM flcol
WHERE (flcol_flhead_id=pSourceFlheadid);

  RETURN _flheadid;
END;
$_$;


ALTER FUNCTION public.copyfinanciallayout(integer, text) OWNER TO admin;

--
-- TOC entry 1214 (class 1255 OID 146565799)
-- Dependencies: 4536 8
-- Name: copyglseries(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION copyglseries(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSequence ALIAS FOR $1;
  _sequence INTEGER := fetchGLSequence();
  _journal INTEGER;

BEGIN

  SELECT gltrans_journalnumber INTO _journal
  FROM gltrans
  WHERE ( gltrans_sequence=pSequence )
  LIMIT 1;

  IF (FOUND) THEN
    INSERT INTO glseries
    ( glseries_sequence, glseries_source, glseries_doctype, glseries_docnumber,
      glseries_notes, glseries_accnt_id, glseries_amount, glseries_distdate )
    SELECT _sequence, gltrans_source, gltrans_doctype, gltrans_docnumber,
           gltrans_notes, gltrans_accnt_id,
           gltrans_amount, gltrans_date
    FROM gltrans
    WHERE ( gltrans_sequence=pSequence );
  ELSE
    RAISE EXCEPTION 'g/l transaction sequence not found';
  END IF;

  RETURN _sequence;
END;
$_$;


ALTER FUNCTION public.copyglseries(integer) OWNER TO admin;

--
-- TOC entry 1236 (class 1255 OID 146565800)
-- Dependencies: 4536 8
-- Name: copyincdt(integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION copyincdt(integer, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pparentid   ALIAS FOR $1;
  ptimestamp  TIMESTAMP WITH TIME ZONE := COALESCE($2, CURRENT_TIMESTAMP);

  _alarmid    INTEGER;
  _incdtid    INTEGER;
  _todoitemid INTEGER;

BEGIN
  INSERT INTO incdt(incdt_number,          incdt_crmacct_id,
                    incdt_cntct_id,        incdt_summary,
                    incdt_descrip,         incdt_item_id,
                    incdt_timestamp,       incdt_incdtcat_id,
                    incdt_incdtseverity_id,incdt_incdtpriority_id,
                    incdt_owner_username,  incdt_recurring_incdt_id
           ) SELECT fetchIncidentNumber(), incdt_crmacct_id,
                    incdt_cntct_id,        incdt_summary,
                    incdt_descrip,         incdt_item_id,
                    ptimestamp,            incdt_incdtcat_id,
                    incdt_incdtseverity_id,incdt_incdtpriority_id,
                    incdt_owner_username,  incdt_recurring_incdt_id
               FROM incdt
              WHERE (incdt_id=pparentid)
  RETURNING incdt_id INTO _incdtid;

  IF (_incdtid IS NULL) THEN
    RETURN -10;
  END IF;

  SELECT MIN(copyTodoitem(todoitem_id, CAST(ptimestamp AS DATE), _incdtid))
            INTO _todoitemid
    FROM todoitem
   WHERE (todoitem_incdt_id=pparentid);

  IF (_todoitemid < 0) THEN
    RETURN _todoitemid;
  END IF;

  SELECT saveAlarm(NULL, NULL, CAST(ptimestamp AS DATE),
                   CAST(alarm_time - DATE_TRUNC('day',alarm_time) AS TIME),
                   alarm_time_offset,
                   alarm_time_qualifier,
                   alarm_event_recipient  IS NOT NULL, alarm_event_recipient,
                   alarm_email_recipient  IS NOT NULL, alarm_email_recipient,
                   alarm_sysmsg_recipient IS NOT NULL, alarm_sysmsg_recipient,
                   'INCDT', _incdtid, 'CHANGEONE')
    INTO _alarmid
    FROM alarm
   WHERE ((alarm_source='INCDT')
      AND (alarm_source_id=pparentid));

   IF (_alarmid < 0) THEN
     RETURN _alarmid;
   END IF;

   INSERT INTO docass (docass_source_id, docass_source_type,
                       docass_target_id, docass_target_type, docass_purpose
              ) SELECT _incdtid,       'INCDT',
                       docass_target_id, docass_target_type, docass_purpose
                  FROM docass
                 WHERE ((docass_source_id=pparentid)
                    AND (docass_source_type='INCDT'));

  RETURN _incdtid;
END;
$_$;


ALTER FUNCTION public.copyincdt(integer, timestamp with time zone) OWNER TO admin;

--
-- TOC entry 1255 (class 1255 OID 146565801)
-- Dependencies: 4536 8
-- Name: copyinvoice(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION copyinvoice(integer, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pInvcheadid ALIAS FOR $1;
  _invcheadid INTEGER;
  _invcnumber TEXT;
  _invcdate DATE := COALESCE($2, CURRENT_DATE);
  _i RECORD;
  _l RECORD;
  _invcitemid INTEGER;

BEGIN
  SELECT *
    INTO _i
    FROM invchead
   WHERE(invchead_id=pInvcheadid);
  IF(NOT FOUND) THEN
    RETURN -1;
  END IF;

  _invcnumber := fetchInvcNumber();
  _invcheadid := nextval('invchead_invchead_id_seq');

  INSERT INTO invchead
        (invchead_id,
         invchead_cust_id, invchead_shipto_id,
         invchead_ordernumber, invchead_orderdate,
         invchead_posted, invchead_printed,
         invchead_invcnumber, invchead_invcdate, invchead_shipdate,
         invchead_ponumber, invchead_shipvia,
         invchead_fob, invchead_billto_name,
         invchead_billto_address1, invchead_billto_address2,
         invchead_billto_address3, invchead_billto_city,
         invchead_billto_state, invchead_billto_zipcode,
         invchead_billto_phone, invchead_shipto_name,
         invchead_shipto_address1, invchead_shipto_address2,
         invchead_shipto_address3, invchead_shipto_city,
         invchead_shipto_state, invchead_shipto_zipcode,
         invchead_shipto_phone, invchead_salesrep_id,
         invchead_commission,
         invchead_terms_id, invchead_freight,
         invchead_misc_amount,
         invchead_misc_descrip, invchead_misc_accnt_id,
         invchead_payment, invchead_paymentref,
         invchead_notes,
         invchead_billto_country, invchead_shipto_country,
         invchead_prj_id, invchead_curr_id,
         invchead_taxzone_id,
         invchead_recurring_invchead_id,
         invchead_saletype_id, invchead_shipzone_id)
  VALUES(_invcheadid,
         _i.invchead_cust_id, _i.invchead_shipto_id,
         _i.invchead_ordernumber, _i.invchead_orderdate,
         false, false,
         _invcnumber, _invcdate, _i.invchead_shipdate,
         _i.invchead_ponumber, _i.invchead_shipvia,
         _i.invchead_fob, _i.invchead_billto_name,
         _i.invchead_billto_address1, _i.invchead_billto_address2,
         _i.invchead_billto_address3, _i.invchead_billto_city,
         _i.invchead_billto_state, _i.invchead_billto_zipcode,
         _i.invchead_billto_phone, _i.invchead_shipto_name,
         _i.invchead_shipto_address1, _i.invchead_shipto_address2,
         _i.invchead_shipto_address3, _i.invchead_shipto_city,
         _i.invchead_shipto_state, _i.invchead_shipto_zipcode,
         _i.invchead_shipto_phone, _i.invchead_salesrep_id,
         _i.invchead_commission,
         _i.invchead_terms_id, _i.invchead_freight,
         _i.invchead_misc_amount,
         _i.invchead_misc_descrip, _i.invchead_misc_accnt_id,
         _i.invchead_payment, _i.invchead_paymentref,
         _i.invchead_notes,
         _i.invchead_billto_country, _i.invchead_shipto_country,
         _i.invchead_prj_id, _i.invchead_curr_id,
         _i.invchead_taxzone_id,
         _i.invchead_recurring_invchead_id,
         _i.invchead_saletype_id, _i.invchead_shipzone_id);

  FOR _l IN SELECT *
            FROM invcitem
            WHERE (invcitem_invchead_id=pInvcheadid) LOOP
    SELECT NEXTVAL('invcitem_invcitem_id_seq') INTO _invcitemid;

    INSERT INTO invcitem
        (invcitem_id, invcitem_invchead_id,
         invcitem_linenumber, invcitem_item_id,
         invcitem_warehous_id, invcitem_custpn,
         invcitem_number, invcitem_descrip,
         invcitem_ordered, invcitem_billed,
         invcitem_custprice, invcitem_price,
         invcitem_notes, invcitem_salescat_id,
         invcitem_taxtype_id,
         invcitem_qty_uom_id, invcitem_qty_invuomratio,
         invcitem_price_uom_id, invcitem_price_invuomratio,
         invcitem_coitem_id)
    VALUES
        (_invcitemid, _invcheadid,
         _l.invcitem_linenumber, _l.invcitem_item_id,
         _l.invcitem_warehous_id, _l.invcitem_custpn,
         _l.invcitem_number, _l.invcitem_descrip,
         _l.invcitem_ordered, _l.invcitem_billed,
         _l.invcitem_custprice, _l.invcitem_price,
         _l.invcitem_notes, _l.invcitem_salescat_id,
         _l.invcitem_taxtype_id,
         _l.invcitem_qty_uom_id, _l.invcitem_qty_invuomratio,
         _l.invcitem_price_uom_id, _l.invcitem_price_invuomratio,
         _l.invcitem_coitem_id);

  END LOOP;

  RETURN _invcheadid;
END;
$_$;


ALTER FUNCTION public.copyinvoice(integer, date) OWNER TO admin;

--
-- TOC entry 1256 (class 1255 OID 146565802)
-- Dependencies: 4536 8
-- Name: copyitem(integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION copyitem(integer, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSItemid ALIAS FOR $1;
  pTItemNumber ALIAS FOR $2;
  _itemid INTEGER;
  _r RECORD;
  _id INTEGER;

BEGIN

  SELECT NEXTVAL('item_item_id_seq') INTO _itemid;
  INSERT INTO item
  ( item_id, item_number, item_descrip1, item_descrip2,
    item_classcode_id, item_type,
    item_active, item_picklist, item_sold, item_fractional,
    item_maxcost, item_prodweight, item_packweight,
    item_prodcat_id,item_exclusive, item_listprice, item_listcost,
    item_config, item_comments, item_extdescrip,
    item_upccode, item_inv_uom_id, item_price_uom_id )
  SELECT _itemid, pTItemNumber, item_descrip1, item_descrip2,
         item_classcode_id, item_type,
         item_active, item_picklist, item_sold, item_fractional,
         item_maxcost, item_prodweight, item_packweight,
         item_prodcat_id, item_exclusive, item_listprice, item_listcost,
         item_config, item_comments, item_extdescrip,
         item_upccode, item_inv_uom_id, item_price_uom_id
  FROM item
  WHERE (item_id=pSItemid);

  INSERT INTO imageass
  (imageass_source_id, imageass_source, imageass_image_id, imageass_purpose)
  SELECT _itemid, 'I', imageass_image_id, imageass_purpose
  FROM imageass
  WHERE ((imageass_source_id=pSItemid)
  AND (imageass_source='I'));

  INSERT INTO url
  (url_source_id, url_source, url_title, url_url)
  SELECT _itemid, 'I', url_title, url_url
  FROM url
  WHERE ((url_source_id=pSItemid)
  AND (url_source='I'));

  INSERT INTO itemtax
        (itemtax_item_id, itemtax_taxzone_id, itemtax_taxtype_id)
  SELECT _itemid, itemtax_taxzone_id, itemtax_taxtype_id
    FROM itemtax
   WHERE(itemtax_item_id=pSItemid);

  INSERT INTO charass
  ( charass_target_type, charass_target_id,
    charass_char_id, charass_value )
  SELECT 'I', _itemid, charass_char_id, charass_value
  FROM charass
  WHERE ( (charass_target_type='I')
   AND (charass_target_id=pSItemid) );

  FOR _r IN SELECT itemuomconv_id,
                   itemuomconv_from_uom_id,
                   itemuomconv_from_value,
                   itemuomconv_to_uom_id,
                   itemuomconv_to_value,
                   itemuomconv_fractional
              FROM itemuomconv
             WHERE(itemuomconv_item_id=pSItemid) LOOP
    SELECT nextval('itemuomconv_itemuomconv_id_seq') INTO _id;
    INSERT INTO itemuomconv
          (itemuomconv_id, itemuomconv_item_id,
           itemuomconv_from_uom_id, itemuomconv_from_value,
           itemuomconv_to_uom_id, itemuomconv_to_value,
           itemuomconv_fractional)
    VALUES(_id, _itemid,
           _r.itemuomconv_from_uom_id, _r.itemuomconv_from_value,
           _r.itemuomconv_to_uom_id, _r.itemuomconv_to_value,
           _r.itemuomconv_fractional);

    INSERT INTO itemuom
          (itemuom_itemuomconv_id, itemuom_uomtype_id)
    SELECT _id, itemuom_uomtype_id
      FROM itemuom
     WHERE(itemuom_itemuomconv_id=_r.itemuomconv_id);
  END LOOP;

  RETURN _itemid;

END;
$_$;


ALTER FUNCTION public.copyitem(integer, text) OWNER TO admin;

--
-- TOC entry 1259 (class 1255 OID 146565805)
-- Dependencies: 4536 8
-- Name: copyitem(integer, text, boolean, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION copyitem(integer, text, boolean, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSItemid      ALIAS FOR $1;
  pTItemNumber  ALIAS FOR $2;
  pCopyBOM      ALIAS FOR $3;
  pCopyCosts    ALIAS FOR $4;

  _itemid       INTEGER;
BEGIN

  _itemid := copyItem(pSItemid, pTItemNumber);

  IF (pCopyBOM) THEN
    PERFORM copyBOM(pSItemid, _itemid, FALSE);
  END IF;

  IF (pCopyCosts) THEN
    INSERT INTO itemcost
    ( itemcost_item_id, itemcost_costelem_id, itemcost_lowlevel,
      itemcost_stdcost, itemcost_posted,
      itemcost_actcost, itemcost_curr_id, itemcost_updated )
    SELECT _itemid, itemcost_costelem_id, itemcost_lowlevel,
      itemcost_stdcost, CURRENT_DATE,
      itemcost_actcost, itemcost_curr_id, CURRENT_DATE
    FROM itemcost
    WHERE (itemcost_item_id=pSItemid);
  END IF;

  RETURN _itemid;

END;
$_$;


ALTER FUNCTION public.copyitem(integer, text, boolean, boolean) OWNER TO admin;

--
-- TOC entry 1257 (class 1255 OID 146565803)
-- Dependencies: 4536 8
-- Name: copyitem(integer, text, boolean, boolean, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION copyitem(integer, text, boolean, boolean, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSItemid ALIAS FOR $1;
  pTItemNumber ALIAS FOR $2;
  pCopyBOM ALIAS FOR $3;
  pCopyBOO ALIAS FOR $4;        -- deprecated - xtmfg-specific
  pCopyCosts ALIAS FOR $5;
BEGIN
  RAISE NOTICE 'copyItem(INTEGER, TEXT, BOOLEAN, BOOLEAN, BOOLEAN) has been deprecated.  Use copyItem(INTEGER, TEXT) or copyItem(INTEGER, TEXT, BOOLEAN, BOOLEAN) or a package-specific version instead.';
  RETURN copyItem(pSItemid, pTItemNumber, pCopyBOM, pCopyCosts);
END;
$_$;


ALTER FUNCTION public.copyitem(integer, text, boolean, boolean, boolean) OWNER TO admin;

--
-- TOC entry 1258 (class 1255 OID 146565804)
-- Dependencies: 4536 8
-- Name: copyitem(integer, text, boolean, boolean, boolean, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION copyitem(integer, text, boolean, boolean, boolean, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSItemid ALIAS FOR $1;
  pTItemNumber ALIAS FOR $2;
  pCopyBOM ALIAS FOR $3;
  pCopyBOO ALIAS FOR $4;        -- deprecated - xtmfg-specific
  pCopyCosts ALIAS FOR $5;
  pCopyUsedAt ALIAS FOR $6;     -- deprecated - xtmfg-specific
BEGIN
  RETURN copyItem(pSItemid, pTItemNumber, pCopyBOM, pCopyCosts);
END;
$_$;


ALTER FUNCTION public.copyitem(integer, text, boolean, boolean, boolean, boolean) OWNER TO admin;

--
-- TOC entry 1260 (class 1255 OID 146565806)
-- Dependencies: 4536 8
-- Name: copyitemsite(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION copyitemsite(pitemsiteid integer, pdestwhsid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.

BEGIN

  RETURN copyItemSite(pitemsiteid, pdestwhsid, NULL);

END;
$$;


ALTER FUNCTION public.copyitemsite(pitemsiteid integer, pdestwhsid integer) OWNER TO admin;

--
-- TOC entry 1261 (class 1255 OID 146565807)
-- Dependencies: 4536 8
-- Name: copyitemsite(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION copyitemsite(pitemsiteid integer, pdestwhsid integer, pdestitemid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pitemsiteid	ALIAS FOR $1;
  pdestwhsid	ALIAS FOR $2;
  _destwhs	whsinfo%ROWTYPE;
  _new		itemsite%ROWTYPE;

BEGIN
  -- make a copy of the old itemsite
  SELECT * INTO _new
  FROM itemsite
  WHERE (itemsite_id=pitemsiteid);
  IF (NOT FOUND) THEN
    RETURN -1;
  END IF;

  -- if there is no dest warehouse then perhaps the user is manually copying it
  IF (pdestwhsid IS NOT NULL) THEN
    SELECT * INTO _destwhs
    FROM whsinfo
    WHERE (warehous_id=pdestwhsid);
    IF (NOT FOUND) THEN
      RETURN -2;
    END IF;
  END IF;

  IF (NOT checkPrivilege('MaintainItemSites')) THEN
    RETURN -3;
  END IF;

  SELECT itemsite_id INTO _new.itemsite_id
  FROM itemsite
  WHERE ((itemsite_item_id=COALESCE(pdestitemid, _new.itemsite_item_id))
    AND  (itemsite_warehous_id=pdestwhsid OR
	  (itemsite_warehous_id IS NULL AND pdestwhsid IS NULL)));
  IF (FOUND) THEN
    RETURN _new.itemsite_id;
  END IF;

  -- now override the things we know have to change
  _new.itemsite_id		:= NEXTVAL('itemsite_itemsite_id_seq');
  _new.itemsite_warehous_id	:= pdestwhsid;
  _new.itemsite_qtyonhand	:= 0;
  _new.itemsite_value           := 0;
  _new.itemsite_datelastcount	:= NULL;
  _new.itemsite_datelastused	:= NULL;
  _new.itemsite_nnqoh		:= 0;
  _new.itemsite_location_id    := -1;

  IF (_destwhs.warehous_transit) THEN
    _new.itemsite_reorderlevel	:= 0;
    _new.itemsite_ordertoqty	:= 0;
    _new.itemsite_soldranking	:= NULL;
    _new.itemsite_posupply	:= FALSE;
    _new.itemsite_wosupply	:= FALSE;
    _new.itemsite_loccntrl	:= FALSE;
    _new.itemsite_safetystock	:= 0;
    _new.itemsite_minordqty	:= 0;
    _new.itemsite_multordqty	:= 0;
    _new.itemsite_leadtime	:= 0;
    _new.itemsite_controlmethod	:= 'R';
    IF(_new.itemsite_costmethod='N') THEN
      _new.itemsite_costmethod := 'S';
    END IF;
    _new.itemsite_active	:= TRUE;
    -- ? _new.itemsite_plancode_id	:= -1;
    -- ? _new.itemsite_costcat_id	:= -1;
    _new.itemsite_eventfence	:= 1;
    _new.itemsite_sold		:= FALSE;
    _new.itemsite_stocked	:= FALSE;
    _new.itemsite_location_id	:= -1;
    _new.itemsite_useparams	:= FALSE;
    _new.itemsite_useparamsmanual := FALSE;
    _new.itemsite_createpr	:= FALSE;
    _new.itemsite_location	:= NULL;
    _new.itemsite_location_comments := NULL;
    _new.itemsite_notes		:= 'Transit Warehouse';
    _new.itemsite_nnqoh		:= 0;
    _new.itemsite_createwo	:= FALSE;
    _new.itemsite_costcat_id	:= _destwhs.warehous_costcat_id;
  END IF;

  INSERT INTO itemsite (
    itemsite_id,			itemsite_item_id,
    itemsite_warehous_id,		itemsite_qtyonhand,
    itemsite_costmethod,                itemsite_value,
    itemsite_reorderlevel,		itemsite_ordertoqty,
    itemsite_cyclecountfreq,		itemsite_datelastcount,
    itemsite_datelastused,
    itemsite_posupply,			itemsite_wosupply,
    itemsite_loccntrl,
    itemsite_safetystock,		itemsite_minordqty,
    itemsite_multordqty,		itemsite_leadtime,
    itemsite_abcclass,			itemsite_issuemethod,
    itemsite_controlmethod,		itemsite_active,
    itemsite_plancode_id,		itemsite_costcat_id,
    itemsite_eventfence,		itemsite_sold,
    itemsite_stocked,			itemsite_freeze,
    itemsite_location_id,
    itemsite_useparams,			itemsite_useparamsmanual,
    itemsite_soldranking,		itemsite_createpr,
    itemsite_location,			itemsite_location_comments,
    itemsite_notes,			itemsite_perishable,
    itemsite_nnqoh,			itemsite_autoabcclass,
    itemsite_ordergroup,		itemsite_disallowblankwip,
    itemsite_maxordqty,			itemsite_mps_timefence,
    itemsite_createwo,			itemsite_warrpurc,
    itemsite_autoreg,
    itemsite_planning_type,             itemsite_supply_itemsite_id
  ) VALUES (
    _new.itemsite_id,			COALESCE(pdestitemid, _new.itemsite_item_id),
    _new.itemsite_warehous_id,		_new.itemsite_qtyonhand,
    _new.itemsite_costmethod,           _new.itemsite_value,
    _new.itemsite_reorderlevel,	        _new.itemsite_ordertoqty,
    _new.itemsite_cyclecountfreq,	_new.itemsite_datelastcount,
    _new.itemsite_datelastused,
    _new.itemsite_posupply,		_new.itemsite_wosupply,
    _new.itemsite_loccntrl,
    _new.itemsite_safetystock,		_new.itemsite_minordqty,
    _new.itemsite_multordqty,		_new.itemsite_leadtime,
    _new.itemsite_abcclass,		_new.itemsite_issuemethod,
    _new.itemsite_controlmethod,	_new.itemsite_active,
    _new.itemsite_plancode_id,		_new.itemsite_costcat_id,
    _new.itemsite_eventfence,		_new.itemsite_sold,
    _new.itemsite_stocked,		_new.itemsite_freeze,
    _new.itemsite_location_id,
    _new.itemsite_useparams,		_new.itemsite_useparamsmanual,
    _new.itemsite_soldranking,		_new.itemsite_createpr,
    _new.itemsite_location,		_new.itemsite_location_comments,
    _new.itemsite_notes,		_new.itemsite_perishable,
    _new.itemsite_nnqoh,		_new.itemsite_autoabcclass,
    _new.itemsite_ordergroup,		_new.itemsite_disallowblankwip,
    _new.itemsite_maxordqty,		_new.itemsite_mps_timefence,
    _new.itemsite_createwo,   	        _new.itemsite_warrpurc,
    _new.itemsite_autoreg,
    _new.itemsite_planning_type,        _new.itemsite_supply_itemsite_id
    );

  RETURN _new.itemsite_id;
END;
$_$;


ALTER FUNCTION public.copyitemsite(pitemsiteid integer, pdestwhsid integer, pdestitemid integer) OWNER TO admin;

--
-- TOC entry 1246 (class 1255 OID 146565808)
-- Dependencies: 4536 8
-- Name: copylocale(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION copylocale(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pLocaleid ALIAS FOR $1;
  _localecode TEXT;
  _localeid INTEGER;

BEGIN

  SELECT locale_code INTO _localecode
  FROM locale
  WHERE (locale_id=pLocaleid);

  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Attempt to copy a non-existent locale-id.';
  END IF;

  IF (EXISTS(SELECT locale_id
             FROM locale
             WHERE (locale_code = (_localecode || '-COPY')))) THEN
    RAISE EXCEPTION 'Attempt to copy a Locale Code that already exists.';
  END IF;

  SELECT NEXTVAL('locale_locale_id_seq') INTO _localeid;

  INSERT INTO locale
        (locale_id, locale_code, locale_descrip,
         locale_lang_file,
         locale_dateformat,
         locale_currformat,
         locale_qtyformat,
         locale_comments,
         locale_qtyperformat,
         locale_salespriceformat,
         locale_extpriceformat,
         locale_timeformat,
         locale_timestampformat,
         local_costformat,
         locale_costformat,
         locale_purchpriceformat,
         locale_uomratioformat,
         locale_intervalformat,
         locale_lang_id,
         locale_country_id,
         locale_error_color,
         locale_warning_color,
         locale_emphasis_color,
         locale_altemphasis_color,
         locale_expired_color,
         locale_future_color,
         locale_curr_scale,
         locale_salesprice_scale,
         locale_purchprice_scale,
         locale_extprice_scale,
         locale_cost_scale,
         locale_qty_scale,
         locale_qtyper_scale,
         locale_uomratio_scale)
  SELECT _localeid, locale_code || '-COPY', '',
         locale_lang_file,
         locale_dateformat,
         locale_currformat,
         locale_qtyformat,
         locale_comments,
         locale_qtyperformat,
         locale_salespriceformat,
         locale_extpriceformat,
         locale_timeformat,
         locale_timestampformat,
         local_costformat,
         locale_costformat,
         locale_purchpriceformat,
         locale_uomratioformat,
         locale_intervalformat,
         locale_lang_id,
         locale_country_id,
         locale_error_color,
         locale_warning_color,
         locale_emphasis_color,
         locale_altemphasis_color,
         locale_expired_color,
         locale_future_color,
         locale_curr_scale,
         locale_salesprice_scale,
         locale_purchprice_scale,
         locale_extprice_scale,
         locale_cost_scale,
         locale_qty_scale,
         locale_qtyper_scale,
         locale_uomratio_scale
    FROM locale
   WHERE(locale_id=pLocaleid);

  RETURN _localeid;

END;
$_$;


ALTER FUNCTION public.copylocale(integer) OWNER TO admin;

--
-- TOC entry 1247 (class 1255 OID 146565809)
-- Dependencies: 4536 8
-- Name: copypo(integer, integer, date, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION copypo(integer, integer, date, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSrcid		ALIAS FOR $1;
  pVendid		ALIAS FOR $2;
  pOrderdate		ALIAS FOR $3;
  pRecheckVendinfo	ALIAS FOR $4;

  _tgtid		INTEGER;
  _orderdate		DATE;
  _head			RECORD;
  _itemsrc		RECORD;
  _lineitem		RECORD;
  _qty			NUMERIC;
  _unitprice		NUMERIC;
  _uomratio		NUMERIC;
  _vend_restrictpurch	BOOLEAN;

BEGIN
  SELECT * INTO _head FROM pohead WHERE pohead_id = pSrcid;
  IF (NOT FOUND) THEN
    RETURN -1;
  END IF;
  IF (_head.pohead_vend_id != pVendid) THEN
    RETURN -2;		-- not supported now but should be in the future
  END IF;		-- when enabled, set pRecheckVendinfo if vendors don't match

  IF (pOrderdate IS NULL) THEN
    _orderdate := CURRENT_DATE;
  ELSE
    _orderdate := pOrderdate;
  END IF;

  INSERT INTO pohead (pohead_status, pohead_number,
		      pohead_orderdate, pohead_vend_id,
		      pohead_fob, pohead_shipvia,
		      pohead_freight, pohead_printed,
		      pohead_terms_id, pohead_warehous_id,
		      pohead_vendaddr_id, pohead_agent_username,
		      pohead_curr_id, pohead_saved,
                      pohead_taxtype_id, pohead_taxzone_id,
                      pohead_dropship, pohead_vend_cntct_id,
                      pohead_vend_cntct_honorific, pohead_vend_cntct_first_name,
                      pohead_vend_cntct_middle, pohead_vend_cntct_last_name,
                      pohead_vend_cntct_suffix, pohead_vend_cntct_phone,
                      pohead_vend_cntct_title, pohead_vend_cntct_fax,
                      pohead_vend_cntct_email, pohead_vendaddress1,
                      pohead_vendaddress2, pohead_vendaddress3,
                      pohead_vendcity, pohead_vendstate,
                      pohead_vendzipcode, pohead_vendcountry,
                      pohead_shipto_cntct_id,
                      pohead_shipto_cntct_honorific, pohead_shipto_cntct_first_name,
                      pohead_shipto_cntct_middle, pohead_shipto_cntct_last_name,
                      pohead_shipto_cntct_suffix, pohead_shipto_cntct_phone,
                      pohead_shipto_cntct_title, pohead_shipto_cntct_fax,
                      pohead_shipto_cntct_email, pohead_shiptoaddress_id,
                      pohead_shiptoaddress1,
                      pohead_shiptoaddress2, pohead_shiptoaddress3,
                      pohead_shiptocity, pohead_shiptostate,
                      pohead_shiptozipcode, pohead_shiptocountry
	      ) VALUES (
		      'U', fetchPoNumber(),
		      _orderdate, _head.pohead_vend_id,
		      _head.pohead_fob, _head.pohead_shipvia,
		      _head.pohead_freight, false,
		      _head.pohead_terms_id, _head.pohead_warehous_id,
		      _head.pohead_vendaddr_id, _head.pohead_agent_username,
		      _head.pohead_curr_id, true,
                      _head.pohead_taxtype_id, _head.pohead_taxzone_id,
                      false, _head.pohead_vend_cntct_id,
                      _head.pohead_vend_cntct_honorific, _head.pohead_vend_cntct_first_name,
                      _head.pohead_vend_cntct_middle, _head.pohead_vend_cntct_last_name,
                      _head.pohead_vend_cntct_suffix, _head.pohead_vend_cntct_phone,
                      _head.pohead_vend_cntct_title, _head.pohead_vend_cntct_fax,
                      _head.pohead_vend_cntct_email, _head.pohead_vendaddress1,
                      _head.pohead_vendaddress2, _head.pohead_vendaddress3,
                      _head.pohead_vendcity, _head.pohead_vendstate,
                      _head.pohead_vendzipcode, _head.pohead_vendcountry,
                      _head.pohead_shipto_cntct_id,
                      _head.pohead_shipto_cntct_honorific, _head.pohead_shipto_cntct_first_name,
                      _head.pohead_shipto_cntct_middle, _head.pohead_shipto_cntct_last_name,
                      _head.pohead_shipto_cntct_suffix, _head.pohead_shipto_cntct_phone,
                      _head.pohead_shipto_cntct_title, _head.pohead_shipto_cntct_fax,
                      _head.pohead_shipto_cntct_email, _head.pohead_shiptoaddress_id,
                      _head.pohead_shiptoaddress1,
                      _head.pohead_shiptoaddress2, _head.pohead_shiptoaddress3,
                      _head.pohead_shiptocity, _head.pohead_shiptostate,
                      _head.pohead_shiptozipcode, _head.pohead_shiptocountry);

  _tgtid := CURRVAL('pohead_pohead_id_seq');

  IF (pRecheckVendinfo) THEN
    SELECT vend_restrictpurch INTO _vend_restrictpurch
      FROM vendinfo WHERE (vend_id = pVendid);

    FOR _lineitem IN SELECT *
		  FROM poitem
		  WHERE (poitem_pohead_id = pSrcid) LOOP

      SELECT * INTO _itemsrc
      FROM itemsrc, itemsite
      WHERE (itemsrc_active
        AND  (itemsrc_id = _lineitem.poitem_itemsrc_id)
	AND  (itemsite_id = _lineitem.poitem_itemsite_id));
      IF (NOT FOUND AND _vend_restrictpurch) THEN
	RETURN -3;
      END IF;

      -- handle changes to the uom ratio and consequent qty changes
      _uomratio := COALESCE(_itemsrc.itemsrc_invvendoruomratio, _lineitem.poitem_invvenduomratio);
      IF (_itemsrc.itemsrc_invvendoruomratio IS NULL
	  OR _itemsrc.itemsrc_invvendoruomratio != _lineitem.poitem_invvenduomratio) THEN
	_qty := _lineitem.poitem_qty_ordered;

      ELSE
	_qty := _lineitem.poitem_qty_ordered * _lineitem.poitem_invvenduomratio /
					       _itemsrc.itemsrc_invvendoruomratio;
	IF (_itemsrc.itemsrc_minordqty IS NOT NULL) THEN
	  IF (_qty < _itemsrc.itemsrc_minordqty) THEN
	    _qty := _itemsrc.itemsrc_minordqty;
	  ELSIF (_itemsrc.itemsrc_multordqty > 0
		   AND _qty % _itemsrc.itemsrc_multordqty > 0) THEN
	    _qty = _qty % _itemsrc.itemsrc_multordqty + _itemsrc.itemsrc_multordqty;
	  END IF;
	END IF;
      END IF;

      IF (_itemsrc.itemsrc_id IS NULL) THEN
	_unitprice = _lineitem.poitem_unitprice;
      ELSE
        SELECT itemsrcPrice(_itemsrc.itemsrc_id, _head.pohead_warehous_id, _head.pohead_dropship,
                            _lineitem.poitem_qty_ordered, _head.pohead_curr_id, CURRENT_DATE) INTO _unitprice;
	IF (_unitprice IS NULL) THEN
	  RETURN -4;
	END IF;
      END IF;

      INSERT INTO poitem (poitem_status, poitem_pohead_id, poitem_linenumber,
			  poitem_duedate,
			  poitem_itemsite_id,
			  poitem_vend_item_descrip,
			  poitem_vend_uom,
			  poitem_invvenduomratio,
			  poitem_qty_ordered, poitem_unitprice,
			  poitem_vend_item_number,
			  poitem_comments, poitem_expcat_id,
			  poitem_itemsrc_id,
			  poitem_freight,
			  poitem_stdcost,
			  poitem_manuf_name,
			  poitem_manuf_item_number,
			  poitem_manuf_item_descrip,
                          poitem_taxtype_id
		    ) VALUES (
			  'U', _tgtid, _lineitem.poitem_linenumber,
			  _orderdate + COALESCE(_itemsrc.itemsrc_leadtime, 0),
			  _lineitem.poitem_itemsite_id,
			  COALESCE(_itemsrc.itemsrc_vend_item_descrip,
				   _lineitem.poitem_vend_item_descrip),
			  COALESCE(_itemsrc.itemsrc_vend_uom, _lineitem.poitem_vend_uom),
			  COALESCE(_itemsrc.itemsrc_invvendoruomratio,
				   _lineitem.poitem_invvenduomratio),
			  _qty, _unitprice,
			  COALESCE(_itemsrc.itemsrc_vend_item_number,
				   _lineitem.poitem_vend_item_number),
			  _lineitem.poitem_comments, _lineitem.poitem_expcat_id,
			  COALESCE(_itemsrc.itemsrc_id, -1),
			  _lineitem.poitem_freight,
			  stdcost(_itemsrc.itemsite_item_id),
			  COALESCE(_itemsrc.itemsrc_manuf_name,
				   _lineitem.poitem_manuf_name),
		          COALESCE(_itemsrc.itemsrc_manuf_item_number,
				   _lineitem.poitem_manuf_item_number),
			  COALESCE(_itemsrc.itemsrc_manuf_item_descrip,
				   _lineitem.poitem_manuf_item_descrip),
                          _lineitem.poitem_taxtype_id);

    END LOOP;
  ELSE
    INSERT INTO poitem (poitem_status, poitem_pohead_id, poitem_linenumber,
			poitem_duedate, poitem_itemsite_id,
			poitem_vend_item_descrip, poitem_vend_uom,
			poitem_invvenduomratio, poitem_qty_ordered,
			poitem_unitprice,
			poitem_vend_item_number, poitem_comments,
			poitem_expcat_id, poitem_itemsrc_id, poitem_freight,
			poitem_stdcost, poitem_manuf_name,
			poitem_manuf_item_number, poitem_manuf_item_descrip,
                        poitem_taxtype_id
		) SELECT 'U', _tgtid, poitem_linenumber,
			_orderdate + COALESCE(itemsrc_leadtime, 0), poitem_itemsite_id,
			poitem_vend_item_descrip, poitem_vend_uom,
			poitem_invvenduomratio, poitem_qty_ordered,
			poitem_unitprice,
			poitem_vend_item_number, poitem_comments,
			poitem_expcat_id, poitem_itemsrc_id, poitem_freight,
			stdcost(itemsite_item_id), poitem_manuf_name,
			poitem_manuf_item_number, poitem_manuf_item_descrip,
                        poitem_taxtype_id
		  FROM poitem
		    LEFT OUTER JOIN itemsrc ON (itemsrc_id=poitem_itemsrc_id)
		    LEFT OUTER JOIN itemsite ON (itemsite_id=poitem_itemsite_id)
		  WHERE (poitem_pohead_id = pSrcid);
  END IF;

  -- Todo: recalculate tax?

  RETURN _tgtid;

END;
$_$;


ALTER FUNCTION public.copypo(integer, integer, date, boolean) OWNER TO admin;

--
-- TOC entry 1262 (class 1255 OID 146565811)
-- Dependencies: 4536 8
-- Name: copypricingschedule(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION copypricingschedule(pipsheadid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _ipsheadid INTEGER;
  _ipsitemid INTEGER;
  _ipsfreightid INTEGER;
  _x RECORD;

BEGIN

  _ipsheadid := nextval('ipshead_ipshead_id_seq');
  INSERT INTO ipshead
  ( ipshead_id, ipshead_name, ipshead_descrip,
    ipshead_effective, ipshead_expires,
    ipshead_curr_id, ipshead_updated )
  SELECT _ipsheadid, orig.ipshead_name || (SELECT CAST((COUNT(cnt.ipshead_id)+1) AS text)
				            FROM ipshead cnt
				            WHERE (SUBSTRING(cnt.ipshead_name FROM 0 FOR char_length(orig.ipshead_name)+1) = orig.ipshead_name)),
	 orig.ipshead_descrip, orig.ipshead_effective, orig.ipshead_expires,
	 orig.ipshead_curr_id, CURRENT_DATE
  FROM ipshead orig
  WHERE (orig.ipshead_id=pIpsheadId);

  FOR _x IN
    SELECT ipsitem_id FROM ipsiteminfo WHERE (ipsitem_ipshead_id=pIpsheadid)
  LOOP
      INSERT INTO ipsiteminfo
          (ipsitem_ipshead_id, ipsitem_item_id, ipsitem_prodcat_id,
           ipsitem_qtybreak, ipsitem_price,
           ipsitem_qty_uom_id, ipsitem_price_uom_id,
           ipsitem_discntprcnt, ipsitem_fixedamtdiscount,
           ipsitem_type, ipsitem_warehous_id)
      SELECT _ipsheadid, ipsitem_item_id, ipsitem_prodcat_id,
           ipsitem_qtybreak, ipsitem_price,
           ipsitem_qty_uom_id, ipsitem_price_uom_id,
           ipsitem_discntprcnt, ipsitem_fixedamtdiscount,
           ipsitem_type, ipsitem_warehous_id
      FROM ipsiteminfo
      WHERE (ipsitem_id=_x.ipsitem_id)
      RETURNING ipsitem_id INTO _ipsitemid;

      INSERT INTO ipsitemchar
        ( ipsitemchar_ipsitem_id, ipsitemchar_char_id,
          ipsitemchar_value, ipsitemchar_price)
      SELECT  _ipsitemid, ipsitemchar_char_id,
          ipsitemchar_value, ipsitemchar_price
      FROM ipsitemchar
      WHERE (ipsitemchar_ipsitem_id=_x.ipsitem_id);
  END LOOP;

  FOR _x IN
    SELECT ipsfreight_id FROM ipsfreight WHERE (ipsfreight_ipshead_id=pIpsheadid)
  LOOP
      _ipsfreightid := nextval('ipsfreight_ipsfreight_id_seq');
      INSERT INTO ipsfreight
          (ipsfreight_id, ipsfreight_ipshead_id,
           ipsfreight_qtybreak, ipsfreight_price,
           ipsfreight_type, ipsfreight_warehous_id,
           ipsfreight_shipzone_id,ipsfreight_freightclass_id,
           ipsfreight_shipvia)
      SELECT _ipsfreightid, _ipsheadid, ipsfreight_qtybreak,
           ipsfreight_price,ipsfreight_type,
           ipsfreight_warehous_id,ipsfreight_shipzone_id,
           ipsfreight_freightclass_id,ipsfreight_shipvia
      FROM ipsfreight
      WHERE (ipsfreight_id=_x.ipsfreight_id);

  END LOOP;

  RETURN _ipsheadid;

END;
$$;


ALTER FUNCTION public.copypricingschedule(pipsheadid integer) OWNER TO admin;

--
-- TOC entry 1263 (class 1255 OID 146565812)
-- Dependencies: 4536 8
-- Name: copyprj(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION copyprj(integer, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pparentid   ALIAS FOR $1;
  _counter    INTEGER;
  _duedate    DATE := COALESCE($2, CURRENT_DATE);
  _alarmid    INTEGER;
  _i          INTEGER;
  _newnumber  TEXT;
  _p          RECORD;
  _prjid      INTEGER;
  _testnumber TEXT;

BEGIN
  RAISE DEBUG 'copyPrj(%, %) entered', pparentid, _duedate;

  SELECT * INTO _p
  FROM prj
  WHERE (prj_id=pparentid);

  -- new number = old number up to but not including -, followed by _duedate
  -- e.g. REPAIR-FRIDGE becomes REPAIR-2010-05-15
  --  but REPAIR_FRIDGE becomes REPAIR_FRIDGE-2010-05-15
  IF (_p.prj_recurring_prj_id IS NULL) THEN
    _newnumber := _p.prj_number;
  ELSE
    _newnumber := SUBSTRING(_p.prj_number FROM '[^-]*');
    IF (_newnumber IS NULL) THEN
      _newnumber := _p.prj_number;
    END IF;
  END IF;
  _newnumber := _newnumber || '-' || to_char(_duedate, 'YYYY-MM-DD');

  RAISE DEBUG 'copyPrj checking if _newnumber % exists', _newnumber;
  SELECT MAX(prj_number) INTO _testnumber
    FROM prj
   WHERE (prj_number ~ ('^' || _newnumber));
  IF (_testnumber = _newnumber) THEN
    _newnumber := _newnumber || '-001';
  ELSIF (_testnumber IS NOT NULL) THEN
    _counter := CAST(SUBSTRING(_testnumber FROM '...$') AS INTEGER);
    _counter := _counter + 1;
    _newnumber := REGEXP_REPLACE(_testnumber, '...$', to_char(_counter, 'FM009'));
  END IF;
  RAISE DEBUG 'copyPrj _newnumber is now %', _newnumber;

  INSERT INTO prj(
            prj_number,     prj_name,           prj_descrip,
            prj_status,     prj_so,             prj_wo,
            prj_po,         prj_owner_username,
            prj_due_date,   prj_username,       prj_recurring_prj_id
  ) SELECT  _newnumber,     _p.prj_name,        _p.prj_descrip,
            'P',            _p.prj_so,          _p.prj_wo,
            _p.prj_po,      _p.prj_owner_username,
            _duedate,       _p.prj_username,    _p. prj_recurring_prj_id
      FROM prj
     WHERE (prj_id=pparentid)
  RETURNING prj_id INTO _prjid;

  IF (_prjid IS NULL) THEN
    RETURN -1;
  END IF;

  SELECT saveAlarm(NULL, NULL, _duedate,
                   CAST(alarm_time - DATE_TRUNC('day',alarm_time) AS TIME),
                   alarm_time_offset,
                   alarm_time_qualifier,
                   alarm_event_recipient  IS NOT NULL, alarm_event_recipient,
                   alarm_email_recipient  IS NOT NULL, alarm_email_recipient,
                   alarm_sysmsg_recipient IS NOT NULL, alarm_sysmsg_recipient,
                   'J', _prjid, 'CHANGEONE')
    INTO _alarmid
    FROM alarm
   WHERE ((alarm_source='J')
      AND (alarm_source_id=pparentid));

   IF (_alarmid < 0) THEN
     RETURN _alarmid;
   END IF;

  RETURN _prjid;
END;
$_$;


ALTER FUNCTION public.copyprj(integer, date) OWNER TO admin;

--
-- TOC entry 1264 (class 1255 OID 146565813)
-- Dependencies: 4536 8
-- Name: copyproject(integer, text, text, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION copyproject(integer, text, text, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPrjId ALIAS FOR $1;
  pPrjNumber ALIAS FOR $2;
  pPrjName ALIAS FOR $3;
  pDueDate ALIAS FOR $4;
  _prjid INTEGER;
  _offset INTEGER;

BEGIN

  IF (COALESCE(pPrjNumber, '') = '') THEN
    RETURN -1;
  END IF;

  IF (COALESCE(pPrjName, '') = '') THEN
    RETURN -1;
  END IF;

  IF (EXISTS(SELECT prj_id FROM prj WHERE UPPER(prj_number)=UPPER(pPrjNumber))) THEN
    RETURN -2;
  END IF;

  IF (NOT EXISTS(SELECT prj_id FROM prj WHERE prj_id=pPrjId)) THEN
    RETURN -3;
  END IF;

  IF (pDueDate IS NULL) THEN
    RETURN -4;
  END IF;

  SELECT (pDueDate - prj_due_date) INTO _offset
   FROM prj
   WHERE (prj_id=pPrjId);

  SELECT NEXTVAL('prj_prj_id_seq') INTO _prjid;

  INSERT INTO prj
  ( prj_id, prj_number, prj_name,
    prj_descrip, prj_status,
    prj_so, prj_wo, prj_po,
    prj_owner_username, prj_start_date,
    prj_due_date, prj_assigned_date, prj_completed_date,
    prj_username, prj_recurring_prj_id,
    prj_crmacct_id, prj_cntct_id )
  SELECT _prjid, UPPER(pPrjNumber), pPrjName,
         prj_descrip, 'P',
         prj_so, prj_wo, prj_po,
         prj_owner_username, NULL,
         (prj_due_date + COALESCE(_offset, 0)),
         CASE WHEN (prj_username IS NULL) THEN NULL ELSE CURRENT_DATE END, NULL,
         prj_username, prj_recurring_prj_id,
         prj_crmacct_id, prj_cntct_id
  FROM prj
  WHERE (prj_id=pPrjId);

  INSERT INTO prjtask
  ( prjtask_number, prjtask_name, prjtask_descrip,
    prjtask_prj_id, prjtask_anyuser, prjtask_status,
    prjtask_hours_budget, prjtask_hours_actual,
    prjtask_exp_budget, prjtask_exp_actual,
    prjtask_owner_username, prjtask_start_date,
    prjtask_due_date, prjtask_assigned_date,
    prjtask_completed_date, prjtask_username )
  SELECT prjtask_number, prjtask_name, prjtask_descrip,
         _prjid, prjtask_anyuser, 'P',
         prjtask_hours_budget, 0.0,
         prjtask_exp_budget, 0.0,
         prjtask_owner_username, NULL,
         (prjtask_due_date + COALESCE(_offset, 0)),
         CASE WHEN (prjtask_username IS NULL) THEN NULL ELSE CURRENT_DATE END,
         NULL, prjtask_username
  FROM prjtask
  WHERE (prjtask_prj_id=pPrjId);

  INSERT INTO docass
  ( docass_source_id, docass_source_type,
    docass_target_id, docass_target_type,
    docass_purpose )
  SELECT _prjid, docass_source_type,
         docass_target_id, docass_target_type,
         docass_purpose
  FROM docass
  WHERE ((docass_source_id=pPrjId)
    AND  (docass_source_type='J'));

  RETURN _prjid;

END;
$_$;


ALTER FUNCTION public.copyproject(integer, text, text, date) OWNER TO admin;

--
-- TOC entry 1265 (class 1255 OID 146565814)
-- Dependencies: 4536 8
-- Name: copyquote(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION copyquote(integer, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pQuheadid ALIAS FOR $1;
  pSchedDate ALIAS FOR $2;
  _quheadid INTEGER;
  _qunumber TEXT;

BEGIN

  SELECT NEXTVAL('quhead_quhead_id_seq') INTO _quheadid;
  IF (fetchMetricText('QUNumberGeneration') = 'S') THEN
    SELECT fetchSoNumber() INTO _qunumber;
  ELSE
    SELECT fetchQuNumber() INTO _qunumber;
  END IF;

  INSERT INTO quhead
  ( quhead_id, quhead_number, quhead_cust_id, quhead_prj_id,
    quhead_quotedate, quhead_packdate, quhead_fob,
    quhead_warehous_id, quhead_terms_id, quhead_salesrep_id,
    quhead_custponumber, quhead_shipvia,
    quhead_shipto_id, quhead_shiptoname, quhead_shiptoaddress1, quhead_shiptoaddress2, quhead_shiptoaddress3,
    quhead_shiptocity, quhead_shiptostate, quhead_shiptozipcode, quhead_shiptophone, quhead_shiptocountry,
    quhead_billtoname, quhead_billtoaddress1, quhead_billtoaddress2, quhead_billtoaddress3,
    quhead_billtocity, quhead_billtostate, quhead_billtozip,
    quhead_misc_accnt_id, quhead_misc_descrip, quhead_misc, quhead_freight, quhead_commission,
    quhead_ordercomments, quhead_shipcomments,
    quhead_imported, quhead_curr_id, quhead_taxzone_id, quhead_taxtype_id, quhead_ophead_id, quhead_status,
    quhead_shipto_cntct_id, quhead_shipto_cntct_honorific, quhead_shipto_cntct_first_name, quhead_shipto_cntct_middle,
    quhead_shipto_cntct_last_name, quhead_shipto_cntct_suffix, quhead_shipto_cntct_phone, quhead_shipto_cntct_title,
    quhead_shipto_cntct_fax, quhead_shipto_cntct_email, quhead_billto_cntct_id, quhead_billto_cntct_honorific,
    quhead_billto_cntct_first_name, quhead_billto_cntct_middle, quhead_billto_cntct_last_name, quhead_billto_cntct_suffix,
    quhead_billto_cntct_phone, quhead_billto_cntct_title, quhead_billto_cntct_fax, quhead_billto_cntct_email )
  SELECT _quheadid, _qunumber, quhead_cust_id, quhead_prj_id,
         CURRENT_DATE, COALESCE(pSchedDate, quhead_packdate), quhead_fob,
         quhead_warehous_id, quhead_terms_id, quhead_salesrep_id,
         quhead_custponumber, quhead_shipvia,
         quhead_shipto_id, quhead_shiptoname, quhead_shiptoaddress1, quhead_shiptoaddress2, quhead_shiptoaddress3,
         quhead_shiptocity, quhead_shiptostate, quhead_shiptozipcode, quhead_shiptophone, quhead_shiptocountry,
         quhead_billtoname, quhead_billtoaddress1, quhead_billtoaddress2, quhead_billtoaddress3,
         quhead_billtocity, quhead_billtostate, quhead_billtozip,
         quhead_misc_accnt_id, quhead_misc_descrip, quhead_misc, quhead_freight, quhead_commission,
         quhead_ordercomments, quhead_shipcomments,
         FALSE, quhead_curr_id, quhead_taxzone_id, quhead_taxtype_id, quhead_ophead_id, 'O',
         quhead_shipto_cntct_id, quhead_shipto_cntct_honorific, quhead_shipto_cntct_first_name, quhead_shipto_cntct_middle,
         quhead_shipto_cntct_last_name, quhead_shipto_cntct_suffix, quhead_shipto_cntct_phone, quhead_shipto_cntct_title,
         quhead_shipto_cntct_fax, quhead_shipto_cntct_email, quhead_billto_cntct_id, quhead_billto_cntct_honorific,
         quhead_billto_cntct_first_name, quhead_billto_cntct_middle, quhead_billto_cntct_last_name, quhead_billto_cntct_suffix,
         quhead_billto_cntct_phone, quhead_billto_cntct_title, quhead_billto_cntct_fax, quhead_billto_cntct_email
  FROM quhead
  WHERE (quhead_id=pQuheadid);

  INSERT INTO quitem
  ( quitem_quhead_id, quitem_linenumber, quitem_itemsite_id,
    quitem_scheddate, quitem_promdate, quitem_qtyord,
    quitem_price, quitem_custprice, quitem_unitcost,
    quitem_qty_uom_id, quitem_price_uom_id,
    quitem_qty_invuomratio, quitem_price_invuomratio,
    quitem_memo, quitem_custpn, quitem_imported, quitem_taxtype_id,
    quitem_createorder, quitem_order_warehous_id, quitem_item_id, quitem_prcost,
    quitem_dropship, quitem_itemsrc_id, quitem_pricemode )
  SELECT _quheadid, quitem_linenumber, quitem_itemsite_id,
         COALESCE(pSchedDate, quitem_scheddate),
         quitem_promdate,
         quitem_qtyord,
         quitem_price, quitem_custprice, stdCost(itemsite_item_id),
         quitem_qty_uom_id, quitem_price_uom_id,
         quitem_qty_invuomratio, quitem_price_invuomratio,
         quitem_memo, quitem_custpn, FALSE, quitem_taxtype_id,
         quitem_createorder, quitem_order_warehous_id, quitem_item_id, quitem_prcost,
         quitem_dropship, quitem_itemsrc_id, quitem_pricemode
  FROM quitem, itemsite
  WHERE ( (quitem_itemsite_id=itemsite_id)
   AND (quitem_quhead_id=pQuheadid));

  INSERT INTO charass
        (charass_target_type, charass_target_id,
         charass_char_id, charass_value)
  SELECT charass_target_type, b.quitem_id,
         charass_char_id, charass_value
    FROM quitem a, charass, quitem b
   WHERE ((charass_target_type='SI')
     AND  (charass_target_id=a.quitem_id)
     AND  (a.quitem_quhead_id=pQuheadid)
     AND  (b.quitem_quhead_id=_quheadid)
     AND  (a.quitem_linenumber=b.quitem_linenumber)
     );

  RETURN _quheadid;

END;
$_$;


ALTER FUNCTION public.copyquote(integer, date) OWNER TO admin;

--
-- TOC entry 1266 (class 1255 OID 146565815)
-- Dependencies: 4536 8
-- Name: copyso(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION copyso(psoheadid integer, pscheddate date) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _soheadid INTEGER;
  _soitemid INTEGER;
  _soitem RECORD;

BEGIN

  SELECT NEXTVAL('cohead_cohead_id_seq') INTO _soheadid;

  INSERT INTO cohead
  ( cohead_id,
    cohead_number,
    cohead_cust_id,
    cohead_custponumber,
    cohead_orderdate,
    cohead_warehous_id,
    cohead_shipto_id,
    cohead_shiptoname,
    cohead_shiptoaddress1,
    cohead_shiptoaddress2,
    cohead_shiptoaddress3,
    cohead_shiptoaddress4,
    cohead_shiptoaddress5,
    cohead_salesrep_id,
    cohead_terms_id,
    cohead_fob,
    cohead_shipvia,
    cohead_shiptocity,
    cohead_shiptostate,
    cohead_shiptozipcode,
    cohead_freight,
    cohead_misc,
    cohead_imported,
    cohead_ordercomments,
    cohead_shipcomments,
    cohead_shiptophone,
    cohead_shipchrg_id,
    cohead_shipform_id,
    cohead_billtoname,
    cohead_billtoaddress1,
    cohead_billtoaddress2,
    cohead_billtoaddress3,
    cohead_billtocity,
    cohead_billtostate,
    cohead_billtozipcode,
    cohead_misc_accnt_id,
    cohead_misc_descrip,
    cohead_commission,
    cohead_miscdate,
    cohead_holdtype,
    cohead_packdate,
    cohead_prj_id,
    cohead_wasquote,
    cohead_lastupdated,
    cohead_shipcomplete,
    cohead_created,
    cohead_creator,
    cohead_quote_number,
    cohead_billtocountry,
    cohead_shiptocountry,
    cohead_curr_id,
    cohead_calcfreight,
    cohead_shipto_cntct_id,
    cohead_shipto_cntct_honorific,
    cohead_shipto_cntct_first_name,
    cohead_shipto_cntct_middle,
    cohead_shipto_cntct_last_name,
    cohead_shipto_cntct_suffix,
    cohead_shipto_cntct_phone,
    cohead_shipto_cntct_title,
    cohead_shipto_cntct_fax,
    cohead_shipto_cntct_email,
    cohead_billto_cntct_id,
    cohead_billto_cntct_honorific,
    cohead_billto_cntct_first_name,
    cohead_billto_cntct_middle,
    cohead_billto_cntct_last_name,
    cohead_billto_cntct_suffix,
    cohead_billto_cntct_phone,
    cohead_billto_cntct_title,
    cohead_billto_cntct_fax,
    cohead_billto_cntct_email,
    cohead_taxzone_id,
    cohead_taxtype_id,
    cohead_ophead_id,
    cohead_status,
    cohead_saletype_id,
    cohead_shipzone_id )
  SELECT
    _soheadid,
    fetchSoNumber(),
    cohead_cust_id,
    cohead_custponumber,
    CURRENT_DATE,
    cohead_warehous_id,
    cohead_shipto_id,
    cohead_shiptoname,
    cohead_shiptoaddress1,
    cohead_shiptoaddress2,
    cohead_shiptoaddress3,
    cohead_shiptoaddress4,
    cohead_shiptoaddress5,
    cohead_salesrep_id,
    cohead_terms_id,
    cohead_fob,
    cohead_shipvia,
    cohead_shiptocity,
    cohead_shiptostate,
    cohead_shiptozipcode,
    cohead_freight,
    cohead_misc,
    FALSE,
    cohead_ordercomments,
    cohead_shipcomments,
    cohead_shiptophone,
    cohead_shipchrg_id,
    cohead_shipform_id,
    cohead_billtoname,
    cohead_billtoaddress1,
    cohead_billtoaddress2,
    cohead_billtoaddress3,
    cohead_billtocity,
    cohead_billtostate,
    cohead_billtozipcode,
    cohead_misc_accnt_id,
    cohead_misc_descrip,
    cohead_commission,
    cohead_miscdate,
    cohead_holdtype,
    COALESCE(pSchedDate, cohead_packdate),
    cohead_prj_id,
    FALSE,
    cohead_lastupdated,
    cohead_shipcomplete,
    NULL,
    getEffectiveXtUser(),
    NULL,
    cohead_billtocountry,
    cohead_shiptocountry,
    cohead_curr_id,
    cohead_calcfreight,
    cohead_shipto_cntct_id,
    cohead_shipto_cntct_honorific,
    cohead_shipto_cntct_first_name,
    cohead_shipto_cntct_middle,
    cohead_shipto_cntct_last_name,
    cohead_shipto_cntct_suffix,
    cohead_shipto_cntct_phone,
    cohead_shipto_cntct_title,
    cohead_shipto_cntct_fax,
    cohead_shipto_cntct_email,
    cohead_billto_cntct_id,
    cohead_billto_cntct_honorific,
    cohead_billto_cntct_first_name,
    cohead_billto_cntct_middle,
    cohead_billto_cntct_last_name,
    cohead_billto_cntct_suffix,
    cohead_billto_cntct_phone,
    cohead_billto_cntct_title,
    cohead_billto_cntct_fax,
    cohead_billto_cntct_email,
    cohead_taxzone_id,
    cohead_taxtype_id,
    cohead_ophead_id,
    cohead_status,
    cohead_saletype_id,
    cohead_shipzone_id
  FROM cohead
  WHERE (cohead_id=pSoheadid);

  FOR _soitem IN
    SELECT *
    FROM coitem JOIN itemsite ON (itemsite_id=coitem_itemsite_id)
    WHERE ( (coitem_cohead_id=pSoheadid)
      AND   (coitem_status <> 'X')
      AND   (coitem_subnumber = 0) ) LOOP

    SELECT NEXTVAL('coitem_coitem_id_seq') INTO _soitemid;

    -- insert characteristics first so they can be copied to associated supply order
    INSERT INTO charass
          (charass_target_type, charass_target_id,
           charass_char_id, charass_value)
    SELECT charass_target_type, _soitemid,
           charass_char_id, charass_value
      FROM charass
     WHERE ((charass_target_type='SI')
       AND  (charass_target_id=_soitem.coitem_id));

    INSERT INTO coitem
    ( coitem_id,
      coitem_cohead_id,
      coitem_linenumber,
      coitem_itemsite_id,
      coitem_status,
      coitem_scheddate,
      coitem_promdate,
      coitem_qtyord,
      coitem_unitcost,
      coitem_price,
      coitem_custprice,
      coitem_qtyshipped,
      coitem_order_id,
      coitem_memo,
      coitem_imported,
      coitem_qtyreturned,
      coitem_closedate,
      coitem_custpn,
      coitem_order_type,
      coitem_close_username,
--      coitem_lastupdated,
      coitem_substitute_item_id,
      coitem_created,
      coitem_creator,
      coitem_prcost,
      coitem_qty_uom_id,
      coitem_qty_invuomratio,
      coitem_price_uom_id,
      coitem_price_invuomratio,
      coitem_warranty,
      coitem_cos_accnt_id,
      coitem_qtyreserved,
      coitem_subnumber,
      coitem_firm,
      coitem_taxtype_id )
    VALUES
    ( _soitemid,
      _soheadid,
      _soitem.coitem_linenumber,
      _soitem.coitem_itemsite_id,
      'O',
      COALESCE(pSchedDate, _soitem.coitem_scheddate),
      _soitem.coitem_promdate,
      _soitem.coitem_qtyord,
      stdCost(_soitem.itemsite_item_id),
      _soitem.coitem_price,
      _soitem.coitem_custprice,
      0.0,
      -1,
      _soitem.coitem_memo,
      FALSE,
      0.0,
      NULL,
      _soitem.coitem_custpn,
      _soitem.coitem_order_type,
      NULL,
--      NULL,
      _soitem.coitem_substitute_item_id,
      NULL,
      getEffectiveXtUser(),
      _soitem.coitem_prcost,
      _soitem.coitem_qty_uom_id,
      _soitem.coitem_qty_invuomratio,
      _soitem.coitem_price_uom_id,
      _soitem.coitem_price_invuomratio,
      _soitem.coitem_warranty,
      _soitem.coitem_cos_accnt_id,
      0.0,
      _soitem.coitem_subnumber,
      _soitem.coitem_firm,
      _soitem.coitem_taxtype_id );

  END LOOP;

  RETURN _soheadid;

END;
$$;


ALTER FUNCTION public.copyso(psoheadid integer, pscheddate date) OWNER TO admin;

--
-- TOC entry 1268 (class 1255 OID 146565816)
-- Dependencies: 4536 8
-- Name: copytodoitem(integer, date, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION copytodoitem(integer, date, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pparentid   ALIAS FOR $1;
  _duedate    DATE := COALESCE($2, CURRENT_DATE);
  pincdtid    ALIAS FOR $3;
  _alarmid    INTEGER;
  _todoitemid INTEGER;

BEGIN
  INSERT INTO todoitem(
            todoitem_name,      todoitem_description,
            todoitem_incdt_id,
            todoitem_creator_username,                  todoitem_status,
            todoitem_active,    todoitem_due_date,
            todoitem_assigned_date,
            todoitem_seq,       todoitem_notes,         todoitem_crmacct_id,
            todoitem_ophead_id, todoitem_owner_username,todoitem_priority_id,
            todoitem_username,  todoitem_recurring_todoitem_id
  ) SELECT  todoitem_name,      todoitem_description,
            CASE WHEN pincdtid IS NULL THEN todoitem_incdt_id ELSE pincdtid END,
            getEffectiveXtUser(),                               'N',
            TRUE,               _duedate,
            CASE WHEN (todoitem_username IS NOT NULL) THEN CURRENT_DATE
                 ELSE NULL
            END,
            todoitem_seq,       todoitem_notes,         todoitem_crmacct_id,
            todoitem_ophead_id, todoitem_owner_username,todoitem_priority_id,
            todoitem_username,  todoitem_recurring_todoitem_id
      FROM todoitem
     WHERE (todoitem_id=pparentid)
  RETURNING todoitem_id INTO _todoitemid;

  IF (_todoitemid IS NULL) THEN
    RETURN -10;
  END IF;

  SELECT saveAlarm(NULL, NULL, _duedate,
                   CAST(alarm_time - DATE_TRUNC('day',alarm_time) AS TIME),
                   alarm_time_offset,
                   alarm_time_qualifier,
                   (alarm_event_recipient IS NOT NULL), alarm_event_recipient,
                   (alarm_email_recipient IS NOT NULL AND fetchMetricBool('EnableBatchManager')), alarm_email_recipient,
                   (alarm_sysmsg_recipient IS NOT NULL), alarm_sysmsg_recipient,
                   'TODO', _todoitemid, 'CHANGEONE')
    INTO _alarmid
    FROM alarm
   WHERE ((alarm_source='TODO')
      AND (alarm_source_id=pparentid));

   IF (_alarmid < 0) THEN
     RETURN _alarmid;
   END IF;

  RETURN _todoitemid;
END;
$_$;


ALTER FUNCTION public.copytodoitem(integer, date, integer) OWNER TO admin;

--
-- TOC entry 1269 (class 1255 OID 146565817)
-- Dependencies: 4536 8
-- Name: copyvoucher(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION copyvoucher(integer, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVoheadid ALIAS FOR $1;
  _voheadid INTEGER;
  _vonumber TEXT;
  _vodate DATE := COALESCE($2, CURRENT_DATE);
  _i RECORD;
  _l RECORD;
  _vodistid INTEGER;

BEGIN
  SELECT *
    INTO _i
    FROM vohead
   WHERE(vohead_id=pVoheadid);
  IF(NOT FOUND) THEN
    RETURN -1;
  END IF;

  _vonumber := fetchVoNumber();
  _voheadid := nextval('vohead_vohead_id_seq');

  INSERT INTO vohead
        (vohead_id,
         vohead_number, vohead_pohead_id,
         vohead_posted, vohead_duedate,
         vohead_invcnumber, vohead_amount,
         vohead_docdate, vohead_1099,
         vohead_distdate, vohead_reference,
         vohead_terms_id, vohead_vend_id,
         vohead_curr_id, vohead_adjtaxtype_id,
         vohead_freighttaxtype_id, vohead_gldistdate,
         vohead_misc, vohead_taxzone_id,
         vohead_taxtype_id, vohead_notes,
         vohead_recurring_vohead_id )
  VALUES(_voheadid,
         _vonumber, _i.vohead_pohead_id,
         false, determineDueDate(_i.vohead_terms_id, _vodate),
         _i.vohead_invcnumber, _i.vohead_amount,
         _vodate, _i.vohead_1099,
         _vodate, _i.vohead_reference,
         _i.vohead_terms_id, _i.vohead_vend_id,
         _i.vohead_curr_id, _i.vohead_adjtaxtype_id,
         _i.vohead_freighttaxtype_id, _vodate,
         _i.vohead_misc, _i.vohead_taxzone_id,
         _i.vohead_taxtype_id, _i.vohead_notes,
         _i.vohead_recurring_vohead_id);

  FOR _l IN SELECT *
            FROM vodist
            WHERE (vodist_vohead_id=pVoheadid) LOOP
    SELECT NEXTVAL('vodist_vodist_id_seq') INTO _vodistid;

    INSERT INTO vodist
        (vodist_id, vodist_poitem_id,
         vodist_vohead_id, vodist_costelem_id,
         vodist_accnt_id, vodist_amount,
         vodist_qty, vodist_expcat_id,
         vodist_tax_id, vodist_discountable,
         vodist_notes)
    VALUES
        (_vodistid, _l.vodist_poitem_id,
         _voheadid, _l.vodist_costelem_id,
         _l.vodist_accnt_id, _l.vodist_amount,
         _l.vodist_qty, _l.vodist_expcat_id,
         _l.vodist_tax_id, _l.vodist_discountable,
         _l.vodist_notes);

  END LOOP;

  RETURN _voheadid;
END;
$_$;


ALTER FUNCTION public.copyvoucher(integer, date) OWNER TO admin;

--
-- TOC entry 1270 (class 1255 OID 146565818)
-- Dependencies: 4536 8
-- Name: correctporeceipt(integer, numeric, numeric, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION correctporeceipt(integer, numeric, numeric, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPorecvid ALIAS FOR $1;
  pQty ALIAS FOR $2;
  pFreight ALIAS FOR $3;
  pItemlocSeries ALIAS FOR $4;

BEGIN
  RETURN correctReceipt('PO', $1, $2, $3, $4, NULL, NULL);
END;
$_$;


ALTER FUNCTION public.correctporeceipt(integer, numeric, numeric, integer) OWNER TO admin;

--
-- TOC entry 1271 (class 1255 OID 146565819)
-- Dependencies: 4536 8
-- Name: correctporeceipt(integer, numeric, numeric, integer, integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION correctporeceipt(integer, numeric, numeric, integer, integer, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN correctReceipt('PO', $1, $2, $3, $4, $5, $6);
END;
$_$;


ALTER FUNCTION public.correctporeceipt(integer, numeric, numeric, integer, integer, date) OWNER TO admin;

--
-- TOC entry 1272 (class 1255 OID 146565820)
-- Dependencies: 4536 8
-- Name: correctproduction(integer, numeric, boolean, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION correctproduction(integer, numeric, boolean, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RAISE NOTICE 'correctProduction(INTEGER, NUMERIC, BOOLEAN, BOOLEAN) has been deprecated. Use corrrectProduction(INTEGER, NUMERIC, BOOLEAN, INTEGER) or a package-specific version instead.';
  RETURN  correctProduction($1, $2, $3, 0, now());
END;
$_$;


ALTER FUNCTION public.correctproduction(integer, numeric, boolean, boolean) OWNER TO admin;

--
-- TOC entry 1273 (class 1255 OID 146565821)
-- Dependencies: 4536 8
-- Name: correctproduction(integer, numeric, boolean, boolean, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION correctproduction(integer, numeric, boolean, boolean, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RAISE NOTICE 'correctProduction(INTEGER, NUMERIC, BOOLEAN, BOOLEAN, INTEGER) has been deprecated. Use corrrectProduction(INTEGER, NUMERIC, BOOLEAN, INTEGER) or a package-specific version instead.';
  RETURN correctProduction($1, $2, $3, $5, now());
END;
$_$;


ALTER FUNCTION public.correctproduction(integer, numeric, boolean, boolean, integer) OWNER TO admin;

--
-- TOC entry 1274 (class 1255 OID 146565822)
-- Dependencies: 4536 8
-- Name: correctproduction(integer, numeric, boolean, integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION correctproduction(integer, numeric, boolean, integer, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoid          ALIAS FOR $1;
  pQty           ALIAS FOR $2;
  pBackflush     ALIAS FOR $3;
  pItemlocSeries ALIAS FOR $4;
  pGlDistTS      ALIAS FOR $5;
BEGIN
  RETURN correctProduction($1, $2, $3, $4, $5, NULL);
END;
$_$;


ALTER FUNCTION public.correctproduction(integer, numeric, boolean, integer, timestamp with time zone) OWNER TO admin;

--
-- TOC entry 1275 (class 1255 OID 146565823)
-- Dependencies: 4536 8
-- Name: correctproduction(integer, numeric, boolean, integer, timestamp with time zone, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION correctproduction(integer, numeric, boolean, integer, timestamp with time zone, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoid          ALIAS FOR $1;
  pQty           ALIAS FOR $2;
  pBackflush     ALIAS FOR $3;
  pItemlocSeries ALIAS FOR $4;
  pGlDistTS      ALIAS FOR $5;
  pInvhistId     ALIAS FOR $6;
  _invhistid        INTEGER;
  _itemlocSeries    INTEGER;
  _r                RECORD;
  _parentWIPAccntid INTEGER;
  _parentQty        NUMERIC;
  _qty              NUMERIC;
  _wipPost          NUMERIC;
  _sense            TEXT;
  _status           TEXT;
  _type             TEXT;
  _qtyfxd           NUMERIC := 0;

BEGIN

  -- Qty is positive for Assembly W/O
  -- Qty is negative for Disassembly W/O
  IF (pQty = 0) THEN
    RETURN pItemlocseries;
  ELSIF (pQty > 0) THEN
    _sense := 'from';
  ELSE
    _sense := 'to';
  END IF;

  SELECT item_type, roundQty(item_fractional, pQty), wo_status
    INTO _type, _parentQty, _status
    FROM wo JOIN itemsite ON (itemsite_id=wo_itemsite_id)
            JOIN item ON (item_id=itemsite_item_id)
   WHERE (wo_id=pWoid);

  IF (_status != 'I') THEN
    RETURN -1;
  END IF;

  IF (_type = 'J') THEN
    RETURN -2;
  END IF;

  IF (pItemlocSeries = 0) THEN
    SELECT NEXTVAL('itemloc_series_seq') INTO _itemlocSeries;
  ELSE
    _itemlocSeries := pItemlocSeries;
  END IF;

  --  Calculate the WIP to correct
  SELECT CASE WHEN (wo_cosmethod = 'D') THEN wo_postedvalue
              ELSE  round(((wo_postedvalue - wo_wipvalue) / wo_qtyrcv * _parentQty), 2)
         END INTO _wipPost
  FROM wo
  WHERE (wo_id=pWoid);

  --  Post the inventory transaction
  SELECT postInvTrans( itemsite_id, 'RM', (_parentQty * -1.0),
                       'W/O', 'WO', formatwonumber(pWoid), '',
                       ('Correct Receive Inventory ' || item_number || ' ' || _sense || ' Manufacturing'),
                       costcat_asset_accnt_id, getPrjAccntId(wo_prj_id, costcat_wip_accnt_id), _itemlocSeries, pGlDistTS,
                       (_wipPost * -1.0), -- only used when cost is average
                       pInvhistId) INTO _invhistid
  FROM wo JOIN itemsite ON (itemsite_id=wo_itemsite_id)
          JOIN item ON (item_id=itemsite_item_id)
          JOIN costcat ON (costcat_id=itemsite_costcat_id)
  WHERE (wo_id=pWoid);

  --  Decrease this W/O's qty. received and increase its WIP value
  UPDATE wo
  SET wo_qtyrcv = (wo_qtyrcv - _parentQty),
      wo_wipvalue = (wo_wipvalue + (CASE WHEN(itemsite_costmethod IN ('A','J'))
                                              THEN _wipPost
                                         WHEN(itemsite_costmethod='S')
                                              THEN stdcost(itemsite_item_id) * _parentQty
                                         ELSE 0.0 END))
  FROM itemsite
  WHERE ( (wo_itemsite_id=itemsite_id)
   AND (wo_id=pWoid) );

  IF (pBackflush) THEN
    FOR _r IN SELECT item_id, item_fractional,
                      itemsite_id, itemsite_warehous_id,
                      itemsite_controlmethod, itemsite_loccntrl,
                      itemsite_costmethod,
                      wo_qtyrcv, wo_prj_id,
                      womatl_id, womatl_qtyfxd, womatl_qtyper,
                      womatl_scrap, womatl_issuemethod, womatl_uom_id
               FROM wo JOIN womatl ON (womatl_wo_id=wo_id AND womatl_issuemethod='L')
                       JOIN itemsite ON (itemsite_id=womatl_itemsite_id)
                       JOIN item ON (item_id=itemsite_item_id)
               WHERE (wo_id=pWoid) LOOP

      --  Cache the qty to be issued
      -- If going back to beginning, unissue fixed qty as well
      IF (_r.wo_qtyrcv - _parentQty > 0) THEN
        _qtyfxd := 0;
      ELSE
        _qtyfxd := _r.womatl_qtyfxd;
      END IF;

      _qty = roundQty(_r.item_fractional, (_qtyfxd + _parentQty * _r.womatl_qtyper) * (1 + _r.womatl_scrap));

      IF (_qty > 0) THEN
        SELECT returnWoMaterial(_r.womatl_id, _qty, _itemlocSeries, pGlDistTS) INTO _itemlocSeries;
      END IF;

    END LOOP;

  	--  BEGIN ROB Decrease this W/O's WIP value for custom costing
	  UPDATE wo
	  SET wo_wipvalue = (wo_wipvalue - (itemcost_stdcost * _parentQty))
	FROM costelem, itemcost, costcat, itemsite, item
	WHERE
	  ((wo_id=pWoid) AND
	  (wo_itemsite_id=itemsite_id) AND
	  (itemsite_item_id=item_id) AND
	  (costelem_id = itemcost_costelem_id) AND
	  (itemcost_item_id = itemsite_item_id) AND
	  (itemsite_costcat_id = costcat_id) AND
	  (costelem_exp_accnt_id) IS NOT NULL  AND
	  (costelem_sys = false));

	--  ROB Distribute to G/L - create Cost Variance, debit WIP
	  PERFORM insertGLTransaction( 'W/O', 'WO', formatwonumber(pWoid),
				       ('Correct Post Other Cost ' || item_number || ' ' || _sense || ' Manufacturing'),
				       getPrjAccntId(wo_prj_id, costelem_exp_accnt_id),
				       getPrjAccntId(wo_prj_id, costcat_wip_accnt_id), _invhistid,
				       ((itemcost_stdcost * _parentQty)* -1),
				       CURRENT_DATE )
	FROM wo, costelem, itemcost, costcat, itemsite, item
	WHERE
	  ((wo_id=pWoid) AND
	  (wo_itemsite_id=itemsite_id) AND
	  (itemsite_item_id=item_id) AND
	  (costelem_id = itemcost_costelem_id) AND
	  (itemcost_item_id = itemsite_item_id) AND
	  (itemsite_costcat_id = costcat_id) AND
	  (costelem_exp_accnt_id) IS NOT NULL  AND
	  (costelem_sys = false));
	--End ROB

  END IF;

  RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.correctproduction(integer, numeric, boolean, integer, timestamp with time zone, integer) OWNER TO admin;

--
-- TOC entry 1276 (class 1255 OID 146565825)
-- Dependencies: 4536 8
-- Name: correctreceipt(integer, numeric, numeric, integer, integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION correctreceipt(integer, numeric, numeric, integer, integer, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
BEGIN
  RETURN correctReceipt($1, $2, $3, $4, $5, $6, NULL);
END;
$_$;


ALTER FUNCTION public.correctreceipt(integer, numeric, numeric, integer, integer, date) OWNER TO admin;

--
-- TOC entry 1277 (class 1255 OID 146565826)
-- Dependencies: 4536 8
-- Name: correctreceipt(integer, numeric, numeric, integer, integer, date, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION correctreceipt(integer, numeric, numeric, integer, integer, date, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  precvid		ALIAS FOR $1;
  pQty			ALIAS FOR $2;
  pFreight		ALIAS FOR $3;
  _itemlocSeries	INTEGER := COALESCE($4, 0);
  _currid		INTEGER := $5;
  pEffective		ALIAS FOR $6;
  pRecvCost		ALIAS FOR $7;
  _freight		NUMERIC;
  _qty			NUMERIC;
  _invhistid		INTEGER;
  _o			RECORD;
  _r			RECORD;
  _recvcost		NUMERIC;
  _tmp        INTEGER;
  _pricevar             NUMERIC := 0.00;
  _journalNumber INTEGER := fetchJournalNumber('GL-MISC');

BEGIN
  SELECT recv_qty, recv_date::DATE AS recv_date, recv_freight_curr_id,
	 recv_orderitem_id,
	 round(currToCurr(recv_freight_curr_id,
			  COALESCE(_currid, recv_freight_curr_id),
         recv_freight, recv_date::DATE),2) AS recv_freight,
         recv_posted, recv_order_type,
         COALESCE(itemsite_id, -1) AS itemsiteid,
	 itemsite_item_id, itemsite_costmethod, itemsite_controlmethod,
	 (recv_splitfrom_id IS NOT NULL
	 OR (SELECT (count(*) > 0)
	     FROM recv
	     WHERE (recv_splitfrom_id=recv_id))) AS split INTO _r
  FROM recv LEFT OUTER JOIN itemsite ON (recv_itemsite_id=itemsite_id)
  WHERE (recv_id=precvid);

  IF (NOT FOUND) THEN
    RETURN _itemlocSeries;
  END IF;

  IF (NOT _r.recv_order_type IN ('PO', 'RA', 'TO')) THEN
    RETURN -11;
  END IF;

  IF (_r.split) THEN
    RETURN -12;
  END IF;

  SELECT currToBase(orderitem_unitcost_curr_id, orderitem_unitcost,
		    _r.recv_date::DATE) AS unitprice_base,
	 orderhead_number, orderitem_linenumber,
	 orderhead_curr_id AS freight_curr_id,
	 orderitem_orderhead_type,
	 orderitem_qty_invuomratio INTO _o
  FROM orderhead, orderitem
  WHERE ((orderhead_id=orderitem_orderhead_id)
    AND  (orderhead_type=orderitem_orderhead_type)
    AND  (orderitem_id=_r.recv_orderitem_id)
    AND  (orderitem_orderhead_type=_r.recv_order_type));

  IF (NOT FOUND) THEN
    RETURN _itemlocSeries;
  END IF;

  -- Default to _o.orderitem_unitcost if recv_purchcost is not supplied
  -- Note: this should never happen, a value is always supplied
  if (pRecvCost IS NULL) THEN
    _recvcost := _o.orderitem_unitcost;
  ELSE
    -- Note: if the receipt has already been posted, pRecvCost will always
    --       equal the original recv_purchcost (cannot be modified in GUI)
    _recvcost := pRecvCost;
  END IF;

  IF (_r.recv_posted) THEN
    _qty := (pQty - _r.recv_qty);
    IF (_qty <> 0) THEN
      IF (_r.itemsiteid = -1) THEN
        PERFORM insertGLTransaction( _journalNumber,'S/R',
                                     _r.recv_order_type,
                                     _o.orderhead_number,
                                     'Receive Non-Inventory from ' || _r.recv_order_type,
                                     expcat_liability_accnt_id,
                                     getPrjAccntId(poitem_prj_id, expcat_exp_accnt_id),
                                     -1,
                                     ROUND(_o.unitprice_base * _qty, 2),
                                     pEffective )
        FROM poitem, expcat
        WHERE ((poitem_expcat_id=expcat_id)
          AND  (poitem_id=_r.recv_orderitem_id)
          AND  (_o.orderitem_orderhead_type='PO'));

        UPDATE recv
        SET recv_qty=pQty,
            recv_value=(recv_value + ROUND(_o.unitprice_base * _qty, 2)),
            recv_date = pEffective
        WHERE (recv_id=precvid);
      ELSEIF (_r.itemsite_controlmethod = 'N') THEN
        PERFORM insertGLTransaction( _journalNumber,'S/R',
                                     _r.recv_order_type,
                                     _o.orderhead_number,
                                     'Receive Non-Controlled Inventory from ' || _r.recv_order_type,
                                     costcat_liability_accnt_id,
                                     getPrjAccntId(poitem_prj_id, costcat_exp_accnt_id),
                                     -1,
                                     ROUND(_o.unitprice_base * _qty, 2),
                                     pEffective )
        FROM poitem, itemsite, costcat
        WHERE ((poitem_itemsite_id=itemsite_id)
          AND  (itemsite_costcat_id=costcat_id)
          AND  (poitem_id=_r.recv_orderitem_id)
          AND  (_o.orderitem_orderhead_type='PO'));

        UPDATE recv
        SET recv_qty=pQty,
            recv_value=(recv_value + ROUND(_o.unitprice_base * _qty, 2)),
            recv_date = pEffective
        WHERE (recv_id=precvid);
      ELSE
        IF (_itemlocSeries = 0 OR _itemlocSeries IS NULL) THEN
          _itemlocSeries := NEXTVAL('itemloc_series_seq');
        END IF;

  SELECT postInvTrans( itemsite_id, 'RP',
			     (_qty * _o.orderitem_qty_invuomratio),
			     'S/R', _r.recv_order_type,
			     _o.orderhead_number::TEXT || '-' || _o.orderitem_linenumber::TEXT, '',
			     'Receive Inventory from ' || _r.recv_order_type,
			     costcat_asset_accnt_id,
			     costcat_liability_accnt_id,
			     _itemlocSeries, pEffective,
           ROUND(_recvcost * _qty, 2) -- alway passing since it is ignored if not average costed item
                           ) INTO _tmp
	FROM itemsite, costcat
	WHERE ((itemsite_costcat_id=costcat_id)
    AND  (itemsite_id=_r.itemsiteid) );

        IF(_r.itemsite_costmethod='A') THEN
	  UPDATE recv
	     SET recv_qty=pQty,
	         recv_value=(recv_value + _recvcost * _qty * _o.orderitem_qty_invuomratio),
                 recv_date = pEffective
	   WHERE(recv_id=precvid);
        ELSE
	  UPDATE recv
	     SET recv_qty=pQty,
	         recv_value=(recv_value + stdcost(_r.itemsite_item_id) * _qty * _o.orderitem_qty_invuomratio),
                 recv_date = pEffective
	   WHERE(recv_id=precvid);
        END IF;
    END IF;

      IF (_r.recv_order_type = 'PO') THEN
	UPDATE poitem
	SET poitem_qty_received=(poitem_qty_received + _qty)
	WHERE (poitem_id=_r.recv_orderitem_id);
      ELSIF (_r.recv_order_type = 'RA' AND fetchMetricBool('EnableReturnAuth')) THEN
	UPDATE raitem
	SET raitem_qtyreceived=(raitem_qtyreceived + _qty)
	WHERE (raitem_id=_r.recv_orderitem_id);
      ELSIF (_r.recv_order_type = 'TO' AND fetchMetricBool('MultiWhs')) THEN
	UPDATE toitem
	SET toitem_qty_received=(toitem_qty_received + _qty)
	WHERE (toitem_id=_r.recv_orderitem_id);
      END IF;

    END IF;

       IF (fetchMetricBool('RecordPPVonReceipt')) THEN -- If the 'Purchase Price Variance on Receipt' option is true
         _invhistid := _tmp;
         -- Find the difference in the purchase price value expected from the P/O and the value of the transaction
         SELECT (((currToBase(pohead_curr_id,
         COALESCE(recv_purchcost, poitem_unitprice),
         recv_date::DATE)) * _qty) - (invhist_value_after - invhist_value_before)) INTO _pricevar
         FROM invhist, recv, pohead, poitem
         WHERE ((recv_orderitem_id=poitem_id)
           AND  (poitem_pohead_id=pohead_id)
           AND  (recv_id=precvid)
           AND  (invhist_id = _invhistid));

         -- If difference exists then
         IF (_pricevar <> 0.00) THEN
           -- Record an additional GL Transaction for the purchase price variance
           SELECT insertGLTransaction( _journalNumber,
                'S/R', _r.recv_order_type, _o.orderhead_number,
                                       'Purchase price variance adjusted for P/O ' || _o.orderhead_number || ' for item ' || _o.orderitem_linenumber::TEXT,
                                       costcat_liability_accnt_id,
                                       getPrjAccntId(poitem_prj_id, costcat_purchprice_accnt_id), -1,
                                       _pricevar,
                                       pEffective, false ) INTO _tmp
           FROM itemsite, costcat, poitem, recv
           WHERE ((itemsite_costcat_id=costcat_id)
              AND (recv_id=precvid)
              AND (recv_orderitem_id=poitem_id)
              AND (itemsite_id=recv_itemsite_id) );
           IF (NOT FOUND) THEN
             RAISE EXCEPTION 'Could not insert G/L transaction: no cost category found for itemsite_id %',
             _r.itemsite_id;
           ELSIF (_tmp < 0 AND _tmp != -3) THEN -- error but not 0-value transaction
             RETURN _tmp;
           ELSE
             -- Posting to trial balance is deferred to prevent locking
             INSERT INTO itemlocpost ( itemlocpost_glseq, itemlocpost_itemlocseries)
             VALUES ( _tmp, _itemlocSeries );
           END IF;
         END IF;
       END IF;

    _freight := (pFreight - _r.recv_freight);
    IF (_freight <> 0) THEN

      IF (_r.itemsiteid = -1) THEN
  PERFORM insertGLTransaction( _journalNumber,'S/R', _r.recv_order_type,
				     _o.orderhead_number,
				    'Receive Non-Inventory Freight from ' || _r.recv_order_type,
             expcat_liability_accnt_id, getPrjAccntId(poitem_prj_id, expcat_freight_accnt_id), -1,
				      ROUND(currToBase(_currid, _freight,
						    pEffective), 2),
				     pEffective )
	FROM poitem, expcat
	WHERE ((poitem_expcat_id=expcat_id)
	  AND  (poitem_id=_r.recv_orderitem_id)
	  AND  (_r.recv_order_type='PO'));
      ELSE
  PERFORM insertGLTransaction(_journalNumber,'S/R', _r.recv_order_type,
				    _o.orderhead_number,
				    'Receive Non-Inventory Freight from ' ||
							    _r.recv_order_type,
				   costcat_liability_accnt_id,
				   costcat_freight_accnt_id, -1,
				   round(currToBase(_currid, _freight,
						    pEffective), 2),
				   pEffective )
	FROM itemsite, costcat
	WHERE ( (itemsite_costcat_id=costcat_id)
	  AND   (itemsite_id=_r.itemsiteid) );
      END IF;

      IF (_r.recv_order_type = 'PO') THEN
	UPDATE poitem
	SET poitem_freight_received=(poitem_freight_received +
				   currToCurr(_currid, _o.freight_curr_id,
					      _freight, pEffective))
	WHERE (poitem_id=_r.recv_orderitem_id);

      -- raitem does not track freight

      ELSEIF (_r.recv_order_type = 'TO' AND fetchMetricBool('MultiWhs')) THEN
	UPDATE toitem
	SET toitem_freight_received=(toitem_freight_received +
				   currToCurr(_currid, _o.freight_curr_id,
					      _freight, pEffective))
	WHERE (toitem_id=_r.recv_orderitem_id);
      END IF;

      UPDATE recv
      SET recv_freight=currToCurr(_currid, recv_freight_curr_id, pFreight,
				  pEffective),
	  recv_date = pEffective
      WHERE (recv_id=precvid);
    END IF;

  ELSE

-- Receipt not posted yet
    UPDATE recv SET recv_qty=pQty, recv_freight=pFreight, recv_purchcost=_recvcost WHERE recv_id=precvid;
  END IF;

RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.correctreceipt(integer, numeric, numeric, integer, integer, date, numeric) OWNER TO admin;

--
-- TOC entry 1278 (class 1255 OID 146565828)
-- Dependencies: 4536 8
-- Name: cosbycustomervalue(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION cosbycustomervalue(integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCustid ALIAS FOR $1;
  pPeriodid ALIAS FOR $2;
  _value NUMERIC;
  _startDate DATE;
  _endDate DATE;

BEGIN

  _startDate := findPeriodStart(pPeriodid);
  _endDate := findPeriodEnd(pPeriodid);

-- Returns value in base currency
-- ToDo: is cohist_shipdate the right DATE to use?
  SELECT SUM(cohist_qtyshipped * currToBase(cohist_curr_id, cohist_unitcost, cohist_shipdate)) INTO _value
  FROM cohist
  WHERE ( (cohist_cust_id=pCustid)
   AND (cohist_invcdate BETWEEN _startDate AND _endDate) );

  IF (_value IS NULL) THEN
    _value := 0;
  END IF;

  RETURN _value;

END;
$_$;


ALTER FUNCTION public.cosbycustomervalue(integer, integer) OWNER TO admin;

--
-- TOC entry 1279 (class 1255 OID 146565829)
-- Dependencies: 4536 8
-- Name: costsbycustomerbyitemsite(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION costsbycustomerbyitemsite(integer, integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCustid ALIAS FOR $1;
  pItemsiteid ALIAS FOR $2;
  pPeriodid ALIAS FOR $3;
  _value NUMERIC;
  _startDate DATE;
  _endDate DATE;

BEGIN

  _startDate := findPeriodStart(pPeriodid);
  _endDate := findPeriodEnd(pPeriodid);

-- Returns value in base currency
-- ToDo: is cohist_shipdate the right DATE to use?
  SELECT SUM(cohist_qtyshipped * currToBase(cohist_curr_id, cohist_unitcost, cohist_shipdate)) INTO _value
  FROM cohist
  WHERE ( (cohist_itemsite_id<>pItemsiteid)
   AND (cohist_cust_id=pCustid)
   AND (cohist_invcdate BETWEEN _startDate AND _endDate) );

  IF (_value IS NULL) THEN
    _value := 0;
  END IF;

  RETURN _value;

END;
$_$;


ALTER FUNCTION public.costsbycustomerbyitemsite(integer, integer, integer) OWNER TO admin;

--
-- TOC entry 1281 (class 1255 OID 146565830)
-- Dependencies: 4536 8
-- Name: costsbycustomervalue(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION costsbycustomervalue(integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCustid ALIAS FOR $1;
  pPeriodid ALIAS FOR $2;
  _value NUMERIC;
  _startDate DATE;
  _endDate DATE;

BEGIN

  _startDate := findPeriodStart(pPeriodid);
  _endDate := findPeriodEnd(pPeriodid);

-- Returns value in base currency
-- ToDo: is cohist_shipdate the right DATE to use?
  SELECT SUM(cohist_qtyshipped * currToBase(cohist_curr_id, cohist_unitcost, cohist_shipdate)) INTO _value
  FROM cohist
  WHERE ( (cohist_itemsite_id<>-1)
   AND (cohist_cust_id=pCustid)
   AND (cohist_invcdate BETWEEN _startDate AND _endDate) );

  IF (_value IS NULL) THEN
    _value := 0;
  END IF;

  RETURN _value;

END;
$_$;


ALTER FUNCTION public.costsbycustomervalue(integer, integer) OWNER TO admin;

--
-- TOC entry 1282 (class 1255 OID 146565831)
-- Dependencies: 4536 8
-- Name: costsbycustomervalue(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION costsbycustomervalue(integer, integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCustid ALIAS FOR $1;
  pPeriodid ALIAS FOR $2;
  pProdcatid ALIAS FOR $3;
  _value NUMERIC;
  _startDate DATE;
  _endDate DATE;

BEGIN

  _startDate := findPeriodStart(pPeriodid);
  _endDate := findPeriodEnd(pPeriodid);

-- Returns value in base currency
-- ToDo: is cohist_shipdate the right DATE to use?
  SELECT SUM(cohist_qtyshipped * currToBase(cohist_curr_id, cohist_unitcost, cohist_shipdate)) INTO _value
  FROM cohist, itemsite, item
  WHERE ( (cohist_cust_id=pCustid)
   AND (cohist_itemsite_id=itemsite_id)
   AND (itemsite_item_id=item_id)
   AND (item_prodcat_id=pProdcatid)
   AND (cohist_invcdate BETWEEN _startDate AND _endDate) );

  IF (_value IS NULL) THEN
    _value := 0;
  END IF;

  RETURN _value;

END;
$_$;


ALTER FUNCTION public.costsbycustomervalue(integer, integer, integer) OWNER TO admin;

--
-- TOC entry 1283 (class 1255 OID 146565832)
-- Dependencies: 4536 8
-- Name: costsbycustomervalue(integer, integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION costsbycustomervalue(integer, integer, text) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCustid ALIAS FOR $1;
  pPeriodid ALIAS FOR $2;
  pProdcat ALIAS FOR $3;
  _value NUMERIC;
  _startDate DATE;
  _endDate DATE;

BEGIN

  _startDate := findPeriodStart(pPeriodid);
  _endDate := findPeriodEnd(pPeriodid);

-- Returns value in base currency
-- ToDo: is cohist_shipdate the right date to use?
  SELECT SUM(cohist_qtyshipped * currToBase(cohist_curr_id, cohist_unitcost, cohist_shipdate)) INTO _value
  FROM cohist, itemsite, item, prodcat
  WHERE ( (cohist_cust_id=pCustid)
   AND (cohist_itemsite_id=itemsite_id)
   AND (itemsite_item_id=item_id)
   AND (item_prodcat_id=prodcat_id)
   AND (prodcat_code ~ pProdcat)
   AND (cohist_invcdate BETWEEN _startDate AND _endDate) );

  IF (_value IS NULL) THEN
    _value := 0;
  END IF;

  RETURN _value;

END;
$_$;


ALTER FUNCTION public.costsbycustomervalue(integer, integer, text) OWNER TO admin;

--
-- TOC entry 1284 (class 1255 OID 146565833)
-- Dependencies: 4536 8
-- Name: createaccountingperiod(date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createaccountingperiod(date, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pStartDate ALIAS FOR $1;
  pEndDate ALIAS FOR $2;

BEGIN

  RETURN createAccountingPeriod(pStartDate, pEndDate, NULL, NULL);

END;
$_$;


ALTER FUNCTION public.createaccountingperiod(date, date) OWNER TO admin;

--
-- TOC entry 1285 (class 1255 OID 146565834)
-- Dependencies: 4536 8
-- Name: createaccountingperiod(date, date, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createaccountingperiod(date, date, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pStartDate ALIAS FOR $1;
  pEndDate ALIAS FOR $2;
  pYearPeriodId ALIAS FOR $3;
  pQuarter ALIAS FOR $4;
  _periodid INTEGER;
  _check INTEGER;
  _r RECORD;
  _initial BOOLEAN;
  _number INTEGER;

BEGIN

--  Make that the passed start date doesn't fall into any existing period
  SELECT period_id INTO _check
  FROM period
  WHERE (pStartDate BETWEEN period_start AND period_end);
  IF (FOUND) THEN
    RETURN -1;
  END IF;

--  Make that the passed end date doesn't fall into any existing period
  SELECT period_id INTO _check
  FROM period
  WHERE (pEndDate BETWEEN period_start AND period_end);
  IF (FOUND) THEN
    RETURN -2;
  END IF;

--  Make that the passed start and end dates don't enclose an existing period
  SELECT period_id INTO _check
  FROM period
  WHERE ( (period_start >= pStartDate)
   AND (period_end <= pEndDate) );
  IF (FOUND) THEN
    RETURN -3;
  END IF;

-- Make sure period is inside fiscal year
  SELECT yearperiod_id INTO _check
  FROM yearperiod
  WHERE ((yearperiod_id=pYearPeriodId)
  AND (pStartDate>=yearperiod_start)
  AND (pEndDate<=yearperiod_end));
  IF NOT (FOUND) THEN
    RETURN -4;
  END IF;

--  Determine if this is the initial accounting period
  SELECT CASE WHEN(count(*) > 0) THEN FALSE
              ELSE TRUE
         END INTO _initial
  FROM period;

-- Determine the next number
  SELECT COALESCE(MAX(period_number),0) + 1 INTO _number
  FROM period
  WHERE (period_yearperiod_id=pYearPeriodId);

--  Create the new accounting period
  SELECT NEXTVAL('period_period_id_seq') INTO _periodid;
  INSERT INTO period
  ( period_id, period_start, period_end, period_closed, period_freeze,
    period_initial, period_number, period_yearperiod_id, period_quarter )
  VALUES
  ( _periodid, pStartDate, pEndDate, FALSE, FALSE, _initial, _number, pYearPeriodId, pQuarter );

--  Post any unposted G/L Transactions into the new period
  FOR _r IN SELECT DISTINCT gltrans_sequence
            FROM gltrans
            WHERE ( (NOT gltrans_posted)
             AND (gltrans_date BETWEEN pStartDate AND pEndDate) ) LOOP
    PERFORM postIntoTrialBalance(_r.gltrans_sequence);
  END LOOP;

  RETURN _periodid;

END;
$_$;


ALTER FUNCTION public.createaccountingperiod(date, date, integer, integer) OWNER TO admin;

--
-- TOC entry 1286 (class 1255 OID 146565835)
-- Dependencies: 4536 8
-- Name: createaccountingyearperiod(date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createaccountingyearperiod(date, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pStartDate ALIAS FOR $1;
  pEndDate ALIAS FOR $2;
  _yearperiodid INTEGER;
  _check INTEGER;
  _checkBool BOOLEAN;
  _r RECORD;
  _initial BOOLEAN;

BEGIN

--  Make that the passed start date doesn't fall into any existing yearperiod
  SELECT yearperiod_id INTO _check
  FROM yearperiod
  WHERE (pStartDate BETWEEN yearperiod_start AND yearperiod_end);
  IF (FOUND) THEN
    RETURN -1;
  END IF;

--  Make that the passed end date doesn't fall into any existing yearperiod
  SELECT yearperiod_id INTO _check
  FROM yearperiod
  WHERE (pEndDate BETWEEN yearperiod_start AND yearperiod_end);
  IF (FOUND) THEN
    RETURN -2;
  END IF;

--  Make that the passed start and end dates don't enclose an existing yearperiod
  SELECT yearperiod_id INTO _check
  FROM yearperiod
  WHERE ( (yearperiod_start >= pStartDate)
   AND (yearperiod_end <= pEndDate) );
  IF (FOUND) THEN
    RETURN -3;
  END IF;

--  Make sure that the passed start is prior to the end date
  SELECT (pStartDate > pEndDate) INTO _checkBool;
  IF (_checkBool) THEN
    RETURN -5;
  END IF;

--  Determine if this is the initial accounting yearperiod
  SELECT CASE WHEN(count(*) > 0) THEN FALSE
              ELSE TRUE
         END INTO _initial
  FROM yearperiod;

--  Create the new accounting yearperiod
  SELECT NEXTVAL('yearperiod_yearperiod_id_seq') INTO _yearperiodid;
  INSERT INTO yearperiod
  ( yearperiod_id, yearperiod_start, yearperiod_end, yearperiod_closed )
  VALUES
  ( _yearperiodid, pStartDate, pEndDate, FALSE );

  RETURN _yearperiodid;

END;
$_$;


ALTER FUNCTION public.createaccountingyearperiod(date, date) OWNER TO admin;

--
-- TOC entry 1287 (class 1255 OID 146565836)
-- Dependencies: 4536 8
-- Name: createapchecks(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createapchecks(integer, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RAISE NOTICE 'createAPChecks() is deprecated - use createChecks() instead';
  RETURN createChecks($1, $2);
END;
$_$;


ALTER FUNCTION public.createapchecks(integer, date) OWNER TO admin;

--
-- TOC entry 1288 (class 1255 OID 146565837)
-- Dependencies: 4536 8
-- Name: createapcreditmemo(integer, text, text, date, numeric, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createapcreditmemo(integer, text, text, date, numeric, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVendid ALIAS FOR $1;
  pDocNumber ALIAS FOR $2;
  pPoNumber ALIAS FOR $3;
  pDocDate ALIAS FOR $4;
  pAmount ALIAS FOR $5;
  pNotes ALIAS FOR $6;
  _result INTEGER;

BEGIN

  SELECT createAPCreditMemo( pVendid, fetchJournalNumber('AP-MISC'),
                             pDocNumber, pPoNumber, pDocDate, pAmount, pNotes, -1, pDocDate, -1, baseCurrId() ) INTO _result;

  RETURN _result;

END;
$_$;


ALTER FUNCTION public.createapcreditmemo(integer, text, text, date, numeric, text) OWNER TO admin;

--
-- TOC entry 1280 (class 1255 OID 146565838)
-- Dependencies: 4536 8
-- Name: createapcreditmemo(integer, integer, text, text, date, numeric, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createapcreditmemo(integer, integer, text, text, date, numeric, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVendid ALIAS FOR $1;
  pJournalNumber ALIAS FOR $2;
  pDocNumber ALIAS FOR $3;
  pPoNumber ALIAS FOR $4;
  pDocDate ALIAS FOR $5;
  pAmount ALIAS FOR $6;
  pNotes ALIAS FOR $7;

BEGIN
  RETURN createAPCreditMemo(pVendid, pJournalNumber, pDocNumber, pPoNumber, pDocDate, pAmount, pNotes, -1, pDocDate, -1, baseCurrId() );
END;
$_$;


ALTER FUNCTION public.createapcreditmemo(integer, integer, text, text, date, numeric, text) OWNER TO admin;

--
-- TOC entry 1163 (class 1255 OID 146565839)
-- Dependencies: 4536 8
-- Name: createapcreditmemo(integer, text, text, date, numeric, text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createapcreditmemo(integer, text, text, date, numeric, text, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVendid ALIAS FOR $1;
  pDocNumber ALIAS FOR $2;
  pPoNumber ALIAS FOR $3;
  pDocDate ALIAS FOR $4;
  pAmount ALIAS FOR $5;
  pNotes ALIAS FOR $6;
  pAccntid ALIAS FOR $7;
  _result INTEGER;

BEGIN

  SELECT createAPCreditMemo( pVendid, fetchJournalNumber('AP-MISC'),
                             pDocNumber, pPoNumber, pDocDate, pAmount, pNotes, pAccntid, pDocDate, -1, baseCurrId() ) INTO _result;

  RETURN _result;

END;
$_$;


ALTER FUNCTION public.createapcreditmemo(integer, text, text, date, numeric, text, integer) OWNER TO admin;

--
-- TOC entry 1289 (class 1255 OID 146565840)
-- Dependencies: 4536 8
-- Name: createapcreditmemo(integer, integer, text, text, date, numeric, text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createapcreditmemo(integer, integer, text, text, date, numeric, text, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVendid ALIAS FOR $1;
  pJournalNumber ALIAS FOR $2;
  pDocNumber ALIAS FOR $3;
  pPoNumber ALIAS FOR $4;
  pDocDate ALIAS FOR $5;
  pAmount ALIAS FOR $6;
  pNotes ALIAS FOR $7;
  pAccntid ALIAS FOR $8;
BEGIN
  RETURN createAPCreditMemo( pVendid, pJournalNumber,
                             pDocNumber, pPoNumber, pDocDate, pAmount, pNotes, pAccntid, pDocDate, -1, baseCurrId() );
END;
$_$;


ALTER FUNCTION public.createapcreditmemo(integer, integer, text, text, date, numeric, text, integer) OWNER TO admin;

--
-- TOC entry 1290 (class 1255 OID 146565841)
-- Dependencies: 4536 8
-- Name: createapcreditmemo(integer, text, text, date, numeric, text, integer, date, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createapcreditmemo(integer, text, text, date, numeric, text, integer, date, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVendid ALIAS FOR $1;
  pDocNumber ALIAS FOR $2;
  pPoNumber ALIAS FOR $3;
  pDocDate ALIAS FOR $4;
  pAmount ALIAS FOR $5;
  pNotes ALIAS FOR $6;
  pAccntid ALIAS FOR $7;
  pDueDate ALIAS FOR $8;
  pTermsid ALIAS FOR $9;
  _result INTEGER;

BEGIN

  SELECT createAPCreditMemo( pVendid, fetchJournalNumber('AP-MISC'),
                             pDocNumber, pPoNumber, pDocDate, pAmount, pNotes, pAccntid, pDueDate, pTermsid, baseCurrId() ) INTO _result;

  RETURN _result;

END;
$_$;


ALTER FUNCTION public.createapcreditmemo(integer, text, text, date, numeric, text, integer, date, integer) OWNER TO admin;

--
-- TOC entry 1291 (class 1255 OID 146565842)
-- Dependencies: 4536 8
-- Name: createapcreditmemo(integer, integer, text, text, date, numeric, text, integer, date, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createapcreditmemo(integer, integer, text, text, date, numeric, text, integer, date, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVendid ALIAS FOR $1;
  pJournalNumber ALIAS FOR $2;
  pDocNumber ALIAS FOR $3;
  pPoNumber ALIAS FOR $4;
  pDocDate ALIAS FOR $5;
  pAmount ALIAS FOR $6;
  pNotes ALIAS FOR $7;
  pAccntid ALIAS FOR $8;
  pDueDate ALIAS FOR $9;
  pTermsid ALIAS FOR $10;
BEGIN
  RETURN createAPCreditMemo( pVendid, pJournalNumber, pDocNumber, pPoNumber, pDocDate, pAmount, pNotes, pAccntid, pDueDate, pTermsid, baseCurrId() );
END;
$_$;


ALTER FUNCTION public.createapcreditmemo(integer, integer, text, text, date, numeric, text, integer, date, integer) OWNER TO admin;

--
-- TOC entry 1292 (class 1255 OID 146565843)
-- Dependencies: 4536 8
-- Name: createapcreditmemo(integer, integer, text, text, date, numeric, text, integer, date, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createapcreditmemo(integer, integer, text, text, date, numeric, text, integer, date, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVendid ALIAS FOR $1;
  pJournalNumber ALIAS FOR $2;
  pDocNumber ALIAS FOR $3;
  pPoNumber ALIAS FOR $4;
  pDocDate ALIAS FOR $5;
  pAmount ALIAS FOR $6;
  pNotes ALIAS FOR $7;
  pAccntid ALIAS FOR $8;
  pDueDate ALIAS FOR $9;
  pTermsid ALIAS FOR $10;
  pCurrId ALIAS FOR $11;
BEGIN
  RETURN createAPCreditMemo( NULL, pVendid, pJournalNumber, pDocNumber, pPoNumber, pDocDate, pAmount, pNotes, pAccntid, pDueDate, pTermsid, pCurrId );
END;
$_$;


ALTER FUNCTION public.createapcreditmemo(integer, integer, text, text, date, numeric, text, integer, date, integer, integer) OWNER TO admin;

--
-- TOC entry 1293 (class 1255 OID 146565844)
-- Dependencies: 4536 8
-- Name: createapcreditmemo(integer, integer, integer, text, text, date, numeric, text, integer, date, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createapcreditmemo(integer, integer, integer, text, text, date, numeric, text, integer, date, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pId ALIAS FOR $1;
  pVendid ALIAS FOR $2;
  pJournalNumber ALIAS FOR $3;
  pDocNumber ALIAS FOR $4;
  pPoNumber ALIAS FOR $5;
  pDocDate ALIAS FOR $6;
  pAmount ALIAS FOR $7;
  pNotes ALIAS FOR $8;
  pAccntid ALIAS FOR $9;
  pDueDate ALIAS FOR $10;
  pTermsid ALIAS FOR $11;
  pCurrId ALIAS FOR $12;
  _vendName TEXT;
  _apAccntid INTEGER;
  _prepaidAccntid INTEGER;
  _accntid INTEGER;
  _glSequence INTEGER;
  _journalNumber INTEGER;
  _apopenid INTEGER;
  _baseAmount NUMERIC;
  _taxBaseValue NUMERIC;
  _test INTEGER;

BEGIN

  _apopenid := pId;

  SELECT findAPAccount(pVendid) INTO _apAccntid;
  SELECT findAPPrepaidAccount(pVendid) INTO _prepaidAccntid;

  SELECT vend_name INTO _vendName
  FROM vendinfo
  WHERE (vend_id=pVendid);

  _accntid := pAccntid;

  PERFORM accnt_id
     FROM accnt
    WHERE (accnt_id=_accntid);
  IF (FOUND) THEN
    _prepaidAccntid := _accntid;
  ELSE
    _accntid := -1;
  END IF;

  IF(pJournalNumber IS NULL) THEN
    SELECT fetchJournalNumber('AP-MISC') INTO _journalNumber;
  ELSE
    _journalNumber := pJournalNumber;
  END IF;

  SELECT fetchGLSequence() INTO _glSequence;

  IF (_apopenid IS NOT NULL) THEN
    UPDATE apopen SET
      apopen_username=getEffectiveXtUser(), apopen_journalnumber=_journalNumber,
      apopen_vend_id=pVendid, apopen_docnumber=pDocNumber,
      apopen_doctype='C', apopen_ponumber=pPoNumber,
      apopen_docdate=pDocDate, apopen_duedate=pDueDate,
      apopen_distdate=pDocDate, apopen_terms_id=pTermsid,
      apopen_amount=pAmount, apopen_paid=0,
      apopen_open=(pAmount <> 0), apopen_notes=pNotes,
      apopen_accnt_id=_accntid, apopen_curr_id=pCurrId,
      apopen_closedate=CASE WHEN (pAmount = 0) THEN pDocdate END
    WHERE apopen_id = _apopenid;
  ELSE
    SELECT NEXTVAL('apopen_apopen_id_seq') INTO _apopenid;
    INSERT INTO apopen
    ( apopen_id, apopen_username, apopen_journalnumber,
      apopen_vend_id, apopen_docnumber, apopen_doctype, apopen_ponumber,
      apopen_docdate, apopen_duedate, apopen_distdate, apopen_terms_id,
      apopen_amount, apopen_paid, apopen_open, apopen_notes, apopen_accnt_id, apopen_curr_id,
      apopen_closedate )
    VALUES
    ( _apopenid, getEffectiveXtUser(), _journalNumber,
      pVendid, pDocNumber, 'C', pPoNumber,
      pDocDate, pDueDate, pDocDate, pTermsid,
      pAmount, 0, (pAmount <> 0), pNotes, _accntid, pCurrId,
      CASE WHEN (pAmount = 0) THEN pDocDate END );
  END IF;

  _baseAmount := round(currToBase(pCurrId, pAmount, pDocDate), 2);

  -- Debit the A/P account for the full amount
  SELECT insertIntoGLSeries ( _glSequence, 'A/P', 'CM',
                              pDocNumber, _apAccntid,
                              (_baseAmount * -1),
                              pDocDate, (_vendName || ' ' || pNotes) ) INTO _test;

  -- Credit the Tax account for the tax amount
  _taxBaseValue := addTaxToGLSeries(_glSequence,
				      'A/P', 'CM', pDocNumber,
				      pCurrId, pDocDate, pDocDate,
                                      'apopentax', _apopenid,
                                      _vendName);

  UPDATE apopentax SET taxhist_journalnumber = _journalNumber
  WHERE taxhist_parent_id=_apopenid;

  -- Credit the Prepaid account for the basis amount
  SELECT insertIntoGLSeries ( _glSequence, 'A/P', 'CM',
                              pDocNumber, _prepaidAccntid,
                              (_baseAmount - _taxBaseValue),
                              pDocDate, (_vendName || ' ' || pNotes) ) INTO _test;

  --  Commit the GLSeries;
  SELECT postGLSeries(_glSequence, _journalNumber) INTO _test;
  IF (_test < 0) THEN
    DELETE FROM apopen WHERE (apopen_id=_apopenid);
    PERFORM deleteGLSeries(_glSequence);
    RAISE EXCEPTION 'postGLSeries commit failed with %', _test;
  END IF;

  RETURN pJournalNumber;

END;
$_$;


ALTER FUNCTION public.createapcreditmemo(integer, integer, integer, text, text, date, numeric, text, integer, date, integer, integer) OWNER TO admin;

--
-- TOC entry 1294 (class 1255 OID 146565845)
-- Dependencies: 4536 8
-- Name: createapcreditmemoapplication(integer, integer, numeric, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createapcreditmemoapplication(psourceapopenid integer, ptargetapopenid integer, pamount numeric, pcurrid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _apCreditApplyId	INTEGER;

BEGIN
  IF (pAmount > (SELECT ROUND(currToCurr(apopen_curr_id, pCurrId, (apopen_amount - apopen_paid), apopen_docdate), 2)
                 FROM apopen
                 WHERE (apopen_id=pTargetApopenId))) THEN
    RETURN -1;
  END IF;

  IF (pAmount > (SELECT ROUND((apopen_amount - apopen_paid) -
		       COALESCE(SUM(currToCurr(apcreditapply_curr_id,
						apopen_curr_id,
						apcreditapply_amount,
						apopen_docdate)), 0), 2)
             FROM apopen LEFT OUTER JOIN apcreditapply
               ON ((apcreditapply_source_apopen_id=apopen_id)
              AND (apcreditapply_target_apopen_id<>pTargetApopenId))
             WHERE (apopen_id=pSourceApopenId)
             GROUP BY apopen_amount, apopen_paid)) THEN
      RETURN -2;
    END IF;

  SELECT apcreditapply_id INTO _apCreditApplyId
    FROM apcreditapply
   WHERE ((apcreditapply_source_apopen_id=pSourceApopenId)
     AND  (apcreditapply_target_apopen_id=pTargetApopenId));

  IF (FOUND) THEN
    UPDATE apcreditapply SET apcreditapply_amount=pAmount,
			     apcreditapply_curr_id=pCurrId
    WHERE (apcreditapply_id=_apCreditApplyId);
  ELSE
    INSERT INTO apcreditapply (
      apcreditapply_source_apopen_id,
      apcreditapply_target_apopen_id,
      apcreditapply_amount, apcreditapply_curr_id
    ) VALUES (
      pSourceApopenId,
      pTargetApopenId,
      pAmount, pCurrId)
    RETURNING apcreditapply_id INTO _apCreditApplyId;
  END IF;

  RETURN _apCreditApplyId;

END;
$$;


ALTER FUNCTION public.createapcreditmemoapplication(psourceapopenid integer, ptargetapopenid integer, pamount numeric, pcurrid integer) OWNER TO admin;

--
-- TOC entry 1295 (class 1255 OID 146565846)
-- Dependencies: 4536 8
-- Name: createapdebitmemo(integer, text, text, date, numeric, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createapdebitmemo(integer, text, text, date, numeric, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVendid ALIAS FOR $1;
  pDocNumber ALIAS FOR $2;
  pPoNumber ALIAS FOR $3;
  pDocDate ALIAS FOR $4;
  pAmount ALIAS FOR $5;
  pNotes ALIAS FOR $6;
  _result INTEGER;

BEGIN

  SELECT createAPDebitMemo( pVendid, fetchJournalNumber('AP-MISC'),
                            pDocNumber, pPoNumber, pDocDate, pAmount, pNotes, -1, pDocDate, -1, baseCurrId() ) INTO _result;

  RETURN _result;

END;
$_$;


ALTER FUNCTION public.createapdebitmemo(integer, text, text, date, numeric, text) OWNER TO admin;

--
-- TOC entry 1296 (class 1255 OID 146565847)
-- Dependencies: 4536 8
-- Name: createapdebitmemo(integer, integer, text, text, date, numeric, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createapdebitmemo(integer, integer, text, text, date, numeric, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVendid ALIAS FOR $1;
  pJournalNumber ALIAS FOR $2;
  pDocNumber ALIAS FOR $3;
  pPoNumber ALIAS FOR $4;
  pDocDate ALIAS FOR $5;
  pAmount ALIAS FOR $6;
  pNotes ALIAS FOR $7;

BEGIN

  RETURN createAPDebitMemo(pVendid, pJournalNumber, pDocNumber, pPoNumber, pDocDate, pAmount, pNotes, -1, pDocDate, -1, baseCurrId() );

END;
$_$;


ALTER FUNCTION public.createapdebitmemo(integer, integer, text, text, date, numeric, text) OWNER TO admin;

--
-- TOC entry 1297 (class 1255 OID 146565848)
-- Dependencies: 4536 8
-- Name: createapdebitmemo(integer, text, text, date, numeric, text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createapdebitmemo(integer, text, text, date, numeric, text, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVendid ALIAS FOR $1;
  pDocNumber ALIAS FOR $2;
  pPoNumber ALIAS FOR $3;
  pDocDate ALIAS FOR $4;
  pAmount ALIAS FOR $5;
  pNotes ALIAS FOR $6;
  pAccntid ALIAS FOR $7;
  _result INTEGER;

BEGIN

  SELECT createAPDebitMemo( pVendid, fetchJournalNumber('AP-MISC'),
                            pDocNumber, pPoNumber, pDocDate, pAmount, pNotes, pAccntid, pDocDate, -1, baseCurrId() ) INTO _result;

  RETURN _result;

END;
$_$;


ALTER FUNCTION public.createapdebitmemo(integer, text, text, date, numeric, text, integer) OWNER TO admin;

--
-- TOC entry 1298 (class 1255 OID 146565849)
-- Dependencies: 4536 8
-- Name: createapdebitmemo(integer, integer, text, text, date, numeric, text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createapdebitmemo(integer, integer, text, text, date, numeric, text, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVendid ALIAS FOR $1;
  pJournalNumber ALIAS FOR $2;
  pDocNumber ALIAS FOR $3;
  pPoNumber ALIAS FOR $4;
  pDocDate ALIAS FOR $5;
  pAmount ALIAS FOR $6;
  pNotes ALIAS FOR $7;
  pAccntid ALIAS FOR $8;
BEGIN
  RETURN createAPDebitMemo( pVendid, pJournalNumber,
                            pDocNumber, pPoNumber, pDocDate, pAmount, pNotes, pAccntid, pDocDate, -1, baseCurrId() );
END;
$_$;


ALTER FUNCTION public.createapdebitmemo(integer, integer, text, text, date, numeric, text, integer) OWNER TO admin;

--
-- TOC entry 1299 (class 1255 OID 146565850)
-- Dependencies: 4536 8
-- Name: createapdebitmemo(integer, text, text, date, numeric, text, integer, date, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createapdebitmemo(integer, text, text, date, numeric, text, integer, date, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVendid ALIAS FOR $1;
  pDocNumber ALIAS FOR $2;
  pPoNumber ALIAS FOR $3;
  pDocDate ALIAS FOR $4;
  pAmount ALIAS FOR $5;
  pNotes ALIAS FOR $6;
  pAccntid ALIAS FOR $7;
  pDueDate ALIAS FOR $8;
  pTermsid ALIAS FOR $9;
  _result INTEGER;

BEGIN

  SELECT createAPDebitMemo( pVendid, fetchJournalNumber('AP-MISC'),
                            pDocNumber, pPoNumber, pDocDate, pAmount, pNotes, pAccntid, pDueDate, pTermsid, baseCurrId() ) INTO _result;

  RETURN _result;

END;
$_$;


ALTER FUNCTION public.createapdebitmemo(integer, text, text, date, numeric, text, integer, date, integer) OWNER TO admin;

--
-- TOC entry 1300 (class 1255 OID 146565851)
-- Dependencies: 4536 8
-- Name: createapdebitmemo(integer, integer, text, text, date, numeric, text, integer, date, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createapdebitmemo(integer, integer, text, text, date, numeric, text, integer, date, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVendid ALIAS FOR $1;
  pJournalNumber ALIAS FOR $2;
  pDocNumber ALIAS FOR $3;
  pPoNumber ALIAS FOR $4;
  pDocDate ALIAS FOR $5;
  pAmount ALIAS FOR $6;
  pNotes ALIAS FOR $7;
  pAccntid ALIAS FOR $8;
  pDueDate ALIAS FOR $9;
  pTermsid ALIAS FOR $10;

BEGIN
  RETURN createAPDebitMemo(pVendid, pJournalNumber, pDocNumber, pPoNumber, pDocDate, pAmount, pNotes, pAccntid, pDueDate, pTermsid, baseCurrId() );
END;
$_$;


ALTER FUNCTION public.createapdebitmemo(integer, integer, text, text, date, numeric, text, integer, date, integer) OWNER TO admin;

--
-- TOC entry 1301 (class 1255 OID 146565852)
-- Dependencies: 4536 8
-- Name: createapdebitmemo(integer, integer, text, text, date, numeric, text, integer, date, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createapdebitmemo(integer, integer, text, text, date, numeric, text, integer, date, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVendid ALIAS FOR $1;
  pJournalNumber ALIAS FOR $2;
  pDocNumber ALIAS FOR $3;
  pPoNumber ALIAS FOR $4;
  pDocDate ALIAS FOR $5;
  pAmount ALIAS FOR $6;
  pNotes ALIAS FOR $7;
  pAccntid ALIAS FOR $8;
  pDueDate ALIAS FOR $9;
  pTermsid ALIAS FOR $10;
  pCurrId ALIAS FOR $11;

BEGIN
  RETURN createAPDebitMemo(NULL, pVendid, pJournalNumber, pDocNumber, pPoNumber, pDocDate, pAmount, pNotes, pAccntid, pDueDate, pTermsid, pCurrId );
END;
$_$;


ALTER FUNCTION public.createapdebitmemo(integer, integer, text, text, date, numeric, text, integer, date, integer, integer) OWNER TO admin;

--
-- TOC entry 1302 (class 1255 OID 146565853)
-- Dependencies: 4536 8
-- Name: createapdebitmemo(integer, integer, integer, text, text, date, numeric, text, integer, date, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createapdebitmemo(integer, integer, integer, text, text, date, numeric, text, integer, date, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pId ALIAS FOR $1;
  pVendid ALIAS FOR $2;
  pJournalNumber ALIAS FOR $3;
  pDocNumber ALIAS FOR $4;
  pPoNumber ALIAS FOR $5;
  pDocDate ALIAS FOR $6;
  pAmount ALIAS FOR $7;
  pNotes ALIAS FOR $8;
  pAccntid ALIAS FOR $9;
  pDueDate ALIAS FOR $10;
  pTermsid ALIAS FOR $11;
  pCurrId ALIAS FOR $12;
  _vendName TEXT;
  _apAccntid INTEGER;
  _prepaidAccntid INTEGER;
  _accntid INTEGER;
  _glSequence INTEGER;
  _journalNumber INTEGER;
  _apopenid INTEGER;
  _baseAmount NUMERIC;
  _taxBaseValue NUMERIC;
  _test INTEGER;

BEGIN

  _apopenid := pId;

  SELECT findAPAccount(pVendid) INTO _apAccntid;
  SELECT findAPPrepaidAccount(pVendid) INTO _prepaidAccntid;

  SELECT vend_name INTO _vendName
  FROM vendinfo
  WHERE (vend_id=pVendid);

  _accntid := pAccntid;

  PERFORM accnt_id
     FROM accnt
    WHERE (accnt_id=_accntid);
  IF (FOUND) THEN
    _prepaidAccntid := _accntid;
  ELSE
    _accntid := -1;
  END IF;

  IF(pJournalNumber IS NULL) THEN
    SELECT fetchJournalNumber('AP-MISC') INTO _journalNumber;
  ELSE
    _journalNumber := pJournalNumber;
  END IF;

  SELECT fetchGLSequence() INTO _glSequence;

  IF (_apopenid IS NOT NULL) THEN
    UPDATE apopen SET
      apopen_username=getEffectiveXtUser(), apopen_journalnumber=_journalNumber,
      apopen_vend_id=pVendid, apopen_docnumber=pDocNumber,
      apopen_doctype='D', apopen_ponumber=pPoNumber,
      apopen_docdate=pDocDate, apopen_duedate=pDueDate,
      apopen_distdate=pDocDate, apopen_terms_id=pTermsid,
      apopen_amount=pAmount, apopen_paid=0,
      apopen_open=(pAmount <> 0), apopen_notes=pNotes,
      apopen_accnt_id=_accntid, apopen_curr_id=pCurrId,
      apopen_closedate=CASE WHEN (pAmount = 0) THEN pDocdate END
    WHERE apopen_id = _apopenid;
  ELSE
    SELECT NEXTVAL('apopen_apopen_id_seq') INTO _apopenid;
    INSERT INTO apopen
    ( apopen_id, apopen_username, apopen_journalnumber,
      apopen_vend_id, apopen_docnumber, apopen_doctype, apopen_ponumber,
      apopen_docdate, apopen_duedate, apopen_distdate, apopen_terms_id,
      apopen_amount, apopen_paid, apopen_discountable_amount, apopen_open, apopen_notes, apopen_accnt_id, apopen_curr_id,
      apopen_closedate )
    VALUES
    ( _apopenid, getEffectiveXtUser(), _journalNumber,
      pVendid, pDocNumber, 'D', pPoNumber,
      pDocDate, pDueDate, pDocDate, pTermsid,
      pAmount, 0, 0, (pAmount <> 0), pNotes, _accntid, pCurrId,
      CASE WHEN (pAmount = 0) THEN pDocDate END );
  END IF;

  _baseAmount := round(currToBase(pCurrId, pAmount, pDocDate), 2);

  -- Credit the A/P account for the full amount
  SELECT insertIntoGLSeries ( _glSequence, 'A/P', 'DM',
                              pDocNumber, _apAccntid,
                              _baseAmount,
                              pDocDate, (_vendName || ' ' || pNotes) ) INTO _test;

  -- Debit the Tax account for the tax amount
  _taxBaseValue := addTaxToGLSeries(_glSequence,
				      'A/P', 'DM', pDocNumber,
				      pCurrId, pDocDate, pDocDate,
                                      'apopentax', _apopenid,
                                      _vendName);

  UPDATE apopentax SET taxhist_journalnumber = _journalNumber
  WHERE taxhist_parent_id=_apopenid;

  -- Debit the Prepaid account for the basis amount
  -- Note, the taxBaseValue is negative so it is added
  SELECT insertIntoGLSeries ( _glSequence, 'A/P', 'DM',
                              pDocNumber, _prepaidAccntid,
                              (_baseAmount + _taxBaseValue) * -1,
                              pDocDate, (_vendName || ' ' || pNotes) ) INTO _test;

  --  Commit the GLSeries;
  SELECT postGLSeries(_glSequence, _journalNumber) INTO _test;
  IF (_test < 0) THEN
    DELETE FROM apopen WHERE (apopen_id=_apopenid);
    PERFORM deleteGLSeries(_glSequence);
    RAISE EXCEPTION 'postGLSeries commit failed with %', _test;
  END IF;

  RETURN _apopenid;

END;
$_$;


ALTER FUNCTION public.createapdebitmemo(integer, integer, integer, text, text, date, numeric, text, integer, date, integer, integer) OWNER TO admin;

--
-- TOC entry 1303 (class 1255 OID 146565854)
-- Dependencies: 4536 8
-- Name: createapdiscount(integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createapdiscount(integer, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pApopenid ALIAS FOR $1;
  pAmount ALIAS FOR $2;
  _result INTEGER;

BEGIN

  SELECT createAPDiscount(pApopenid, fetchJournalNumber('AP-MISC'), pAmount) INTO _result;

  RETURN _result;

END;
$_$;


ALTER FUNCTION public.createapdiscount(integer, numeric) OWNER TO admin;

--
-- TOC entry 1304 (class 1255 OID 146565855)
-- Dependencies: 4536 8
-- Name: createapdiscount(integer, integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createapdiscount(integer, integer, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pApopenid ALIAS FOR $1;
  pJournalNumber ALIAS FOR $2;
  pAmount ALIAS FOR $3;
  _ap RECORD;
  _sequence INTEGER;
  _apopenid INTEGER;
  _apcreditapplyid INTEGER;
  _result INTEGER;
  _crAccnt INTEGER;
  _dbAccnt INTEGER;
  _reference    TEXT;
  _discountDateAmt NUMERIC;

BEGIN

  SELECT NEXTVAL('apopen_apopen_id_seq') INTO _apopenid;

  SELECT * INTO _ap
  FROM apopen
  WHERE (apopen_id = pApopenid);
  IF (NOT FOUND) THEN
    RETURN -1;
  END IF;

  _crAccnt := findAPDiscountAccount(_ap.apopen_vend_id);
  _dbAccnt := findAPAccount(_ap.apopen_vend_id);
  _reference := ('Discount for ' || _ap.apopen_doctype || ' ' || _ap.apopen_docnumber);

  SELECT fetchGLSequence() INTO _sequence;

  _discountDateAmt = round(pAmount / _ap.apopen_curr_rate, 2);
  PERFORM insertIntoGLSeries( _sequence, 'A/P', 'DS', _ap.apopen_docnumber,
                              _dbAccnt,
                              _discountDateAmt * -1,
                              CURRENT_DATE,
                              _reference);
  PERFORM insertIntoGLSeries( _sequence, 'A/P', 'DS', _ap.apopen_docnumber,
                              _crAccnt,
                              _discountDateAmt,
                              CURRENT_DATE,
                              _reference);

  PERFORM postGLSeries(_sequence, pJournalNumber);

  INSERT INTO apopen
  ( apopen_id, apopen_username, apopen_journalnumber,
    apopen_vend_id, apopen_docnumber, apopen_doctype, apopen_ponumber,
    apopen_docdate, apopen_duedate, apopen_distdate, apopen_terms_id, apopen_curr_id,
    apopen_amount, apopen_paid, apopen_open, apopen_notes, apopen_discount, apopen_curr_rate )
  SELECT _apopenid, getEffectiveXtUser(), pJournalNumber,
         apopen_vend_id, apopen_docnumber, 'C', apopen_ponumber,
         CURRENT_DATE, CURRENT_DATE, CURRENT_DATE, -1, apopen_curr_id,
         pAmount, 0, TRUE, _reference, TRUE, apopen_curr_rate
    FROM apopen
   WHERE (apopen_id=pApopenid);

  SELECT apcreditapply_id INTO _apcreditapplyid
    FROM apcreditapply
   WHERE ( (apcreditapply_source_apopen_id=_apopenid)
     AND   (apcreditapply_target_apopen_id=pApopenid) );
  IF (FOUND) THEN
    UPDATE apcreditapply
       SET apcreditapply_amount=pAmount
     WHERE (apcreditapply_id=_apcreditapplyid);
  ELSE
    SELECT nextval('apcreditapply_apcreditapply_id_seq') INTO _apcreditapplyid;
    INSERT INTO apcreditapply
           ( apcreditapply_id, apcreditapply_source_apopen_id,
             apcreditapply_target_apopen_id, apcreditapply_amount,
             apcreditapply_curr_id )
    VALUES ( _apcreditapplyid, _apopenid, pApopenid, pAmount, _ap.apopen_curr_id );
  END IF;

  SELECT postAPCreditMemoApplication(_apopenid) INTO _result;

  IF (_result < 0) THEN
    RETURN _result;
  END IF;

  RETURN pJournalNumber;

END;
$_$;


ALTER FUNCTION public.createapdiscount(integer, integer, numeric) OWNER TO admin;

--
-- TOC entry 1306 (class 1255 OID 146565856)
-- Dependencies: 4536 8
-- Name: createarcashdeposit(integer, text, text, date, numeric, text, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createarcashdeposit(integer, text, text, date, numeric, text, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCustid ALIAS FOR $1;
  pDocNumber ALIAS FOR $2;
  pOrderNumber ALIAS FOR $3;
  pDocDate ALIAS FOR $4;
  pAmount ALIAS FOR $5;
  pNotes ALIAS FOR $6;
  pJournalNumber ALIAS FOR $7;
  pCurrId ALIAS FOR $8;
  _prepaidaccntid INTEGER;
  _deferredaccntid INTEGER;
  _glSequence INTEGER;
  _aropenid INTEGER;

BEGIN

  IF (pAmount <= 0) THEN
    RETURN 0;
  END IF;

  _prepaidaccntid := findPrepaidAccount(pCustid);
  IF (_prepaidaccntid = -1) THEN
    RAISE EXCEPTION 'There was an error creating the Customer Deposit GL Transactions. No Prepaid Account is assigned.';
  END IF;

  _deferredaccntid := findDeferredAccount(pCustid);
  IF (_deferredaccntid = -1) THEN
    RAISE EXCEPTION 'There was an error creating the Customer Deposit GL Transactions. No Deferred Account is assigned.';
  END IF;

  SELECT NEXTVAL('aropen_aropen_id_seq') INTO _aropenid;

  SELECT insertGLTransaction( pJournalNumber, 'A/R', 'CD',
                              pDocNumber, pNotes, _deferredaccntid, _prepaidaccntid,
                              _aropenid,
                              round(currToBase(pCurrId, pAmount, pDocDate), 2),
                              pDocDate) INTO _glSequence;

  INSERT INTO aropen
  ( aropen_id, aropen_username, aropen_journalnumber,
    aropen_cust_id, aropen_docnumber, aropen_doctype, aropen_ordernumber,
    aropen_docdate, aropen_duedate, aropen_distdate, aropen_terms_id, aropen_salesrep_id,
    aropen_amount, aropen_paid, aropen_commission_due, aropen_commission_paid,
    aropen_applyto, aropen_ponumber, aropen_cobmisc_id,
    aropen_open, aropen_notes, aropen_rsncode_id,
    aropen_salescat_id, aropen_accnt_id, aropen_curr_id )
  VALUES
  ( _aropenid, getEffectiveXtUser(), pJournalNumber,
    pCustid, pDocNumber, 'R', pOrderNumber,
    pDocDate, pDocDate, pDocDate, -1, NULL,
    round(pAmount, 2), 0, 0.0, FALSE,
    '', '', -1,
    TRUE, pNotes, -1,
    -1, -1, pCurrId );

  RETURN _aropenid;

END;
$_$;


ALTER FUNCTION public.createarcashdeposit(integer, text, text, date, numeric, text, integer, integer) OWNER TO admin;

--
-- TOC entry 1307 (class 1255 OID 146565857)
-- Dependencies: 907 4536 8
-- Name: createarcreditmemo(integer, integer, text, text, date, numeric, text, integer, integer, integer, date, integer, integer, numeric, integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createarcreditmemo(pid integer, pcustid integer, pdocnumber text, pordernumber text, pdocdate date, pamount numeric, pnotes text, prsncodeid integer, psalescatid integer, paccntid integer, pduedate date, ptermsid integer, psalesrepid integer, pcommissiondue numeric DEFAULT 0, pjournalnumber integer DEFAULT NULL::integer, pcurrid integer DEFAULT basecurrid(), paraccntid integer DEFAULT NULL::integer, pcoccpayid integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _accntid        INTEGER;
  _arAccntid      INTEGER;
  _aropenid       INTEGER;
  _cohistid       INTEGER;
  _custName       TEXT;
  _duedate        DATE    := COALESCE(pDueDate, pDocDate);
  _glSequence     INTEGER;
  _journalNumber  INTEGER;
  _prepaidAccntid INTEGER;
  _salescatid     INTEGER;
  _taxBaseValue   NUMERIC;
  _test           INTEGER;
  _tmp            INTEGER;

BEGIN

  _aropenid := pId;

  IF (pAmount <= 0) THEN
    RETURN 0;
  END IF;

  _arAccntid := COALESCE(pARAccntid, findARAccount(pCustid));
  _prepaidAccntid := findPrepaidAccount(pCustid);

  _accntid := pAccntid;
  _salescatid := pSalescatid;

  SELECT cust_name INTO _custName
  FROM custinfo
  WHERE (cust_id=pCustid);

  IF EXISTS(SELECT 1 FROM accnt WHERE (accnt_id=_accntid)) THEN
    _prepaidAccntid := _accntid;
  ELSE
    _accntid := -1;
  END IF;

  SELECT accnt_id INTO _tmp
    FROM salescat, accnt
   WHERE ((salescat_prepaid_accnt_id=accnt_id)
     AND  (salescat_id=_salescatid));
  IF (FOUND) THEN
    _accntid := -1;
    _prepaidAccntid := _tmp;
  ELSE
    _salescatid = -1;
  END IF;

  IF(pJournalNumber IS NULL) THEN
    SELECT fetchJournalNumber('AR-MISC') INTO _journalNumber;
  ELSE
    _journalNumber := pJournalNumber;
  END IF;

  _glSequence := fetchGLSequence();

  -- CreatelUpdate aropen for full amount
  IF (_aropenid IS NOT NULL) THEN
    UPDATE aropen SET
      aropen_username=getEffectiveXtUser(), aropen_journalnumber=_journalNumber,
      aropen_cust_id=pCustid, aropen_docnumber=pDocNumber, aropen_doctype='C',
      aropen_ordernumber=pOrderNumber,aropen_docdate=pDocDate, aropen_duedate=_duedate,
      aropen_distdate=pDocDate, aropen_terms_id=pTermsid,
      aropen_salesrep_id=pSalesrepid, aropen_amount=round(pAmount, 2), aropen_paid=0,
      aropen_commission_due=pCommissiondue, aropen_commission_paid=FALSE,
      aropen_applyto='', aropen_ponumber='', aropen_cobmisc_id=-1,
      aropen_open=TRUE, aropen_notes=pNotes, aropen_rsncode_id=pRsncodeid,
      aropen_salescat_id=_salescatid, aropen_accnt_id=_accntid, aropen_curr_id=pCurrId
    WHERE aropen_id = pId;
  ELSE
    SELECT NEXTVAL('aropen_aropen_id_seq') INTO _aropenid;
    INSERT INTO aropen
    ( aropen_id, aropen_username, aropen_journalnumber,
      aropen_cust_id, aropen_docnumber, aropen_doctype, aropen_ordernumber,
      aropen_docdate, aropen_duedate, aropen_distdate, aropen_terms_id, aropen_salesrep_id,
      aropen_amount, aropen_paid, aropen_commission_due, aropen_commission_paid,
      aropen_applyto, aropen_ponumber, aropen_cobmisc_id,
      aropen_open, aropen_notes, aropen_rsncode_id,
      aropen_salescat_id, aropen_accnt_id, aropen_curr_id )
    VALUES
    ( _aropenid, getEffectiveXtUser(), _journalNumber,
      pCustid, pDocNumber, 'C', pOrderNumber,
      pDocDate, _duedate, pDocDate, pTermsid, pSalesrepid,
      round(pAmount, 2), 0, pCommissiondue, FALSE,
      '', '', -1,
      TRUE, pNotes, pRsncodeid,
      _salescatid, _accntid, pCurrId );
  END IF;

  -- Credit the A/R account for the full amount
  SELECT insertIntoGLSeries ( _glSequence, 'A/R', 'CM',
                              pDocNumber, _arAccntid,
                              round(currToBase(pCurrId, pAmount, pDocDate), 2),
                              pDocDate, (_custName || ' ' || pNotes)) INTO _test;

  -- Debit the Tax account for the tax amount
  _taxBaseValue := addTaxToGLSeries(_glSequence,
				      'A/R', 'CM', pDocNumber,
				      pCurrId, pDocDate, pDocDate,
                                      'aropentax', _aropenid,
                                      (_custName || ' ' || pNotes));

  UPDATE aropentax SET taxhist_journalnumber = _journalNumber
  WHERE taxhist_parent_id=_aropenid;

  -- Debit the Prepaid account for the basis amount
  -- Note, _taxBaseValue is negative so it is added to pAmount
  SELECT insertIntoGLSeries ( _glSequence, 'A/R', 'CM',
                              pDocNumber, _prepaidAccntid,
                              round(currToBase(pCurrId, pAmount * -1, pDocDate) + _taxBaseValue * -1, 2),
                              pDocDate, (_custName || ' ' || pNotes)) INTO _test;

  --  Commit the GLSeries;
  SELECT postGLSeries(_glSequence, _journalNumber) INTO _test;
  IF (_test < 0) THEN
    DELETE FROM aropen WHERE (aropen_id=_aropenid);
    PERFORM deleteGLSeries(_glSequence);
    RAISE EXCEPTION 'postGLSeries commit failed with %', _test;
  END IF;

  --  Record Sales History
  INSERT INTO cohist
  ( cohist_cust_id,
   cohist_itemsite_id, cohist_shipto_id,
    cohist_misc_type, cohist_misc_descrip,
    cohist_shipdate, cohist_shipvia,
    cohist_ordernumber, cohist_ponumber, cohist_orderdate,
    cohist_doctype, cohist_invcnumber, cohist_invcdate,
    cohist_qtyshipped, cohist_unitprice, cohist_unitcost,
    cohist_salesrep_id,
    cohist_commission, cohist_commissionpaid,
    cohist_curr_id, cohist_sequence, cohist_cohead_ccpay_id)
  VALUES
  (CASE WHEN pCustid < 0 THEN NULL ELSE pCustid END,
   -1, -1,
    'M', 'A/R Misc Credit Memo',
    pDocDate, '',
    pOrderNumber, '', pDocDate,
    'C', pDocNumber, pDocDate,
    1, (pAmount + _taxBaseValue) * -1, 0, -- taxBaseValue is negative, so we add
    CASE WHEN pSalesrepid < 0 THEN NULL ELSE pSalesrepid END,
    (pCommissiondue * -1.0), FALSE,
    pCurrId, _glSequence, pCoCcpayId)
  RETURNING cohist_id INTO _cohistid;

  INSERT INTO cohisttax
  ( taxhist_parent_id, taxhist_taxtype_id, taxhist_tax_id,
    taxhist_basis, taxhist_basis_tax_id, taxhist_sequence,
    taxhist_percent, taxhist_amount, taxhist_tax,
    taxhist_docdate, taxhist_distdate, taxhist_curr_id, taxhist_curr_rate,
    taxhist_journalnumber )
  SELECT _cohistid, taxhist_taxtype_id, taxhist_tax_id,
         taxhist_basis, taxhist_basis_tax_id, taxhist_sequence,
         taxhist_percent, taxhist_amount, taxhist_tax,
         taxhist_docdate, taxhist_distdate, taxhist_curr_id, taxhist_curr_rate,
         taxhist_journalnumber
  FROM aropentax
  WHERE (taxhist_parent_id=_aropenid);

  RETURN _aropenid;

END;
$$;


ALTER FUNCTION public.createarcreditmemo(pid integer, pcustid integer, pdocnumber text, pordernumber text, pdocdate date, pamount numeric, pnotes text, prsncodeid integer, psalescatid integer, paccntid integer, pduedate date, ptermsid integer, psalesrepid integer, pcommissiondue numeric, pjournalnumber integer, pcurrid integer, paraccntid integer, pcoccpayid integer) OWNER TO admin;

--
-- TOC entry 1308 (class 1255 OID 146565859)
-- Dependencies: 4536 8
-- Name: createardebitmemo(integer, integer, integer, text, text, date, numeric, text, integer, integer, integer, date, integer, integer, numeric, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createardebitmemo(integer, integer, integer, text, text, date, numeric, text, integer, integer, integer, date, integer, integer, numeric, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pId			ALIAS FOR $1;
  pCustid		ALIAS FOR $2;
  pJournalNumber	ALIAS FOR $3;
  pDocNumber		ALIAS FOR $4;
  pOrderNumber		ALIAS FOR $5;
  pDocDate		ALIAS FOR $6;
  pAmount		ALIAS FOR $7;
  pNotes		ALIAS FOR $8;
  pRsncodeid		ALIAS FOR $9;
  pSalescatid		ALIAS FOR $10;
  pAccntid		ALIAS FOR $11;
  pDueDate		ALIAS FOR $12;
  pTermsid		ALIAS FOR $13;
  pSalesrepid		ALIAS FOR $14;
  pCommissiondue	ALIAS FOR $15;
  pCurrId		ALIAS FOR $16;
  _custName TEXT;
  _journalNumber INTEGER;
  _arAccntid INTEGER;
  _prepaidAccntid INTEGER;
  _salescatid INTEGER;
  _accntid INTEGER;
  _glSequence INTEGER;
  _aropenid INTEGER;
  _cohistid INTEGER;
  _tmp INTEGER;
  _test INTEGER;
  _taxBaseValue NUMERIC;

BEGIN
  _aropenid=pId;

  IF (pAmount <= 0) THEN
    RETURN 0;
  END IF;

  SELECT findARAccount(pCustid) INTO _arAccntid;
  SELECT findPrepaidAccount(pCustid) INTO _prepaidAccntid;

  _accntid := pAccntid;
  _salescatid := pSalescatid;

  SELECT cust_name INTO _custName
  FROM custinfo
  WHERE (cust_id=pCustid);

  PERFORM accnt_id
     FROM accnt
    WHERE (accnt_id=_accntid);
  IF (FOUND) THEN
    _prepaidAccntid := _accntid;
  ELSE
    _accntid := -1;
  END IF;

  SELECT accnt_id INTO _tmp
    FROM salescat, accnt
   WHERE ((salescat_prepaid_accnt_id=accnt_id)
     AND  (salescat_id=_salescatid));
  IF (FOUND) THEN
    _accntid := -1;
    _prepaidAccntid := _tmp;
  ELSE
    _salescatid = -1;
  END IF;

  IF (pJournalNumber IS NULL) THEN
    _journalNumber := fetchJournalNumber('AR-MISC');
  ELSE
    _journalNumber := pJournalNumber;
  END IF;

  SELECT fetchGLSequence() INTO _glSequence;

  -- CreatelUpdate aropen for full amount
  IF (_aropenid IS NOT NULL) THEN
    UPDATE aropen SET
      aropen_username=getEffectiveXtUser(), aropen_journalnumber=_journalNumber,
      aropen_cust_id=pCustid, aropen_docnumber=pDocNumber, aropen_doctype='D',
      aropen_ordernumber=pOrderNumber,aropen_docdate=pDocDate, aropen_duedate=pDueDate,
      aropen_distdate=pDocDate, aropen_terms_id=pTermsid,
      aropen_salesrep_id=pSalesrepid, aropen_amount=round(pAmount, 2), aropen_paid=0,
      aropen_commission_due=pCommissiondue, aropen_commission_paid=FALSE,
      aropen_applyto='', aropen_ponumber='', aropen_cobmisc_id=-1,
      aropen_open=TRUE, aropen_notes=pNotes, aropen_rsncode_id=pRsncodeid,
      aropen_salescat_id=_salescatid, aropen_accnt_id=_accntid, aropen_curr_id=pCurrId
    WHERE aropen_id = pId;
  ELSE
    SELECT NEXTVAL('aropen_aropen_id_seq') INTO _aropenid;
    INSERT INTO aropen
    ( aropen_id, aropen_username, aropen_journalnumber,
      aropen_cust_id, aropen_docnumber, aropen_doctype, aropen_ordernumber,
      aropen_docdate, aropen_duedate, aropen_distdate, aropen_terms_id, aropen_salesrep_id,
      aropen_amount, aropen_paid, aropen_commission_due, aropen_commission_paid,
      aropen_applyto, aropen_ponumber, aropen_cobmisc_id,
      aropen_open, aropen_notes, aropen_rsncode_id,
      aropen_salescat_id, aropen_accnt_id, aropen_curr_id )
    VALUES
    ( _aropenid, getEffectiveXtUser(), _journalNumber,
      pCustid, pDocNumber, 'D', pOrderNumber,
      pDocDate, pDueDate, pDocDate, pTermsid, pSalesrepid,
      round(pAmount, 2), 0, pCommissiondue, FALSE,
      '', '', -1,
      TRUE, pNotes, pRsncodeid,
      _salescatid, _accntid, pCurrId );
  END IF;

  -- Debit the A/R account for the full amount
  SELECT insertIntoGLSeries ( _glSequence, 'A/R', 'DM',
                              pDocNumber, _arAccntid,
                              round(currToBase(pCurrId, pAmount, pDocDate) * -1, 2),
                              pDocDate, (_custName || ' ' || pNotes)) INTO _test;

  -- Credit the Tax account for the tax amount
  _taxBaseValue := addTaxToGLSeries(_glSequence,
				      'A/R', 'DM', pDocNumber,
				      pCurrId, pDocDate, pDocDate,
                                      'aropentax', _aropenid,
                                      (_custName || ' ' || pNotes));

  UPDATE aropentax SET taxhist_journalnumber = _journalNumber
  WHERE taxhist_parent_id=_aropenid;

  -- Credit the Prepaid account for the basis amount
  SELECT insertIntoGLSeries ( _glSequence, 'A/R', 'DM',
                              pDocNumber, _prepaidAccntid,
                              round(currToBase(pCurrId, (pAmount), pDocDate), 2) - _taxBaseValue,
                              pDocDate, (_custName || ' ' || pNotes)) INTO _test;

  --  Commit the GLSeries;
  SELECT postGLSeries(_glSequence, _journalNumber) INTO _test;
  IF (_test < 0) THEN
    DELETE FROM aropen WHERE (aropen_id=_aropenid);
    PERFORM deleteGLSeries(_glSequence);
    RAISE EXCEPTION 'postGLSeries commit failed with %', _test;
  END IF;

  --  Record Sales History
  SELECT nextval('cohist_cohist_id_seq') INTO _cohistid;
  INSERT INTO cohist
  ( cohist_id, cohist_cust_id, cohist_itemsite_id, cohist_shipto_id,
    cohist_misc_type, cohist_misc_descrip,
    cohist_shipdate, cohist_shipvia,
    cohist_ordernumber, cohist_ponumber, cohist_orderdate,
    cohist_doctype, cohist_invcnumber, cohist_invcdate,
    cohist_qtyshipped, cohist_unitprice, cohist_unitcost,
    cohist_salesrep_id, cohist_commission, cohist_commissionpaid,
    cohist_curr_id, cohist_sequence )
  VALUES
  ( _cohistid, pCustid, -1, -1,
    'M', 'A/R Misc Debit Memo',
    pDocDate, '',
    '', '', pDocDate,
    'D', pDocNumber, pDocDate,
    1, (pAmount - _taxBaseValue), 0,
    pSalesrepid, pCommissiondue, FALSE,
    pCurrId, _glSequence );
  INSERT INTO cohisttax
  ( taxhist_parent_id, taxhist_taxtype_id, taxhist_tax_id,
    taxhist_basis, taxhist_basis_tax_id, taxhist_sequence,
    taxhist_percent, taxhist_amount, taxhist_tax,
    taxhist_docdate, taxhist_distdate, taxhist_curr_id, taxhist_curr_rate,
    taxhist_journalnumber )
  SELECT _cohistid, taxhist_taxtype_id, taxhist_tax_id,
         taxhist_basis, taxhist_basis_tax_id, taxhist_sequence,
         taxhist_percent, taxhist_amount, taxhist_tax,
         taxhist_docdate, taxhist_distdate, taxhist_curr_id, taxhist_curr_rate,
         taxhist_journalnumber
  FROM aropentax
  WHERE (taxhist_parent_id=_aropenid);

  RETURN _aropenid;

END;
$_$;


ALTER FUNCTION public.createardebitmemo(integer, integer, integer, text, text, date, numeric, text, integer, integer, integer, date, integer, integer, numeric, integer) OWNER TO admin;

--
-- TOC entry 1309 (class 1255 OID 146565861)
-- Dependencies: 4536 8
-- Name: createbillingheader(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createbillingheader(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSoheadid		ALIAS FOR $1;
  _cobmiscid		INTEGER;
  _cohead		cohead%ROWTYPE;
  _miscApplied          NUMERIC := 0.0;
  _freight		NUMERIC;
  _freighttypeid        INTEGER;
  _invcDate		DATE;
  _schedDate		DATE;
  _shipDate		DATE;
  _shipVia		TEXT;
  _tax			NUMERIC;

BEGIN

  --  Fetch cohead
  SELECT * INTO _cohead
  FROM cohead
  WHERE (cohead_id=pSoheadid);

  --  Check for an existing cobmisc
  SELECT cobmisc_id INTO _cobmiscid
  FROM cobmisc
  WHERE ( (NOT cobmisc_posted)
   AND (cobmisc_cohead_id=pSoheadid) );

  IF (FOUND) THEN
  --  Find a Shipping-Entered freight charge
    SELECT SUM(currToCurr(shiphead_freight_curr_id, _cohead.cohead_curr_id,
                          shiphead_freight, CURRENT_DATE)) INTO _freight
    FROM (
    SELECT shiphead_id, shiphead_freight_curr_id, shiphead_freight
    FROM shiphead JOIN shipitem ON (shipitem_shiphead_id=shiphead_id AND NOT shipitem_invoiced)
    WHERE ((shiphead_order_type='SO')
      AND  (shiphead_order_id=pSoheadid))
    GROUP BY shiphead_id, shiphead_freight_curr_id, shiphead_freight) AS data;

    IF (_freight IS NOT NULL) THEN
      UPDATE cobmisc SET cobmisc_freight = _freight
      WHERE (cobmisc_id=_cobmiscid);
    END IF;

    RETURN _cobmiscid;
  END IF;

  --  Find misc charges that have already been applied for the S/O
  SELECT COALESCE(SUM(cobmisc_misc), 0.0) INTO _miscApplied
  FROM cobmisc
  WHERE (cobmisc_cohead_id=pSoheadid);

  SELECT NEXTVAL('cobmisc_cobmisc_id_seq') INTO _cobmiscid;

  --  Check for a valid shipdate
  SELECT MIN(shiphead_shipdate) INTO _shipDate
  FROM shiphead, shipitem
  WHERE ( (shipitem_shiphead_id=shiphead_id)
   AND (NOT shipitem_invoiced)
   AND (shiphead_shipped)
   AND (shiphead_order_type='SO')
   AND (shiphead_order_id=pSoheadid) );

  --  Schema shouldn't allow, but we'll try for now
  IF (_shipDate IS NULL) THEN
    SELECT MAX(shipitem_shipdate) INTO _shipDate
    FROM shipitem, shiphead
    WHERE ( (shipitem_shiphead_id=shiphead_id)
     AND (shiphead_order_type='SO')
     AND (shiphead_order_id=pSoheadid) );

    --  How about a transaction date
    IF (_shipDate IS NULL) THEN
      SELECT COALESCE(MAX(shipitem_transdate), CURRENT_DATE) INTO _shipDate
      FROM shipitem, shiphead
      WHERE ((shipitem_shiphead_id=shiphead_id)
        AND  (shiphead_order_type='SO')
        AND  (shiphead_order_id=pSoheadid) );
    END IF;
  END IF;

  --  Get the earliest schedule date for this order.
  SELECT MIN(coitem_scheddate) INTO _schedDate
    FROM coitem
   WHERE ((coitem_status <> 'X') AND (coitem_cohead_id=pSoheadid));

  IF (_schedDate IS NULL) THEN
    _schedDate := _shipDate;
  END IF;

  --  Find a Shipping-Entered freight charge
  SELECT SUM(currToCurr(shiphead_freight_curr_id, _cohead.cohead_curr_id,
                        shiphead_freight, CURRENT_DATE)), shiphead_shipvia
         INTO _freight, _shipVia
  FROM (
  SELECT shiphead_id, shiphead_freight_curr_id, shiphead_freight, shiphead_shipvia
  FROM shiphead JOIN shipitem ON (shipitem_shiphead_id=shiphead_id AND NOT shipitem_invoiced)
  WHERE ((shiphead_order_type='SO')
    AND  (shiphead_order_id=pSoheadid))
  GROUP BY shiphead_id, shiphead_freight_curr_id, shiphead_freight, shiphead_shipvia) AS data
  GROUP BY shiphead_shipvia;

  --  Nope, use the cohead freight charge
  IF (_freight IS NULL) THEN
    _freight	   := _cohead.cohead_freight;
  END IF;

  --  Finally, look for a Shipping-Entered Ship Via
  SELECT shiphead_shipvia INTO _shipVia
  FROM shiphead, shipitem
  WHERE ( (shipitem_shiphead_id=shiphead_id)
   AND (NOT shipitem_invoiced)
   AND (shiphead_order_type='SO')
   AND (shiphead_order_id=pSoheadid) )
  LIMIT 1;
  IF (NOT FOUND) THEN
    _shipVia := _cohead.cohead_shipvia;
  END IF;

  --Determine any tax

  SELECT
  getFreightTaxTypeId() INTO _freighttypeid;
  SELECT SUM(COALESCE(taxdetail_tax, 0.00)) INTO _tax
  FROM calculatetaxdetail(_cohead.cohead_taxzone_id, _freighttypeid, _cohead.cohead_orderdate,_cohead.cohead_curr_id, _freight);

  --  Determine if we are using the _shipDate or _schedDate or current_date for the _invcDate
  IF( fetchMetricText('InvoiceDateSource')='scheddate') THEN
    _invcDate := _schedDate;
  ELSIF( fetchMetricText('InvoiceDateSource')='shipdate') THEN
    _invcDate := _shipDate;
  ELSE
    _invcDate := current_date;
  END IF;

   INSERT INTO cobmisc (
	cobmisc_id, cobmisc_cohead_id, cobmisc_shipvia, cobmisc_freight, cobmisc_misc, cobmisc_payment
	,cobmisc_notes,cobmisc_shipdate ,cobmisc_invcdate,cobmisc_posted ,cobmisc_misc_accnt_id
	,cobmisc_misc_descrip,cobmisc_closeorder,cobmisc_curr_id
	,cobmisc_taxtype_id,cobmisc_taxzone_id
	)
	SELECT
	_cobmiscid,_cohead.cohead_id,_shipVia,_freight,
        CASE WHEN (_cohead.cohead_misc - _miscApplied = 0.0) THEN 0.0
             ELSE (_cohead.cohead_misc - _miscApplied) END,0,
        _cohead.cohead_ordercomments,_shipDate,_invcDate,FALSE,_cohead.cohead_misc_accnt_id,
        _cohead.cohead_misc_descrip,NOT(cust_backorder),_cohead.cohead_curr_id,
	_cohead.cohead_taxtype_id,_cohead.cohead_taxzone_id
	FROM custinfo
	WHERE (cust_id=_cohead.cohead_cust_id);

  RETURN _cobmiscid;

END;
$_$;


ALTER FUNCTION public.createbillingheader(integer) OWNER TO admin;

--
-- TOC entry 1310 (class 1255 OID 146565863)
-- Dependencies: 4536 8
-- Name: createbomitem(integer, integer, integer, integer, character, integer, numeric, numeric, date, date, boolean, integer, boolean, text, character, integer, integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createbomitem(integer, integer, integer, integer, character, integer, numeric, numeric, date, date, boolean, integer, boolean, text, character, integer, integer, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
  pBomitemid ALIAS FOR $1;
  pParentItemid ALIAS FOR $2;
  pComponentItemid ALIAS FOR $3;
  pSeqNumber ALIAS FOR $4;
  pIssueMethod ALIAS FOR $5;
  pUomId ALIAS FOR $6;
  pQtyPer ALIAS FOR $7;
  pScrap ALIAS FOR $8;
  pEffective ALIAS FOR $9;
  pExpires ALIAS FOR $10;
  pCreateWo ALIAS FOR $11;
  pBOOItemseqid ALIAS FOR $12;
  pSchedAtWooper ALIAS FOR $13;
  pECN ALIAS FOR $14;
  pSubType ALIAS FOR $15;
  pRevisionid ALIAS FOR $16;
  pCharId ALIAS FOR $17;
  pCharVal ALIAS FOR $18;
  _bomworksetid INTEGER;
  _temp INTEGER;
  _bomitemid INTEGER;

BEGIN

  SELECT createBOMItem( pBomitemid, pParentItemid, pComponentItemid,
                        pSeqNumber, pIssueMethod,
                        pUomId, pQtyPer, pScrap,
                        pEffective, pExpires,
                        pCreateWo, pBOOItemseqid, pSchedAtWooper, pECN, pSubType, pRevisionid, pCharId, pCharVal, NULL, NULL ) INTO _bomitemid;

  RETURN _bomitemid;

END;
$_$;


ALTER FUNCTION public.createbomitem(integer, integer, integer, integer, character, integer, numeric, numeric, date, date, boolean, integer, boolean, text, character, integer, integer, text) OWNER TO admin;

--
-- TOC entry 1312 (class 1255 OID 146565865)
-- Dependencies: 4536 8
-- Name: createbomitem(integer, integer, integer, character, integer, numeric, numeric, date, date, boolean, integer, boolean, text, character, integer, integer, text, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createbomitem(integer, integer, integer, character, integer, numeric, numeric, date, date, boolean, integer, boolean, text, character, integer, integer, text, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
  pBomitemid ALIAS FOR $1;
  pParentItemid ALIAS FOR $2;
  pComponentItemid ALIAS FOR $3;
  pIssueMethod ALIAS FOR $4;
  pUomId ALIAS FOR $5;
  pQtyPer ALIAS FOR $6;
  pScrap ALIAS FOR $7;
  pEffective ALIAS FOR $8;
  pExpires ALIAS FOR $9;
  pCreateWo ALIAS FOR $10;
  pBOOItemseqid ALIAS FOR $11;
  pSchedAtWooper ALIAS FOR $12;
  pECN ALIAS FOR $13;
  pSubType ALIAS FOR $14;
  pRevisionid ALIAS FOR $15;
  pCharId ALIAS FOR $16;
  pCharVal ALIAS FOR $17;
  pNotes ALIAS FOR $18;
  pRef ALIAS FOR $19;
  _seqNumber INTEGER;
  _bomitemid INTEGER;

BEGIN

--  Grab the next Sequence Number, if any
  SELECT MAX(bomitem_seqnumber) INTO _seqNumber
  FROM bomitem(pParentItemid,pRevisionid);

  IF (_seqNumber IS NOT NULL) THEN
   _seqNumber := (_seqNumber + 10);
  ELSE
   _seqNumber := 10;
  END IF;

  SELECT createBOMItem( pBomitemid, pParentItemid, pComponentItemid,
                        _seqNumber, pIssueMethod,
                        pUomId, pQtyPer, pScrap,
                        pEffective, pExpires,
                        pCreateWo, pBOOItemseqid, pSchedAtWooper, pECN, pSubType, pRevisionid, pCharId, pCharVal, pNotes, pRef ) INTO _bomitemid;

  RETURN _bomitemid;

END;
$_$;


ALTER FUNCTION public.createbomitem(integer, integer, integer, character, integer, numeric, numeric, date, date, boolean, integer, boolean, text, character, integer, integer, text, text, text) OWNER TO admin;

--
-- TOC entry 1315 (class 1255 OID 146565867)
-- Dependencies: 4536 8
-- Name: createbomitem(integer, integer, integer, integer, character, integer, numeric, numeric, numeric, date, date, boolean, integer, boolean, text, character, integer, integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createbomitem(integer, integer, integer, integer, character, integer, numeric, numeric, numeric, date, date, boolean, integer, boolean, text, character, integer, integer, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pBomitemid ALIAS FOR $1;
  pParentItemid ALIAS FOR $2;
  pComponentItemid ALIAS FOR $3;
  pSeqNumber ALIAS FOR $4;
  pIssueMethod ALIAS FOR $5;
  pUomId ALIAS FOR $6;
  pQtyFxd ALIAS FOR $7;
  pQtyPer ALIAS FOR $8;
  pScrap ALIAS FOR $9;
  pEffective ALIAS FOR $10;
  pExpires ALIAS FOR $11;
  pCreateWo ALIAS FOR $12;
  pBOOItemseqid ALIAS FOR $13;
  pSchedAtWooper ALIAS FOR $14;
  pECN ALIAS FOR $15;
  pSubType ALIAS FOR $16;
  pRevisionid ALIAS FOR $17;
  pCharId ALIAS FOR $18;
  pCharVal ALIAS FOR $19;
  _bomworksetid INTEGER;
  _temp INTEGER;
  _bomitemid INTEGER;

BEGIN

  SELECT createBOMItem( pBomitemid, pParentItemid, pComponentItemid,
                        pSeqNumber, pIssueMethod,
                        pUomId, pQtyFxd, pQtyPer, pScrap,
                        pEffective, pExpires,
                        pCreateWo, pBOOItemseqid, pSchedAtWooper, pECN, pSubType, pRevisionid, pCharId, pCharVal, NULL, NULL ) INTO _bomitemid;

  RETURN _bomitemid;

END;
$_$;


ALTER FUNCTION public.createbomitem(integer, integer, integer, integer, character, integer, numeric, numeric, numeric, date, date, boolean, integer, boolean, text, character, integer, integer, text) OWNER TO admin;

--
-- TOC entry 1311 (class 1255 OID 146565864)
-- Dependencies: 4536 8
-- Name: createbomitem(integer, integer, integer, integer, character, integer, numeric, numeric, date, date, boolean, integer, boolean, text, character, integer, integer, text, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createbomitem(integer, integer, integer, integer, character, integer, numeric, numeric, date, date, boolean, integer, boolean, text, character, integer, integer, text, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
  pBomitemid ALIAS FOR $1;
  pParentItemid ALIAS FOR $2;
  pComponentItemid ALIAS FOR $3;
  pSeqNumber ALIAS FOR $4;
  pIssueMethod ALIAS FOR $5;
  pUomId ALIAS FOR $6;
  pQtyPer ALIAS FOR $7;
  pScrap ALIAS FOR $8;
  pEffective ALIAS FOR $9;
  pExpires ALIAS FOR $10;
  pCreateWo ALIAS FOR $11;
  pBOOItemseqid ALIAS FOR $12;
  pSchedAtWooper ALIAS FOR $13;
  pECN ALIAS FOR $14;
  pSubType ALIAS FOR $15;
  pRevisionid ALIAS FOR $16;
  pCharId ALIAS FOR $17;
  pCharVal ALIAS FOR $18;
  pNotes ALIAS FOR $19;
  pRef ALIAS FOR $20;
  _bomworksetid INTEGER;
  _temp INTEGER;

BEGIN

--  Make sure that the parent and component are not the same
  IF (pParentItemid = pComponentItemid) THEN
    RETURN -1;
  END IF;

--  Make sure that the parent is not used in the component at some level
  IF ( SELECT (item_type IN ('M', 'F'))
       FROM item
       WHERE (item_id=pComponentItemid) ) THEN
    SELECT indentedWhereUsed(pParentItemid) INTO _bomworksetid;
    SELECT bomwork_id INTO _temp
    FROM bomwork
    WHERE ( (bomwork_set_id=_bomworksetid)
     AND (bomwork_item_id=pComponentItemid) )
    LIMIT 1;
    IF (FOUND) THEN
      PERFORM deleteBOMWorkset(_bomworksetid);
      RETURN -2;
    END IF;
  END IF;

  PERFORM deleteBOMWorkset(_bomworksetid);

--  Create the BOM Item
  INSERT INTO bomitem
  ( bomitem_id, bomitem_parent_item_id, bomitem_item_id,
    bomitem_seqnumber, bomitem_issuemethod,
    bomitem_uom_id, bomitem_qtyper, bomitem_scrap,
    bomitem_effective, bomitem_expires,
    bomitem_createwo,
    bomitem_booitem_seq_id, bomitem_schedatwooper,
    bomitem_ecn, bomitem_subtype, bomitem_moddate, bomitem_rev_id,
    bomitem_char_id, bomitem_value, bomitem_notes, bomitem_ref )
  VALUES
  ( pBomitemid, pParentItemid, pComponentItemid,
    pSeqNumber, pIssueMethod,
    pUomId, pQtyPer, pScrap,
    pEffective, pExpires,
    pCreateWo,
    pBOOItemseqid, COALESCE(pSchedAtWooper, FALSE),
    pECN, pSubType, CURRENT_DATE, pRevisionid,
    pCharId,pCharVal,pNotes, pRef );

  RETURN pBomitemid;

END;
$_$;


ALTER FUNCTION public.createbomitem(integer, integer, integer, integer, character, integer, numeric, numeric, date, date, boolean, integer, boolean, text, character, integer, integer, text, text, text) OWNER TO admin;

--
-- TOC entry 1316 (class 1255 OID 146565868)
-- Dependencies: 4536 8
-- Name: createbomitem(integer, integer, integer, character, integer, numeric, numeric, numeric, date, date, boolean, integer, boolean, text, character, integer, integer, text, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createbomitem(integer, integer, integer, character, integer, numeric, numeric, numeric, date, date, boolean, integer, boolean, text, character, integer, integer, text, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pBomitemid ALIAS FOR $1;
  pParentItemid ALIAS FOR $2;
  pComponentItemid ALIAS FOR $3;
  pIssueMethod ALIAS FOR $4;
  pUomId ALIAS FOR $5;
  pQtyFxd ALIAS FOR $6;
  pQtyPer ALIAS FOR $7;
  pScrap ALIAS FOR $8;
  pEffective ALIAS FOR $9;
  pExpires ALIAS FOR $10;
  pCreateWo ALIAS FOR $11;
  pBOOItemseqid ALIAS FOR $12;
  pSchedAtWooper ALIAS FOR $13;
  pECN ALIAS FOR $14;
  pSubType ALIAS FOR $15;
  pRevisionid ALIAS FOR $16;
  pCharId ALIAS FOR $17;
  pCharVal ALIAS FOR $18;
  pNotes ALIAS FOR $19;
  pRef ALIAS FOR $20;
  _seqNumber INTEGER;
  _bomitemid INTEGER;

BEGIN

--  Grab the next Sequence Number, if any
  SELECT MAX(bomitem_seqnumber) INTO _seqNumber
  FROM bomitem(pParentItemid,pRevisionid);

  IF (_seqNumber IS NOT NULL) THEN
   _seqNumber := (_seqNumber + 10);
  ELSE
   _seqNumber := 10;
  END IF;

  SELECT createBOMItem( pBomitemid, pParentItemid, pComponentItemid,
                        _seqNumber, pIssueMethod,
                        pUomId, pQtyFxd, pQtyPer, pScrap,
                        pEffective, pExpires,
                        pCreateWo, pBOOItemseqid, pSchedAtWooper, pECN, pSubType, pRevisionid, pCharId, pCharVal, pNotes, pRef ) INTO _bomitemid;

  RETURN _bomitemid;

END;
$_$;


ALTER FUNCTION public.createbomitem(integer, integer, integer, character, integer, numeric, numeric, numeric, date, date, boolean, integer, boolean, text, character, integer, integer, text, text, text) OWNER TO admin;

--
-- TOC entry 1314 (class 1255 OID 146565866)
-- Dependencies: 4536 8
-- Name: createbomitem(integer, integer, integer, integer, character, integer, numeric, numeric, numeric, date, date, boolean, integer, boolean, text, character, integer, integer, text, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createbomitem(integer, integer, integer, integer, character, integer, numeric, numeric, numeric, date, date, boolean, integer, boolean, text, character, integer, integer, text, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pBomitemid ALIAS FOR $1;
  pParentItemid ALIAS FOR $2;
  pComponentItemid ALIAS FOR $3;
  pSeqNumber ALIAS FOR $4;
  pIssueMethod ALIAS FOR $5;
  pUomId ALIAS FOR $6;
  pQtyFxd ALIAS FOR $7;
  pQtyPer ALIAS FOR $8;
  pScrap ALIAS FOR $9;
  pEffective ALIAS FOR $10;
  pExpires ALIAS FOR $11;
  pCreateWo ALIAS FOR $12;
  pBOOItemseqid ALIAS FOR $13;
  pSchedAtWooper ALIAS FOR $14;
  pECN ALIAS FOR $15;
  pSubType ALIAS FOR $16;
  pRevisionid ALIAS FOR $17;
  pCharId ALIAS FOR $18;
  pCharVal ALIAS FOR $19;
  pNotes ALIAS FOR $20;
  pRef ALIAS FOR $21;
  _bomworksetid INTEGER;
  _temp INTEGER;

BEGIN

--  Make sure that the parent and component are not the same
  IF (pParentItemid = pComponentItemid) THEN
    RETURN -1;
  END IF;

--  Make sure that the parent is not used in the component at some level
  SELECT indentedWhereUsed(pParentItemid) INTO _bomworksetid;
  SELECT bomwork_id INTO _temp
  FROM bomwork
  WHERE ( (bomwork_set_id=_bomworksetid)
   AND (bomwork_item_id=pComponentItemid) )
  LIMIT 1;
  IF (FOUND) THEN
    PERFORM deleteBOMWorkset(_bomworksetid);
    RETURN -2;
  END IF;

  PERFORM deleteBOMWorkset(_bomworksetid);

--  Create the BOM Item
  INSERT INTO bomitem
  ( bomitem_id, bomitem_parent_item_id, bomitem_item_id,
    bomitem_seqnumber, bomitem_issuemethod,
    bomitem_uom_id, bomitem_qtyfxd, bomitem_qtyper, bomitem_scrap,
    bomitem_effective, bomitem_expires,
    bomitem_createwo,
    bomitem_booitem_seq_id, bomitem_schedatwooper,
    bomitem_ecn, bomitem_subtype, bomitem_moddate, bomitem_rev_id,
    bomitem_char_id, bomitem_value, bomitem_notes, bomitem_ref )
  VALUES
  ( pBomitemid, pParentItemid, pComponentItemid,
    pSeqNumber, pIssueMethod,
    pUomId, pQtyFxd, pQtyPer, pScrap,
    pEffective, pExpires,
    pCreateWo,
    pBOOItemseqid, COALESCE(pSchedAtWooper, FALSE),
    pECN, pSubType, CURRENT_DATE, pRevisionid,
    pCharId,pCharVal,pNotes, pRef );

  RETURN pBomitemid;

END;
$_$;


ALTER FUNCTION public.createbomitem(integer, integer, integer, integer, character, integer, numeric, numeric, numeric, date, date, boolean, integer, boolean, text, character, integer, integer, text, text, text) OWNER TO admin;

--
-- TOC entry 1317 (class 1255 OID 146565869)
-- Dependencies: 4536 8
-- Name: createcheck(integer, text, integer, date, numeric, integer, integer, integer, text, text, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createcheck(integer, text, integer, date, numeric, integer, integer, integer, text, text, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pBankaccntid		ALIAS FOR  $1;
  pRecipType		ALIAS FOR  $2;
  pRecipId		ALIAS FOR  $3;
  pCheckDate		ALIAS FOR  $4;
  pAmount		ALIAS FOR  $5;
  pCurrid		ALIAS FOR  $6;
  pExpcatid		ALIAS FOR  $7;
  _journalNumber	INTEGER := $8;
  pFor			ALIAS FOR  $9;
  pNotes		ALIAS FOR $10;
  pMisc			ALIAS FOR $11;
  _checkid INTEGER;
BEGIN

  SELECT createCheck(pBankaccntid,pRecipType,pRecipId,pCheckDate,pAmount,pCurrid,pExpcatid,_journalNumber,pFor,pNotes,pMisc,NULL) INTO _checkid;
  RETURN _checkid;

END;
$_$;


ALTER FUNCTION public.createcheck(integer, text, integer, date, numeric, integer, integer, integer, text, text, boolean) OWNER TO admin;

--
-- TOC entry 1318 (class 1255 OID 146565870)
-- Dependencies: 4536 8
-- Name: createcheck(integer, text, integer, date, numeric, integer, integer, integer, text, text, boolean, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createcheck(integer, text, integer, date, numeric, integer, integer, integer, text, text, boolean, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pBankaccntid		ALIAS FOR  $1;
  pRecipType		ALIAS FOR  $2;
  pRecipId		ALIAS FOR  $3;
  pCheckDate		ALIAS FOR  $4;
  pAmount		ALIAS FOR  $5;
  pCurrid		ALIAS FOR  $6;
  pExpcatid		ALIAS FOR  $7;
  _journalNumber	INTEGER := $8;
  pFor			ALIAS FOR  $9;
  pNotes		ALIAS FOR $10;
  pMisc			ALIAS FOR $11;
  pAropenid             ALIAS FOR $12;
  _checkid		INTEGER;
  _check_curr_rate      NUMERIC;
  _bankaccnt_currid	INTEGER;

BEGIN
  SELECT bankaccnt_curr_id,currRate(bankaccnt_curr_id,pCheckDate) INTO _bankaccnt_currid, _check_curr_rate
  FROM bankaccnt
  WHERE bankaccnt_id = pBankaccntid;
  IF (NOT FOUND) THEN
    RETURN -1;
  END IF;

  IF (pRecipType NOT IN ('C', 'T', 'V')) THEN
    RETURN -2;
  END IF;

  IF (pCheckDate IS NULL) THEN
    RETURN -3;
  END IF;

  IF (pAmount <= 0) THEN
    RETURN -4;
  END IF;

  IF (pCurrid IS NULL
      OR NOT EXISTS(SELECT * FROM curr_symbol WHERE (curr_id=pCurrid))) THEN
    RETURN -5;
  END IF;

  IF (pExpcatid IS NOT NULL
      AND NOT EXISTS(SELECT * FROM expcat WHERE (expcat_id=pExpcatid))) THEN
    RETURN -6;
  END IF;

-- Do not assign Journal Number until check is posted
--  if (_journalNumber IS NULL) THEN
--    _journalNumber := fetchJournalNumber('AP-CK');
--  END IF;

  _checkid := NEXTVAL('checkhead_checkhead_id_seq');

  INSERT INTO checkhead
  ( checkhead_id,		checkhead_recip_type,	checkhead_recip_id,
    checkhead_bankaccnt_id,	checkhead_number,
    checkhead_amount,
    checkhead_checkdate,	checkhead_misc,		checkhead_expcat_id,
    checkhead_journalnumber,	checkhead_for,		checkhead_notes,
    checkhead_curr_id )
  VALUES
  ( _checkid,			pRecipType,		pRecipId,
    pBankaccntid,		-1, --fetchNextCheckNumber(pBankaccntid),
    currToCurr(pCurrid, _bankaccnt_currid, pAmount, pCheckDate),
    pCheckDate,			COALESCE(pMisc, FALSE),	pExpcatid,
    _journalNumber,		pFor,			pNotes,
    _bankaccnt_currid );

  IF (pAropenid IS NOT NULL AND fetchmetricbool('EnableReturnAuth')) THEN
    INSERT INTO checkitem (checkitem_checkhead_id,checkitem_amount,checkitem_discount,checkitem_ponumber,
                           checkitem_aropen_id,checkitem_docdate,checkitem_curr_id,checkitem_cmnumber,
                           checkitem_ranumber, checkitem_curr_rate)
    SELECT _checkid, currToCurr(checkhead_curr_id, aropen_curr_id, pAmount, checkhead_checkdate),
      0,cmhead_custponumber,pAropenid,aropen_docdate,aropen_curr_id,cmhead_number,rahead_number,
      1 / (_check_curr_rate / aropen_curr_rate)
    FROM checkhead, aropen
      LEFT OUTER JOIN cmhead ON (aropen_docnumber=cmhead_number)
      LEFT OUTER JOIN rahead ON (cmhead_rahead_id=rahead_id)
    WHERE ((aropen_id=pAropenid)
     AND (checkhead_id=_checkid));
  ELSIF (pAropenid IS NOT NULL) THEN
    INSERT INTO checkitem (checkitem_checkhead_id,checkitem_amount,checkitem_discount,checkitem_ponumber,
                           checkitem_aropen_id,checkitem_docdate,checkitem_curr_id,checkitem_cmnumber,
                           checkitem_ranumber, checkitem_curr_rate)
    SELECT _checkid,currToCurr(checkhead_curr_id, aropen_curr_id, pAmount, checkhead_checkdate),
      0,cmhead_custponumber,pAropenid,aropen_docdate,aropen_curr_id,cmhead_number,NULL,
      1 / (_check_curr_rate / aropen_curr_rate)
    FROM checkhead, aropen
      LEFT OUTER JOIN cmhead ON (aropen_docnumber=cmhead_number)
    WHERE ((aropen_id=pAropenid)
     AND (checkhead_id=_checkid));
  END IF;


  RETURN _checkid;

END;
$_$;


ALTER FUNCTION public.createcheck(integer, text, integer, date, numeric, integer, integer, integer, text, text, boolean, integer) OWNER TO admin;

--
-- TOC entry 1320 (class 1255 OID 146565871)
-- Dependencies: 4536 8
-- Name: createchecks(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createchecks(pbankaccntid integer, pcheckdate date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _v RECORD;
  _r RECORD;
  _c RECORD;
  _checkid		INTEGER;
  _counter		INTEGER := 0;
  _check_curr_id	INTEGER;
  _check_curr_rate      NUMERIC;

BEGIN

  SELECT bankaccnt_curr_id, currRate(bankaccnt_curr_id, pCheckDate)
    INTO _check_curr_id, _check_curr_rate
    FROM bankaccnt
    WHERE ( bankaccnt_id = pBankaccntid );
  FOR _v IN SELECT DISTINCT vend_id, vend_number, vend_name
              FROM apselect
              JOIN apopen   ON (apselect_apopen_id=apopen_id)
              JOIN vendinfo ON (apopen_vend_id=vend_id)
            WHERE ((apselect_bankaccnt_id=pBankaccntid)
               AND (apselect_date <= pCheckDate)) LOOP

    -- if we owe this vendor anything (we might not) then create a check
    -- allow $0 checks
    IF ((SELECT SUM(CASE apopen_doctype WHEN 'C' THEN (apselect_amount * -1.0)
                                        ELSE apselect_amount END * _check_curr_rate / apopen_curr_rate)
	 FROM apselect JOIN apopen ON (apopen_id=apselect_apopen_id)
	 WHERE ((apopen_vend_id=_v.vend_id)
	   AND  (apselect_bankaccnt_id=pBankaccntid)) ) >= 0) THEN
      -- 0.01 is a temporary amount; we''ll update the check amount later
      _checkid := createCheck(pBankaccntid,	'V',	_v.vend_id,
			      pCheckDate,		0.01,	_check_curr_id,
			      NULL,		NULL, '',	'',	FALSE);

      FOR _r IN SELECT apopen_id, apselect_id,
		       apopen_docnumber, apopen_invcnumber, apopen_ponumber,
		       apopen_docdate, apselect_curr_id,
		       apselect_amount, apselect_discount
		FROM apselect, apopen
		WHERE ( (apselect_apopen_id=apopen_id)
		 AND (apopen_vend_id=_v.vend_id)
		 AND (apselect_bankaccnt_id=pBankaccntid) ) LOOP
	INSERT INTO checkitem
	( checkitem_checkhead_id, checkitem_apopen_id,
	  checkitem_vouchernumber, checkitem_invcnumber, checkitem_ponumber,
	  checkitem_amount, checkitem_discount, checkitem_docdate,
          checkitem_curr_id, checkitem_curr_rate )
	VALUES
	( _checkid, _r.apopen_id,
	  _r.apopen_docnumber, _r.apopen_invcnumber, _r.apopen_ponumber,
	  _r.apselect_amount, _r.apselect_discount, _r.apopen_docdate,
	  _r.apselect_curr_id,
          1 / (_check_curr_rate / currRate(_r.apselect_curr_id, pCheckdate))  );

	DELETE FROM apselect
	WHERE (apselect_id=_r.apselect_id);

      END LOOP;

      -- one check can pay for purchases on multiple dates in multiple currencies
      UPDATE checkhead
      SET checkhead_amount = (SELECT SUM(CASE WHEN (apopen_doctype='C') THEN checkitem_amount / checkitem_curr_rate * -1.0
                                              ELSE checkitem_amount / checkitem_curr_rate END)
			      FROM checkitem LEFT OUTER JOIN apopen ON (apopen_id=checkitem_apopen_id)
			      WHERE (checkitem_checkhead_id=checkhead_id))
      WHERE (checkhead_id=_checkid);

      _counter := (_counter + 1);
    END IF;

  END LOOP;

  RETURN _counter;

END;
$_$;


ALTER FUNCTION public.createchecks(pbankaccntid integer, pcheckdate date) OWNER TO admin;

--
-- TOC entry 1321 (class 1255 OID 146565872)
-- Dependencies: 4536 8
-- Name: createcounttag(integer, text, boolean, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createcounttag(integer, text, boolean, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pComments ALIAS FOR $2;
  pPriority ALIAS FOR $3;
  pFreeze ALIAS FOR $4;
BEGIN
  RETURN createCountTag(pItemsiteid, pComments, pPriority, pFreeze, NULL);
END;
$_$;


ALTER FUNCTION public.createcounttag(integer, text, boolean, boolean) OWNER TO admin;

--
-- TOC entry 1322 (class 1255 OID 146565873)
-- Dependencies: 4536 8
-- Name: createcounttag(integer, text, boolean, boolean, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createcounttag(integer, text, boolean, boolean, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$

-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pComments ALIAS FOR $2;
  pPriority ALIAS FOR $3;
  pFreeze ALIAS FOR $4;
  pLocationid ALIAS FOR $5;
  _invcntid INTEGER;
  _whs		RECORD;
  _type CHARACTER;
  _controlmethod        CHARACTER;

BEGIN

  SELECT item_type, itemsite_controlmethod INTO _type, _controlmethod
    FROM itemsite, item
   WHERE ((itemsite_item_id=item_id)
     AND  (itemsite_id=pItemsiteid));

  IF (NOT FOUND OR _type IN ('F', 'R', 'L','J') OR _controlmethod = 'N') THEN
    RETURN 0; -- We simply do not do these item types.
  END IF;

  -- Test for existing tags
   IF (pLocationid IS NULL) THEN
       SELECT invcnt_id INTO _invcntid
       FROM invcnt
       WHERE ((NOT invcnt_posted)
       AND (invcnt_location_id IS NULL)
       AND (invcnt_itemsite_id=pItemsiteid));

  ELSE

    SELECT invcnt_id INTO _invcntid
     FROM invcnt
     WHERE ((NOT invcnt_posted)
     AND (invcnt_itemsite_id=pItemsiteid)
     AND (invcnt_location_id=pLocationid));
  END IF;

  IF (NOT FOUND) THEN
    SELECT NEXTVAL('invcnt_invcnt_id_seq') INTO _invcntid;

    SELECT whsinfo.* INTO _whs
      FROM whsinfo, itemsite
     WHERE ((warehous_id=itemsite_warehous_id)
       AND  (itemsite_id=pItemsiteid));

    INSERT INTO invcnt (
      invcnt_id, invcnt_itemsite_id, invcnt_tagdate,
      invcnt_tagnumber,
      invcnt_tag_username, invcnt_posted,
      invcnt_priority, invcnt_comments, invcnt_location_id
    ) VALUES (
      _invcntid, pItemsiteid, CURRENT_TIMESTAMP,
      (_whs.warehous_counttag_prefix || _whs.warehous_counttag_number::TEXT),
      getEffectiveXtUser(), FALSE,
      pPriority, pComments, pLocationid
    );

    UPDATE whsinfo
    SET warehous_counttag_number=(warehous_counttag_number + 1)
    WHERE (warehous_id=_whs.warehous_id);

    IF (pFreeze) THEN
      UPDATE itemsite
      SET itemsite_freeze=TRUE
      WHERE (itemsite_id=pItemsiteid);
    END IF;

  END IF;

  RETURN _invcntid;
END;
$_$;


ALTER FUNCTION public.createcounttag(integer, text, boolean, boolean, integer) OWNER TO admin;

--
-- TOC entry 1323 (class 1255 OID 146565874)
-- Dependencies: 4536 8
-- Name: createcustomer(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createcustomer(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
  DECLARE
    pcrmacctId  ALIAS FOR $1;
    _custId     INTEGER := 0;
  BEGIN
    IF (pcrmacctId < 0 OR pcrmacctId IS NULL) THEN
      RETURN -1;
    END IF;

    SELECT crmacct_cust_id INTO _custId
    FROM crmacct WHERE crmacct_id = pcrmacctId;

    IF (_custId IS NOT NULL AND _custId <= 0) THEN
      RETURN -2;
    END IF;

    INSERT INTO _customer (active, customer_number, customer_name)
      SELECT crmacct_active, crmacct_number, crmacct_name
      FROM crmacct
      WHERE crmacct_id = pcrmacctId;
    _custId := CURRVAL('cust_cust_id_seq');

    UPDATE crmacct SET crmacct_prospect_id = NULL, crmacct_cust_id = _custId
    WHERE crmacct_id = pcrmacctId;

    RETURN _custId;
  END;
$_$;


ALTER FUNCTION public.createcustomer(integer) OWNER TO admin;

--
-- TOC entry 1324 (class 1255 OID 146565875)
-- Dependencies: 4536 8
-- Name: createcyclecountsbywarehouse(integer, integer, text, boolean, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createcyclecountsbywarehouse(integer, integer, text, boolean, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWarehousid ALIAS FOR $1;
  pMaxNumber ALIAS FOR $2;
  pComments ALIAS FOR $3;
  pPriority ALIAS FOR $4;
  pFreeze ALIAS FOR $5;

BEGIN
  RETURN createCycleCountsByWarehouse(pWarehousid, pMaxNumber, pComments, pPriority, pFreeze, NULL, FALSE);
END;
$_$;


ALTER FUNCTION public.createcyclecountsbywarehouse(integer, integer, text, boolean, boolean) OWNER TO admin;

--
-- TOC entry 1325 (class 1255 OID 146565876)
-- Dependencies: 4536 8
-- Name: createcyclecountsbywarehouse(integer, integer, integer, text, boolean, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createcyclecountsbywarehouse(integer, integer, integer, text, boolean, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWarehousid ALIAS FOR $1;
  pClasscodeid ALIAS FOR $2;
  pMaxNumber ALIAS FOR $3;
  pComments ALIAS FOR $4;
  pPriority ALIAS FOR $5;
  pFreeze ALIAS FOR $6;
BEGIN
  RETURN createCycleCountsByWarehouseByClassCode(pWarehousid, pClasscodeid, pMaxNumber, pComments, pPriority, pFreeze, NULL, FALSE);
END;
$_$;


ALTER FUNCTION public.createcyclecountsbywarehouse(integer, integer, integer, text, boolean, boolean) OWNER TO admin;

--
-- TOC entry 1326 (class 1255 OID 146565877)
-- Dependencies: 4536 8
-- Name: createcyclecountsbywarehouse(integer, text, integer, text, boolean, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createcyclecountsbywarehouse(integer, text, integer, text, boolean, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWarehousid ALIAS FOR $1;
  pClasscodePattern ALIAS FOR $2;
  pMaxNumber ALIAS FOR $3;
  pComments ALIAS FOR $4;
  pPriority ALIAS FOR $5;
  pFreeze ALIAS FOR $6;
BEGIN
  RETURN createCycleCountsByWarehouseByClassCode(pWarehousid, pClasscodePattern, pMaxNumber, pComments, pPriority, pFreeze, NULL, FALSE);
END;
$_$;


ALTER FUNCTION public.createcyclecountsbywarehouse(integer, text, integer, text, boolean, boolean) OWNER TO admin;

--
-- TOC entry 1327 (class 1255 OID 146565878)
-- Dependencies: 4536 8
-- Name: createcyclecountsbywarehouse(integer, integer, text, boolean, boolean, integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createcyclecountsbywarehouse(integer, integer, text, boolean, boolean, integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWarehousid ALIAS FOR $1;
  pMaxNumber ALIAS FOR $2;
  pComments ALIAS FOR $3;
  pPriority ALIAS FOR $4;
  pFreeze ALIAS FOR $5;
  pLocationid ALIAS FOR $6;
  pIgnoreZeroBalance ALIAS FOR $7;
  _itemsites RECORD;
  _returnVal	INTEGER;

BEGIN

IF (pLocationid IS NULL) THEN
  FOR _itemsites IN SELECT itemsite_id, itemsite_warehous_id, itemsite_qtyonhand
                    FROM itemsite, item
                    WHERE ( (itemsite_active)
                     AND (itemsite_item_id=item_id)
                     AND (itemsite_cyclecountfreq > 0)
                     AND ((COALESCE(itemsite_datelastcount, startOfTime()) + itemsite_cyclecountfreq) < CURRENT_DATE)
                     AND (itemsite_id NOT IN ( SELECT invcnt_itemsite_id
                                               FROM invcnt, itemsite
                                               WHERE ( (invcnt_itemsite_id=itemsite_id)
                                                AND (itemsite_warehous_id=pWarehousid)
						AND (invcnt_location_id IS NULL)
                                                AND (NOT invcnt_posted) ) ) )
                     AND ((NOT pIgnoreZeroBalance) OR (itemsite_qtyonhand <> 0))
                     AND ((pLocationid IS NULL) OR (validLocation(pLocationid, itemsite_id)))
                     AND (itemsite_warehous_id=pWarehousid) )
                    ORDER BY (COALESCE(itemsite_datelastcount, startOfTime()) + itemsite_cyclecountfreq), itemsite_abcclass, item_number

LIMIT pMaxNumber LOOP
    _returnVal := createCountTag(_itemsites.itemsite_id, pComments,
				    pPriority, pFreeze, pLocationid);
    IF (_returnVal < 0) THEN
      RETURN _returnVal;
    END IF;
  END LOOP;

ELSE
  FOR _itemsites IN SELECT itemsite_id, itemsite_warehous_id, SUM(itemloc_qty)
                    FROM itemsite, itemloc
                    WHERE ( (itemsite_active)
                     AND (itemsite_cyclecountfreq > 0)
                     AND ((COALESCE(itemsite_datelastcount, startOfTime()) + itemsite_cyclecountfreq) < CURRENT_DATE)
                     AND ((NOT pIgnoreZeroBalance) OR (itemsite_qtyonhand <> 0))
                     AND (pLocationid = itemloc_location_id)
                     AND (itemloc_itemsite_id = itemsite_id)
                     AND (itemsite_warehous_id=pWarehousid) )
		    GROUP BY itemsite_id, itemsite_warehous_id,
			     itemsite_datelastcount, itemsite_cyclecountfreq,
			     itemsite_abcclass
                    ORDER BY (COALESCE(itemsite_datelastcount, startOfTime()) + itemsite_cyclecountfreq), itemsite_abcclass

LIMIT pMaxNumber LOOP
    _returnVal := createCountTag(_itemsites.itemsite_id, pComments,
				    pPriority, pFreeze, pLocationid);
    IF (_returnVal < 0) THEN
      RETURN _returnVal;
    END IF;
  END LOOP;

END IF;

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.createcyclecountsbywarehouse(integer, integer, text, boolean, boolean, integer, boolean) OWNER TO admin;

--
-- TOC entry 1313 (class 1255 OID 146565879)
-- Dependencies: 4536 8
-- Name: createcyclecountsbywarehousebyclasscode(integer, integer, integer, text, boolean, boolean, integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createcyclecountsbywarehousebyclasscode(integer, integer, integer, text, boolean, boolean, integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWarehousid ALIAS FOR $1;
  pClasscodeid ALIAS FOR $2;
  pMaxNumber ALIAS FOR $3;
  pComments ALIAS FOR $4;
  pPriority ALIAS FOR $5;
  pFreeze ALIAS FOR $6;
  pLocationid ALIAS FOR $7;
  pIgnoreZeroBalance ALIAS FOR $8;
  _itemsites RECORD;
  _returnVal	INTEGER;

BEGIN

IF (pLocationid IS NULL) THEN
  FOR _itemsites IN SELECT itemsite_id, itemsite_warehous_id, itemsite_qtyonhand
                    FROM itemsite, item
                    WHERE ( (itemsite_active)
                     AND (itemsite_item_id=item_id)
                     AND (itemsite_cyclecountfreq > 0)
                     AND ((COALESCE(itemsite_datelastcount, startOfTime()) + itemsite_cyclecountfreq) < CURRENT_DATE)
                     AND (itemsite_id NOT IN ( SELECT invcnt_itemsite_id
                                               FROM invcnt, itemsite
                                               WHERE ( (invcnt_itemsite_id=itemsite_id)
                                                AND (itemsite_warehous_id=pWarehousid)
						AND (invcnt_location_id IS NULL)
                                                AND (NOT invcnt_posted) ) ) )
                     AND ((NOT pIgnoreZeroBalance) OR (itemsite_qtyonhand <> 0))
                     AND ((pLocationid IS NULL) OR (validLocation(pLocationid, itemsite_id)))
                     AND (itemsite_warehous_id=pWarehousid)
                     AND (item_classcode_id=pClasscodeid) )
                    ORDER BY (COALESCE(itemsite_datelastcount, startOfTime()) + itemsite_cyclecountfreq), itemsite_abcclass, item_number
                    LIMIT pMaxNumber LOOP
    _returnVal := createCountTag(_itemsites.itemsite_id, pComments,
				    pPriority, pFreeze, pLocationid);
    IF (_returnVal < 0) THEN
      RETURN _returnVal;
    END IF;
  END LOOP;

ELSE
  FOR _itemsites IN SELECT itemsite_id, itemsite_warehous_id, SUM(itemloc_qty)
                    FROM itemsite, item, itemloc
                    WHERE ( (itemsite_active)
                     AND (itemsite_item_id=item_id)
                     AND (itemsite_cyclecountfreq > 0)
                     AND ((COALESCE(itemsite_datelastcount, startOfTime()) + itemsite_cyclecountfreq) < CURRENT_DATE)
                     AND ((NOT pIgnoreZeroBalance) OR (itemsite_qtyonhand <> 0))
                     AND (pLocationid = itemloc_location_id)
                     AND (itemloc_itemsite_id = itemsite_id)
                     AND (itemsite_warehous_id=pWarehousid)
                     AND (item_classcode_id=pClasscodeid) )
		    GROUP BY itemsite_id, itemsite_warehous_id,
			     itemsite_datelastcount, itemsite_cyclecountfreq,
			     itemsite_abcclass
                    ORDER BY (COALESCE(itemsite_datelastcount, startOfTime()) + itemsite_cyclecountfreq), itemsite_abcclass
                    LIMIT pMaxNumber LOOP
    _returnVal := createCountTag(_itemsites.itemsite_id, pComments,
				    pPriority, pFreeze, pLocationid);
    IF (_returnVal < 0) THEN
      RETURN _returnVal;
    END IF;
  END LOOP;

END IF;

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.createcyclecountsbywarehousebyclasscode(integer, integer, integer, text, boolean, boolean, integer, boolean) OWNER TO admin;

--
-- TOC entry 1319 (class 1255 OID 146565880)
-- Dependencies: 4536 8
-- Name: createcyclecountsbywarehousebyclasscode(integer, text, integer, text, boolean, boolean, integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createcyclecountsbywarehousebyclasscode(integer, text, integer, text, boolean, boolean, integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWarehousid ALIAS FOR $1;
  pClasscodePattern ALIAS FOR $2;
  pMaxNumber ALIAS FOR $3;
  pComments ALIAS FOR $4;
  pPriority ALIAS FOR $5;
  pFreeze ALIAS FOR $6;
  pLocationid ALIAS FOR $7;
  pIgnoreZeroBalance ALIAS FOR $8;
  _itemsites RECORD;
  _returnVal	INTEGER;

BEGIN

IF (pLocationid IS NULL) THEN
  FOR _itemsites IN SELECT itemsite_id, itemsite_warehous_id, itemsite_qtyonhand
                    FROM itemsite, item, classcode
                    WHERE ( (itemsite_active)
                     AND (itemsite_item_id=item_id)
                     AND (item_classcode_id=classcode_id)
                     AND (itemsite_cyclecountfreq > 0)
                     AND ((COALESCE(itemsite_datelastcount, startOfTime()) + itemsite_cyclecountfreq) < CURRENT_DATE)
                     AND (itemsite_id NOT IN ( SELECT invcnt_itemsite_id
                                               FROM invcnt, itemsite
                                               WHERE ( (invcnt_itemsite_id=itemsite_id)
                                                AND (itemsite_warehous_id=pWarehousid)
						AND (invcnt_location_id IS NULL)
                                                AND (NOT invcnt_posted) ) ) )
                     AND ((NOT pIgnoreZeroBalance) OR (itemsite_qtyonhand <> 0))
                     AND ((pLocationid IS NULL) OR (validLocation(pLocationid, itemsite_id)))
                     AND (itemsite_warehous_id=pWarehousid)
                     AND (classcode_code ~ pClasscodePattern) )
                    ORDER BY (COALESCE(itemsite_datelastcount, startOfTime()) + itemsite_cyclecountfreq), itemsite_abcclass, item_number
                    LIMIT pMaxNumber LOOP
    _returnVal := createCountTag(_itemsites.itemsite_id, pComments,
				    pPriority, pFreeze, pLocationid);
    IF (_returnVal < 0) THEN
      RETURN _returnVal;
    END IF;
  END LOOP;

ELSE
  FOR _itemsites IN SELECT itemsite_id, itemsite_warehous_id, SUM(itemloc_qty)
                    FROM itemsite, item, classcode, itemloc
                    WHERE ( (itemsite_active)
                     AND (itemsite_item_id=item_id)
                     AND (item_classcode_id=classcode_id)
                     AND (itemsite_cyclecountfreq > 0)
                     AND ((COALESCE(itemsite_datelastcount, startOfTime()) + itemsite_cyclecountfreq) < CURRENT_DATE)
                     AND ((NOT pIgnoreZeroBalance) OR (itemsite_qtyonhand <> 0))
                     AND (pLocationid = itemloc_location_id)
                     AND (itemloc_itemsite_id = itemsite_id)
                     AND (itemsite_warehous_id=pWarehousid)
                     AND (classcode_code ~ pClasscodePattern) )
		    GROUP BY itemsite_id, itemsite_warehous_id,
			     itemsite_datelastcount, itemsite_cyclecountfreq,
			     itemsite_abcclass
                    ORDER BY (COALESCE(itemsite_datelastcount, startOfTime()) + itemsite_cyclecountfreq), itemsite_abcclass
                    LIMIT pMaxNumber LOOP
    _returnVal := createCountTag(_itemsites.itemsite_id, pComments,
				    pPriority, pFreeze, pLocationid);
    IF (_returnVal < 0) THEN
      RETURN _returnVal;
    END IF;
  END LOOP;

END IF;

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.createcyclecountsbywarehousebyclasscode(integer, text, integer, text, boolean, boolean, integer, boolean) OWNER TO admin;

--
-- TOC entry 1329 (class 1255 OID 146565881)
-- Dependencies: 4536 8
-- Name: createcyclecountsbywarehousebyplannercode(integer, text, integer, text, boolean, boolean, integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createcyclecountsbywarehousebyplannercode(integer, text, integer, text, boolean, boolean, integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWarehousid ALIAS FOR $1;
  pPlancodePattern ALIAS FOR $2;
  pMaxNumber ALIAS FOR $3;
  pComments ALIAS FOR $4;
  pPriority ALIAS FOR $5;
  pFreeze ALIAS FOR $6;
  pLocationid ALIAS FOR $7;
  pIgnoreZeroBalance ALIAS FOR $8;
  _itemsites RECORD;
  _returnVal	INTEGER;

BEGIN

IF (pLocationid IS NULL) THEN
  FOR _itemsites IN SELECT itemsite_id, itemsite_warehous_id, itemsite_qtyonhand
                    FROM itemsite, item, plancode
                    WHERE ( (itemsite_active)
                     AND (itemsite_item_id=item_id)
                     AND (itemsite_plancode_id=plancode_id)
                     AND (itemsite_cyclecountfreq > 0)
                     AND ((COALESCE(itemsite_datelastcount, startOfTime()) + itemsite_cyclecountfreq) < CURRENT_DATE)
                     AND (itemsite_id NOT IN ( SELECT invcnt_itemsite_id
                                               FROM invcnt, itemsite
                                               WHERE ( (invcnt_itemsite_id=itemsite_id)
                                                AND (itemsite_warehous_id=pWarehousid)
						AND (invcnt_location_id IS NULL)
                                                AND (NOT invcnt_posted) ) ) )
                     AND ((NOT pIgnoreZeroBalance) OR (itemsite_qtyonhand <> 0))
                     AND ((pLocationid IS NULL) OR (validLocation(pLocationid, itemsite_id)))
                     AND (itemsite_warehous_id=pWarehousid)
                     AND (plancode_code ~ pPlancodePattern) )
                    ORDER BY (COALESCE(itemsite_datelastcount, startOfTime()) + itemsite_cyclecountfreq), itemsite_abcclass, item_number
                    LIMIT pMaxNumber LOOP
    _returnVal := createCountTag(_itemsites.itemsite_id, pComments,
				    pPriority, pFreeze, pLocationid);
    IF (_returnVal < 0) THEN
      RETURN _returnVal;
    END IF;
  END LOOP;

ELSE
  FOR _itemsites IN SELECT itemsite_id, itemsite_warehous_id, SUM(itemloc_qty)
                    FROM itemsite, plancode, itemloc
                    WHERE ( (itemsite_active)
                     AND (itemsite_plancode_id=plancode_id)
                     AND (itemsite_cyclecountfreq > 0)
                     AND ((COALESCE(itemsite_datelastcount, startOfTime()) + itemsite_cyclecountfreq) < CURRENT_DATE)
                     AND ((NOT pIgnoreZeroBalance) OR (itemsite_qtyonhand <> 0))
                     AND (pLocationid = itemloc_location_id)
                     AND (itemloc_itemsite_id = itemsite_id)
                     AND (itemsite_warehous_id=pWarehousid)
                     AND (plancode_code ~ pPlancodePattern) )
		    GROUP BY itemsite_id, itemsite_warehous_id,
			     itemsite_datelastcount, itemsite_cyclecountfreq,
			     itemsite_abcclass
                    ORDER BY (COALESCE(itemsite_datelastcount, startOfTime()) + itemsite_cyclecountfreq), itemsite_abcclass
                    LIMIT pMaxNumber LOOP
    _returnVal := createCountTag(_itemsites.itemsite_id, pComments,
				    pPriority, pFreeze, pLocationid);
    IF (_returnVal < 0) THEN
      RETURN _returnVal;
    END IF;
  END LOOP;

END IF;

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.createcyclecountsbywarehousebyplannercode(integer, text, integer, text, boolean, boolean, integer, boolean) OWNER TO admin;

--
-- TOC entry 1330 (class 1255 OID 146565882)
-- Dependencies: 4536 8
-- Name: createcyclecountsbywarehousebyplannercode(integer, integer, integer, text, boolean, boolean, integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createcyclecountsbywarehousebyplannercode(integer, integer, integer, text, boolean, boolean, integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWarehousid ALIAS FOR $1;
  pPlancodeid ALIAS FOR $2;
  pMaxNumber ALIAS FOR $3;
  pComments ALIAS FOR $4;
  pPriority ALIAS FOR $5;
  pFreeze ALIAS FOR $6;
  pLocationid ALIAS FOR $7;
  pIgnoreZeroBalance ALIAS FOR $8;
  _itemsites RECORD;
  _returnVal	INTEGER;

BEGIN

IF (pLocationid IS NULL) THEN
  FOR _itemsites IN SELECT itemsite_id, itemsite_warehous_id, itemsite_qtyonhand
                    FROM itemsite, item
                    WHERE ( (itemsite_active)
                     AND (itemsite_item_id=item_id)
                     AND (itemsite_cyclecountfreq > 0)
                     AND ((COALESCE(itemsite_datelastcount, startOfTime()) + itemsite_cyclecountfreq) < CURRENT_DATE)
                     AND (itemsite_id NOT IN ( SELECT invcnt_itemsite_id
                                               FROM invcnt, itemsite
                                               WHERE ( (invcnt_itemsite_id=itemsite_id)
                                                AND (itemsite_warehous_id=pWarehousid)
						AND (invcnt_location_id IS NULL)
                                                AND (NOT invcnt_posted) ) ) )
                     AND ((NOT pIgnoreZeroBalance) OR (itemsite_qtyonhand <> 0))
                     AND ((pLocationid IS NULL) OR (validLocation(pLocationid, itemsite_id)))
                     AND (itemsite_warehous_id=pWarehousid)
                     AND (itemsite_plancode_id=pPlancodeid) )
                    ORDER BY (COALESCE(itemsite_datelastcount, startOfTime()) + itemsite_cyclecountfreq), itemsite_abcclass, item_number
                    LIMIT pMaxNumber LOOP
    _returnVal := createCountTag(_itemsites.itemsite_id, pComments,
				    pPriority, pFreeze, pLocationid);
    IF (_returnVal < 0) THEN
      RETURN _returnVal;
    END IF;
  END LOOP;

ELSE
  FOR _itemsites IN SELECT itemsite_id, itemsite_warehous_id, SUM(itemloc_qty)
                    FROM itemsite, itemloc
                    WHERE ( (itemsite_active)
                     AND (itemsite_cyclecountfreq > 0)
                     AND ((COALESCE(itemsite_datelastcount, startOfTime()) + itemsite_cyclecountfreq) < CURRENT_DATE)
                     AND ((NOT pIgnoreZeroBalance) OR (itemsite_qtyonhand <> 0))
                     AND (itemloc_itemsite_id = itemsite_id)
                     AND (itemsite_warehous_id=pWarehousid)
                     AND (pLocationid = itemloc_location_id)
                     AND (itemsite_plancode_id=pPlancodeid) )
		    GROUP BY itemsite_id, itemsite_warehous_id,
			     itemsite_datelastcount, itemsite_cyclecountfreq,
			     itemsite_abcclass
                    ORDER BY (COALESCE(itemsite_datelastcount, startOfTime()) + itemsite_cyclecountfreq), itemsite_abcclass
                    LIMIT pMaxNumber LOOP
    _returnVal := createCountTag(_itemsites.itemsite_id, pComments,
				    pPriority, pFreeze, pLocationid);
    IF (_returnVal < 0) THEN
      RETURN _returnVal;
    END IF;
  END LOOP;

END IF;

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.createcyclecountsbywarehousebyplannercode(integer, integer, integer, text, boolean, boolean, integer, boolean) OWNER TO admin;

--
-- TOC entry 1331 (class 1255 OID 146565883)
-- Dependencies: 4536 8
-- Name: createfile(text, text, bytea); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createfile(text, text, bytea) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  pTitle ALIAS FOR $1;
  pDescription ALIAS FOR $2;
  pStream ALIAS FOR $3;
  _id integer;
begin
  _id := nextval('file_file_id_seq');
  insert into file (file_id, file_title, file_descrip, file_stream) values (_id, pTitle, pDescription, pStream);
  return _id;
end;
$_$;


ALTER FUNCTION public.createfile(text, text, bytea) OWNER TO admin;

--
-- TOC entry 1332 (class 1255 OID 146565884)
-- Dependencies: 4536 8
-- Name: createinvoice(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createinvoice(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCobmiscid ALIAS FOR $1;
  _invcheadid INTEGER;
  _invcitemid INTEGER;
  _qtyToInvoice	NUMERIC;
  _r		RECORD;
  _s		RECORD;
  _lastlinenumber INTEGER := 1;

BEGIN

  IF ( ( SELECT cobmisc_posted
         FROM cobmisc
         WHERE (cobmisc_id=pCobmiscid) ) ) THEN
    RETURN -1;
  END IF;

  SELECT NEXTVAL('invchead_invchead_id_seq') INTO _invcheadid;

--  Give this selection a number if it has not been assigned one
  UPDATE cobmisc
  SET cobmisc_invcnumber=fetchInvcNumber()
  WHERE ( (cobmisc_invcnumber IS NULL)
   AND (cobmisc_id=pCobmiscid) );

--  Create the Invoice header
  INSERT INTO invchead
  (
	invchead_id,invchead_cust_id,invchead_shipto_id,invchead_ordernumber,invchead_orderdate,
	invchead_posted,invchead_printed,invchead_invcnumber,invchead_invcdate,invchead_shipdate,
	invchead_ponumber,invchead_shipvia,invchead_fob,invchead_billto_name,invchead_billto_address1,
	invchead_billto_address2,invchead_billto_address3,invchead_billto_city,invchead_billto_state,invchead_billto_zipcode,
	invchead_billto_phone,invchead_billto_country,invchead_shipto_name,invchead_shipto_address1,invchead_shipto_address2,
	invchead_shipto_address3,invchead_shipto_city,invchead_shipto_state,invchead_shipto_zipcode,invchead_shipto_phone,
	invchead_shipto_country,invchead_salesrep_id,invchead_commission,invchead_terms_id,invchead_freight,
	invchead_misc_amount,invchead_misc_descrip,invchead_misc_accnt_id,invchead_payment,
	invchead_paymentref,invchead_notes,invchead_prj_id,invchead_curr_id,
	invchead_taxzone_id, invchead_shipchrg_id,
        invchead_saletype_id, invchead_shipzone_id
   )
  SELECT
	_invcheadid,cohead_cust_id,cohead_shipto_id,cohead_number,cohead_orderdate,
	FALSE,FALSE,cobmisc_invcnumber,cobmisc_invcdate,cobmisc_shipdate,
	cohead_custponumber,cobmisc_shipvia,cohead_fob,cohead_billtoname,cohead_billtoaddress1,
	cohead_billtoaddress2,cohead_billtoaddress3,cohead_billtocity,cohead_billtostate,cohead_billtozipcode,
	cntct_phone AS cust_phone,cohead_billtocountry,cohead_shiptoname,cohead_shiptoaddress1,cohead_shiptoaddress2,
	cohead_shiptoaddress3,cohead_shiptocity,cohead_shiptostate,cohead_shiptozipcode,cohead_shipto_cntct_phone,
	cohead_shiptocountry,cohead_salesrep_id,COALESCE(cohead_commission,0),cohead_terms_id,cobmisc_freight,
	COALESCE(cobmisc_misc, 0.00),cobmisc_misc_descrip,cobmisc_misc_accnt_id,cobmisc_payment,
	cobmisc_paymentref,cobmisc_notes,cohead_prj_id,cobmisc_curr_id,
	cobmisc_taxzone_id, cohead_shipchrg_id,
        cohead_saletype_id, cohead_shipzone_id
    FROM cobmisc, cohead, custinfo
    LEFT OUTER JOIN cntct ON (cust_cntct_id=cntct_id)
  WHERE ( (cobmisc_cohead_id=cohead_id)
   AND (cohead_cust_id=cust_id)
   AND (cobmisc_id=pCobmiscid) );

	INSERT INTO invcheadtax(taxhist_parent_id, taxhist_taxtype_id, taxhist_tax_id, taxhist_basis,
			taxhist_basis_tax_id, taxhist_sequence, taxhist_percent, taxhist_amount, taxhist_tax, taxhist_docdate)
        SELECT _invcheadid,taxhist_taxtype_id, taxhist_tax_id, taxhist_basis,
			taxhist_basis_tax_id, taxhist_sequence, taxhist_percent, taxhist_amount, taxhist_tax, taxhist_docdate
        FROM cobmisctax
	WHERE taxhist_parent_id = pCobmiscid
	AND taxhist_taxtype_id = getadjustmenttaxtypeid();

--  Create the Invoice Characteristic Assignments
    INSERT INTO charass
          (charass_target_type, charass_target_id, charass_char_id, charass_value, charass_default, charass_price)
    SELECT 'INV', _invcheadid, charass_char_id, charass_value, charass_default, charass_price
      FROM cobmisc JOIN cohead ON (cohead_id=cobmisc_cohead_id)
                   JOIN charass ON ((charass_target_type='SO') AND (charass_target_id=cohead_id))
                   JOIN char ON (char_id=charass_char_id AND char_invoices)
    WHERE (cobmisc_id=pCobmiscid);

--  Create the Invoice items
  FOR _r IN SELECT coitem_id, coitem_linenumber, coitem_subnumber, coitem_custpn,
                   coitem_qtyord, cobill_qty,
                   coitem_qty_uom_id, coitem_qty_invuomratio,
                   coitem_custprice, coitem_price,
                   coitem_price_uom_id, coitem_price_invuomratio,
                   coitem_memo, coitem_rev_accnt_id,
                   itemsite_item_id, itemsite_warehous_id,
                   cobill_taxtype_id,
                   formatSoItemNumber(coitem_id) AS ordnumber
            FROM coitem, cobill, itemsite
            WHERE ( (cobill_coitem_id=coitem_id)
             AND (coitem_itemsite_id=itemsite_id)
             AND (cobill_cobmisc_id=pCobmiscid) )
            ORDER BY coitem_linenumber, coitem_subnumber LOOP

    SELECT NEXTVAL('invcitem_invcitem_id_seq') INTO _invcitemid;
    INSERT INTO invcitem
    ( invcitem_id, invcitem_invchead_id,
      invcitem_linenumber, invcitem_item_id, invcitem_warehous_id,
      invcitem_custpn, invcitem_number, invcitem_descrip,
      invcitem_ordered, invcitem_billed,
      invcitem_qty_uom_id, invcitem_qty_invuomratio,
      invcitem_custprice, invcitem_price,
      invcitem_price_uom_id, invcitem_price_invuomratio,
      invcitem_notes, invcitem_taxtype_id,
      invcitem_coitem_id, invcitem_rev_accnt_id )
    VALUES
    ( _invcitemid, _invcheadid,
      _lastlinenumber,
      _r.itemsite_item_id, _r.itemsite_warehous_id,
      _r.coitem_custpn, '', '',
      _r.coitem_qtyord, _r.cobill_qty,
      _r.coitem_qty_uom_id, _r.coitem_qty_invuomratio,
      _r.coitem_custprice, _r.coitem_price,
      _r.coitem_price_uom_id, _r.coitem_price_invuomratio,
      _r.coitem_memo, _r.cobill_taxtype_id,
      _r.coitem_id, _r.coitem_rev_accnt_id );

--  Find and mark any Lot/Serial invdetail records associated with this bill
    UPDATE invdetail SET invdetail_invcitem_id = _invcitemid
     WHERE (invdetail_id IN (SELECT invdetail_id
                               FROM invhist JOIN invdetail ON (invdetail_invhist_id=invhist_id)
                              WHERE ( (invhist_ordnumber = _r.ordnumber)
                                AND   (invhist_ordtype = 'SO')
                                AND   (invhist_transtype = 'SH')
                                AND   (invdetail_invcitem_id IS NULL) ) ));

--  Mark any shipped, uninvoiced shipitems for the current coitem as invoiced
    _qtyToInvoice :=  _r.cobill_qty;
    FOR _s IN SELECT shipitem.*, shipitem_qty = _r.cobill_qty AS matched
	      FROM shipitem, shiphead
	      WHERE ((shipitem_shiphead_id=shiphead_id)
	        AND  (shipitem_orderitem_id=_r.coitem_id)
	        AND  (shiphead_shipped)
		AND  (shiphead_order_type='SO')
	        AND  (NOT shipitem_invoiced))
	      ORDER BY matched DESC, shipitem_qty DESC FOR UPDATE LOOP
      IF (_qtyToInvoice >= _s.shipitem_qty) THEN
	UPDATE shipitem
	SET shipitem_invoiced=TRUE, shipitem_invcitem_id=_invcitemid
	WHERE (shipitem_id=_s.shipitem_id);
	_qtyToInvoice := _qtyToInvoice - _s.shipitem_qty;
      END IF;
      IF (_qtyToInvoice <= 0) THEN
	EXIT;
      END IF;
    END LOOP;

    UPDATE cobill SET cobill_invcnum=cobmisc_invcnumber,
		      cobill_invcitem_id=invcitem_id
    FROM invcitem, coitem, cobmisc
    WHERE ((invcitem_linenumber=_lastlinenumber)
      AND  (coitem_id=cobill_coitem_id)
      AND  (cobmisc_id=cobill_cobmisc_id)
      AND  (cobill_cobmisc_id=pCobmiscid)
      AND  (invcitem_invchead_id=_invcheadid));

    _lastlinenumber := _lastlinenumber + 1;

  END LOOP;

--  Close all requested coitem's
  IF ( ( SELECT cobmisc_closeorder
         FROM cobmisc
         WHERE (cobmisc_id=pCobmiscid) ) ) THEN
    UPDATE coitem
    SET coitem_status='C'
    FROM cobmisc
    WHERE ( (coitem_status NOT IN ('C', 'X'))
     AND (coitem_cohead_id=cobmisc_cohead_id)
     AND (cobmisc_id=pCobmiscid) );
  ELSE
    UPDATE coitem
    SET coitem_status='C'
    FROM cobill
    WHERE ( (cobill_coitem_id=coitem_id)
     AND (coitem_status <> 'X')
     AND (cobill_toclose)
     AND (cobill_cobmisc_id=pCobmiscid) );
  END IF;

--  Mark the cobmisc as posted
  UPDATE cobmisc
  SET cobmisc_posted=TRUE, cobmisc_invchead_id=_invcheadid
  WHERE (cobmisc_id=pCobmiscid);

--  All done
  RETURN _invcheadid;

END;
$_$;


ALTER FUNCTION public.createinvoice(integer) OWNER TO admin;

--
-- TOC entry 1333 (class 1255 OID 146565886)
-- Dependencies: 4536 8
-- Name: createinvoiceconsolidated(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createinvoiceconsolidated(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCustid ALIAS FOR $1;
  _invcheadid INTEGER;
  _invcitemid INTEGER;
  _qtyToInvoice	NUMERIC;
  _r		RECORD;
  _s		RECORD;
  _c		RECORD;
  _i		RECORD;
  _count      INTEGER;
  _invcnumber INTEGER;
  _lastlinenumber INTEGER;

BEGIN
  _count := 0;

  FOR _c IN SELECT min(cobmisc_id) AS cobmisc_id, count(*) AS cnt,
-- there are the key values for consolidation
                   cohead_billtoname, cohead_billtoaddress1,
                   cohead_billtoaddress2, cohead_billtoaddress3,
                   cohead_billtocity, cohead_billtostate,
                   cohead_billtozipcode, cntct_phone AS cust_phone,
                   cohead_billtocountry,
                   cohead_salesrep_id, cohead_commission,
                   cohead_terms_id,
                   cobmisc_misc_accnt_id,
                   cohead_prj_id, cobmisc_curr_id,
                   cobmisc_taxzone_id,
                   cohead_shipchrg_id,
                   cohead_saletype_id,
                   cohead_shipzone_id,

		-- the following are consolidated values to use in creating the header
                   MIN(cohead_number) AS cohead_number,
                   MIN(cohead_orderdate) AS cohead_orderdate,
                   MIN(cobmisc_invcdate) AS cobmisc_invcdate,
                   MIN(cobmisc_shipdate) AS cobmisc_shipdate,
                   SUM(cobmisc_freight) AS cobmisc_freight,
                   SUM(cobmisc_misc) AS cobmisc_misc,
                   SUM(cobmisc_payment) AS cobmisc_payment

              FROM cobmisc
              JOIN cohead   ON (cobmisc_cohead_id=cohead_id)
              JOIN custinfo ON (cohead_cust_id=cust_id)
              LEFT OUTER JOIN cntct ON (cust_cntct_id=cntct_id)
             WHERE(NOT cobmisc_posted
               AND (cohead_cust_id=pCustid)
               )
          GROUP BY cohead_billtoname, cohead_billtoaddress1,
                   cohead_billtoaddress2, cohead_billtoaddress3,
                   cohead_billtocity, cohead_billtostate,
                   cohead_billtozipcode, cust_phone,
                   cohead_billtocountry,
                   cohead_salesrep_id, cohead_commission,
                   cohead_terms_id,
                   cobmisc_misc_accnt_id,
                   cohead_prj_id, cobmisc_curr_id,
                   cobmisc_taxzone_id,
                   cohead_shipchrg_id,
                   cohead_saletype_id,
                   cohead_shipzone_id
		LOOP

    IF(_c.cnt = 1) THEN
      PERFORM createInvoice(_c.cobmisc_id);
      _count := (_count + 1);
    ELSE
      SELECT NEXTVAL('invchead_invchead_id_seq'), fetchInvcNumber() INTO _invcheadid, _invcnumber;

  --  Create the Invoice header
      INSERT INTO invchead
      ( invchead_id, invchead_cust_id, invchead_shipto_id,
        invchead_ordernumber, invchead_orderdate,
        invchead_posted, invchead_printed,
        invchead_invcnumber, invchead_invcdate, invchead_shipdate,
        invchead_ponumber, invchead_shipvia, invchead_fob,
        invchead_billto_name, invchead_billto_address1,
        invchead_billto_address2, invchead_billto_address3,
        invchead_billto_city, invchead_billto_state,
        invchead_billto_zipcode, invchead_billto_phone,
        invchead_billto_country,
        invchead_shipto_name, invchead_shipto_address1,
        invchead_shipto_address2, invchead_shipto_address3,
        invchead_shipto_city, invchead_shipto_state,
        invchead_shipto_zipcode, invchead_shipto_phone,
        invchead_shipto_country,
        invchead_salesrep_id, invchead_commission,
        invchead_terms_id,
        invchead_freight,
        invchead_misc_amount, invchead_misc_descrip, invchead_misc_accnt_id,
        invchead_payment, invchead_paymentref,
        invchead_notes, invchead_prj_id, invchead_curr_id,
        invchead_taxzone_id,
        invchead_shipchrg_id,
        invchead_saletype_id, invchead_shipzone_id )
      VALUES(_invcheadid,
             pCustid, -1,
             NULL, _c.cohead_orderdate,
             FALSE, FALSE,
             _invcnumber, _c.cobmisc_invcdate, _c.cobmisc_shipdate,
             'MULTIPLE', '', '',
             _c.cohead_billtoname, _c.cohead_billtoaddress1,
             _c.cohead_billtoaddress2, _c.cohead_billtoaddress3,
             _c.cohead_billtocity, _c.cohead_billtostate,
             _c.cohead_billtozipcode, _c.cust_phone,
             _c.cohead_billtocountry,
             '', '', '', '', '', '', '', '', '',
             _c.cohead_salesrep_id, COALESCE(_c.cohead_commission, 0),
             _c.cohead_terms_id,
             _c.cobmisc_freight,
             _c.cobmisc_misc, CASE WHEN(_c.cobmisc_misc <> 0) THEN 'Multiple' ELSE '' END,
             _c.cobmisc_misc_accnt_id,
             _c.cobmisc_payment, '',
             'Multiple Sales Order # Invoice', _c.cohead_prj_id, _c.cobmisc_curr_id,
             _c.cobmisc_taxzone_id,
             _c.cohead_shipchrg_id,
             _c.cohead_saletype_id, _c.cohead_shipzone_id
             );

    _lastlinenumber := 1;
    FOR _i IN SELECT cobmisc_id
                FROM cobmisc
                JOIN cohead   ON (cobmisc_cohead_id=cohead_id)
                JOIN custinfo ON (cohead_cust_id=cust_id)
                LEFT OUTER JOIN cntct ON (cust_cntct_id=cntct_id)
               WHERE(NOT cobmisc_posted
                 AND (cohead_cust_id=pCustid)
                 AND (COALESCE(cohead_billtoname,'')         = COALESCE(_c.cohead_billtoname,''))
                 AND (COALESCE(cohead_billtoaddress1,'')     = COALESCE(_c.cohead_billtoaddress1,''))
                 AND (COALESCE(cohead_billtoaddress2,'')     = COALESCE(_c.cohead_billtoaddress2,''))
                 AND (COALESCE(cohead_billtoaddress3,'')     = COALESCE(_c.cohead_billtoaddress3,''))
                 AND (COALESCE(cohead_billtocity,'')         = COALESCE(_c.cohead_billtocity,''))
                 AND (COALESCE(cohead_billtostate,'')        = COALESCE(_c.cohead_billtostate,''))
                 AND (COALESCE(cohead_billtozipcode,'')      = COALESCE(_c.cohead_billtozipcode,''))
                 AND (COALESCE(cntct_phone,'')               = COALESCE(_c.cust_phone,''))
                 AND (COALESCE(cohead_billtocountry,'')      = COALESCE(_c.cohead_billtocountry,''))
                 AND (COALESCE(cohead_salesrep_id, 0)        = COALESCE(_c.cohead_salesrep_id, 0))
                 AND (COALESCE(cohead_commission, 0)         = COALESCE(_c.cohead_commission, 0))
                 AND (COALESCE(cohead_terms_id, 0)           = COALESCE(_c.cohead_terms_id, 0))
                 AND (COALESCE(cobmisc_misc_accnt_id, 0)     = COALESCE(_c.cobmisc_misc_accnt_id, 0))
                 AND (COALESCE(cohead_prj_id, 0)             = COALESCE(_c.cohead_prj_id, 0))
                 AND (COALESCE(cobmisc_curr_id, 0)           = COALESCE(_c.cobmisc_curr_id, 0))
                 AND (COALESCE(cobmisc_taxzone_id, 0)        = COALESCE(_c.cobmisc_taxzone_id, 0))
                 AND (COALESCE(cohead_saletype_id, 0)        = COALESCE(_c.cohead_saletype_id, 0))
                 AND (COALESCE(cohead_shipzone_id, 0)        = COALESCE(_c.cohead_shipzone_id, 0))
                ) LOOP

    --  Create the Invoice Head tax
        INSERT INTO invcheadtax(taxhist_parent_id, taxhist_taxtype_id, taxhist_tax_id, taxhist_basis,
                                taxhist_basis_tax_id, taxhist_sequence, taxhist_percent, taxhist_amount, taxhist_tax, taxhist_docdate)
        SELECT _invcheadid,taxhist_taxtype_id, taxhist_tax_id, taxhist_basis,
               taxhist_basis_tax_id, taxhist_sequence, taxhist_percent, taxhist_amount, taxhist_tax, taxhist_docdate
        FROM cobmisctax
        WHERE taxhist_parent_id = _i.cobmisc_id
          AND taxhist_taxtype_id = getadjustmenttaxtypeid();

    --  Give this selection a number if it has not been assigned one
        UPDATE cobmisc
           SET cobmisc_invcnumber=_invcnumber
         WHERE(cobmisc_id=_i.cobmisc_id);

    --  Create the Invoice items
        FOR _r IN SELECT coitem_id, coitem_linenumber, coitem_subnumber, coitem_custpn,
                         coitem_qtyord, cobill_qty,
                         coitem_qty_uom_id, coitem_qty_invuomratio,
                         coitem_custprice, coitem_price,
                         coitem_price_uom_id, coitem_price_invuomratio,
                         coitem_memo,
                         itemsite_item_id, itemsite_warehous_id,
                         cobill_taxtype_id
                    FROM cohead, coitem, cobill, itemsite
                   WHERE((cobill_coitem_id=coitem_id)
                     AND (cohead_id=coitem_cohead_id)
                     AND (coitem_itemsite_id=itemsite_id)
                     AND (cobill_cobmisc_id=_i.cobmisc_id) )
                   ORDER BY cohead_number, coitem_linenumber, coitem_subnumber LOOP

          SELECT NEXTVAL('invcitem_invcitem_id_seq') INTO _invcitemid;
          INSERT INTO invcitem
          ( invcitem_id, invcitem_invchead_id,
            invcitem_linenumber, invcitem_item_id, invcitem_warehous_id,
            invcitem_custpn, invcitem_number, invcitem_descrip,
            invcitem_ordered, invcitem_billed,
            invcitem_qty_uom_id, invcitem_qty_invuomratio,
            invcitem_custprice, invcitem_price,
            invcitem_price_uom_id, invcitem_price_invuomratio,
            invcitem_notes,
            invcitem_taxtype_id,
            invcitem_coitem_id )
          VALUES
          ( _invcitemid, _invcheadid,
            _lastlinenumber,
            _r.itemsite_item_id, _r.itemsite_warehous_id,
            _r.coitem_custpn, '', '',
            _r.coitem_qtyord, _r.cobill_qty,
            _r.coitem_qty_uom_id, _r.coitem_qty_invuomratio,
            _r.coitem_custprice, _r.coitem_price,
            _r.coitem_price_uom_id, _r.coitem_price_invuomratio,
            _r.coitem_memo,
            _r.cobill_taxtype_id,
            _r.coitem_id );

      --  Find and mark any Lot/Serial invdetail records associated with this bill
          UPDATE invdetail SET invdetail_invcitem_id = _invcitemid
           WHERE (invdetail_id IN (SELECT invdetail_id
                                     FROM coitem, cohead, invhist, invdetail
                                    WHERE ((coitem_cohead_id=cohead_id)
                                      AND  (invdetail_invhist_id=invhist_id)
                                      AND  (invhist_ordnumber = text(cohead_number||'-'||formatSoLineNumber(coitem_id)))
                                      AND  (invdetail_invcitem_id IS NULL)
                                      AND  (coitem_id=_r.coitem_id)) ) );

      --  Mark any shipped, uninvoiced shipitems for the current coitem as invoiced
          _qtyToInvoice :=  _r.cobill_qty;
          FOR _s IN SELECT shipitem.*, shipitem_qty = _r.cobill_qty AS matched
	            FROM shipitem, shiphead
	            WHERE ((shipitem_shiphead_id=shiphead_id)
	              AND  (shipitem_orderitem_id=_r.coitem_id)
	              AND  (shiphead_shipped)
		      AND  (shiphead_order_type='SO')
	              AND  (NOT shipitem_invoiced))
	            ORDER BY matched DESC, shipitem_qty DESC FOR UPDATE LOOP
            IF (_qtyToInvoice >= _s.shipitem_qty) THEN
	      UPDATE shipitem
	      SET shipitem_invoiced=TRUE, shipitem_invcitem_id=_invcitemid
	      WHERE (shipitem_id=_s.shipitem_id);
	      _qtyToInvoice := _qtyToInvoice - _s.shipitem_qty;
            END IF;
            IF (_qtyToInvoice <= 0) THEN
	      EXIT;
            END IF;
          END LOOP;

          UPDATE cobill SET cobill_invcnum=cobmisc_invcnumber,
		          cobill_invcitem_id=invcitem_id
          FROM invcitem, coitem, cobmisc
          WHERE ((invcitem_linenumber=_lastlinenumber )
            AND  (coitem_id=cobill_coitem_id)
            AND  (cobmisc_id=cobill_cobmisc_id)
            AND  (cobill_cobmisc_id=_i.cobmisc_id)
            AND  (invcitem_invchead_id=_invcheadid));


          _lastlinenumber := _lastlinenumber + 1;

        END LOOP;

      --  Close all requested coitem's
        IF ( ( SELECT cobmisc_closeorder
               FROM cobmisc
               WHERE (cobmisc_id=_i.cobmisc_id) ) ) THEN
          UPDATE coitem
          SET coitem_status='C'
          FROM cobmisc
          WHERE ( (coitem_status NOT IN ('C', 'X'))
           AND (coitem_cohead_id=cobmisc_cohead_id)
           AND (cobmisc_id=_i.cobmisc_id) );
        ELSE
          UPDATE coitem
          SET coitem_status='C'
          FROM cobill
          WHERE ( (cobill_coitem_id=coitem_id)
           AND (coitem_status <> 'X')
           AND (cobill_toclose)
           AND (cobill_cobmisc_id=_i.cobmisc_id) );
        END IF;

      --  Mark the cobmisc as posted
        UPDATE cobmisc
        SET cobmisc_posted=TRUE, cobmisc_invchead_id=_invcheadid
        WHERE (cobmisc_id=_i.cobmisc_id);

      --  All done
        _count := (_count + 1);
      END LOOP;
    END IF;
  END LOOP;
  RETURN _count;
END;
$_$;


ALTER FUNCTION public.createinvoiceconsolidated(integer) OWNER TO admin;

--
-- TOC entry 1334 (class 1255 OID 146565888)
-- Dependencies: 4536 8
-- Name: createinvoices(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createinvoices() RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _counter INTEGER;
  _cobmisc RECORD;

BEGIN

  _counter := 0;

  FOR _cobmisc IN SELECT cobmisc_id
                  FROM cobmisc
                  WHERE (NOT cobmisc_posted) LOOP

    PERFORM createinvoice(_cobmisc.cobmisc_id);
    _counter := (_counter + 1);

  END LOOP;

  RETURN _counter;
END;
$$;


ALTER FUNCTION public.createinvoices() OWNER TO admin;

--
-- TOC entry 1335 (class 1255 OID 146565889)
-- Dependencies: 4536 8
-- Name: createinvoices(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createinvoices(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN createinvoices($1, false);
END;
$_$;


ALTER FUNCTION public.createinvoices(integer) OWNER TO admin;

--
-- TOC entry 1336 (class 1255 OID 146565890)
-- Dependencies: 4536 8
-- Name: createinvoices(integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createinvoices(integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCustTypeId ALIAS FOR $1;
  pConsolidate ALIAS FOR $2;
  _counter INTEGER;
  _tcounter INTEGER;
  _cobmisc RECORD;

BEGIN

  _counter := 0;

  IF (pConsolidate) THEN
    FOR _cobmisc IN SELECT DISTINCT cust_id
                      FROM cobmisc, cohead, custinfo
                     WHERE((NOT cobmisc_posted)
                       AND (cohead_id=cobmisc_cohead_id)
                       AND (cust_id=cohead_cust_id)
                       AND (cust_custtype_id=pCustTypeId)) LOOP

      SELECT createinvoiceConsolidated(_cobmisc.cust_id)
        INTO _tcounter;
      _counter := (_counter + _tcounter);
    END LOOP;
  ELSE
    FOR _cobmisc IN SELECT cobmisc_id
                      FROM cobmisc, cohead, custinfo
                     WHERE((NOT cobmisc_posted)
                       AND (cohead_id=cobmisc_cohead_id)
                       AND (cust_id=cohead_cust_id)
                       AND (cust_custtype_id=pCustTypeId)) LOOP

      PERFORM createinvoice(_cobmisc.cobmisc_id);
      _counter := (_counter + 1);

    END LOOP;
  END IF;

  RETURN _counter;
END;
$_$;


ALTER FUNCTION public.createinvoices(integer, boolean) OWNER TO admin;

--
-- TOC entry 1337 (class 1255 OID 146565891)
-- Dependencies: 4536 8
-- Name: createmiscapcheck(integer, integer, date, numeric, integer, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createmiscapcheck(integer, integer, date, numeric, integer, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RAISE NOTICE 'createMiscAPCheck() is deprecated - use createCheck() instead';
  RETURN createCheck($1, 'V', $2, $3, $4, baseCurrId(), $5, NULL, $6, $7, FALSE);
END;
$_$;


ALTER FUNCTION public.createmiscapcheck(integer, integer, date, numeric, integer, text, text) OWNER TO admin;

--
-- TOC entry 1338 (class 1255 OID 146565892)
-- Dependencies: 4536 8
-- Name: createmiscapcheck(integer, integer, date, numeric, integer, integer, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createmiscapcheck(integer, integer, date, numeric, integer, integer, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RAISE NOTICE 'createMiscAPCheck() is deprecated - use createCheck() instead';
  RETURN createCheck($1, 'V', $2, $3, pAmount, $5, $6, NULL, $7, $8, FALSE);
END;
$_$;


ALTER FUNCTION public.createmiscapcheck(integer, integer, date, numeric, integer, integer, text, text) OWNER TO admin;

--
-- TOC entry 1339 (class 1255 OID 146565893)
-- Dependencies: 4536 8
-- Name: createpkgschema(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createpkgschema(text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pname         ALIAS FOR $1;
  pcomment      ALIAS FOR $2;
  _createtable  TEXT;
  _debug        BOOL    := true;
  _namespaceoid INTEGER := -1;
  _tabs         TEXT[] := ARRAY['cmd',  'cmdarg', 'image',  'metasql',
                                'priv', 'report', 'script', 'uiform'] ;
  _pkgtab       TEXT;

BEGIN
  IF (LENGTH(COALESCE(pname, '')) <= 0) THEN
    RAISE EXCEPTION 'Cannot create a schema for this package without a name.';
  END IF;

  SELECT oid INTO _namespaceoid
  FROM pg_namespace
  WHERE (LOWER(nspname)=LOWER(pname));
  IF (NOT FOUND) THEN
    EXECUTE 'CREATE SCHEMA ' || LOWER(pname);
    EXECUTE 'GRANT ALL ON SCHEMA ' || LOWER(pname) || ' TO GROUP xtrole;';

    SELECT oid INTO _namespaceoid
    FROM pg_namespace
    WHERE (LOWER(nspname)=LOWER(pname));
  END IF;

  FOR i IN ARRAY_LOWER(_tabs,1)..ARRAY_UPPER(_tabs,1) LOOP
    _pkgtab := pname || '.pkg' || _tabs[i];

    IF NOT EXISTS(SELECT oid
                  FROM pg_class
                  WHERE ((relname=_pkgtab)
                     AND (relnamespace=_namespaceoid))) THEN
      _createtable := 'CREATE TABLE ' || _pkgtab || ' () INHERITS (' || _tabs[i] || ');';
      IF (_debug) THEN RAISE NOTICE '%', _createtable; END IF;
      EXECUTE _createtable;

      EXECUTE 'ALTER TABLE ' || _pkgtab ||
              ' ALTER ' || _tabs[i] || '_id SET NOT NULL,' ||
              ' ADD PRIMARY KEY (' || _tabs[i] || '_id),' ||
              ' ALTER ' || _tabs[i] || '_id SET DEFAULT NEXTVAL(''' ||
              _tabs[i] || '_' || _tabs[i] || '_id_seq'');';

      EXECUTE 'REVOKE ALL ON ' || _pkgtab || ' FROM PUBLIC;';
      EXECUTE 'GRANT  ALL ON ' || _pkgtab || ' TO GROUP xtrole;';

      IF (_tabs[i] = 'cmdarg') THEN
        EXECUTE 'ALTER TABLE ' || _pkgtab ||
                ' ADD FOREIGN KEY (cmdarg_cmd_id) REFERENCES ' ||
                pname || '.pkgcmd(cmd_id);';
      END IF;

      EXECUTE 'SELECT dropIfExists(''TRIGGER'', ''pkg' ||
                                   _tabs[i] || 'beforetrigger'', ''' ||
                                   pname || ''');' ;
      EXECUTE 'CREATE TRIGGER pkg' || _tabs[i] || 'beforetrigger ' ||
              'BEFORE INSERT OR UPDATE OR DELETE ON ' || _pkgtab ||
              ' FOR EACH ROW EXECUTE PROCEDURE _pkg' || _tabs[i] || 'beforetrigger();';

      EXECUTE 'SELECT dropIfExists(''TRIGGER'', ''pkg' ||
                                   _tabs[i] || 'altertrigger'', ''' ||
                                   pname || ''');' ;
      EXECUTE 'CREATE TRIGGER pkg' || _tabs[i] || 'altertrigger ' ||
              'BEFORE INSERT OR UPDATE OR DELETE ON ' || _pkgtab ||
              ' FOR EACH ROW EXECUTE PROCEDURE _pkg' || _tabs[i] || 'altertrigger();';

      EXECUTE 'SELECT dropIfExists(''TRIGGER'', ''pkg' ||
                                   _tabs[i] || 'aftertrigger'', ''' ||
                                   pname || ''');' ;
      EXECUTE 'CREATE TRIGGER pkg' || _tabs[i] || 'aftertrigger ' ||
              'AFTER INSERT OR UPDATE OR DELETE ON ' || _pkgtab ||
              ' FOR EACH ROW EXECUTE PROCEDURE _pkg' || _tabs[i] || 'aftertrigger();';

    END IF;
  END LOOP;

  EXECUTE 'COMMENT ON SCHEMA ' || quote_ident(pname) || ' IS ' ||
           quote_literal(pcomment) || ';';

  RETURN _namespaceoid;
END;
$_$;


ALTER FUNCTION public.createpkgschema(text, text) OWNER TO admin;

--
-- TOC entry 1341 (class 1255 OID 146565896)
-- Dependencies: 4536 8
-- Name: createpr(character, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createpr(character, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pParentType ALIAS FOR $1;
  pParentId ALIAS FOR $2;
  _orderNumber INTEGER;
  _prid INTEGER;

BEGIN

  IF (pParentType = 'W') THEN
    SELECT wo_number INTO _orderNumber
    FROM wo, womatl
    WHERE ((womatl_wo_id=wo_id)
     AND (womatl_id=pParentId));

  ELSIF (pParentType = 'S') THEN
    SELECT CAST(cohead_number AS INTEGER) INTO _orderNumber
    FROM cohead, coitem
    WHERE ((coitem_cohead_id=cohead_id)
     AND (coitem_id=pParentId));

  ELSIF (pParentType = 'F') THEN
    SELECT fetchPrNumber() INTO _orderNumber;

  ELSE
    RETURN -2;
  END IF;

  IF (NOT FOUND) THEN
    RETURN -1;
  END IF;

  SELECT createPr(_orderNumber, pParentType, pParentId) INTO _prid;

  RETURN _prid;

END;
$_$;


ALTER FUNCTION public.createpr(character, integer) OWNER TO admin;

--
-- TOC entry 1340 (class 1255 OID 146565895)
-- Dependencies: 4536 8
-- Name: createpr(integer, character, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createpr(integer, character, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pOrderNumber ALIAS FOR $1;
  pParentType ALIAS FOR $2;
  pParentId ALIAS FOR $3;
  _parent RECORD;
  _prid INTEGER;
  _orderNumber INTEGER;

BEGIN

  IF (pOrderNumber = -1) THEN
    SELECT fetchPrNumber() INTO _orderNumber;
  ELSE
    _orderNumber := pOrderNumber;
  END IF;

  IF (pParentType = 'W') THEN
    SELECT womatl_itemsite_id AS itemsiteid,
           itemuomtouom(itemsite_item_id, womatl_uom_id, NULL, womatl_qtyreq) AS qty,
           womatl_duedate AS duedate, wo_prj_id AS prjid,
           womatl_notes AS notes INTO _parent
    FROM wo, womatl, itemsite
    WHERE ((womatl_wo_id=wo_id)
     AND (womatl_itemsite_id=itemsite_id)
     AND (womatl_id=pParentId));

  ELSIF (pParentType = 'S') THEN
    SELECT coitem_itemsite_id AS itemsiteid,
           (coitem_qtyord - coitem_qtyshipped + coitem_qtyreturned) AS qty,
           coitem_scheddate AS duedate, cohead_prj_id AS prjid,
           coitem_memo AS notes INTO _parent
    FROM coitem, cohead
    WHERE ((cohead_id=coitem_cohead_id)
     AND (coitem_id=pParentId));

  ELSIF (pParentType = 'F') THEN
    SELECT planord_itemsite_id AS itemsiteid,
           planord_qty AS qty,
           planord_duedate AS duedate, NULL::INTEGER AS prjid,
           planord_comments AS notes INTO _parent
    FROM planord
    WHERE (planord_id=pParentId);

  ELSE
    RETURN -2;
  END IF;

  IF (NOT FOUND) THEN
    RETURN -1;
  END IF;

  SELECT NEXTVAL('pr_pr_id_seq') INTO _prid;
  INSERT INTO pr
  ( pr_id, pr_number, pr_subnumber, pr_status,
    pr_order_type, pr_order_id, pr_prj_id,
    pr_itemsite_id, pr_qtyreq,
    pr_duedate, pr_releasenote )
  VALUES
  ( _prid, _orderNumber, nextPrSubnumber(_orderNumber), 'O',
    pParentType, pParentId, _parent.prjid,
    _parent.itemsiteid, validateOrderQty(_parent.itemsiteid, _parent.qty, TRUE),
    _parent.duedate, _parent.notes );

  RETURN _prid;

END;
$_$;


ALTER FUNCTION public.createpr(integer, character, integer) OWNER TO admin;

--
-- TOC entry 1343 (class 1255 OID 146565898)
-- Dependencies: 4536 8
-- Name: createpr(integer, character, integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createpr(integer, character, integer, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pOrderNumber ALIAS FOR $1;
  pParentType ALIAS FOR $2;
  pParentId ALIAS FOR $3;
  pParentNotes ALIAS FOR $4;
  _parent RECORD;
  _prid INTEGER;
  _orderNumber INTEGER;

BEGIN

  IF (pOrderNumber = -1) THEN
    SELECT fetchPrNumber() INTO _orderNumber;
  ELSE
    _orderNumber := pOrderNumber;
  END IF;

  IF (pParentType = 'W') THEN
    SELECT womatl_itemsite_id AS itemsiteid,
           itemuomtouom(itemsite_item_id, womatl_uom_id, NULL, womatl_qtyreq) AS qty,
           womatl_duedate AS duedate, wo_prj_id AS prjid INTO _parent
    FROM wo, womatl, itemsite
    WHERE ((womatl_wo_id=wo_id)
     AND (womatl_itemsite_id=itemsite_id)
     AND (womatl_id=pParentId));

  ELSIF (pParentType = 'S') THEN
    SELECT coitem_itemsite_id AS itemsiteid,
           (coitem_qtyord - coitem_qtyshipped + coitem_qtyreturned) AS qty,
           coitem_scheddate AS duedate, cohead_prj_id AS prjid INTO _parent
    FROM coitem, cohead
    WHERE ((cohead_id=coitem_cohead_id)
     AND (coitem_id=pParentId));

  ELSIF (pParentType = 'F') THEN
    SELECT planord_itemsite_id AS itemsiteid,
           planord_qty AS qty,
           planord_duedate AS duedate, NULL::INTEGER AS prjid
           INTO _parent
    FROM planord
    WHERE (planord_id=pParentId);

  ELSE
    RETURN -2;
  END IF;

  IF (NOT FOUND) THEN
    RETURN -1;
  END IF;

  SELECT NEXTVAL('pr_pr_id_seq') INTO _prid;
  INSERT INTO pr
  ( pr_id, pr_number, pr_subnumber, pr_status,
    pr_order_type, pr_order_id, pr_prj_id,
    pr_itemsite_id, pr_qtyreq, pr_duedate, pr_releasenote )
  VALUES
  ( _prid, _orderNumber, nextPrSubnumber(_orderNumber), 'O',
    pParentType, pParentId, _parent.prjid,
    _parent.itemsiteid, validateOrderQty(_parent.itemsiteid, _parent.qty, TRUE),
    _parent.duedate, pParentNotes );

  RETURN _prid;

END;
$_$;


ALTER FUNCTION public.createpr(integer, character, integer, text) OWNER TO admin;

--
-- TOC entry 1328 (class 1255 OID 146565894)
-- Dependencies: 4536 8
-- Name: createpr(integer, integer, numeric, date, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createpr(integer, integer, numeric, date, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pOrderNumber ALIAS FOR $1;
  pItemsiteid ALIAS FOR $2;
  pQty ALIAS FOR $3;
  pDueDate ALIAS FOR $4;
  pNotes ALIAS FOR $5;
  _prid INTEGER;

BEGIN

  SELECT NEXTVAL('pr_pr_id_seq') INTO _prid;
  INSERT INTO pr
  ( pr_id, pr_number, pr_subnumber, pr_status,
    pr_order_type, pr_order_id,
    pr_itemsite_id, pr_qtyreq, pr_duedate, pr_releasenote )
  VALUES
  ( _prid, pOrderNumber, nextPrSubnumber(pOrderNumber), 'O',
    'M', -1,
    pItemsiteid, pQty, pDuedate, pNotes);

  RETURN _prid;

END;
$_$;


ALTER FUNCTION public.createpr(integer, integer, numeric, date, text) OWNER TO admin;

--
-- TOC entry 1342 (class 1255 OID 146565897)
-- Dependencies: 4536 8
-- Name: createpr(integer, integer, numeric, date, text, character, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createpr(integer, integer, numeric, date, text, character, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pOrderNumber ALIAS FOR $1;
  pItemsiteid ALIAS FOR $2;
  pQty ALIAS FOR $3;
  pDueDate ALIAS FOR $4;
  pNotes ALIAS FOR $5;
  pOrderType ALIAS FOR $6;
  pOrderId ALIAS FOR $7;
  _prid INTEGER;

BEGIN

  SELECT NEXTVAL('pr_pr_id_seq') INTO _prid;
  INSERT INTO pr
  ( pr_id, pr_number, pr_subnumber, pr_status,
    pr_order_type, pr_order_id,
    pr_itemsite_id, pr_qtyreq, pr_duedate, pr_releasenote )
  VALUES
  ( _prid, pOrderNumber, nextPrSubnumber(pOrderNumber), 'O',
    pOrderType, pOrderId,
    pItemsiteid, pQty, pDuedate, pNotes );

  RETURN _prid;

END;
$_$;


ALTER FUNCTION public.createpr(integer, integer, numeric, date, text, character, integer) OWNER TO admin;

--
-- TOC entry 1344 (class 1255 OID 146565899)
-- Dependencies: 4536 8
-- Name: createpriv(text, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createpriv(text, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pModule ALIAS FOR $1;
  pName   ALIAS FOR $2;
  pDesc   ALIAS FOR $3;
  _id     INTEGER;
BEGIN

  SELECT priv_id
    INTO _id
    FROM priv
   WHERE(priv_name=pName);

  IF (FOUND) THEN
    UPDATE priv
       SET priv_module=pModule,
           priv_descrip=pDesc
     WHERE(priv_id=_id);
  ELSE
    SELECT nextval('priv_priv_id_seq') INTO _id;
    INSERT INTO priv
          (priv_id, priv_module, priv_name, priv_descrip)
    VALUES(_id, pModule, pName, pDesc);
  END IF;

  RETURN _id;
END;
$_$;


ALTER FUNCTION public.createpriv(text, text, text) OWNER TO admin;

--
-- TOC entry 1345 (class 1255 OID 146565900)
-- Dependencies: 4536 8
-- Name: createpurchasetosale(integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createpurchasetosale(integer, integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCoitemId ALIAS FOR $1;
  pItemSourceId ALIAS FOR $2;
  pDropShip ALIAS FOR $3;

BEGIN

  RETURN createPurchaseToSale(pCoitemId, pItemSourceId, pDropShip, NULL, NULL, NULL);

END;
$_$;


ALTER FUNCTION public.createpurchasetosale(integer, integer, boolean) OWNER TO admin;

--
-- TOC entry 1346 (class 1255 OID 146565901)
-- Dependencies: 4536 8
-- Name: createpurchasetosale(integer, integer, boolean, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createpurchasetosale(integer, integer, boolean, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCoitemId ALIAS FOR $1;
  pItemSourceId ALIAS FOR $2;
  pDropShip ALIAS FOR $3;
  pPrice ALIAS FOR $4;

BEGIN

  RETURN createPurchaseToSale(pCoitemId, pItemSourceId, pDropShip, NULL, NULL, pPrice);

END;
$_$;


ALTER FUNCTION public.createpurchasetosale(integer, integer, boolean, numeric) OWNER TO admin;

--
-- TOC entry 1347 (class 1255 OID 146565902)
-- Dependencies: 4536 8
-- Name: createpurchasetosale(integer, integer, boolean, numeric, date, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createpurchasetosale(integer, integer, boolean, numeric, date, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCoitemId ALIAS FOR $1;
  pItemSourceId ALIAS FOR $2;
  pDropShip ALIAS FOR $3;
  pQty ALIAS FOR $4;
  pDueDate ALIAS FOR $5;
  pPrice ALIAS FOR $6;

  _s RECORD;
  _w RECORD;
  _i RECORD;
  _shipto RECORD;
  _poheadid INTEGER := -1;
  _poitemid INTEGER := -1;
  _taxtypeid INTEGER := -1;
  _polinenumber INTEGER;
  _ponumber NUMERIC;
  _price NUMERIC;
  _temp INTEGER;

BEGIN

  -- Check for existing poitem for this coitem
  SELECT poitem_id INTO _poitemid
  FROM poitem
  WHERE (poitem_order_id=pCoitemId)
    AND (poitem_order_type='S');
  IF (FOUND) THEN
    RETURN _poitemid;
  END IF;

  SELECT *,
         COALESCE(roundQty(item_fractional, (coitem_qtyord * coitem_qty_invuomratio)), 0.0) AS orderqty
  INTO _s
  FROM coitem JOIN cohead ON (cohead_id = coitem_cohead_id)
              LEFT OUTER JOIN shiptoinfo ON (cohead_shipto_id = shipto_id)
              LEFT OUTER JOIN addr ON (shipto_addr_id = addr_id)
              LEFT OUTER JOIN cntct ON (shipto_cntct_id = cntct_id)
              LEFT OUTER JOIN itemsite ON (coitem_itemsite_id = itemsite_id)
              LEFT OUTER JOIN item ON (item_id = itemsite_item_id)
  WHERE (coitem_id = pCoitemId);
  IF (NOT FOUND) THEN
    RETURN -1;
  END IF;

  SELECT * INTO _w
  FROM itemsite JOIN whsinfo ON (warehous_id = itemsite_warehous_id)
                LEFT OUTER JOIN addr ON (warehous_addr_id = addr_id)
                LEFT OUTER JOIN cntct ON (warehous_cntct_id = cntct_id)
  WHERE (itemsite_id = _s.itemsite_id);

  SELECT * INTO _i
  FROM itemsrc JOIN vendinfo ON (itemsrc_vend_id = vend_id)
               LEFT OUTER JOIN cntct ON (vend_cntct1_id = cntct_id)
               LEFT OUTER JOIN addr ON (vend_addr_id = addr_id)
  WHERE (itemsrc_id = pItemSourceId);
  IF (NOT FOUND) THEN
    RETURN -2;
  END IF;

  IF (pDropShip) THEN
    SELECT COALESCE(pohead_id, -1) INTO _temp
    FROM pohead
    WHERE ( (pohead_status = 'U')
      AND (pohead_vend_id = _i.itemsrc_vend_id)
      AND (pohead_shiptoname = COALESCE(_s.cohead_shiptoname, _s.shipto_name, ''))
      AND (pohead_shiptoaddress1 = COALESCE(_s.cohead_shiptoaddress1, _s.addr_line1, ''))
      AND (pohead_shiptoaddress2 = COALESCE(_s.cohead_shiptoaddress2, _s.addr_line2, ''))
      AND (pohead_shiptoaddress3 = COALESCE(_s.cohead_shiptoaddress3, _s.addr_line3, ''))
      AND (pohead_shiptocity = COALESCE(_s.cohead_shiptocity, _s.addr_city, ''))
      AND (pohead_shiptostate = COALESCE(_s.cohead_shiptostate, _s.addr_state, ''))
      AND (pohead_shiptozipcode = COALESCE(_s.cohead_shiptozipcode, _s.addr_postalcode, ''))
      AND (pohead_shiptocountry = COALESCE(_s.cohead_shiptocountry, _s.addr_country, '')) );
  ELSE
    SELECT COALESCE(pohead_id, -1) INTO _temp
    FROM pohead
    WHERE ( (pohead_status = 'U')
      AND (pohead_vend_id = _i.itemsrc_vend_id)
      AND (pohead_shiptoaddress1 = COALESCE(_w.addr_line1, ''))
      AND (pohead_shiptoaddress2 = COALESCE(_w.addr_line2, ''))
      AND (pohead_shiptoaddress3 = COALESCE(_w.addr_line3, ''))
      AND (pohead_shiptocity = COALESCE(_w.addr_city, ''))
      AND (pohead_shiptostate = COALESCE(_w.addr_state, ''))
      AND (pohead_shiptozipcode = COALESCE(_w.addr_postalcode, ''))
      AND (pohead_shiptocountry = COALESCE(_w.addr_country, '')) );
  END IF;

  IF (FOUND) THEN
    _poheadid := _temp;
    UPDATE pohead
    SET pohead_dropship = pDropShip
    WHERE (pohead_id = _poheadid);
  ELSE
    SELECT NEXTVAL('pohead_pohead_id_seq') INTO _poheadid;
    SELECT fetchPoNumber() INTO _ponumber;

    IF (pDropShip) THEN
      INSERT INTO pohead
        ( pohead_id, pohead_number, pohead_status, pohead_dropship,
          pohead_agent_username, pohead_vend_id, pohead_taxzone_id,
          pohead_orderdate, pohead_curr_id, pohead_cohead_id,
          pohead_warehous_id, pohead_shipvia,
          pohead_terms_id, pohead_shipto_cntct_id,
          pohead_shipto_cntct_honorific, pohead_shipto_cntct_first_name,
          pohead_shipto_cntct_middle, pohead_shipto_cntct_last_name,
          pohead_shipto_cntct_suffix, pohead_shipto_cntct_phone,
          pohead_shipto_cntct_title, pohead_shipto_cntct_fax,
          pohead_shipto_cntct_email, pohead_shiptoaddress_id,
          pohead_shiptoname,
          pohead_shiptoaddress1,
          pohead_shiptoaddress2,
          pohead_shiptoaddress3,
          pohead_shiptocity,
          pohead_shiptostate, pohead_shiptozipcode,
          pohead_shiptocountry, pohead_vend_cntct_id,
          pohead_vend_cntct_honorific, pohead_vend_cntct_first_name,
          pohead_vend_cntct_middle, pohead_vend_cntct_last_name,
          pohead_vend_cntct_suffix, pohead_vend_cntct_phone,
          pohead_vend_cntct_title, pohead_vend_cntct_fax,
          pohead_vend_cntct_email, pohead_vendaddress1,
          pohead_vendaddress2, pohead_vendaddress3,
          pohead_vendcity, pohead_vendstate,
          pohead_vendzipcode, pohead_vendcountry, pohead_comments )
      VALUES
        ( _poheadid, _ponumber, 'U', pDropShip,
          getEffectiveXtUser(), _i.itemsrc_vend_id, _i.vend_taxzone_id,
	  CURRENT_DATE, COALESCE(_i.vend_curr_id, basecurrid()), _s.cohead_id,
          COALESCE(_s.cohead_warehous_id, -1), COALESCE(_i.vend_shipvia, TEXT('')),
          COALESCE(_i.vend_terms_id, -1), COALESCE(_s.cohead_shipto_cntct_id, _s.shipto_cntct_id),
          COALESCE(_s.cohead_shipto_cntct_honorific, _s.cntct_honorific), COALESCE(_s.cohead_shipto_cntct_first_name, _s.cntct_first_name),
          COALESCE(_s.cohead_shipto_cntct_middle, _s.cntct_middle), COALESCE(_s.cohead_shipto_cntct_last_name, _s.cntct_last_name),
          COALESCE(_s.cohead_shipto_cntct_suffix, _s.cntct_suffix), COALESCE(_s.cohead_shipto_cntct_phone, _s.cntct_phone),
          COALESCE(_s.cohead_shipto_cntct_title, _s.cntct_title), COALESCE(_s.cohead_shipto_cntct_fax, _s.cntct_fax),
          COALESCE(_s.cohead_shipto_cntct_email, _s.cntct_email), COALESCE(_s.shipto_addr_id, _s.addr_id),
          COALESCE(_s.cohead_shiptoname, _s.shipto_name, ''),
          COALESCE(_s.cohead_shiptoaddress1, _s.addr_line1, ''),
          COALESCE(_s.cohead_shiptoaddress2, _s.addr_line2, ''),
          COALESCE(_s.cohead_shiptoaddress3, _s.addr_line3, ''),
          COALESCE(_s.cohead_shiptocity, _s.addr_city, ''),
          COALESCE(_s.cohead_shiptostate, _s.addr_state, ''), COALESCE(_s.cohead_shiptozipcode, _s.addr_postalcode, ''),
          COALESCE(_s.cohead_shiptocountry, _s.addr_country, ''), _i.cntct_id,
          COALESCE(_i.cntct_honorific, TEXT('')), COALESCE(_i.cntct_first_name, TEXT('')),
          COALESCE(_i.cntct_middle, TEXT('')), COALESCE(_i.cntct_last_name, TEXT('')),
          COALESCE(_i.cntct_suffix, TEXT('')), COALESCE(_i.cntct_phone, TEXT('')),
          COALESCE(_i.cntct_title, TEXT('')), COALESCE(_i.cntct_fax, TEXT('')),
          COALESCE(_i.cntct_email, TEXT('')), COALESCE(_i.addr_line1, TEXT('')),
          COALESCE(_i.addr_line2, TEXT('')), COALESCE(_i.addr_line3, TEXT('')),
          COALESCE(_i.addr_city, TEXT('')), COALESCE(_i.addr_state, TEXT('')),
          COALESCE(_i.addr_postalcode, TEXT('')), COALESCE(_i.addr_country, TEXT('')), COALESCE(_s.cohead_shipcomments, TEXT('')) );
    ELSE
      INSERT INTO pohead
        ( pohead_id, pohead_number, pohead_status, pohead_dropship,
          pohead_agent_username, pohead_vend_id, pohead_taxzone_id,
          pohead_orderdate, pohead_curr_id, pohead_cohead_id,
          pohead_warehous_id, pohead_shipvia,
          pohead_terms_id, pohead_shipto_cntct_id,
          pohead_shipto_cntct_honorific, pohead_shipto_cntct_first_name,
          pohead_shipto_cntct_middle, pohead_shipto_cntct_last_name,
          pohead_shipto_cntct_suffix, pohead_shipto_cntct_phone,
          pohead_shipto_cntct_title, pohead_shipto_cntct_fax,
          pohead_shipto_cntct_email, pohead_shiptoaddress_id,
          pohead_shiptoaddress1,
          pohead_shiptoaddress2,
          pohead_shiptoaddress3,
          pohead_shiptocity,
          pohead_shiptostate, pohead_shiptozipcode,
          pohead_shiptocountry, pohead_vend_cntct_id,
          pohead_vend_cntct_honorific, pohead_vend_cntct_first_name,
          pohead_vend_cntct_middle, pohead_vend_cntct_last_name,
          pohead_vend_cntct_suffix, pohead_vend_cntct_phone,
          pohead_vend_cntct_title, pohead_vend_cntct_fax,
          pohead_vend_cntct_email, pohead_vendaddress1,
          pohead_vendaddress2, pohead_vendaddress3,
          pohead_vendcity, pohead_vendstate,
          pohead_vendzipcode, pohead_vendcountry )
      VALUES
        ( _poheadid, _ponumber, 'U', pDropShip,
          getEffectiveXtUser(), _i.itemsrc_vend_id, _i.vend_taxzone_id,
	  CURRENT_DATE, COALESCE(_i.vend_curr_id, basecurrid()), _s.cohead_id,
          COALESCE(_s.cohead_warehous_id, -1), COALESCE(_i.vend_shipvia, TEXT('')),
          COALESCE(_i.vend_terms_id, -1), _w.cntct_id,
          _w.cntct_honorific, _w.cntct_first_name,
          _w.cntct_middle, _w.cntct_last_name,
          _w.cntct_suffix, _w.cntct_phone,
          _w.cntct_title, _w.cntct_fax,
          _w.cntct_email, _w.addr_id,
          COALESCE(_w.addr_line1, ''),
          COALESCE(_w.addr_line2, ''),
          COALESCE(_w.addr_line3, ''),
          COALESCE(_w.addr_city, ''),
          COALESCE(_w.addr_state, ''), COALESCE(_w.addr_postalcode, ''),
          COALESCE(_w.addr_country, ''), _i.cntct_id,
          COALESCE(_i.cntct_honorific, TEXT('')), COALESCE(_i.cntct_first_name, TEXT('')),
          COALESCE(_i.cntct_middle, TEXT('')), COALESCE(_i.cntct_last_name, TEXT('')),
          COALESCE(_i.cntct_suffix, TEXT('')), COALESCE(_i.cntct_phone, TEXT('')),
          COALESCE(_i.cntct_title, TEXT('')), COALESCE(_i.cntct_fax, TEXT('')),
          COALESCE(_i.cntct_email, TEXT('')), COALESCE(_i.addr_line1, TEXT('')),
          COALESCE(_i.addr_line2, TEXT('')), COALESCE(_i.addr_line3, TEXT('')),
          COALESCE(_i.addr_city, TEXT('')), COALESCE(_i.addr_state, TEXT('')),
          COALESCE(_i.addr_postalcode, TEXT('')), COALESCE(_i.addr_country, TEXT('')) );
    END IF;
  END IF;

  SELECT NEXTVAL('poitem_poitem_id_seq') INTO _poitemid;

  SELECT (COALESCE(MAX(poitem_linenumber), 0) + 1) INTO _polinenumber
  FROM poitem
  WHERE (poitem_pohead_id = _poheadid);

  SELECT COALESCE(itemtax_taxtype_id, -1) INTO _taxtypeid
  FROM itemtax
  WHERE (itemtax_item_id = _i.itemsrc_item_id);

  IF (pPrice IS NULL) THEN
    SELECT itemsrcPrice(pItemSourceId,
                        COALESCE(_s.cohead_warehous_id, -1),
                        pDropShip,
                        (COALESCE(pQty, _s.orderqty) / COALESCE(_i.itemsrc_invvendoruomratio, 1.00)),
                        COALESCE(_i.vend_curr_id, baseCurrId()),
                        CURRENT_DATE) INTO _price;
  ELSE
    _price := pPrice;
  END IF;
  raise notice '_price=%', _price;

  IF (pDropShip) THEN
    INSERT INTO poitem
      ( poitem_id, poitem_status, poitem_pohead_id, poitem_linenumber,
        poitem_duedate, poitem_itemsite_id,
        poitem_vend_item_descrip, poitem_vend_uom,
        poitem_invvenduomratio, poitem_qty_ordered,
        poitem_unitprice, poitem_vend_item_number,
        poitem_itemsrc_id, poitem_order_id, poitem_order_type, poitem_prj_id, poitem_stdcost,
        poitem_manuf_name, poitem_manuf_item_number,
        poitem_manuf_item_descrip, poitem_taxtype_id, poitem_comments )
    VALUES
      ( _poitemid, 'U', _poheadid, _polinenumber,
        COALESCE(pDueDate, _s.coitem_scheddate), _s.coitem_itemsite_id,
        COALESCE(_i.itemsrc_vend_item_descrip, TEXT('')), COALESCE(_i.itemsrc_vend_uom, TEXT('')),
        COALESCE(_i.itemsrc_invvendoruomratio, 1.00), (COALESCE(pQty, _s.orderqty) / COALESCE(_i.itemsrc_invvendoruomratio, 1.00)),
        _price, COALESCE(_i.itemsrc_vend_item_number, TEXT('')),
        pItemSourceId, pCoitemId, 'S', _s.cohead_prj_id, stdcost(_i.itemsrc_item_id),
        COALESCE(_i.itemsrc_manuf_name, TEXT('')), COALESCE(_i.itemsrc_manuf_item_number, TEXT('')),
        COALESCE(_i.itemsrc_manuf_item_descrip, TEXT('')), _taxtypeid,
        COALESCE(_s.coitem_memo, TEXT('')));
  ELSE
    INSERT INTO poitem
      ( poitem_id, poitem_status, poitem_pohead_id, poitem_linenumber,
        poitem_duedate, poitem_itemsite_id,
        poitem_vend_item_descrip, poitem_vend_uom,
        poitem_invvenduomratio, poitem_qty_ordered,
        poitem_unitprice, poitem_vend_item_number,
        poitem_itemsrc_id, poitem_order_id, poitem_order_type, poitem_prj_id, poitem_stdcost,
        poitem_manuf_name, poitem_manuf_item_number,
        poitem_manuf_item_descrip, poitem_taxtype_id, poitem_comments )
    VALUES
      ( _poitemid, 'U', _poheadid, _polinenumber,
        COALESCE(pDueDate, _s.coitem_scheddate), _s.coitem_itemsite_id,
        COALESCE(_i.itemsrc_vend_item_descrip, TEXT('')), COALESCE(_i.itemsrc_vend_uom, TEXT('')),
        COALESCE(_i.itemsrc_invvendoruomratio, 1.00), (COALESCE(pQty, _s.orderqty) / COALESCE(_i.itemsrc_invvendoruomratio, 1.00)),
        _price, COALESCE(_i.itemsrc_vend_item_number, TEXT('')),
        pItemSourceId, pCoitemId, 'S', _s.cohead_prj_id, stdcost(_i.itemsrc_item_id),
        COALESCE(_i.itemsrc_manuf_name, TEXT('')), COALESCE(_i.itemsrc_manuf_item_number, TEXT('')),
        COALESCE(_i.itemsrc_manuf_item_descrip, TEXT('')), _taxtypeid,
        COALESCE(_s.coitem_memo, TEXT('')));
  END IF;
  -- Copy characteristics from the coitem to the poitem
  INSERT INTO charass
    ( charass_target_type, charass_target_id, charass_char_id,
      charass_value, charass_default, charass_price )
  SELECT 'PI', _poitemid, charass_char_id,
         charass_value, charass_default, charass_price
  FROM charass
  WHERE ( (charass_target_type='SI')
    AND   (charass_target_id=pCoitemId) );

  UPDATE coitem
  SET coitem_order_type = 'P',
      coitem_order_id = _poitemid
  WHERE ( coitem_id = pCoitemId );

  -- Generate the PoItemCreatedBySo event notice
  PERFORM postEvent('PoItemCreatedBySo', 'P', poitem_id,
                    itemsite_warehous_id,
                    (pohead_number || '-'|| poitem_linenumber || ': ' || item_number),
                    NULL, NULL, NULL, NULL)
  FROM poitem JOIN pohead ON (pohead_id=poitem_pohead_id)
              JOIN itemsite ON (itemsite_id=poitem_itemsite_id)
              JOIN item ON (item_id=itemsite_item_id)
  WHERE (poitem_id=_poitemid)
    AND (poitem_duedate <= (CURRENT_DATE + itemsite_eventfence));

  RETURN _poitemid;

END;
$_$;


ALTER FUNCTION public.createpurchasetosale(integer, integer, boolean, numeric, date, numeric) OWNER TO admin;

--
-- TOC entry 1348 (class 1255 OID 146565904)
-- Dependencies: 4536 8
-- Name: createrecurringinvoices(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createrecurringinvoices() RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RAISE NOTICE 'createRecurringInvoices() has been deprecated; use createRecurringItems(NULL, ''I'') instead.';

  RETURN createRecurringItems(NULL, 'I');
END;
$$;


ALTER FUNCTION public.createrecurringinvoices() OWNER TO admin;

--
-- TOC entry 1349 (class 1255 OID 146565905)
-- Dependencies: 4536 8
-- Name: createrecurringitems(integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createrecurringitems(integer, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pParentid  ALIAS FOR $1;      -- if NULL then all items with the given pType
  pType      TEXT := UPPER($2); -- if NULL then all types
                                -- if both are null then all items of all types
  _copystmt  TEXT;
  _count     INTEGER := 0;
  _countstmt TEXT;
  _existcnt  INTEGER;
  _id        INTEGER;
  _interval  TEXT;
  _last      TIMESTAMP WITH TIME ZONE;
  _loopcount INTEGER := 1;
  _maxstmt   TEXT;
  _maxdate   TIMESTAMP WITH TIME ZONE := endOfTime();
  _result    INTEGER := 0;
  _next      TIMESTAMP WITH TIME ZONE;
  _r         RECORD;
  _rt        RECORD;
  _tmp       INTEGER;

BEGIN
  RAISE DEBUG 'createRecurringItems(%, %) entered', pParentid, pType;

  FOR _r IN SELECT *
              FROM recur
             WHERE ((COALESCE(recur_end, endOfTime()) >= CURRENT_TIMESTAMP)
                AND (pParentid IS NULL OR recur_parent_id=pParentid)
                AND (pType IS NULL OR UPPER(recur_parent_type)=UPPER(pType))) LOOP

    RAISE DEBUG 'createRecurringItems looking at recur %, %',
                _r.recur_id, _r.recur_parent_type;
    _r.recur_max := COALESCE(_r.recur_max,
                             CAST(fetchMetricValue('RecurringInvoiceBuffer') AS INTEGER),
                             1);
    _interval := CASE _r.recur_period WHEN 'Y' THEN ' year'
                                      WHEN 'M' THEN ' month'
                                      WHEN 'W' THEN ' week'
                                      WHEN 'D' THEN ' day'
                                      WHEN 'H' THEN ' hour'
                                      WHEN 'm' THEN ' minute'
                                      ELSE NULL
                 END;

    IF (_interval IS NULL OR COALESCE(_r.recur_freq, 0) <= 0) THEN
      RAISE EXCEPTION 'Unknown recurrence frequency % % ON % %',
                      _r.recur_freq,        _r.recur_period,
                      _r.recur_parent_type, _r.recur_parent_id;
    END IF;

    SELECT * INTO _rt FROM recurtype WHERE (UPPER(recurtype_type)=UPPER(pType));
    GET DIAGNOSTICS _count = ROW_COUNT;
    IF (_count <= 0) THEN
      RETURN -10;
    END IF;

    -- if the recurrence type has a max lookahead window, use it
    IF (_r.recur_parent_type = 'I') THEN
      _maxdate := CURRENT_TIMESTAMP + CAST(fetchMetricText('RecurringInvoiceBuffer') || ' days' AS INTERVAL);
    END IF;
    IF (_r.recur_parent_type = 'V') THEN
      _maxdate := CURRENT_TIMESTAMP + CAST(fetchMetricText('RecurringVoucherBuffer') || ' days' AS INTERVAL);
    END IF;
    IF (_maxdate > _r.recur_end) THEN   -- if recur_end is null, _maxdate is ok
      _maxdate = _r.recur_end;
    END IF;

    -- build statements dynamically from the recurtype table because packages
    -- might also require recurring items. this way the algorithm is fixed
    -- and the details are data-driven
    _countstmt := 'SELECT COUNT(*) FROM [fulltable]'
               || ' WHERE (($1=[table]_recurring_[table]_id)'
               || ' AND NOT([done]) '
               || ' AND ([limit]));';
    _countstmt := REPLACE(_countstmt, '[fulltable]', _rt.recurtype_table);
    _countstmt := REPLACE(_countstmt, '[table]',
                          REGEXP_REPLACE(_rt.recurtype_table, E'.*\\.', ''));
    _countstmt := REPLACE(_countstmt, '[done]',  _rt.recurtype_donecheck);
    _countstmt := REPLACE(_countstmt, '[limit]',
                          COALESCE(_rt.recurtype_limit, 'TRUE'));

    _maxstmt := 'SELECT MAX([schedcol]) FROM [fulltable]'
               || ' WHERE (($1=[table]_recurring_[table]_id)'
               || '    AND ([limit]));';
    _maxstmt := REPLACE(_maxstmt, '[schedcol]', _rt.recurtype_schedcol);
    _maxstmt := REPLACE(_maxstmt, '[fulltable]',_rt.recurtype_table);
    _maxstmt := REPLACE(_maxstmt, '[table]',
                          REGEXP_REPLACE(_rt.recurtype_table, E'.*\\.', ''));
    _maxstmt := REPLACE(_maxstmt, '[limit]', COALESCE(_rt.recurtype_limit,
                                                     'TRUE'));

    _copystmt := 'SELECT [copy]($1, [datetime] [more]);';
    _copystmt := REPLACE(_copystmt, '[copy]', _rt.recurtype_copyfunc);
    _copystmt := REPLACE(_copystmt, '[datetime]',
                         CASE WHEN UPPER(_rt.recurtype_copyargs[2])='DATE' THEN
                                    'CAST(''$2'' AS DATE)'
                              ELSE '''$2''' END);
    -- 8.4+:
    -- _copystmt := REPLACE(_copystmt, '[more]',
    --                      REPEAT(', NULL',
    --                             array_length(_rt.recurtype_copyargs) - 2));
    _tmp := CAST(REPLACE(REGEXP_REPLACE(array_dims(_rt.recurtype_copyargs),
                                        '.*:', ''), ']', '') AS INTEGER);
    _copystmt := REPLACE(_copystmt, '[more]', REPEAT(', NULL', _tmp - 2));

    EXECUTE REPLACE(_countstmt, '$1', _r.recur_parent_id::TEXT) INTO _existcnt;
    EXECUTE REPLACE(_maxstmt,   '$1', _r.recur_parent_id::TEXT) INTO _last;
    RAISE DEBUG E'% got %, % got %', _countstmt, _existcnt, _maxstmt, _last;

    _next := _last;
    _loopcount := 1;
    WHILE (_existcnt < _r.recur_max AND _next < _maxdate) LOOP
      _next := _last +
               CAST(_r.recur_freq * _loopcount || _interval AS INTERVAL);
      RAISE DEBUG 'createrecurringitems looping, existcnt = %, max = %, is % between % and %?',
                  _existcnt, _r.recur_max, _next, _r.recur_start, _r.recur_end;

      IF (_next BETWEEN _r.recur_start AND _maxdate) THEN
        RAISE DEBUG 'createrecurringitems executing % with % and %',
                    _copystmt, _r.recur_parent_id, _next;
        -- 8.4+: EXECUTE _copystmt INTO _id USING _r.recur_parent_id, _next;
        EXECUTE REPLACE(REPLACE(_copystmt, '$1', _r.recur_parent_id::TEXT),
                                           '$2', _next::TEXT) INTO _id;
        RAISE DEBUG 'Copying for % returned %', _next, _id;
        _result   := _result   + 1;
        _existcnt := _existcnt + 1;
      END IF;
      _loopcount := _loopcount + 1;
    END LOOP;
  END LOOP;

  RETURN _result;
END;
$_$;


ALTER FUNCTION public.createrecurringitems(integer, text) OWNER TO admin;

--
-- TOC entry 1350 (class 1255 OID 146565907)
-- Dependencies: 4536 8
-- Name: createtodoitem(integer, text, text, text, integer, integer, integer, date, date, character, date, date, integer, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createtodoitem(integer, text, text, text, integer, integer, integer, date, date, character, date, date, integer, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN createTodoItem($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, NULL);
END;
$_$;


ALTER FUNCTION public.createtodoitem(integer, text, text, text, integer, integer, integer, date, date, character, date, date, integer, text, text) OWNER TO admin;

--
-- TOC entry 1352 (class 1255 OID 146565908)
-- Dependencies: 4536 8
-- Name: createtodoitem(integer, text, text, text, integer, integer, integer, date, date, character, date, date, integer, text, text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createtodoitem(integer, text, text, text, integer, integer, integer, date, date, character, date, date, integer, text, text, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  ptodoid     ALIAS FOR  $1;
  pusername   ALIAS FOR  $2;
  pname       ALIAS FOR  $3;
  pdesc       ALIAS FOR  $4;
  pincdtid    ALIAS FOR  $5;
  pcrmacctid  ALIAS FOR  $6;
  pOpheadid   ALIAS FOR  $7;
  pstarted    ALIAS FOR  $8;
  pdue        ALIAS FOR  $9;
  pstatus     ALIAS FOR $10;
  passigned   ALIAS FOR $11;
  pcompleted  ALIAS FOR $12;
  ppriority   ALIAS FOR $13;
  pnotes      ALIAS FOR $14;
  powner      ALIAS FOR $15;
  pcntctid    ALIAS FOR $16;

  _todoid     INTEGER;
  _priority   INTEGER         := ppriority;
  _status     CHARACTER(1)    := pstatus;
  _incdtid    INTEGER         := pincdtid;
  _crmacctid  INTEGER         := pcrmacctid;
  _opheadid   INTEGER         := pOpheadid;
  _assigned   DATE            := passigned;
  _result     INTEGER;

BEGIN
  IF (pusername IS NULL OR pusername = '') THEN
    RETURN -1;
  END IF;

  IF (pname IS NULL OR pname = '') THEN
    RETURN -2;
  END IF;

  IF (pdue IS NULL) THEN
    RETURN -3;
  END IF;

  IF (pcompleted IS NOT NULL) THEN
    _status := 'C';
  ELSIF (pstatus IS NULL AND pstarted IS NOT NULL) THEN
    _status := 'I';
  ELSIF (pstatus IS NULL) THEN
    _status := 'N';
  END IF;

  IF (_incdtid <= 0) THEN
    _incdtid := NULL;
  END IF;

  IF (_crmacctid <= 0) THEN
    _crmacctid := NULL;
  END IF;

  IF (_opheadid <= 0) THEN
    _opheadid := NULL;
  END IF;

  IF (_priority <= 0) THEN
    _priority := NULL;
  END IF;

  IF (_assigned IS NULL) THEN
    _assigned := CURRENT_DATE;
  END IF;

  IF (ptodoid IS NULL) THEN
    SELECT NEXTVAL('todoitem_todoitem_id_seq') INTO _todoid;
  ELSE
    _todoid := ptodoid;
  END IF;

  INSERT INTO todoitem ( todoitem_id, todoitem_username, todoitem_name,
                         todoitem_description, todoitem_incdt_id,
                         todoitem_creator_username, todoitem_status,
                         todoitem_active, todoitem_start_date,
                         todoitem_due_date, todoitem_assigned_date,
                         todoitem_completed_date, todoitem_priority_id,
                         todoitem_notes, todoitem_crmacct_id,
                         todoitem_ophead_id, todoitem_owner_username,
                         todoitem_cntct_id
              ) VALUES ( _todoid, pusername, pname,
                         pdesc, _incdtid,
                         getEffectiveXtUser(), _status,
                         TRUE, pstarted,
                         pdue, _assigned,
                         pcompleted, _priority, pnotes, _crmacctid, _opheadid, powner,
                         pcntctid );

  RETURN _todoid;
END;
$_$;


ALTER FUNCTION public.createtodoitem(integer, text, text, text, integer, integer, integer, date, date, character, date, date, integer, text, text, integer) OWNER TO admin;

--
-- TOC entry 1353 (class 1255 OID 146565909)
-- Dependencies: 4536 8
-- Name: createurl(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createurl(text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
declare
  pTitle ALIAS FOR $1;
  pUrl ALIAS FOR $2;
  _id integer;
begin
  _id := nextval('urlinfo_url_id_seq');
  insert into urlinfo (url_id, url_title, url_url) values (_id, pTitle, pUrl);
  return _id;
end;
$_$;


ALTER FUNCTION public.createurl(text, text) OWNER TO admin;

--
-- TOC entry 1354 (class 1255 OID 146565910)
-- Dependencies: 4536 8
-- Name: createuser(text, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createuser(pusername text, pcreateusers boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (pCreateUsers) THEN
    EXECUTE 'CREATE USER "' || pUsername || '" CREATEROLE   IN GROUP xtrole;';
  ELSE
    EXECUTE 'CREATE USER "' || pUsername || '" NOCREATEROLE IN GROUP xtrole;';
  END IF;
  RETURN 1;
END;
$$;


ALTER FUNCTION public.createuser(pusername text, pcreateusers boolean) OWNER TO admin;

--
-- TOC entry 1356 (class 1255 OID 146565912)
-- Dependencies: 4536 8
-- Name: createwo(integer, integer, numeric, integer, date, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createwo(integer, integer, numeric, integer, date, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoNumber ALIAS FOR $1;
  pItemsiteid ALIAS FOR $2;
  pQtyOrdered ALIAS FOR $3;
  pLeadTime ALIAS FOR $4;
  pDueDate ALIAS FOR $5;
  pProductionNotes ALIAS FOR $6;

BEGIN
  RETURN createWo( pWoNumber, pItemsiteid, 1, pQtyOrdered,
                   (pDueDate - pLeadTime), pDueDate,
                   pProductionNotes, NULL, NULL, -1 );
END;
$_$;


ALTER FUNCTION public.createwo(integer, integer, numeric, integer, date, text) OWNER TO admin;

--
-- TOC entry 1357 (class 1255 OID 146565913)
-- Dependencies: 4536 8
-- Name: createwo(integer, integer, numeric, date, date, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createwo(integer, integer, numeric, date, date, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoNumber ALIAS FOR $1;
  pItemsiteid ALIAS FOR $2;
  pQtyOrdered ALIAS FOR $3;
  pStartDate ALIAS FOR $4;
  pDueDate ALIAS FOR $5;
  pProductionNotes ALIAS FOR $6;

BEGIN
  RETURN createWo( pWoNumber, pItemsiteid, 1, pQtyOrdered,
                   pStartDate, pDueDate, pProductionNotes, NULL, NULL, -1);
END;
$_$;


ALTER FUNCTION public.createwo(integer, integer, numeric, date, date, text) OWNER TO admin;

--
-- TOC entry 1355 (class 1255 OID 146565911)
-- Dependencies: 4536 8
-- Name: createwo(integer, integer, numeric, integer, date, text, character, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createwo(integer, integer, numeric, integer, date, text, character, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoNumber ALIAS FOR $1;
  pItemsiteid ALIAS FOR $2;
  pQtyOrdered ALIAS FOR $3;
  pLeadTime ALIAS FOR $4;
  pDueDate ALIAS FOR $5;
  pProductionNotes ALIAS FOR $6;
  pParentType ALIAS FOR $7;
  pParentId ALIAS FOR $8;

BEGIN
  RETURN createWo( pWoNumber, pItemsiteid, 1, pQtyOrdered,
                   (pDueDate - pLeadTime), pDueDate,
                   pProductionNotes, pParentType, pParentId, -1 );
END;
$_$;


ALTER FUNCTION public.createwo(integer, integer, numeric, integer, date, text, character, integer) OWNER TO admin;

--
-- TOC entry 1358 (class 1255 OID 146565914)
-- Dependencies: 4536 8
-- Name: createwo(integer, integer, integer, numeric, integer, date, text, character, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createwo(integer, integer, integer, numeric, integer, date, text, character, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoNumber ALIAS FOR $1;
  pItemsiteid ALIAS FOR $2;
  pPriority ALIAS FOR $3;
  pQtyOrdered ALIAS FOR $4;
  pLeadTime ALIAS FOR $5;
  pDueDate ALIAS FOR $6;
  pProductionNotes ALIAS FOR $7;
  pParentType ALIAS FOR $8;
  pParentId ALIAS FOR $9;

BEGIN
  RETURN createWo(pWoNumber, pItemsiteid, pPriority, pQtyOrdered,
                  (pDueDate - pLeadTime), pDueDate, pProductionNotes,
                  pParentType, pParentId, -1);
END;
$_$;


ALTER FUNCTION public.createwo(integer, integer, integer, numeric, integer, date, text, character, integer) OWNER TO admin;

--
-- TOC entry 1359 (class 1255 OID 146565915)
-- Dependencies: 4536 8
-- Name: createwo(integer, integer, integer, numeric, integer, date, text, character, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createwo(integer, integer, integer, numeric, integer, date, text, character, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoNumber ALIAS FOR $1;
  pItemsiteid ALIAS FOR $2;
  pPriority ALIAS FOR $3;
  pQtyOrdered ALIAS FOR $4;
  pLeadTime ALIAS FOR $5;
  pDueDate ALIAS FOR $6;
  pProductionNotes ALIAS FOR $7;
  pParentType ALIAS FOR $8;
  pParentId ALIAS FOR $9;
  pProjectId ALIAS FOR $10;

BEGIN
  RETURN createWo(pWoNumber, pItemsiteid, pPriority, pQtyOrdered,
                  (pDueDate - pLeadTime), pDueDate, pProductionNotes,
                  pParentType, pParentId, pProjectId);
END;
$_$;


ALTER FUNCTION public.createwo(integer, integer, integer, numeric, integer, date, text, character, integer, integer) OWNER TO admin;

--
-- TOC entry 1360 (class 1255 OID 146565916)
-- Dependencies: 4536 8
-- Name: createwo(integer, integer, integer, numeric, date, date, text, character, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createwo(integer, integer, integer, numeric, date, date, text, character, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoNumber ALIAS FOR $1;
  pItemsiteid ALIAS FOR $2;
  pPriority ALIAS FOR $3;
  pQtyOrdered ALIAS FOR $4;
  pStartDate ALIAS FOR $5;
  pDueDate ALIAS FOR $6;
  pProductionNotes ALIAS FOR $7;
  pParentType ALIAS FOR $8;
  pParentId ALIAS FOR $9;
  pProjectId ALIAS FOR $10;
  _woid INTEGER;
  _result INTEGER;
  _parentType char(1);
  _bomrevid INTEGER;
  _boorevid INTEGER;

BEGIN

  SELECT getActiveRevId('BOM',itemsite_item_id) INTO _bomrevid
  FROM itemsite
  WHERE (itemsite_id=pItemsiteid);

  SELECT getActiveRevId('BOO',itemsite_item_id) INTO _boorevid
  FROM itemsite
  WHERE (itemsite_id=pItemsiteid);

  RETURN createWo(pWoNumber, pItemsiteid, pPriority, pQtyOrdered,
                  pStartDate, pDueDate, pProductionNotes,
                  pParentType, pParentId, pProjectId, _bomrevid, _boorevid, NULL);

END;
$_$;


ALTER FUNCTION public.createwo(integer, integer, integer, numeric, date, date, text, character, integer, integer) OWNER TO admin;

--
-- TOC entry 1361 (class 1255 OID 146565917)
-- Dependencies: 4536 8
-- Name: createwo(integer, integer, integer, numeric, integer, date, text, character, integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createwo(integer, integer, integer, numeric, integer, date, text, character, integer, integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoNumber ALIAS FOR $1;
  pItemsiteid ALIAS FOR $2;
  pPriority ALIAS FOR $3;
  pQtyOrdered ALIAS FOR $4;
  pLeadTime ALIAS FOR $5;
  pDueDate ALIAS FOR $6;
  pProductionNotes ALIAS FOR $7;
  pParentType ALIAS FOR $8;
  pParentId ALIAS FOR $9;
  pProjectId ALIAS FOR $10;
  pBomRevId ALIAS FOR $11;
  pBooRevId ALIAS FOR $12;

BEGIN
  RETURN createWo(pWoNumber, pItemsiteid, pPriority, pQtyOrdered,
                  (pDueDate - pLeadTime), pDueDate, pProductionNotes,
                  pParentType, pParentId, pProjectId, pBomRevId, pBooRevId, NULL);
END;
$_$;


ALTER FUNCTION public.createwo(integer, integer, integer, numeric, integer, date, text, character, integer, integer, integer, integer) OWNER TO admin;

--
-- TOC entry 1362 (class 1255 OID 146565918)
-- Dependencies: 4536 8
-- Name: createwo(integer, integer, integer, numeric, date, date, text, character, integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createwo(integer, integer, integer, numeric, date, date, text, character, integer, integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoNumber ALIAS FOR $1;
  pItemsiteid ALIAS FOR $2;
  pPriority ALIAS FOR $3;
  pQtyOrdered ALIAS FOR $4;
  pStartDate ALIAS FOR $5;
  pDueDate ALIAS FOR $6;
  pProductionNotes ALIAS FOR $7;
  pParentType ALIAS FOR $8;
  pParentId ALIAS FOR $9;
  pProjectId ALIAS FOR $10;
  pBomRevId ALIAS FOR $11;
  pBooRevId ALIAS FOR $12;
BEGIN
  RETURN createWo(pWoNumber, pItemsiteid, pPriority, pQtyOrdered,
                  pStartDate, pDueDate, pProductionNotes,
                  pParentType, pParentId, pProjectId, pBomRevId, pBooRevId, NULL);
END;
$_$;


ALTER FUNCTION public.createwo(integer, integer, integer, numeric, date, date, text, character, integer, integer, integer, integer) OWNER TO admin;

--
-- TOC entry 1363 (class 1255 OID 146565919)
-- Dependencies: 4536 8
-- Name: createwo(integer, integer, integer, numeric, date, date, text, character, integer, integer, integer, integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createwo(integer, integer, integer, numeric, date, date, text, character, integer, integer, integer, integer, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoNumber ALIAS FOR $1;
  pItemsiteid ALIAS FOR $2;
  pPriority ALIAS FOR $3;
  pQtyOrdered ALIAS FOR $4;
  pStartDate ALIAS FOR $5;
  pDueDate ALIAS FOR $6;
  pProductionNotes ALIAS FOR $7;
  pParentType ALIAS FOR $8;
  pParentId ALIAS FOR $9;
  pProjectId ALIAS FOR $10;
  pBomRevId ALIAS FOR $11;
  pBooRevId ALIAS FOR $12;
  pCosMethod ALIAS FOR $13;
  _startDate DATE;
  _woid INTEGER;
  _result INTEGER;
  _parentType char(1);
  _parentId INTEGER;
  _cosmethod char(1);
  _itemsite RECORD;

BEGIN

  _parentType := COALESCE(pParentType, ' ');
  _parentId   := COALESCE(pParentId, -1);

  SELECT * INTO _itemsite FROM itemsite WHERE itemsite_id = pItemsiteid;

--  Check to make sure the itemsite specified is supplied at itemsite
  IF (NOT _itemsite.itemsite_wosupply) THEN
    RETURN -1;
  END IF;

--  Check to make sure if this is a job item that it is tied to a sales order
--  Or if it is just an avarage costed item
  IF (pCosMethod IN ('D', 'P')) THEN
    _cosmethod := pCosMethod;
  ELSE
    IF (_itemsite.itemsite_costmethod = 'J') THEN
      IF (_parentType = ' ' OR _parentId = -1) THEN
        RAISE EXCEPTION 'Work Orders for Item Sites that are Job cost must have a parent order.';
      ELSE
        SELECT COALESCE(itemsite_cosdefault,fetchmetrictext('JobItemCosDefault'),'D') INTO _cosmethod FROM itemsite WHERE itemsite_id=pItemsiteid;
      END IF;
    ELSIF (_itemsite.itemsite_costmethod = 'A') THEN
      _cosmethod := COALESCE(_itemsite.itemsite_cosdefault,fetchmetrictext('JobItemCosDefault'),'D');
    END IF;
  END IF;

--  Check to see if the site calendar metric is set, and if so adjust the start date if necessary
  IF (fetchmetricbool('UseSiteCalendar')) THEN
    _startDate := calculatenextworkingdate(_itemsite.itemsite_warehous_id, pStartDate, 0);
    IF (_startDate != pStartDate) THEN
      _startDate := calculatenextworkingdate(_itemsite.itemsite_warehous_id, pDueDate, -_itemsite.itemsite_leadtime);
    END IF;
  ELSE
    _startDate := pStartDate;
  END IF;

--  Grab the next wo_id
  SELECT NEXTVAL('wo_wo_id_seq') INTO _woid;

--  Create the W/O
  INSERT INTO wo
  ( wo_id, wo_number, wo_subnumber, wo_itemsite_id,
    wo_priority, wo_ordtype, wo_ordid,
    wo_status, wo_startdate, wo_duedate,
    wo_qtyord, wo_qtyrcv, wo_prodnotes, wo_prj_id,
    wo_bom_rev_id, wo_boo_rev_id, wo_cosmethod )
  SELECT _woid, pWoNumber, nextWoSubnumber(pWoNumber), itemsite_id,
         pPriority, _parentType, pParentId,
         'O', _startDate, pDueDate,
         roundQty(item_fractional, pQtyOrdered), 0, pProductionNotes, pProjectId,
         pBomRevid, pBooRevid, _cosmethod
  FROM itemsite, item
  WHERE ((itemsite_item_id=item_id)
   AND (itemsite_id=pItemsiteid));

--  Explode the newly created W/O according to metrics
  IF ( ( SELECT (metric_value='t')
         FROM metric
         WHERE (metric_name='AutoExplodeWO') ) ) THEN
    SELECT explodeWo( _woid, ( SELECT (metric_value = 'M')
                               FROM metric
                               WHERE (metric_name='WOExplosionLevel') ) ) INTO _result;
  ELSE
    _result := _woid;
  END IF;

  RETURN _result;

END;
$_$;


ALTER FUNCTION public.createwo(integer, integer, integer, numeric, date, date, text, character, integer, integer, integer, integer, text) OWNER TO admin;

--
-- TOC entry 1364 (class 1255 OID 146565920)
-- Dependencies: 4536 8
-- Name: createwomaterial(integer, integer, character, numeric, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createwomaterial(integer, integer, character, numeric, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
  pWoid ALIAS FOR $1;
  pItemsiteid ALIAS FOR $2;
  pIssueMethod ALIAS FOR $3;
  pQtyPer ALIAS FOR $4;
  pScrap ALIAS FOR $5;
  _result INTEGER;
BEGIN
  SELECT createWoMaterial(pWoid, pItemsiteid, pIssueMethod, item_inv_uom_id, pQtyPer, pScrap)
    INTO _result
    FROM itemsite JOIN item ON (itemsite_item_id=item_id)
   WHERE(itemsite_id=pItemsiteid);
  RETURN _result;
END;
$_$;


ALTER FUNCTION public.createwomaterial(integer, integer, character, numeric, numeric) OWNER TO admin;

--
-- TOC entry 1365 (class 1255 OID 146565921)
-- Dependencies: 4536 8
-- Name: createwomaterial(integer, integer, character, integer, numeric, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createwomaterial(integer, integer, character, integer, numeric, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
  pWoid ALIAS FOR $1;
  pItemsiteid ALIAS FOR $2;
  pIssueMethod ALIAS FOR $3;
  pUomId ALIAS FOR $4;
  pQtyPer ALIAS FOR $5;
  pScrap ALIAS FOR $6;
  _womatlid INTEGER;

BEGIN

  SELECT createWoMaterial(pWoid,pItemsiteid,pIssueMethod,pUomId,pQtyPer,pScrap,-1, NULL, NULL) INTO _womatlid;

  RETURN _womatlid;
END;
$_$;


ALTER FUNCTION public.createwomaterial(integer, integer, character, integer, numeric, numeric) OWNER TO admin;

--
-- TOC entry 1368 (class 1255 OID 146565924)
-- Dependencies: 4536 8
-- Name: createwomaterial(integer, integer, character, numeric, numeric, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createwomaterial(integer, integer, character, numeric, numeric, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoid ALIAS FOR $1;
  pItemsiteid ALIAS FOR $2;
  pIssueMethod ALIAS FOR $3;
  pQtyFxd ALIAS FOR $4;
  pQtyPer ALIAS FOR $5;
  pScrap ALIAS FOR $6;
  _result INTEGER;
BEGIN
  SELECT createWoMaterial(pWoid, pItemsiteid, pIssueMethod, item_inv_uom_id, pQtyFxd, pQtyPer, pScrap)
    INTO _result
    FROM itemsite JOIN item ON (itemsite_item_id=item_id)
   WHERE(itemsite_id=pItemsiteid);
  RETURN _result;
END;
$_$;


ALTER FUNCTION public.createwomaterial(integer, integer, character, numeric, numeric, numeric) OWNER TO admin;

--
-- TOC entry 1366 (class 1255 OID 146565922)
-- Dependencies: 4536 8
-- Name: createwomaterial(integer, integer, character, integer, numeric, numeric, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createwomaterial(integer, integer, character, integer, numeric, numeric, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
  pWoid ALIAS FOR $1;
  pItemsiteid ALIAS FOR $2;
  pIssueMethod ALIAS FOR $3;
  pUomId ALIAS FOR $4;
  pQtyPer ALIAS FOR $5;
  pScrap ALIAS FOR $6;
  pBomitemId ALIAS FOR $7;
  _womatlid INTEGER;

BEGIN

  _womatlid := (SELECT NEXTVAL('womatl_womatl_id_seq'));

  INSERT INTO womatl
  ( womatl_id, womatl_wo_id, womatl_itemsite_id,
    womatl_issuemethod, womatl_uom_id, womatl_qtyper, womatl_scrap,
    womatl_qtyreq, womatl_qtyiss, womatl_qtywipscrap,
    womatl_wooper_id, womatl_bomitem_id, womatl_duedate )
  SELECT _womatlid, wo_id, pItemsiteid,
         pIssueMethod, pUomId, pQtyPer, pScrap,
         roundQty(item_fractional, (wo_qtyord * (pQtyPer * (1 + pScrap)))), 0, 0,
         -1, pBomitemId, wo_startdate
  FROM wo, itemsite, item
  WHERE ( (itemsite_item_id=item_id)
   AND (wo_id=pWoid)
   AND (itemsite_id=pItemsiteid) );

  UPDATE wo
  SET wo_adhoc=TRUE
  WHERE (wo_id=pWoid);

  UPDATE wo
  SET wo_status='E'
  WHERE ( (wo_status='O')
   AND (wo_id=pWoid) );

  RETURN _womatlid;
END;
$_$;


ALTER FUNCTION public.createwomaterial(integer, integer, character, integer, numeric, numeric, integer) OWNER TO admin;

--
-- TOC entry 1369 (class 1255 OID 146565925)
-- Dependencies: 4536 8
-- Name: createwomaterial(integer, integer, character, integer, numeric, numeric, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createwomaterial(integer, integer, character, integer, numeric, numeric, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoid ALIAS FOR $1;
  pItemsiteid ALIAS FOR $2;
  pIssueMethod ALIAS FOR $3;
  pUomId ALIAS FOR $4;
  pQtyFxd ALIAS FOR $5;
  pQtyPer ALIAS FOR $6;
  pScrap ALIAS FOR $7;
  _womatlid INTEGER;

BEGIN

  SELECT createWoMaterial(pWoid,pItemsiteid,pIssueMethod,pUomId,pQtyFxd,pQtyPer,pScrap,-1, NULL, NULL) INTO _womatlid;

  RETURN _womatlid;
END;
$_$;


ALTER FUNCTION public.createwomaterial(integer, integer, character, integer, numeric, numeric, numeric) OWNER TO admin;

--
-- TOC entry 1367 (class 1255 OID 146565923)
-- Dependencies: 4536 8
-- Name: createwomaterial(integer, integer, character, integer, numeric, numeric, integer, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createwomaterial(integer, integer, character, integer, numeric, numeric, integer, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
  pWoid ALIAS FOR $1;
  pItemsiteid ALIAS FOR $2;
  pIssueMethod ALIAS FOR $3;
  pUomId ALIAS FOR $4;
  pQtyPer ALIAS FOR $5;
  pScrap ALIAS FOR $6;
  pBomitemId ALIAS FOR $7;
  pNotes ALIAS FOR $8;
  pRef ALIAS FOR $9;
  _womatlid INTEGER;
  _p RECORD;

BEGIN

  _womatlid := (SELECT NEXTVAL('womatl_womatl_id_seq'));

  INSERT INTO womatl
  ( womatl_id, womatl_wo_id, womatl_itemsite_id,
    womatl_issuemethod, womatl_uom_id, womatl_qtyper, womatl_scrap,
    womatl_qtyreq, womatl_qtyiss, womatl_qtywipscrap,
    womatl_wooper_id, womatl_bomitem_id, womatl_duedate, womatl_notes, womatl_ref )
  SELECT _womatlid, wo_id, pItemsiteid,
         pIssueMethod, pUomId, pQtyPer, pScrap,
         roundQty(item_fractional, (wo_qtyord * (pQtyPer * (1 + pScrap)))), 0, 0,
         -1, pBomitemId, wo_startdate, pNotes, pRef
  FROM wo, itemsite, item
  WHERE ( (itemsite_item_id=item_id)
   AND (wo_id=pWoid)
   AND (itemsite_id=pItemsiteid) );

-- Handle all of the Phantom material requirements
  WHILE ( ( SELECT COUNT(*)
            FROM womatl, itemsite, item
            WHERE ( (womatl_itemsite_id=itemsite_id)
             AND (itemsite_item_id=item_id)
             AND (womatl_wo_id=pWoid)
             AND (item_type='F') ) ) > 0 ) LOOP

    FOR _p IN SELECT wo_qtyord, wo_startdate, womatl_id, womatl_wooper_id
              FROM wo, womatl, itemsite, item
              WHERE ( (womatl_itemsite_id=itemsite_id)
               AND (itemsite_item_id=item_id)
               AND (item_type='F')
               AND (womatl_wo_id=wo_id)
               AND (wo_id=pWoid) ) LOOP

      INSERT INTO womatl
      ( womatl_wo_id, womatl_itemsite_id, womatl_wooper_id,
        womatl_schedatwooper, womatl_duedate,
        womatl_uom_id, womatl_qtyper, womatl_scrap,
        womatl_qtyreq,
        womatl_qtyiss, womatl_qtywipscrap,
        womatl_lastissue, womatl_lastreturn,
        womatl_cost, womatl_picklist, womatl_createwo,
        womatl_issuemethod, womatl_notes, womatl_ref )
      SELECT pWoid, cs.itemsite_id, _p.womatl_wooper_id,
             womatl_schedatwooper, womatl_duedate,
             bomitem_uom_id, (bomitem_qtyper * womatl_qtyper), bomitem_scrap,
             roundQty(itemuomfractionalbyuom(bomitem_item_id, bomitem_uom_id), (_p.wo_qtyord * bomitem_qtyper * womatl_qtyper * (1 + bomitem_scrap))),
             0, 0,
             startOfTime(), startOfTime(),
             0, ci.item_picklist, ( (ci.item_type='M') AND (bomitem_createwo) ),
             bomitem_issuemethod, bomitem_notes, bomitem_ref
      FROM wo, womatl, bomitem,
           itemsite AS cs, itemsite AS ps,
           item AS ci, item AS pi
      WHERE ( (womatl_itemsite_id=ps.itemsite_id)
       AND (womatl_wo_id=wo_id)
       AND (bomitem_parent_item_id=pi.item_id)
       AND (bomitem_item_id=ci.item_id)
       AND (ps.itemsite_warehous_id=cs.itemsite_warehous_id)
       AND (cs.itemsite_item_id=ci.item_id)
       AND (ps.itemsite_item_id=pi.item_id)
       AND (woEffectiveDate(_p.wo_startdate) BETWEEN bomitem_effective AND (bomitem_expires - 1))
       AND (womatl_id=_p.womatl_id));

      DELETE FROM womatl
      WHERE (womatl_id=_p.womatl_id);

    END LOOP;
  END LOOP;

  UPDATE wo
  SET wo_adhoc=TRUE
  WHERE (wo_id=pWoid);

  UPDATE wo
  SET wo_status='E'
  WHERE ( (wo_status='O')
   AND (wo_id=pWoid) );

  RETURN _womatlid;
END;
$_$;


ALTER FUNCTION public.createwomaterial(integer, integer, character, integer, numeric, numeric, integer, text, text) OWNER TO admin;

--
-- TOC entry 1370 (class 1255 OID 146565926)
-- Dependencies: 4536 8
-- Name: createwomaterial(integer, integer, character, integer, numeric, numeric, numeric, integer, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createwomaterial(integer, integer, character, integer, numeric, numeric, numeric, integer, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoid ALIAS FOR $1;
  pItemsiteid ALIAS FOR $2;
  pIssueMethod ALIAS FOR $3;
  pUomId ALIAS FOR $4;
  pQtyFxd ALIAS FOR $5;
  pQtyPer ALIAS FOR $6;
  pScrap ALIAS FOR $7;
  pBomitemId ALIAS FOR $8;
  pNotes ALIAS FOR $9;
  pRef ALIAS FOR $10;
  _womatlid INTEGER;

BEGIN

  SELECT createWoMaterial(pWoid,pItemsiteid,pIssueMethod,pUomId,pQtyFxd,pQtyPer,pScrap,pBomitemId,pNotes,pRef,NULL,NULL) INTO _womatlid;

  RETURN _womatlid;
END;
$_$;


ALTER FUNCTION public.createwomaterial(integer, integer, character, integer, numeric, numeric, numeric, integer, text, text) OWNER TO admin;

--
-- TOC entry 1371 (class 1255 OID 146565927)
-- Dependencies: 4536 8
-- Name: createwomaterial(integer, integer, character, integer, numeric, numeric, numeric, integer, text, text, integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createwomaterial(pwoid integer, pitemsiteid integer, pissuemethod character, puomid integer, pqtyfxd numeric, pqtyper numeric, pscrap numeric, pbomitemid integer, pnotes text, pref text, pwooperid integer, ppicklist boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _womatlid INTEGER;

BEGIN

  SELECT createWoMaterial(pWoid,
                          pItemsiteid,
                          pIssueMethod,
                          pUomId,
                          pQtyFxd,
                          pQtyPer,
                          pScrap,
                          pBomitemId,
                          pNotes,
                          pRef,
                          pWooperId,
                          pPickList,
                          0.0) INTO _womatlid;

  RETURN _womatlid;
END;
$$;


ALTER FUNCTION public.createwomaterial(pwoid integer, pitemsiteid integer, pissuemethod character, puomid integer, pqtyfxd numeric, pqtyper numeric, pscrap numeric, pbomitemid integer, pnotes text, pref text, pwooperid integer, ppicklist boolean) OWNER TO admin;

--
-- TOC entry 1372 (class 1255 OID 146565928)
-- Dependencies: 4536 8
-- Name: createwomaterial(integer, integer, character, integer, numeric, numeric, numeric, integer, text, text, integer, boolean, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION createwomaterial(pwoid integer, pitemsiteid integer, pissuemethod character, puomid integer, pqtyfxd numeric, pqtyper numeric, pscrap numeric, pbomitemid integer, pnotes text, pref text, pwooperid integer, ppicklist boolean, pprice numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _womatlid INTEGER;
  _p RECORD;

BEGIN

  _womatlid := (SELECT NEXTVAL('womatl_womatl_id_seq'));

  INSERT INTO womatl
  ( womatl_id, womatl_wo_id, womatl_itemsite_id,
    womatl_issuemethod, womatl_uom_id, womatl_qtyfxd,
    womatl_qtyper, womatl_scrap, womatl_qtyreq,
    womatl_qtyiss, womatl_qtywipscrap, womatl_wooper_id,
    womatl_bomitem_id, womatl_duedate, womatl_notes,
    womatl_ref, womatl_picklist, womatl_price )
  SELECT _womatlid, wo_id, pItemsiteid,
         pIssueMethod, pUomId, pQtyFxd,
         pQtyPer, pScrap, roundQty(item_fractional, (pQtyFxd + wo_qtyord * pQtyPer) * (1 + pScrap) ),
         0, 0, COALESCE(pWooperId, -1),
         pBomitemId, wo_startdate, pNotes,
         pRef, COALESCE(pPickList, item_picklist), pPrice
  FROM wo, itemsite JOIN item ON (item_id=itemsite_item_id)
  WHERE ( (wo_id=pWoid)
   AND (itemsite_id=pItemsiteid) );

-- Handle all of the Phantom material requirements
  WHILE ( ( SELECT COUNT(*)
            FROM womatl, itemsite, item
            WHERE ( (womatl_itemsite_id=itemsite_id)
             AND (itemsite_item_id=item_id)
             AND (womatl_wo_id=pWoid)
             AND (item_type='F') ) ) > 0 ) LOOP

    FOR _p IN SELECT wo_qtyord, wo_startdate, womatl_id, womatl_wooper_id
              FROM wo, womatl, itemsite, item
              WHERE ( (womatl_itemsite_id=itemsite_id)
               AND (itemsite_item_id=item_id)
               AND (item_type='F')
               AND (womatl_wo_id=wo_id)
               AND (wo_id=pWoid) ) LOOP

      INSERT INTO womatl
      ( womatl_wo_id, womatl_itemsite_id, womatl_wooper_id,
        womatl_schedatwooper, womatl_duedate,
        womatl_uom_id, womatl_qtyfxd, womatl_qtyper, womatl_scrap,
        womatl_qtyreq,
        womatl_qtyiss, womatl_qtywipscrap,
        womatl_lastissue, womatl_lastreturn,
        womatl_cost, womatl_picklist, womatl_createwo,
        womatl_issuemethod, womatl_notes, womatl_ref )
      SELECT pWoid, cs.itemsite_id, _p.womatl_wooper_id,
             womatl_schedatwooper, womatl_duedate,
             bomitem_uom_id, bomitem_qtyfxd, (bomitem_qtyper * womatl_qtyper), bomitem_scrap,
             roundQty(itemuomfractionalbyuom(bomitem_item_id, bomitem_uom_id),
                     ((bomitem_qtyfxd + _p.wo_qtyord * bomitem_qtyper) * womatl_qtyper * (1 + bomitem_scrap))),
             0, 0,
             startOfTime(), startOfTime(),
             0, ci.item_picklist, ( (ci.item_type='M') AND (bomitem_createwo) ),
             bomitem_issuemethod, bomitem_notes, bomitem_ref
      FROM wo, womatl, bomitem,
           itemsite AS cs, itemsite AS ps,
           item AS ci, item AS pi
      WHERE ( (womatl_itemsite_id=ps.itemsite_id)
       AND (womatl_wo_id=wo_id)
       AND (bomitem_parent_item_id=pi.item_id)
       AND (bomitem_item_id=ci.item_id)
       AND (ps.itemsite_warehous_id=cs.itemsite_warehous_id)
       AND (cs.itemsite_item_id=ci.item_id)
       AND (ps.itemsite_item_id=pi.item_id)
       AND (woEffectiveDate(_p.wo_startdate) BETWEEN bomitem_effective AND (bomitem_expires - 1))
       AND (womatl_id=_p.womatl_id));

      DELETE FROM womatl
      WHERE (womatl_id=_p.womatl_id);

    END LOOP;
  END LOOP;

  UPDATE wo
  SET wo_adhoc=TRUE
  WHERE (wo_id=pWoid);

  UPDATE wo
  SET wo_status='E'
  WHERE ( (wo_status='O')
   AND (wo_id=pWoid) );

  RETURN _womatlid;
END;
$$;


ALTER FUNCTION public.createwomaterial(pwoid integer, pitemsiteid integer, pissuemethod character, puomid integer, pqtyfxd numeric, pqtyper numeric, pscrap numeric, pbomitemid integer, pnotes text, pref text, pwooperid integer, ppicklist boolean, pprice numeric) OWNER TO admin;

--
-- TOC entry 1373 (class 1255 OID 146565929)
-- Dependencies: 4536 8
-- Name: creditmemototal(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION creditmemototal(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCreditmemoId ALIAS FOR $1;
  _result       NUMERIC;

BEGIN

  -- TO DO:  Add in line item taxes
  SELECT COALESCE(cmhead_freight,0.0) + COALESCE(cmhead_misc,0.0) +
         ( SELECT COALESCE(ROUND(SUM((cmitem_qtycredit * cmitem_qty_invuomratio) * cmitem_unitprice / cmitem_price_invuomratio), 2), 0.0)
             FROM cmitem
            WHERE (cmitem_cmhead_id=cmhead_id)
           ) +
         (SELECT COALESCE(SUM(tax) * -1, 0) AS tax
           FROM ( SELECT ROUND(SUM(taxdetail_tax),2) AS tax
                  FROM tax
                  JOIN calculateTaxDetailSummary('CM', cmhead_id, 'T') ON (taxdetail_tax_id=tax_id)
                  GROUP BY tax_id) AS data)
           INTO _result
  FROM cmhead
  WHERE (cmhead_id=pCreditmemoId);

  IF (NOT FOUND) THEN
    return 0;
  ELSE
    RETURN _result;
  END IF;

END;
$_$;


ALTER FUNCTION public.creditmemototal(integer) OWNER TO admin;

--
-- TOC entry 205 (class 1259 OID 146565930)
-- Dependencies: 5947 5948 5949 5950 5951 8
-- Name: crmacct; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE crmacct (
    crmacct_id integer NOT NULL,
    crmacct_number text NOT NULL,
    crmacct_name text,
    crmacct_active boolean DEFAULT true,
    crmacct_type character(1),
    crmacct_cust_id integer,
    crmacct_competitor_id integer,
    crmacct_partner_id integer,
    crmacct_prospect_id integer,
    crmacct_vend_id integer,
    crmacct_cntct_id_1 integer,
    crmacct_cntct_id_2 integer,
    crmacct_parent_id integer,
    crmacct_notes text,
    crmacct_taxauth_id integer,
    crmacct_owner_username text,
    crmacct_emp_id integer,
    crmacct_salesrep_id integer,
    crmacct_usr_username text,
    CONSTRAINT crmacct_crmacct_number_check CHECK ((crmacct_number <> ''::text)),
    CONSTRAINT crmacct_crmacct_type_check CHECK ((crmacct_type = ANY (ARRAY['I'::bpchar, 'O'::bpchar]))),
    CONSTRAINT crmacct_crmacct_usr_username_check CHECK ((btrim(crmacct_usr_username) <> ''::text)),
    CONSTRAINT crmacct_owner_username_check CHECK ((btrim(crmacct_owner_username) <> ''::text))
);


ALTER TABLE public.crmacct OWNER TO admin;


--
-- TOC entry 1374 (class 1255 OID 146565941)
-- Dependencies: 2781 4536 8
-- Name: crmacct(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION crmacct() RETURNS SETOF crmacct
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _row crmacct%ROWTYPE;
  _priv TEXT;
  _grant BOOLEAN;

BEGIN
  -- This query will give us the most permissive privilege the user has been granted
  SELECT privilege, granted INTO _priv, _grant
  FROM privgranted
  WHERE privilege IN ('MaintainAllCRMAccounts','ViewAllCRMAccounts','MaintainPersonalCRMAccounts','ViewPersonalCRMAccounts')
  ORDER BY granted DESC, sequence
  LIMIT 1;

  -- If have an 'All' privilege return all results
  IF (_priv ~ 'All' AND _grant) THEN
    FOR _row IN
      SELECT * FROM crmacct
    LOOP
      RETURN NEXT _row;
    END LOOP;
  -- Otherwise if have any other grant, must be personal privilege.
  ELSIF (_grant) THEN
    FOR _row IN
      SELECT * FROM crmacct
      WHERE crmacct_owner_username = getEffectiveXtUser()
    LOOP
      RETURN NEXT _row;
    END LOOP;
  END IF;

  RETURN;

END;
$$;


ALTER FUNCTION public.crmacct() OWNER TO admin;

--
-- TOC entry 8974 (class 0 OID 0)
-- Dependencies: 1374
-- Name: FUNCTION crmacct(); Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON FUNCTION crmacct() IS 'A table function that returns CRM Account results according to privilege settings.';


--
-- TOC entry 1375 (class 1255 OID 146565942)
-- Dependencies: 8
-- Name: crypt(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION crypt(text, text) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgcrypto', 'pg_crypt';


ALTER FUNCTION public.crypt(text, text) OWNER TO admin;

--
-- TOC entry 1376 (class 1255 OID 146565943)
-- Dependencies: 4536 8
-- Name: currconcat(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION currconcat(integer) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  id ALIAS FOR $1;
  returnVal   VARCHAR(15) := '';
BEGIN
  SELECT currConcat(curr_abbr, curr_symbol) INTO returnVal
      FROM curr_symbol WHERE curr_id = id;
  RETURN returnVal;
END;
$_$;


ALTER FUNCTION public.currconcat(integer) OWNER TO admin;

--
-- TOC entry 1377 (class 1255 OID 146565944)
-- Dependencies: 4536 8
-- Name: currconcat(character varying, character varying); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION currconcat(character varying, character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  curr_abbr   ALIAS FOR $1;
  curr_symbol ALIAS FOR $2;
  returnVal   VARCHAR(15) := '';
BEGIN
  IF length(trim(curr_abbr)) > 0 AND length(trim(curr_symbol)) > 0 THEN
      returnVal := trim(curr_abbr) || ' - ' || trim(curr_symbol);

  ELSIF length(trim(curr_abbr)) > 0 THEN
      returnVal := curr_abbr;

  ELSIF length(trim(curr_symbol)) > 0 THEN
      returnVal := curr_symbol;
  END IF;

  RETURN returnVal;
END;
$_$;


ALTER FUNCTION public.currconcat(character varying, character varying) OWNER TO admin;

--
-- TOC entry 1378 (class 1255 OID 146565945)
-- Dependencies: 4536 8
-- Name: currentapmemonumber(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION currentapmemonumber() RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _number INTEGER;

BEGIN

  SELECT orderseq_number INTO _number
  FROM orderseq
  WHERE (orderseq_name='APMemoNumber');
  IF (NOT FOUND) THEN
    _number := 0;
  END IF;

  RETURN _number;

END;
$$;


ALTER FUNCTION public.currentapmemonumber() OWNER TO admin;

--
-- TOC entry 1351 (class 1255 OID 146565946)
-- Dependencies: 4536 8
-- Name: currentarmemonumber(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION currentarmemonumber() RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _number INTEGER;

BEGIN

  SELECT orderseq_number INTO _number
  FROM orderseq
  WHERE (orderseq_name='ARMemoNumber');
  IF (NOT FOUND) THEN
    _number := 0;
  END IF;

  RETURN _number;

END;
$$;


ALTER FUNCTION public.currentarmemonumber() OWNER TO admin;

--
-- TOC entry 1172 (class 1255 OID 146565947)
-- Dependencies: 4536 8
-- Name: currentcashrcptnumber(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION currentcashrcptnumber() RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _number INTEGER;

BEGIN

  SELECT orderseq_number INTO _number
  FROM orderseq
  WHERE (orderseq_name='CashRcptNumber');
  IF (NOT FOUND) THEN
    _number := 0;
  END IF;

  RETURN _number;

END;
$$;


ALTER FUNCTION public.currentcashrcptnumber() OWNER TO admin;

--
-- TOC entry 1267 (class 1255 OID 146565948)
-- Dependencies: 4536 8
-- Name: currentnumber(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION currentnumber(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pName   ALIAS FOR $1;
  _number INTEGER;

BEGIN
  SELECT orderseq_number INTO _number
  FROM orderseq
  WHERE (orderseq_name=pName);
  IF (NOT FOUND) THEN
    _number := 0;
  END IF;

  RETURN _number;

END;
$_$;


ALTER FUNCTION public.currentnumber(text) OWNER TO admin;

--
-- TOC entry 1379 (class 1255 OID 146565949)
-- Dependencies: 4536 8
-- Name: currexchangecheckoverlap(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION currexchangecheckoverlap() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
    numberOfOverlaps INTEGER NOT NULL := 0;
    curr_string VARCHAR(16);
    new_id INTEGER;
BEGIN
  new_id := NEW.curr_id;
  -- ensure that effective date <= expiration date
  IF NEW.curr_effective > NEW.curr_expires THEN
    RAISE EXCEPTION
      'Effective date % must be earlier than expiration date %',
      NEW.curr_effective, NEW.curr_expires;
  END IF;

  -- ensure new exchange rate does not overlap in time with any others
  SELECT count(*) INTO numberOfOverlaps
    FROM curr_rate
    WHERE curr_id = NEW.curr_id
      AND curr_rate_id != NEW.curr_rate_id
      AND (
          (curr_effective BETWEEN
              NEW.curr_effective AND NEW.curr_expires OR
           curr_expires BETWEEN
              NEW.curr_effective AND NEW.curr_expires)
         OR (curr_effective <= NEW.curr_effective AND
             curr_expires   >= NEW.curr_expires)
      );
  IF numberOfOverlaps > 0 THEN
    SELECT currConcat(curr_symbol, curr_abbr)
      INTO curr_string
      FROM curr_symbol
      WHERE curr_id = new_id;
    RAISE EXCEPTION
      'The date range % to % overlaps with another date range.',
      NEW.curr_effective, NEW.curr_expires;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.currexchangecheckoverlap() OWNER TO admin;

--
-- TOC entry 1380 (class 1255 OID 146565950)
-- Dependencies: 4536 8
-- Name: currgain(integer, numeric, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION currgain(integer, numeric, date, date) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pId ALIAS FOR $1;
  pValue ALIAS FOR $2;
  pStart ALIAS FOR $3;
  pEnd ALIAS FOR $4;
  _start DATE;
  _end DATE;
  _gain NUMERIC;
  _multiplier	INTEGER	:= 1;

BEGIN
  IF (pEnd = pStart OR pValue = 0) THEN
    RETURN 0;
  END IF;

  IF (pStart > pEnd) THEN
    _start := pEnd;
    _end   := pStart;
    _multiplier := -1;
  ELSE
    _start := pStart;
    _end := pEnd;
  END IF;

  _gain := currToBase(pId, pValue, _start) - currToBase(pId, pValue, _end);
  IF (_gain IS NULL) THEN
    RAISE EXCEPTION 'Missing exchange rate for curr_id % on % or %',
                    pId, _start, _end;
  END IF;

  RETURN _gain * _multiplier;
END;
$_$;


ALTER FUNCTION public.currgain(integer, numeric, date, date) OWNER TO admin;

--
-- TOC entry 1381 (class 1255 OID 146565951)
-- Dependencies: 4536 8
-- Name: curronebase(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION curronebase() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  baseCount INTEGER := 0;
BEGIN
  IF NEW.curr_base = TRUE THEN
    SELECT count(*)
      INTO baseCount
      FROM curr_symbol
      WHERE curr_base = TRUE
        AND curr_id != NEW.curr_id;
    IF baseCount > 0 THEN
      RAISE EXCEPTION
          'Cannot make % - % the base currency because one is already defined.',
          NEW.curr_symbol, NEW.curr_abbr;
    ELSE
      SELECT count(*)
        INTO baseCount
        FROM curr_rate
        WHERE curr_id = NEW.curr_id;
      IF baseCount = 0 THEN
        -- put a row in the curr_rate table to avoid special-case
        -- code for converting base currency to base currency
        INSERT INTO curr_rate
          (curr_id, curr_rate, curr_effective, curr_expires) VALUES
          (NEW.curr_id, 1, startOfTime(), endOfTime());
      END IF;
    END IF;
  END IF;
  RETURN NEW;
END;
$$;


ALTER FUNCTION public.curronebase() OWNER TO admin;

--
-- TOC entry 1382 (class 1255 OID 146565952)
-- Dependencies: 4536 8
-- Name: currrate(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION currrate(integer, date) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN currRate($1, NULL, $2);

END;
$_$;


ALTER FUNCTION public.currrate(integer, date) OWNER TO admin;

--
-- TOC entry 1383 (class 1255 OID 146565953)
-- Dependencies: 4536 8
-- Name: currrate(integer, integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION currrate(pfromcurr integer, ptocurr integer, pdate date) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _fromRate NUMERIC := 1.0;
  _toRate NUMERIC := 1.0;
  _returnVal NUMERIC := 1.0;
BEGIN
  IF pFromCurr = pToCurr THEN
    RETURN _returnVal;
  END IF;

  IF (pFromCurr IS NOT NULL) THEN
    SELECT curr_rate INTO _fromRate
    FROM curr_rate
    WHERE ( (curr_id=pFromCurr)
    AND (pDate BETWEEN curr_effective AND curr_expires) );

    IF ( NOT FOUND) THEN
      RAISE EXCEPTION 'Currency exchange rate for currency % not found on %', pFromCurr, formatDate(pDate);
    END IF;
  END IF;

  IF (pToCurr IS NOT NULL) THEN
    SELECT curr_rate INTO _toRate
    FROM curr_rate
    WHERE ( (curr_id=pToCurr)
    AND (pDate BETWEEN curr_effective AND curr_expires) );

    IF ( NOT FOUND) THEN
      RAISE EXCEPTION 'Currency exchange rate for currency % not found on %', pToCurr, formatDate(pDate);
    END IF;
  END IF;

  _returnVal := _fromRate / _toRate;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.currrate(pfromcurr integer, ptocurr integer, pdate date) OWNER TO admin;

--
-- TOC entry 1384 (class 1255 OID 146565954)
-- Dependencies: 4536 8
-- Name: currtobase(integer, numeric, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION currtobase(integer, numeric, date) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pId     ALIAS FOR $1;
  pValue  ALIAS FOR $2;
  _date  DATE;
  _output NUMERIC;
BEGIN
  _date := $3;
  IF _date IS NULL THEN
    _date := 'now';
  END IF;

  IF pValue = 0 OR pValue IS NULL THEN
    _output := 0;
  ELSIF (baseCurrId() = pId) THEN
    _output := pValue;
  ELSE
    SELECT pValue / curr_rate
        INTO  _output
      FROM  curr_rate
     WHERE curr_id = pId
       AND _date BETWEEN curr_effective AND curr_expires;
    IF (_output IS NULL OR NOT FOUND) THEN
      RAISE EXCEPTION 'No exchange rate for % on %', pId, _date;
    END IF;
  END IF;
  RETURN _output;
END;
$_$;


ALTER FUNCTION public.currtobase(integer, numeric, date) OWNER TO admin;

--
-- TOC entry 1385 (class 1255 OID 146565955)
-- Dependencies: 4536 8
-- Name: currtocurr(integer, integer, numeric, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION currtocurr(integer, integer, numeric, date) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pFromCurr ALIAS FOR $1;
  pToCurr ALIAS FOR $2;
  pValue   ALIAS FOR $3;
  pEffective ALIAS FOR $4;
  _convertedValue NUMERIC;
  _fromRate NUMERIC;
  _toRate NUMERIC;
BEGIN
  IF pFromCurr = pToCurr THEN
    RETURN pValue;
  END IF;

  IF pValue = 0 OR pValue IS NULL THEN
    RETURN 0;
  END IF;

  SELECT curr_rate INTO _fromRate
  FROM curr_rate
  WHERE curr_id = pFromCurr
    AND pEffective BETWEEN curr_effective AND curr_expires;

  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'No exchange rate for % on %', pFromCurr, pEffective;
  END IF;

  SELECT curr_rate INTO _toRate
  FROM curr_rate
  WHERE curr_id = pToCurr
    AND pEffective BETWEEN curr_effective AND curr_expires;

  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'No exchange rate for % on %', pToCurr, pEffective;
  END IF;

  _convertedValue := pValue * _toRate / _fromRate;

  RETURN _convertedValue;
END;
$_$;


ALTER FUNCTION public.currtocurr(integer, integer, numeric, date) OWNER TO admin;

--
-- TOC entry 1387 (class 1255 OID 146565956)
-- Dependencies: 4536 8
-- Name: currtolocal(integer, numeric, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION currtolocal(integer, numeric, date) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
    pId     ALIAS FOR $1;
    pValue  ALIAS FOR $2;
    _date   DATE;
    _output NUMERIC;
BEGIN
    _date := $3;
    IF _date IS NULL THEN
        _date := 'now';
    END IF;

    IF pValue = 0 OR pValue IS NULL THEN
        _output := 0;
    ELSIF (baseCurrId() = pId) THEN
      _output := pValue;
    ELSE
        SELECT pValue * curr_rate
            INTO  _output
            FROM  curr_rate
            WHERE curr_id = pId
              AND _date BETWEEN curr_effective AND curr_expires;
        IF (_output IS NULL OR NOT FOUND) THEN
          RAISE EXCEPTION 'No exchange rate for % on %', pId, _date;
        END IF;
    END IF;
    RETURN _output;
END;
$_$;


ALTER FUNCTION public.currtolocal(integer, numeric, date) OWNER TO admin;

--
-- TOC entry 1388 (class 1255 OID 146565957)
-- Dependencies: 8
-- Name: custitem(integer, integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION custitem(cust_id integer, shipto_id integer DEFAULT (-1), asof date DEFAULT ('now'::text)::date) RETURNS SETOF integer
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.

  -- Non Exclusive
  SELECT item_id
  FROM item
  WHERE (NOT item_exclusive)
   AND (item_sold)
  UNION
  -- Exclusive, Shipto match
  SELECT item_id
  FROM item
    JOIN ipsiteminfo ON (ipsitem_item_id=item_id)
    JOIN ipshead ON (ipshead_id=ipsitem_ipshead_id)
    JOIN ipsass ON (ipsass_ipshead_id=ipshead_id)
  WHERE (item_exclusive)
   AND (item_sold)
   AND ($2 != -1)
   AND (ipsass_shipto_id=$2)
   AND ($3 BETWEEN ipshead_effective AND (ipshead_expires - 1))
  UNION
  SELECT item_id
  FROM item
    JOIN ipsiteminfo ON (ipsitem_prodcat_id=item_prodcat_id)
    JOIN ipshead ON (ipshead_id=ipsitem_ipshead_id)
    JOIN ipsass ON (ipsass_ipshead_id=ipshead_id)
  WHERE (item_exclusive)
   AND (item_sold)
   AND ($2 != -1)
   AND (ipsass_shipto_id=$2)
   AND ($3 BETWEEN ipshead_effective AND (ipshead_expires - 1))
  UNION
   -- Exclusive, Shipto pattern match
  SELECT item_id
  FROM item
    JOIN ipsiteminfo ON (ipsitem_item_id=item_id)
    JOIN ipshead ON (ipshead_id=ipsitem_ipshead_id)
    JOIN ipsass ON (ipsass_ipshead_id=ipshead_id)
    JOIN shiptoinfo ON (shipto_num ~ ipsass_shipto_pattern)
  WHERE (item_exclusive)
   AND (item_sold)
   AND (COALESCE(length(ipsass_shipto_pattern), 0) > 0)
   AND (ipsass_cust_id=$1)
   AND ($2 != -1)
   AND (shipto_id=$2)
   AND ($3 BETWEEN ipshead_effective AND (ipshead_expires - 1))
  UNION
  SELECT item_id
  FROM item
    JOIN ipsiteminfo ON (ipsitem_prodcat_id=item_prodcat_id)
    JOIN ipshead ON (ipshead_id=ipsitem_ipshead_id)
    JOIN ipsass ON (ipsass_ipshead_id=ipshead_id)
    JOIN shiptoinfo ON (shipto_num ~ ipsass_shipto_pattern)
  WHERE (item_exclusive)
   AND (item_sold)
   AND (COALESCE(length(ipsass_shipto_pattern), 0) > 0)
   AND (ipsass_cust_id=$1)
   AND ($2 != -1)
   AND (shipto_id=$2)
   AND ($3 BETWEEN ipshead_effective AND (ipshead_expires - 1))
  UNION
   -- Exclusive, Customer match
  SELECT item_id
  FROM item
    JOIN ipsiteminfo ON (ipsitem_item_id=item_id)
    JOIN ipshead ON (ipshead_id=ipsitem_ipshead_id)
    JOIN ipsass ON (ipsass_ipshead_id=ipshead_id)
  WHERE (item_exclusive)
   AND (item_sold)
   AND (ipsass_cust_id=$1)
   AND (ipsass_shipto_id=-1)
   AND (ipsass_shipto_pattern='')
   AND (ipsass_custtype_id=-1)
   AND (ipsass_custtype_pattern='')
   AND ($3 BETWEEN ipshead_effective AND (ipshead_expires - 1))
  UNION
  SELECT item_id
  FROM item
    JOIN ipsiteminfo ON (ipsitem_prodcat_id=item_prodcat_id)
    JOIN ipshead ON (ipshead_id=ipsitem_ipshead_id)
    JOIN ipsass ON (ipsass_ipshead_id=ipshead_id)
  WHERE (item_exclusive)
   AND (item_sold)
   AND (ipsass_cust_id=$1)
   AND (ipsass_shipto_id=-1)
   AND (ipsass_shipto_pattern='')
   AND (ipsass_custtype_id=-1)
   AND (ipsass_custtype_pattern='')
   AND ($3 BETWEEN ipshead_effective AND (ipshead_expires - 1))
  UNION
  -- Exclusive, Customer Type match
  SELECT item_id
  FROM item
    JOIN ipsiteminfo ON (ipsitem_item_id=item_id)
    JOIN ipshead ON (ipshead_id=ipsitem_ipshead_id)
    JOIN ipsass ON (ipsass_ipshead_id=ipshead_id)
    JOIN custinfo ON (ipsass_custtype_id=cust_custtype_id)
  WHERE (item_exclusive)
   AND (item_sold)
   AND (cust_id=$1)
   AND ($3 BETWEEN ipshead_effective AND (ipshead_expires - 1))
  UNION
  SELECT item_id
  FROM item
    JOIN ipsiteminfo ON (ipsitem_prodcat_id=item_prodcat_id)
    JOIN ipshead ON (ipshead_id=ipsitem_ipshead_id)
    JOIN ipsass ON (ipsass_ipshead_id=ipshead_id)
    JOIN custinfo ON (ipsass_custtype_id=cust_custtype_id)
  WHERE (item_exclusive)
   AND (item_sold)
   AND (cust_id=$1)
   AND ($3 BETWEEN ipshead_effective AND (ipshead_expires - 1))
  UNION
  -- Exclusive, Customer Type pattern match
  SELECT item_id
  FROM item
    JOIN ipsiteminfo ON (ipsitem_item_id=item_id)
    JOIN ipshead ON (ipshead_id=ipsitem_ipshead_id)
    JOIN ipsass ON (ipsass_ipshead_id=ipshead_id)
    JOIN custtype ON (custtype_code ~ ipsass_custtype_pattern)
    JOIN custinfo ON (cust_custtype_id=custtype_id)
  WHERE (item_exclusive)
   AND (item_sold)
   AND (COALESCE(length(ipsass_custtype_pattern), 0) > 0)
   AND (cust_id=$1)
   AND ($3 BETWEEN ipshead_effective AND (ipshead_expires - 1))
  UNION
  SELECT item_id
  FROM item
    JOIN ipsiteminfo ON (ipsitem_prodcat_id=item_prodcat_id)
    JOIN ipshead ON (ipshead_id=ipsitem_ipshead_id)
    JOIN ipsass ON (ipsass_ipshead_id=ipshead_id)
    JOIN custtype ON (custtype_code ~ ipsass_custtype_pattern)
    JOIN custinfo ON (cust_custtype_id=custtype_id)
  WHERE (item_exclusive)
   AND (item_sold)
   AND (COALESCE(length(ipsass_custtype_pattern), 0) > 0)
   AND (cust_id=$1)
   AND ($3 BETWEEN ipshead_effective AND (ipshead_expires - 1))

$_$;


ALTER FUNCTION public.custitem(cust_id integer, shipto_id integer, asof date) OWNER TO admin;

--
-- TOC entry 1389 (class 1255 OID 146565958)
-- Dependencies: 4536 8
-- Name: customercanpurchase(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION customercanpurchase(integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pitemid ALIAS FOR $1;
  pCustid ALIAS FOR $2;

BEGIN
  RETURN customerCanPurchase(pitemid, pCustid, -1);
END;
$_$;


ALTER FUNCTION public.customercanpurchase(integer, integer) OWNER TO admin;

--
-- TOC entry 1390 (class 1255 OID 146565959)
-- Dependencies: 4536 8
-- Name: customercanpurchase(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION customercanpurchase(integer, integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pitemid ALIAS FOR $1;
  pCustid ALIAS FOR $2;
  pShiptoid AlIAS FOR $3;
  _id INTEGER;
  _item RECORD;

BEGIN
  RETURN customerCanPurchase(pitemid, pCustid, pShiptoid, CURRENT_DATE);
END;
$_$;


ALTER FUNCTION public.customercanpurchase(integer, integer, integer) OWNER TO admin;

--
-- TOC entry 1391 (class 1255 OID 146565960)
-- Dependencies: 4536 8
-- Name: customercanpurchase(integer, integer, integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION customercanpurchase(integer, integer, integer, date) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pitemid ALIAS FOR $1;
  pCustid ALIAS FOR $2;
  pShiptoid AlIAS FOR $3;
  pAsOf ALIAS FOR $4;
  _id INTEGER;
  _item RECORD;

BEGIN

  SELECT item_sold, item_exclusive
    INTO _item
    FROM item
   WHERE(item_id=pItemid);

--  Make sure that this is at least a sold Item
  IF (NOT _item.item_sold) THEN
    RETURN FALSE;
  END IF;

--  Everyone can purchase a non-exclusive item
  IF (NOT _item.item_exclusive) THEN
    RETURN TRUE;
  END IF;

  IF(pShiptoid != -1) THEN
--  Check for a shipto Assigned Price
    SELECT ipsitem_id INTO _id
      FROM ipsiteminfo, ipshead, ipsass
     WHERE((ipsitem_ipshead_id=ipshead_id)
       AND (ipsass_ipshead_id=ipshead_id)
       AND (pAsOf BETWEEN ipshead_effective AND (ipshead_expires - 1))
       AND (ipsitem_item_id=pItemid)
       AND (ipsass_shipto_id != -1)
       AND (ipsass_shipto_id=pShiptoid))
     LIMIT 1;
    IF (FOUND) THEN
      RETURN TRUE;
    END IF;
    SELECT ipsitem_id INTO _id
      FROM ipsiteminfo, item, ipshead, ipsass
     WHERE((ipsitem_ipshead_id=ipshead_id)
       AND (ipsitem_prodcat_id = item_prodcat_id)
       AND (ipsass_ipshead_id=ipshead_id)
       AND (pAsOf BETWEEN ipshead_effective AND (ipshead_expires - 1))
       AND (item_id=pItemid)
       AND (ipsass_shipto_id != -1)
       AND (ipsass_shipto_id=pShiptoid))
     LIMIT 1;
    IF (FOUND) THEN
      RETURN TRUE;
    END IF;

--  Check for a Shipto Pattern Assigned Price
    SELECT ipsitem_id INTO _id
      FROM ipsiteminfo, ipshead, ipsass, shiptoinfo
     WHERE((ipsitem_ipshead_id=ipshead_id)
       AND (ipsass_ipshead_id=ipshead_id)
       AND (pAsOf BETWEEN ipshead_effective AND (ipshead_expires - 1))
       AND (COALESCE(length(ipsass_shipto_pattern), 0) > 0)
       AND (shipto_num ~ ipsass_shipto_pattern)
       AND (ipsass_cust_id=pCustid)
       AND (ipsitem_item_id=pItemid)
       AND (shipto_id=pShiptoid))
     LIMIT 1;
    IF (FOUND) THEN
      RETURN TRUE;
    END IF;
    SELECT ipsitem_id INTO _id
      FROM ipsiteminfo, item, ipshead, ipsass, shiptoinfo
     WHERE((ipsitem_ipshead_id=ipshead_id)
       AND (ipsitem_prodcat_id = item_prodcat_id)
       AND (ipsass_ipshead_id=ipshead_id)
       AND (pAsOf BETWEEN ipshead_effective AND (ipshead_expires - 1))
       AND (COALESCE(length(ipsass_shipto_pattern), 0) > 0)
       AND (shipto_num ~ ipsass_shipto_pattern)
       AND (ipsass_cust_id=pCustid)
       AND (item_id=pItemid)
       AND (shipto_id=pShiptoid))
     LIMIT 1;
    IF (FOUND) THEN
      RETURN TRUE;
    END IF;
  END IF;

--  Check for a Customer Assigned Price
  SELECT ipsitem_id INTO _id
    FROM ipsiteminfo, ipshead, ipsass
   WHERE((ipsitem_ipshead_id=ipshead_id)
     AND (ipsass_ipshead_id=ipshead_id)
     AND (pAsOf BETWEEN ipshead_effective AND (ipshead_expires - 1))
     AND (ipsitem_item_id=pItemid)
     AND (COALESCE(length(ipsass_shipto_pattern), 0) = 0)
     AND (ipsass_cust_id=pCustid))
   LIMIT 1;
  IF (FOUND) THEN
    RETURN TRUE;
  END IF;
  SELECT ipsitem_id INTO _id
    FROM ipsiteminfo, item, ipshead, ipsass
   WHERE((ipsitem_ipshead_id=ipshead_id)
     AND (ipsitem_prodcat_id = item_prodcat_id)
     AND (ipsass_ipshead_id=ipshead_id)
     AND (pAsOf BETWEEN ipshead_effective AND (ipshead_expires - 1))
     AND (item_id=pItemid)
     AND (COALESCE(length(ipsass_shipto_pattern), 0) = 0)
     AND (ipsass_cust_id=pCustid))
   LIMIT 1;
  IF (FOUND) THEN
    RETURN TRUE;
  END IF;

--  Check for a Customer Type Assigned Price
  SELECT ipsitem_id INTO _id
    FROM ipsiteminfo, ipshead, ipsass, custinfo
   WHERE( (ipsitem_ipshead_id=ipshead_id)
     AND  (ipsass_ipshead_id=ipshead_id)
     AND  (ipsass_custtype_id != -1)
     AND  (cust_custtype_id = ipsass_custtype_id)
     AND  (pAsOf BETWEEN ipshead_effective AND (ipshead_expires - 1))
     AND  (ipsitem_item_id=pItemid)
     AND  (cust_id=pCustid))
    LIMIT 1;
  IF (FOUND) THEN
    RETURN TRUE;
  END IF;
  SELECT ipsitem_id INTO _id
    FROM ipsiteminfo, item, ipshead, ipsass, custinfo
   WHERE( (ipsitem_ipshead_id=ipshead_id)
     AND  (ipsitem_prodcat_id = item_prodcat_id)
     AND  (ipsass_ipshead_id=ipshead_id)
     AND  (ipsass_custtype_id != -1)
     AND  (cust_custtype_id = ipsass_custtype_id)
     AND  (pAsOf BETWEEN ipshead_effective AND (ipshead_expires - 1))
     AND  (item_id=pItemid)
     AND  (cust_id=pCustid))
    LIMIT 1;
  IF (FOUND) THEN
    RETURN TRUE;
  END IF;

--  Check for a Customer Type Pattern Assigned Price
  SELECT ipsitem_id INTO _id
    FROM ipsiteminfo, ipshead, ipsass, custtype, custinfo
   WHERE((ipsitem_ipshead_id=ipshead_id)
     AND (ipsass_ipshead_id=ipshead_id)
     AND (coalesce(length(ipsass_custtype_pattern), 0) > 0)
     AND (custtype_code ~ ipsass_custtype_pattern)
     AND (cust_custtype_id=custtype_id)
     AND (pAsOf BETWEEN ipshead_effective AND (ipshead_expires - 1))
     AND (ipsitem_item_id=pItemid)
     AND (cust_id=pCustid))
   LIMIT 1;
  IF (FOUND) THEN
    RETURN TRUE;
  END IF;
  SELECT ipsitem_id INTO _id
    FROM ipsiteminfo, item, ipshead, ipsass, custtype, custinfo
   WHERE((ipsitem_ipshead_id=ipshead_id)
     AND (ipsitem_prodcat_id = item_prodcat_id)
     AND (ipsass_ipshead_id=ipshead_id)
     AND (coalesce(length(ipsass_custtype_pattern), 0) > 0)
     AND (custtype_code ~ ipsass_custtype_pattern)
     AND (cust_custtype_id=custtype_id)
     AND (pAsOf BETWEEN ipshead_effective AND (ipshead_expires - 1))
     AND (item_id=pItemid)
     AND (cust_id=pCustid))
   LIMIT 1;
  IF (FOUND) THEN
    RETURN TRUE;
  END IF;

--  That's it, Sales don't count - yet
  RETURN FALSE;

END;
$_$;


ALTER FUNCTION public.customercanpurchase(integer, integer, integer, date) OWNER TO admin;

--
-- TOC entry 1392 (class 1255 OID 146565961)
-- Dependencies: 8
-- Name: dearmor(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION dearmor(text) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgcrypto', 'pg_dearmor';


ALTER FUNCTION public.dearmor(text) OWNER TO admin;

--
-- TOC entry 1393 (class 1255 OID 146565962)
-- Dependencies: 8
-- Name: decrypt(bytea, bytea, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION decrypt(bytea, bytea, text) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgcrypto', 'pg_decrypt';


ALTER FUNCTION public.decrypt(bytea, bytea, text) OWNER TO admin;

--
-- TOC entry 1394 (class 1255 OID 146565963)
-- Dependencies: 8
-- Name: decrypt_iv(bytea, bytea, bytea, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION decrypt_iv(bytea, bytea, bytea, text) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgcrypto', 'pg_decrypt_iv';


ALTER FUNCTION public.decrypt_iv(bytea, bytea, bytea, text) OWNER TO admin;

--
-- TOC entry 1395 (class 1255 OID 146565964)
-- Dependencies: 4536 8
-- Name: defaultlocationname(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION defaultlocationname(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  _p RECORD;

BEGIN

  SELECT itemsite_location_id, itemsite_location INTO _p
  FROM itemsite
  WHERE (itemsite_id=pItemsiteid);

  IF (NOT FOUND) THEN
    RETURN 'Error';
  ELSIF (_p.itemsite_location_id = -1) THEN
    RETURN _p.itemsite_location;
  ELSE
    RETURN formatLocationName(_p.itemsite_location_id);
  END IF;

END;
$_$;


ALTER FUNCTION public.defaultlocationname(integer) OWNER TO admin;

--
-- TOC entry 1396 (class 1255 OID 146565965)
-- Dependencies: 4536 8
-- Name: deleteaccount(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteaccount(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pAccntid ALIAS FOR $1;
  _check INTEGER;

BEGIN

--  Check to see if the passed accnt is used in a Cost Category
  SELECT costcat_id INTO _check
  FROM costcat
  WHERE ( (costcat_asset_accnt_id=pAccntid)
     OR   (costcat_liability_accnt_id=pAccntid)
     OR   (costcat_adjustment_accnt_id=pAccntid)
     OR   (costcat_purchprice_accnt_id=pAccntid)
     OR   (costcat_laboroverhead_accnt_id=pAccntid)
     OR   (costcat_scrap_accnt_id=pAccntid)
     OR   (costcat_invcost_accnt_id=pAccntid)
     OR   (costcat_wip_accnt_id=pAccntid)
     OR   (costcat_shipasset_accnt_id=pAccntid)
     OR   (costcat_mfgscrap_accnt_id=pAccntid)
     OR   (costcat_transform_accnt_id=pAccntid)
     OR   (costcat_freight_accnt_id=pAccntid) )
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -1;
  END IF;

--  Check to see if the passed accnt is used in a Sales Account Assignment
  SELECT salesaccnt_id INTO _check
  FROM salesaccnt
  WHERE ( (salesaccnt_sales_accnt_id=pAccntid)
     OR   (salesaccnt_credit_accnt_id=pAccntid)
     OR   (salesaccnt_cos_accnt_id=pAccntid) )
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -2;
  END IF;

--  Check to see if the passed accnt is used in a A/R Account Assignment
  SELECT araccnt_id INTO _check
  FROM araccnt
  WHERE ( (araccnt_freight_accnt_id=pAccntid)
     OR   (araccnt_ar_accnt_id=pAccntid)
     OR   (araccnt_prepaid_accnt_id=pAccntid) )
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -3;
  END IF;

--  Check to see if the passed accnt is used in a Warehouse
  IF EXISTS (SELECT 1
               FROM whsinfo
              WHERE (warehous_default_accnt_id=pAccntid)) THEN
    RETURN -4;
  END IF;

--  Check to see if the passed accnt is used in a Bank Account
  SELECT bankaccnt_id INTO _check
  FROM bankaccnt
  WHERE (bankaccnt_accnt_id=pAccntid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -5;
  END IF;

--  Check to see if the passed accnt is used in an Expense Category
  SELECT expcat_id INTO _check
  FROM expcat
  WHERE ( (expcat_exp_accnt_id=pAccntid)
     OR   (expcat_liability_accnt_id=pAccntid)
     OR   (expcat_purchprice_accnt_id=pAccntid)
     OR   (expcat_freight_accnt_id=pAccntid) )
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -6;
  END IF;

--  Check to see if the passed accnt is used in a Tax Code
  SELECT tax_id INTO _check
  FROM tax
  WHERE (tax_sales_accnt_id=pAccntid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -7;
  END IF;

--  Check to see if the passed accnt is used in a Standard Journal Item
  SELECT stdjrnlitem_id INTO _check
  FROM stdjrnlitem
  WHERE (stdjrnlitem_accnt_id=pAccntid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -8;
  END IF;

--  Check to see if the passed accnt is used in a A/P Account Assignment
  SELECT apaccnt_ap_accnt_id INTO _check
  FROM apaccnt
  WHERE ( (apaccnt_ap_accnt_id=pAccntid)
     OR   (apaccnt_prepaid_accnt_id=pAccntid)
     OR   (apaccnt_discount_accnt_id=pAccntid) )
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -9;
  END IF;

--  Check to see if the passed accnt is used in an A/R Open Item record
  SELECT aropen_accnt_id INTO _check
    FROM aropen
   WHERE (aropen_accnt_id=pAccntid)
   LIMIT 1;
  IF (FOUND) THEN
    RETURN -11;
  END IF;

--  Check to see if the passed accnt has been used in the G/L
  SELECT gltrans_accnt_id INTO _check
  FROM gltrans
  WHERE (gltrans_accnt_id=pAccntid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -99;
  END IF;

  SELECT glseries_accnt_id INTO _check
  FROM glseries
  WHERE (glseries_accnt_id=pAccntid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -99;
  END IF;

  SELECT trialbal_accnt_id INTO _check
  FROM trialbal
  WHERE (trialbal_accnt_id=pAccntid)
    AND (trialbal_beginning != 0 OR trialbal_ending != 0)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -99;
  END IF;

  SELECT cashrcptmisc_accnt_id INTO _check
  FROM cashrcptmisc
  WHERE (cashrcptmisc_accnt_id=pAccntid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -99;
  END IF;

--  Delete any non-critical use
  DELETE FROM flitem
  WHERE (flitem_accnt_id=pAccntid);

  -- only possible because of trialbal error-check above
  DELETE FROM trialbal
  WHERE (trialbal_accnt_id=pAccntid)
    AND (trialbal_beginning=0)
    AND (trialbal_ending=0);

--  Delete the Account
  DELETE FROM accnt
  WHERE (accnt_id=pAccntid);

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.deleteaccount(integer) OWNER TO admin;

--
-- TOC entry 1398 (class 1255 OID 146565966)
-- Dependencies: 4536 8
-- Name: deleteaccountingperiod(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteaccountingperiod(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPeriodid ALIAS FOR $1;
  _check RECORD;

BEGIN

--  Check to make sure that the passed period is not closed
  IF ( ( SELECT period_closed
         FROM period
         WHERE (period_id=pPeriodid) ) ) THEN
    RETURN -1;
  END IF;

--  Check to make sure that there are not any posted G/L Transactions
--  in the period.
  SELECT gltrans_id INTO _check
  FROM gltrans, period
  WHERE ( (gltrans_date BETWEEN period_start AND period_end)
   AND (gltrans_posted)
   AND (period_id=pPeriodid) )
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -4;
  END IF;

  SELECT b.period_id INTO _check
    FROM period AS a, period AS b
   WHERE((a.period_id=pPeriodid)
     AND (a.period_end < b.period_start))
   LIMIT 1;
  IF (FOUND) THEN
    RETURN -5;
  END IF;

--  Delete the period
  DELETE FROM period
  WHERE (period_id=pPeriodid);

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.deleteaccountingperiod(integer) OWNER TO admin;

--
-- TOC entry 1399 (class 1255 OID 146565967)
-- Dependencies: 4536 8
-- Name: deleteaccountingyearperiod(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteaccountingyearperiod(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPeriodid ALIAS FOR $1;
  _check RECORD;

BEGIN

--  Check to make sure that the passed yearperiod is not closed
  IF ( ( SELECT yearperiod_closed
         FROM yearperiod
         WHERE (yearperiod_id=pPeriodid) ) ) THEN
    RETURN -1;
  END IF;

  -- this yearperiod is in use by existing periods
  IF (EXISTS(SELECT period_id
             FROM period
             WHERE (period_yearperiod_id=pPeriodid))) THEN
    RETURN -2;
  END IF;

--  Delete the yearperiod
  DELETE FROM yearperiod
  WHERE (yearperiod_id=pPeriodid);

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.deleteaccountingyearperiod(integer) OWNER TO admin;

--
-- TOC entry 1400 (class 1255 OID 146565968)
-- Dependencies: 4536 8
-- Name: deleteaddress(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteaddress(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  paddrId     ALIAS FOR $1;
  _count      INTEGER := 0;
BEGIN
  SELECT count(*) INTO _count
    FROM cntct
    WHERE (cntct_active
      AND  (cntct_addr_id = paddrId));
  IF (_count > 0) THEN
    RETURN -1;
  END IF;

  SELECT count(*) INTO _count
    FROM vendinfo
    WHERE (vend_active
      AND  (vend_addr_id = paddrId));
  IF (_count > 0) THEN
    RETURN -2;
  END IF;

  SELECT count(*) INTO _count
    FROM shiptoinfo
    WHERE (shipto_active
      AND  (shipto_addr_id = paddrId));
  IF (_count > 0) THEN
    RETURN -3;
  END IF;

  SELECT count(*) INTO _count
    FROM vendaddrinfo
    WHERE (vendaddr_addr_id = paddrId);
  IF (_count > 0) THEN
    RETURN -4;
  END IF;

  SELECT count(*) INTO _count
    FROM whsinfo
    WHERE (warehous_active
      AND  (warehous_addr_id = paddrId));
  IF (_count > 0) THEN
    RETURN -5;
  END IF;

  UPDATE cntct SET cntct_addr_id = NULL WHERE (cntct_addr_id = paddrId);
  UPDATE vendinfo SET vend_addr_id = NULL WHERE (vend_addr_id = paddrId);
  UPDATE shiptoinfo SET shipto_addr_id = NULL WHERE (shipto_addr_id =paddrId);
  UPDATE vendaddrinfo SET vendaddr_addr_id = NULL
    WHERE (vendaddr_addr_id = paddrId);
  UPDATE whsinfo SET warehous_addr_id = NULL WHERE (warehous_addr_id=paddrId);

  DELETE FROM addr WHERE addr_id = paddrId;
  RETURN 0;
END;
$_$;


ALTER FUNCTION public.deleteaddress(integer) OWNER TO admin;

--
-- TOC entry 1401 (class 1255 OID 146565969)
-- Dependencies: 4536 8
-- Name: deleteapcheck(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteapcheck(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RAISE NOTICE 'deleteAPCheck() is deprecated - use deleteCheck() instead';
  RETURN deleteCheck($1);
END;
$_$;


ALTER FUNCTION public.deleteapcheck(integer) OWNER TO admin;

--
-- TOC entry 1402 (class 1255 OID 146565970)
-- Dependencies: 4536 8
-- Name: deletebankadjustmenttype(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletebankadjustmenttype(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pBankadjtypeid ALIAS FOR $1;
  _check INTEGER;

BEGIN

-- Check to see if the the adjustment type is being used in any adjustments
  SELECT bankadj_bankadjtype_id INTO _check
    FROM bankadj
   WHERE (bankadj_bankadjtype_id=pBankadjtypeid)
   LIMIT 1;
  IF (FOUND) THEN
    RETURN -1;
  END IF;

--  Delete the Account
  DELETE FROM bankadjtype
  WHERE (bankadjtype_id=pbankadjtypeid);

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.deletebankadjustmenttype(integer) OWNER TO admin;

--
-- TOC entry 1403 (class 1255 OID 146565971)
-- Dependencies: 4536 8
-- Name: deletebankreconciliation(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletebankreconciliation(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pbankrecid    ALIAS FOR $1;
BEGIN
  DELETE FROM bankrecitem
  WHERE bankrecitem_bankrec_id=pbankrecid;

  DELETE FROM bankrec
  WHERE bankrec_id=pbankrecid;

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.deletebankreconciliation(integer) OWNER TO admin;

--
-- TOC entry 1404 (class 1255 OID 146565972)
-- Dependencies: 4536 8
-- Name: deletebom(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletebom(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  _result INTEGER;

BEGIN

  IF (fetchmetricbool('RevControl')) THEN
    SELECT rev_id INTO _result
    FROM rev
    WHERE ((rev_target_id=pItemid)
    AND (rev_target_type = 'BOM'))
    LIMIT 1;
    IF (FOUND) THEN
      RAISE EXCEPTION 'Bill of Materials has revision control records and may not be deleted.';
    END IF;
  END IF;

  DELETE FROM bomhead
  WHERE (bomhead_item_id=pItemid);
  DELETE FROM bomitem
  WHERE (bomitem_parent_item_id=pItemid);

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.deletebom(integer) OWNER TO admin;

--
-- TOC entry 1405 (class 1255 OID 146565973)
-- Dependencies: 4536 8
-- Name: deletebomworkset(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletebomworkset(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWorksetid ALIAS FOR $1;

BEGIN

--  All done with the bomwork set indicated by pWorksetid, delete all of it
  DELETE FROM bomwork
  WHERE (bomwork_set_id=pWorksetid);

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.deletebomworkset(integer) OWNER TO admin;

--
-- TOC entry 1406 (class 1255 OID 146565974)
-- Dependencies: 4536 8
-- Name: deletebudget(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletebudget(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pBudgheadid ALIAS FOR $1;

BEGIN
  DELETE FROM budgitem WHERE (budgitem_budghead_id=pBudgheadid);
  DELETE FROM budghead WHERE (budghead_id=pBudgheadid);

  RETURN pBudgheadid;
END;
$_$;


ALTER FUNCTION public.deletebudget(integer) OWNER TO admin;

--
-- TOC entry 1407 (class 1255 OID 146565975)
-- Dependencies: 4536 8
-- Name: deletebudgetitems(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletebudgetitems(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pBudgheadid ALIAS FOR $1;

BEGIN
  DELETE FROM budgitem WHERE (budgitem_budghead_id=pBudgheadid);

  RETURN pBudgheadid;
END;
$_$;


ALTER FUNCTION public.deletebudgetitems(integer) OWNER TO admin;

--
-- TOC entry 1409 (class 1255 OID 146565976)
-- Dependencies: 4536 8
-- Name: deletecashrcpt(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletecashrcpt(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pcashrcptid ALIAS FOR $1;
  _ccreceipt    BOOLEAN;

BEGIN

  IF EXISTS(SELECT cashrcpt_id
            FROM cashrcpt
            JOIN ccpay ON (cashrcpt_cust_id=ccpay_cust_id)
                       AND ((CASE WHEN TRIM(COALESCE(cashrcpt_docnumber, ''))='' THEN TEXT(cashrcpt_id)
                                  ELSE cashrcpt_docnumber
                             END)=ccpay_order_number)
            WHERE ((cashrcpt_fundstype IN ('A', 'D', 'M', 'V'))
               AND (ccpay_status NOT IN ('D', 'X'))
               AND (ccpay_id NOT IN (SELECT payco_ccpay_id FROM payco))
               AND (cashrcpt_id=pcashrcptid))) THEN
    RETURN -1;
  END IF;

  IF EXISTS(SELECT cashrcpt_id
            FROM cashrcpt
            WHERE ( (cashrcpt_id=pcashrcptid)
              AND   (cashrcpt_posted) )) THEN
    RETURN -2;
  END IF;

  -- If there are applications for this Cash Receipt then
  -- it has been posted and reversed.  Void instead of delete.
  IF EXISTS(SELECT cashrcpt_id
            FROM cashrcpt JOIN cashrcptitem ON (cashrcptitem_cashrcpt_id=cashrcpt_id)
                          JOIN arapply ON ((arapply_reftype='CRA') AND
                                           (arapply_ref_id=cashrcptitem_id))
            WHERE (cashrcpt_id=pcashrcptid))
     OR
     EXISTS(SELECT cashrcpt_id
            FROM cashrcpt JOIN cashrcptmisc ON (cashrcptmisc_cashrcpt_id=cashrcpt_id)
                          JOIN arapply ON ((arapply_reftype='CRD') AND
                                           (arapply_ref_id=cashrcptmisc_id))
            WHERE (cashrcpt_id=pcashrcptid)) THEN
    UPDATE cashrcpt SET cashrcpt_void = TRUE
    WHERE (cashrcpt_id=pcashrcptid);
    RETURN 1;
  END IF;

  DELETE FROM cashrcptitem
  WHERE (cashrcptitem_cashrcpt_id=pcashrcptid);

  DELETE FROM cashrcptmisc
  WHERE (cashrcptmisc_cashrcpt_id=pcashrcptid);

  DELETE FROM cashrcpt
  WHERE (cashrcpt_id=pcashrcptid);

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.deletecashrcpt(integer) OWNER TO admin;

--
-- TOC entry 1410 (class 1255 OID 146565977)
-- Dependencies: 4536 8
-- Name: deletecharacteristic(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletecharacteristic(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCharid ALIAS FOR $1;
  _check INTEGER;
  _r RECORD;

BEGIN

--  Cache the specifics of the characteristic
  SELECT * INTO _r
  FROM char
  WHERE (char_id=pCharid);
  IF (NOT(FOUND)) THEN
    RETURN 0;
  END IF;

--  If the passed characteristic is used
  SELECT * INTO _r
  FROM charass
  WHERE (charass_char_id=pCharid)
  LIMIT 1;
  IF (FOUND) THEN
    IF (_r.charass_target_type = 'I') THEN
      RETURN -1;
    ELSIF (_r.charass_target_type = 'C') THEN
      RETURN -2;
    ELSIF (_r.charass_target_type = 'ADDR') THEN
      RETURN -3;
    ELSIF (_r.charass_target_type = 'CNTCT') THEN
      RETURN -4;
    ELSIF (_r.charass_target_type = 'CRMACCT') THEN
      RETURN -5;
    ELSIF (_r.charass_target_type = 'INCDT	') THEN
      RETURN -6;
    ELSIF (_r.charass_target_type = 'EMP') THEN
      RETURN -7;
    ELSIF (_r.charass_target_type = 'QU') THEN
      RETURN -8;
    ELSIF (_r.charass_target_type = 'SO') THEN
      RETURN -9;
    ELSIF (_r.charass_target_type = 'INV') THEN
      RETURN -10;
    ELSIF (_r.charass_target_type = 'V') THEN
      RETURN -11;
    ELSIF (_r.charass_target_type = 'PO') THEN
      RETURN -12;
    ELSIF (_r.charass_target_type = 'VO') THEN
      RETURN -13;
    ELSE
      RETURN -99;
    END IF;
  END IF;

--  Delete the passed characterisitic
  DELETE FROM char
  WHERE (char_id=pCharid);

  RETURN pCharid;

END;
$_$;


ALTER FUNCTION public.deletecharacteristic(integer) OWNER TO admin;

--
-- TOC entry 1411 (class 1255 OID 146565978)
-- Dependencies: 4536 8
-- Name: deletecheck(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletecheck(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCheckid ALIAS FOR $1;

BEGIN
  IF (SELECT (NOT checkhead_void) OR checkhead_posted OR checkhead_replaced
              OR checkhead_deleted
              OR (checkhead_ach_batch IS NOT NULL AND checkhead_printed)
      FROM checkhead
      WHERE (checkhead_id=pCheckid) ) THEN
    RETURN -1;
  END IF;

  UPDATE checkhead
  SET checkhead_deleted=TRUE
  WHERE (checkhead_id=pCheckid);

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.deletecheck(integer) OWNER TO admin;

--
-- TOC entry 1412 (class 1255 OID 146565979)
-- Dependencies: 4536 8
-- Name: deleteclasscode(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteclasscode(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pClasscodeid ALIAS FOR $1;
  _check INTEGER;

BEGIN

--  Check to see if any items are assigned to the passed classcode
  SELECT item_id INTO _check
  FROM item
  WHERE (item_classcode_id=pClasscodeid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -1;
  END IF;

--  Delete the passed classcode
  DELETE FROM classcode
  WHERE (classcode_id=pClasscodeid);

  RETURN pClasscodeid;

END;
$_$;


ALTER FUNCTION public.deleteclasscode(integer) OWNER TO admin;

--
-- TOC entry 1413 (class 1255 OID 146565980)
-- Dependencies: 4536 8
-- Name: deletecompany(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletecompany(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pcompanyid ALIAS FOR $1;

BEGIN
  IF (EXISTS(SELECT accnt_id
             FROM accnt, company
             WHERE ((accnt_company=company_number)
               AND  (company_id=pcompanyid))
            )) THEN
    RETURN -1;
  END IF;

  DELETE FROM company
  WHERE (company_id=pcompanyid);

  RETURN pcompanyid;

END;
$_$;


ALTER FUNCTION public.deletecompany(integer) OWNER TO admin;

--
-- TOC entry 1414 (class 1255 OID 146565981)
-- Dependencies: 4536 8
-- Name: deletecreditmemo(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletecreditmemo(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCmheadid ALIAS FOR $1;

BEGIN

  DELETE FROM cmitem
  WHERE (cmitem_cmhead_id=pCmheadid);

  DELETE FROM cmhead
  WHERE (cmhead_id=pCmheadid);

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.deletecreditmemo(integer) OWNER TO admin;

--
-- TOC entry 1415 (class 1255 OID 146565982)
-- Dependencies: 4536 8
-- Name: deletecustomer(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletecustomer(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCustid ALIAS FOR $1;

BEGIN

  PERFORM shipto_id
  FROM shiptoinfo
  WHERE (shipto_cust_id=pCustid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -1;
  END IF;

  PERFORM cohead_id
  FROM cohead
  WHERE (cohead_cust_id=pCustid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -2;
  END IF;

  PERFORM cmhead_id
  FROM cmhead
  WHERE (cmhead_cust_id=pCustid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -3;
  END IF;

  PERFORM cohist_id
  FROM cohist
  WHERE (cohist_cust_id=pCustid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -4;
  END IF;

  PERFORM aropen_id
  FROM aropen
  WHERE (aropen_cust_id=pCustid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -5;
  END IF;

  PERFORM checkhead_recip_id
    FROM checkhead
   WHERE ((checkhead_recip_id=pCustid)
     AND  (checkhead_recip_type='C'))
   LIMIT 1;
   IF (FOUND) THEN
     RETURN -6;
   END IF;

  PERFORM invchead_id
     FROM invchead
    WHERE(invchead_cust_id=pCustid)
    LIMIT 1;
  IF (FOUND) THEN
    RETURN -7;
  END IF;

  PERFORM quhead_id
     FROM quhead
    WHERE(quhead_cust_id=pCustid)
    LIMIT 1;
  IF (FOUND) THEN
    RETURN -8;
  END IF;

  DELETE FROM taxreg
   WHERE ((taxreg_rel_type='C')
     AND  (taxreg_rel_id=pCustid));

  DELETE FROM ipsass
  WHERE (ipsass_cust_id=pCustid);

  DELETE FROM custinfo
  WHERE (cust_id=pCustid);

  UPDATE crmacct SET crmacct_cust_id = NULL
  WHERE (crmacct_cust_id=pCustid);

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.deletecustomer(integer) OWNER TO admin;

--
-- TOC entry 1416 (class 1255 OID 146565983)
-- Dependencies: 4536 8
-- Name: deletecustomertype(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletecustomertype(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCusttypeid ALIAS FOR $1;

BEGIN

  IF EXISTS(SELECT 1
              FROM custinfo
             WHERE (cust_custtype_id=pCusttypeid)) THEN
    RETURN -1;
  END IF;

  DELETE FROM ipsass
  WHERE (ipsass_custtype_id=pCusttypeid);

  DELETE FROM salesaccnt
  WHERE (salesaccnt_custtype_id=pCusttypeid);

  DELETE FROM araccnt
  WHERE (araccnt_custtype_id=pCusttypeid);

  DELETE FROM custform
  WHERE (custform_custtype_id=pCusttypeid);

  DELETE FROM custtype
  WHERE (custtype_id=pCusttypeid);

  RETURN pCusttypeid;

END;
$_$;


ALTER FUNCTION public.deletecustomertype(integer) OWNER TO admin;

--
-- TOC entry 1305 (class 1255 OID 146565984)
-- Dependencies: 4536 8
-- Name: deleteempgrp(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteempgrp(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pempgrpid ALIAS FOR $1;

BEGIN
--  Check to see if any employees are assigned to the passed empgrp
  PERFORM empgrpitem_emp_id
  FROM empgrpitem
  WHERE (empgrpitem_empgrp_id=pempgrpid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -1;
  END IF;

  DELETE FROM empgrp     WHERE (empgrp_id=pempgrpid);

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.deleteempgrp(integer) OWNER TO admin;

--
-- TOC entry 1386 (class 1255 OID 146565985)
-- Dependencies: 4536 8
-- Name: deleteexpiredips(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteexpiredips() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _r RECORD;

BEGIN

  FOR _r IN SELECT ipshead_id
    FROM ipshead
    WHERE (ipshead_expires <= current_date)
  LOOP

    DELETE FROM ipsass
      WHERE (ipsass_ipshead_id=_r.ipshead_id);
    DELETE FROM ipsiteminfo
      WHERE (ipsitem_ipshead_id=_r.ipshead_id);
    DELETE FROM ipsfreight
      WHERE (ipsfreight_ipshead_id=_r.ipshead_id);
    DELETE FROM ipshead
      WHERE (ipshead_id=_r.ipshead_id);
  END LOOP;

  RETURN TRUE;

END;
$$;


ALTER FUNCTION public.deleteexpiredips() OWNER TO admin;

--
-- TOC entry 1397 (class 1255 OID 146565986)
-- Dependencies: 4536 8
-- Name: deletefile(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletefile(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  pId ALIAS FOR $1;
begin
  delete from file
  where ( file_id in (
    select file_id
    from file
      join docass on (docass_target_id=file_id)
                 and (docass_target_type='FILE')
    where ( docass_id = pId ) ) );

  delete from docass where docass_id = pId;

  return true;
end;
$_$;


ALTER FUNCTION public.deletefile(integer) OWNER TO admin;

--
-- TOC entry 1417 (class 1255 OID 146565987)
-- Dependencies: 4536 8
-- Name: deleteflgrp(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteflgrp(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pFlgrpid ALIAS FOR $1;
  _r RECORD;

BEGIN

  FOR _r IN SELECT flgrp_id
            FROM flgrp
            WHERE (flgrp_flgrp_id=pFlgrpid) LOOP
    PERFORM deleteFlgrp(_r.flgrp_id);
  END LOOP;

  DELETE FROM flitem
  WHERE (flitem_flgrp_id=pFlgrpid);

  DELETE FROM flspec
  WHERE (flspec_flgrp_id=pFlgrpid);

  DELETE FROM flgrp
  WHERE (flgrp_id=pFlgrpid);

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.deleteflgrp(integer) OWNER TO admin;

--
-- TOC entry 1418 (class 1255 OID 146565988)
-- Dependencies: 4536 8
-- Name: deleteform(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteform(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pFormid ALIAS FOR $1;
  _key TEXT;
  _check INTEGER;

BEGIN

--  Cache the key of the passed form
  SELECT form_key INTO _key
  FROM form
  WHERE (form_id=pFormid);
  IF (NOT(FOUND)) THEN
    RETURN 0;
  END IF;

--  Handle checks based on the type of the form
  IF (_key='Chck') THEN
    SELECT bankaccnt_id INTO _check
    FROM bankaccnt
    WHERE (bankaccnt_check_form_id=pFormid)
    LIMIT 1;
    IF (FOUND) THEN
      RETURN -1;
    END IF;

  END IF;

--  Delete the form
  DELETE FROM form
  WHERE (form_id=pFormid);

  RETURN pFormid;

END;
$_$;


ALTER FUNCTION public.deleteform(integer) OWNER TO admin;

--
-- TOC entry 1419 (class 1255 OID 146565989)
-- Dependencies: 4536 8
-- Name: deletefreightclass(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletefreightclass(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pFreightClassid ALIAS FOR $1;
  _check INTEGER;

BEGIN

--  Check to see if any items are assigned to the passed freightclass
  SELECT item_id INTO _check
  FROM item
  WHERE (item_freightclass_id=pFreightClassid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -1;
  END IF;

--  Delete the passed freightclass
  DELETE FROM freightclass
  WHERE (freightclass_id=pFreightClassid);

  RETURN pFreightClassid;

END;
$_$;


ALTER FUNCTION public.deletefreightclass(integer) OWNER TO admin;

--
-- TOC entry 1420 (class 1255 OID 146565990)
-- Dependencies: 4536 8
-- Name: deleteglseries(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteglseries(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
  pSequence ALIAS FOR $1;

BEGIN

  DELETE FROM glseries
  WHERE (glseries_sequence=pSequence);

  RETURN pSequence;

END;
$_$;


ALTER FUNCTION public.deleteglseries(integer) OWNER TO admin;

--
-- TOC entry 1421 (class 1255 OID 146565991)
-- Dependencies: 4536 8
-- Name: deleteglseries(integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteglseries(integer, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSequence ALIAS FOR $1;
  pNotes ALIAS FOR $2;
  _trialbalid INTEGER;
  _count INTEGER;
  _r RECORD;

BEGIN

--  March through all of the G/L Transactions for the passed sequence
  FOR _r IN SELECT gltrans_id, gltrans_date, gltrans_accnt_id, gltrans_amount, gltrans_posted, gltrans_rec,
                   accnt_forwardupdate, period_id, period_closed, period_freeze
            FROM accnt, gltrans LEFT OUTER JOIN period ON (gltrans_date BETWEEN period_start AND period_end)
            WHERE ( (gltrans_accnt_id=accnt_id)
             AND (NOT gltrans_deleted)
             AND (gltrans_sequence=pSequence) ) LOOP

--  If we can post into a Trial Balance, do so
    IF ( (NOT _r.period_closed) AND
       ( (NOT _r.period_freeze) OR (checkPrivilege('PostFrozenPeriod')) ) AND
       (  NOT _r.gltrans_rec) AND
       ( _r.gltrans_posted ) ) THEN

--  Try to find an existing trialbal
      SELECT trialbal_id INTO _trialbalid
      FROM trialbal
      WHERE ( (trialbal_period_id=_r.period_id)
       AND (trialbal_accnt_id=_r.gltrans_accnt_id) );

      GET DIAGNOSTICS _count = ROW_COUNT;
      IF (_count > 0) THEN

--  We found a trialbal, update it with the G/L Transaction
--  Note - two stage update to avoid any funny value caching logic
        IF (_r.gltrans_amount > 0) THEN
          UPDATE trialbal
          SET trialbal_credits = (trialbal_credits - _r.gltrans_amount)
          WHERE (trialbal_id=_trialbalid);
        ELSE
          UPDATE trialbal
          SET trialbal_debits = (trialbal_debits - (_r.gltrans_amount * -1))
          WHERE (trialbal_id=_trialbalid);
        END IF;

        UPDATE trialbal
        SET trialbal_ending = (trialbal_beginning - trialbal_debits + trialbal_credits),
            trialbal_dirty=TRUE
        WHERE (trialbal_id=_trialbalid);

      ELSE
        RAISE EXCEPTION 'Can not delete G/L Series.  Trial balance record not found.';
      END IF;

--  Forward update if we should
      IF (_r.accnt_forwardupdate AND fetchmetricbool('ManualForwardUpdate')) THEN
        PERFORM forwardUpdateTrialBalance(_trialbalid);
      END IF;

--  Delete any bank reconciliation records if this was marked cleared but non reconciled
    DELETE FROM bankrecitem
    WHERE ((bankrecitem_source='GL')
    AND (bankrecitem_source_id=_r.gltrans_id));

--  Unflag any journals as posted as a result of this series
    UPDATE sltrans SET
      sltrans_posted=false,
      sltrans_gltrans_journalnumber=null
    FROM gltrans
    WHERE ((gltrans_sequence=pSequence)
    AND (sltrans_gltrans_journalnumber=gltrans_journalnumber));

--  Mark the G/L Transaction as deleted
      UPDATE gltrans SET
        gltrans_posted=false,
        gltrans_deleted=true,
        gltrans_notes=gltrans_notes || E'\n' || pNotes
      WHERE (gltrans_id=_r.gltrans_id);

    ELSIF (_r.period_freeze) THEN
        RAISE EXCEPTION 'Can not delete a G/L Transaction in a frozen period';
    ELSIF (_r.period_closed) THEN
        RAISE EXCEPTION 'Can not delete a G/L Transaction on account % in a closed period', formatGlAccount(_r.gltrans_accnt_id);
    ELSIF (_r.gltrans_rec) THEN
        RAISE EXCEPTION 'Can not delete a G/L Transaction that has been reconciled';
    ELSIF (NOT _r.gltrans_posted) THEN
        RAISE EXCEPTION 'Can not delete a G/L Transaction that has not been posted to Trial Balance';
    END IF;

  END LOOP;

  RETURN true;

END;
$_$;


ALTER FUNCTION public.deleteglseries(integer, text) OWNER TO admin;

--
-- TOC entry 1422 (class 1255 OID 146565992)
-- Dependencies: 4536 8
-- Name: deleteincident(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteincident(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pincdtid    ALIAS FOR $1;
  _count      INTEGER := 0;
  _incdtnbr   INTEGER := 0;
BEGIN
  SELECT COUNT(*) INTO _count
  FROM todoitem
  WHERE (todoitem_incdt_id=pincdtid);
  IF (_count > 0) THEN
    RETURN -1;
  END IF;

  DELETE FROM comment
   WHERE((comment_source='INCDT')
     AND (comment_source_id=pincdtid));

  DELETE FROM incdthist
   WHERE (incdthist_incdt_id=pincdtid);

  DELETE FROM imageass
  WHERE ((imageass_source='INCDT')
     AND (imageass_source_id=pincdtid));

  DELETE FROM url
  WHERE ((url_source='INCDT')
     AND (url_source_id=pincdtid));

  SELECT incdt_number INTO _incdtnbr
  FROM incdt
  WHERE (incdt_id=pincdtid);

  DELETE FROM incdt
    WHERE (incdt_id=pincdtid);

-- Incident #11538 needs to be fully resolved before release can be implemented
--    PERFORM releaseIncidentNumber(_incdtnbr);

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.deleteincident(integer) OWNER TO admin;

--
-- TOC entry 1423 (class 1255 OID 146565993)
-- Dependencies: 4536 8
-- Name: deleteinvoice(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteinvoice(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pInvcheadid ALIAS FOR $1;

BEGIN
  UPDATE shipitem SET shipitem_invoiced=FALSE, shipitem_invcitem_id=NULL
  FROM invcitem
  WHERE ((shipitem_invoiced)
    AND  (shipitem_invcitem_id=invcitem_id)
    AND  (invcitem_invchead_id=pInvcheadid));

  UPDATE coitem SET coitem_status = 'O'
  WHERE ((coitem_status = 'C')
    AND  (coitem_id IN (SELECT cobill_coitem_id
		        FROM cobill, invcitem
			WHERE ((cobill_invcitem_id=invcitem_id)
			  AND  (invcitem_invchead_id=pInvcheadid)))));

  UPDATE cobill SET cobill_invcnum=NULL, cobill_invcitem_id=NULL
  FROM invcitem
  WHERE ((cobill_invcitem_id=invcitem_id)
    AND  (invcitem_invchead_id=pInvcheadid));

  UPDATE invdetail SET invdetail_invcitem_id=NULL
  FROM invcitem
  WHERE ((invdetail_invcitem_id=invcitem_id)
    AND  (invcitem_invchead_id=pInvcheadid));

  UPDATE cobmisc SET cobmisc_invcnumber=NULL, cobmisc_invchead_id=NULL,
		     cobmisc_posted=FALSE
  WHERE (cobmisc_invchead_id=pInvcheadid);

  DELETE FROM aropenalloc
  WHERE (aropenalloc_doctype='I')
    AND (aropenalloc_doc_id=pInvcheadid);

  DELETE FROM charass
  WHERE (charass_target_type='INV')
    AND (charass_target_id=pInvcheadid);

  DELETE FROM invcitem
  WHERE (invcitem_invchead_id=pInvcheadid);

  DELETE FROM invchead
  WHERE (invchead_id=pInvcheadid);

  RETURN pInvcheadid;

END;
$_$;


ALTER FUNCTION public.deleteinvoice(integer) OWNER TO admin;

--
-- TOC entry 1424 (class 1255 OID 146565994)
-- Dependencies: 4536 8
-- Name: deleteipsitem(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteipsitem(pipsitemid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE

BEGIN

  DELETE FROM ipsiteminfo WHERE ipsitem_id=pIpsItemId;

  RETURN 1;
END;
$$;


ALTER FUNCTION public.deleteipsitem(pipsitemid integer) OWNER TO admin;

--
-- TOC entry 1425 (class 1255 OID 146565995)
-- Dependencies: 4536 8
-- Name: deleteipsprodcat(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteipsprodcat(pipsitemid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE

BEGIN

  DELETE FROM ipsiteminfo WHERE ipsitem_id=pIpsItemId;

  RETURN 1;
END;
$$;


ALTER FUNCTION public.deleteipsprodcat(pipsitemid integer) OWNER TO admin;

--
-- TOC entry 1426 (class 1255 OID 146565996)
-- Dependencies: 4536 8
-- Name: deleteitem(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteitem(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  _result INTEGER;

BEGIN

  SELECT bomitem_id INTO _result
  FROM bomitem
  WHERE (bomitem_item_id=pItemid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -1;
  END IF;

  SELECT itemsite_id INTO _result
  FROM itemsite
  WHERE (itemsite_item_id=pItemid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -2;
  END IF;

  SELECT itemsub_id INTO _result
  FROM itemsub
  WHERE (itemsub_sub_item_id=pItemid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -3;
  END IF;

  IF (fetchmetricbool('RevControl')) THEN
    SELECT rev_id INTO _result
    FROM rev
    WHERE ((rev_target_id=pItemid)
    AND (rev_target_type = 'BOM'))
    LIMIT 1;
    IF (FOUND) THEN
      RETURN -6;
    END IF;
  END IF;

  DELETE FROM bomhead
  WHERE (bomhead_item_id=pItemid);
  DELETE FROM bomitem
  WHERE (bomitem_item_id=pItemid);

  DELETE FROM itemcost
  WHERE (itemcost_item_id=pItemid);
  DELETE FROM costhist
  WHERE (costhist_item_id=pItemid);

  DELETE FROM itemsub
  WHERE (itemsub_parent_item_id=pItemid);
  DELETE FROM itemsub
  WHERE (itemsub_sub_item_id=pItemid);

  DELETE FROM itemsrcp
  WHERE (itemsrcp_itemsrc_id IN (SELECT itemsrc_id FROM itemsrc WHERE (itemsrc_item_id=pItemid)));
  DELETE FROM itemsrc
  WHERE (itemsrc_item_id=pItemid);

  DELETE FROM itemalias
  WHERE (itemalias_item_id=pItemid);

  DELETE FROM itemgrpitem
  WHERE (itemgrpitem_item_id=pItemid);

  DELETE FROM ipsiteminfo
  WHERE (ipsitem_item_id=pItemid);

  DELETE FROM imageass
  WHERE ( (imageass_source='I')
    AND   (imageass_source_id=pItemid) );

  DELETE FROM locitem
  WHERE (locitem_item_id=pItemid);

  DELETE FROM itemtax
   WHERE(itemtax_item_id=pItemid);

  DELETE FROM itemsite
  WHERE (itemsite_item_id=pItemid);

  DELETE FROM itemuom
   WHERE(itemuom_itemuomconv_id IN (SELECT itemuomconv_id
                                      FROM itemuomconv
                                     WHERE(itemuomconv_item_id=pItemid)));

  DELETE FROM itemuomconv
   WHERE(itemuomconv_item_id=pItemid);

  DELETE FROM item
  WHERE (item_id=pItemid);

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.deleteitem(integer) OWNER TO admin;

--
-- TOC entry 1427 (class 1255 OID 146565997)
-- Dependencies: 4536 8
-- Name: deleteitemcost(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteitemcost(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemId ALIAS FOR $1;
  pCostElemId ALIAS FOR $2;
  _itemcost_id INTEGER;
  _postcost_return BOOLEAN;
  _std_cost NUMERIC;

BEGIN
  SELECT itemcost_id INTO _itemcost_id
  FROM itemcost
  WHERE ( (itemcost_item_id = pItemId) AND (itemcost_costelem_id = pCostElemId) );

  IF (NOT FOUND) THEN
	RAISE EXCEPTION 'itemcost % not found for. ', pItemId || ' & ' || pCostElemId;
  END IF;

  SELECT itemcost_stdcost INTO _std_cost
  FROM itemcost
  WHERE (itemcost_id = _itemcost_id);

  IF (_std_cost > 0) THEN
--Actual Cost is updated to zero to ensure inventory is valued correctly
    PERFORM updateCost(_itemcost_id, 0);
  END IF;

  DELETE FROM itemcost
  WHERE (itemcost_id=_itemcost_id);

  RETURN _itemcost_id;

END;
$_$;


ALTER FUNCTION public.deleteitemcost(integer, integer) OWNER TO admin;

--
-- TOC entry 1428 (class 1255 OID 146565998)
-- Dependencies: 4536 8
-- Name: deleteitemsite(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteitemsite(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  _result INTEGER;
  _lotserial BOOLEAN;
  _bbom BOOLEAN;
  _mfg BOOLEAN;
  _standard BOOLEAN;

BEGIN

  IF ( ( SELECT ( (itemsite_qtyonhand <> 0) OR (itemsite_nnqoh <> 0) )
         FROM itemsite
         WHERE (itemsite_id=pItemsiteid) ) ) THEN
    RETURN -9;
  END IF;

  SELECT metric_value='t' INTO _bbom
    FROM metric
   WHERE (metric_name='BBOM');

  SELECT metric_value='t' INTO _lotserial
    FROM metric
   WHERE (metric_name='LotSerialControl');

  SELECT metric_value NOT IN ('PostBooks', 'Standard') INTO _mfg
    FROM metric
   WHERE (metric_name='Application');

  SELECT metric_value='Standard' INTO _standard
    FROM metric
   WHERE (metric_name='Application');

  SELECT invhist_id INTO _result
  FROM invhist
  WHERE (invhist_itemsite_id=pItemsiteid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -1;
  END IF;

  IF (_lotserial) THEN
    SELECT lsdetail_id INTO _result
    FROM lsdetail
    WHERE (lsdetail_itemsite_id=pItemsiteid)
    LIMIT 1;
    IF (FOUND) THEN
      RETURN -1;
    END IF;
  END IF;

  SELECT wo_id INTO _result
  FROM wo
  WHERE (wo_itemsite_id=pItemsiteid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -2;
  END IF;

  SELECT womatl_id INTO _result
  FROM womatl
  WHERE (womatl_itemsite_id=pItemsiteid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -2;
  END IF;

  SELECT womatlvar_id INTO _result
  FROM womatlvar
  WHERE ( (womatlvar_parent_itemsite_id=pItemsiteid)
   OR (womatlvar_component_itemsite_id=pItemsiteid) )
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -2;
  END IF;

  IF (_bbom) THEN
    SELECT brdvar_id INTO _result
    FROM xtmfg.brdvar
    WHERE ( (brdvar_itemsite_id=pItemsiteid)
     OR (brdvar_parent_itemsite_id=pItemsiteid) )
    LIMIT 1;
    IF (FOUND) THEN
      RETURN -2;
    END IF;
  END IF;

  SELECT coitem_id INTO _result
  FROM coitem
  WHERE (coitem_itemsite_id=pItemsiteid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -3;
  END IF;

  SELECT cohist_id INTO _result
  FROM cohist
  WHERE (cohist_itemsite_id=pItemsiteid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -3;
  END IF;

  SELECT quitem_id INTO _result
  FROM quitem
  WHERE (quitem_itemsite_id=pItemsiteid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -3;
  END IF;

  SELECT cmitem_id INTO _result
  FROM cmitem
  WHERE (cmitem_itemsite_id=pItemsiteid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -3;
  END IF;


  SELECT poitem_id INTO _result
  FROM poitem
  WHERE (poitem_itemsite_id=pItemsiteid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -4;
  END IF;

  SELECT recv_id INTO _result
  FROM recv
  WHERE (recv_itemsite_id=pItemsiteid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -4;
  END IF;

  SELECT poreject_id INTO _result
  FROM poreject
  WHERE (poreject_itemsite_id=pItemsiteid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -4;
  END IF;

  SELECT pr_id INTO _result
  FROM pr
  WHERE (pr_itemsite_id=pItemsiteid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -4;
  END IF;

  IF (_mfg OR _standard) THEN
    SELECT planord_id INTO _result
    FROM planord
    WHERE (planord_itemsite_id=pItemsiteid)
    LIMIT 1;
    IF (FOUND) THEN
      RETURN -5;
    END IF;
  END IF;

  IF (_mfg) THEN
    SELECT pschitem_id INTO _result
    FROM xtmfg.pschitem
    WHERE (pschitem_itemsite_id=pItemsiteid)
    LIMIT 1;
    IF (FOUND) THEN
      RETURN -6;
    END IF;

    SELECT woopervar_id INTO _result
    FROM xtmfg.woopervar
    WHERE (woopervar_parent_itemsite_id=pItemsiteid)
    LIMIT 1;
    IF (FOUND) THEN
      RETURN -2;
    END IF;

  END IF;

  IF (_mfg OR _standard) THEN
    SELECT itemsite_id INTO _result
    FROM itemsite
    WHERE (itemsite_supply_itemsite_id=pItemsiteid)
    LIMIT 1;
    IF (FOUND) THEN
      RETURN -7;
    END IF;
  END IF;

  DELETE FROM invcnt
  WHERE (invcnt_itemsite_id=pItemsiteid);

  DELETE FROM itemloc
  WHERE (itemloc_itemsite_id=pItemsiteid);
  DELETE FROM itemlocdist
  WHERE (itemlocdist_itemsite_id=pItemsiteid);

  IF (_bbom) THEN
    DELETE FROM xtmfg.brddist
    WHERE (brddist_itemsite_id=pItemsiteid);
  END IF;

  DELETE FROM itemsite
  WHERE (itemsite_id=pItemsiteid);

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.deleteitemsite(integer) OWNER TO admin;

--
-- TOC entry 1429 (class 1255 OID 146565999)
-- Dependencies: 4536 8
-- Name: deleteitemuom(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteitemuom(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemuomid ALIAS FOR $1;

BEGIN
  DELETE FROM itemuom WHERE itemuom_id=pItemuomid;

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.deleteitemuom(integer) OWNER TO admin;

--
-- TOC entry 1430 (class 1255 OID 146566000)
-- Dependencies: 4536 8
-- Name: deleteitemuomconv(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteitemuomconv(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemuomconvid ALIAS FOR $1;
  _fromuomid     INTEGER;
  _invuomid      INTEGER;
  _itemid        INTEGER;
  _touomid       INTEGER;

BEGIN
  SELECT itemuomconv_item_id, item_inv_uom_id,
         itemuomconv_from_uom_id, itemuomconv_to_uom_id
          INTO _itemid, _invuomid, _fromuomid, _touomid
  FROM itemuomconv JOIN item ON (itemuomconv_item_id=item_id)
  WHERE (itemuomconv_id=pItemuomconvid);

  IF EXISTS(SELECT *
            FROM uomusedforitem(_itemid)
            WHERE ((uom_id IN (_fromuomid, _touomid))
               AND (uom_id != _invuomid)) ) THEN
    RETURN -1;
  END IF;

  DELETE FROM itemuom WHERE itemuom_itemuomconv_id=pItemuomconvid;
  DELETE FROM itemuomconv WHERE itemuomconv_id=pItemuomconvid;

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.deleteitemuomconv(integer) OWNER TO admin;

--
-- TOC entry 1431 (class 1255 OID 146566001)
-- Dependencies: 4536 8
-- Name: deletelocation(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletelocation(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pLocationid ALIAS FOR $1;
  _check INTEGER;

BEGIN

--  Check to see if any itemsite used the passed location as their default
  SELECT itemsite_id INTO _check
  FROM itemsite
  WHERE (itemsite_location_id=pLocationid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -1;
  END IF;

--  Check to see if any inventory is currently stored at the passed location
  SELECT itemloc_id INTO _check
  FROM itemloc
  WHERE (itemloc_location_id=pLocationid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -2;
  END IF;

--  Check to see if any undistributed inventory transactions are currently posted at the passed location
  SELECT itemlocdist_id INTO _check
  FROM itemlocdist
  WHERE ( (itemlocdist_source_type='L')
  AND (itemlocdist_source_id=pLocationid) )
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -3;
  END IF;

--  Check to see if the passed location has any Inventory Detail posted against it
  SELECT invdetail_id INTO _check
  FROM invdetail
  WHERE (invdetail_location_id=pLocationid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -4;
  END IF;

--  Delete any associated locitem records
  DELETE FROM locitem
  WHERE (locitem_location_id=pLocationid);

--  Delete the location record
  DELETE FROM location
  WHERE (location_id=pLocationid);

  RETURN pLocationid;

END;
$_$;


ALTER FUNCTION public.deletelocation(integer) OWNER TO admin;

--
-- TOC entry 1432 (class 1255 OID 146566002)
-- Dependencies: 4536 8
-- Name: deletemetasql(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletemetasql(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pid ALIAS FOR $1;
BEGIN
  DELETE FROM metasql WHERE metasql_id = pid;
  RETURN 0;
END;
$_$;


ALTER FUNCTION public.deletemetasql(integer) OWNER TO admin;

--
-- TOC entry 1435 (class 1255 OID 146566003)
-- Dependencies: 4536 8
-- Name: deleteopenrecurringitems(integer, text, timestamp with time zone, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteopenrecurringitems(integer, text, timestamp with time zone, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pParentid     ALIAS FOR $1;
  pType         TEXT                     := UPPER($2);
  pDatetime     TIMESTAMP WITH TIME ZONE := COALESCE($3, startOfTime());
  pInclParent   BOOLEAN                  := COALESCE($4, FALSE);

  _count         INTEGER := 0;
  _delchildstmt  TEXT;
  _delparentstmt TEXT;
  _rt            RECORD;
  _tmp           INTEGER;
BEGIN
  RAISE DEBUG 'deleteOpenRecurringItems(%, %, %)', pParentid, pType, pDatetime;

  IF (pParentid IS NULL) THEN
    RETURN -11;
  END IF;

  SELECT * INTO _rt FROM recurtype WHERE (UPPER(recurtype_type)=pType);
  GET DIAGNOSTICS _count = ROW_COUNT;
  IF (_count <= 0) THEN
    RETURN -10;
  END IF;

  -- 2 deletes avoid reparenting problems if the parent gets deleted first
  IF (_rt.recurtype_delfunc IS NULL) THEN
    _delchildstmt := 'DELETE FROM [fulltable] '
                  || ' WHERE (NOT ([done])'
                  || '    AND ([schedcol]>''$2'')'
                  || '    AND ([table]_recurring_[table]_id=$1)'
                  || '    AND ([table]_id!=$1));';

    _delparentstmt := 'DELETE FROM [fulltable] USING recur'
                   || ' WHERE (NOT ([done])'
                   || '    AND ([schedcol]>''$2'')'
                   || '    AND ([table]_recurring_[table]_id=$1)'
                   || '    AND ([table]_id=$1));';

  ELSE
    _delchildstmt := 'SELECT [delfunc]([table]_id)'
                  || '  FROM [fulltable] '
                  || ' WHERE (NOT ([done])'
                  || '    AND ([schedcol]>''$2'')'
                  || '    AND ([table]_recurring_[table]_id=$1)'
                  || '    AND ([table]_id!=$1));';
    _delparentstmt := 'SELECT [delfunc]([table]_id)'
                   || '  FROM [fulltable] '
                   || ' WHERE (NOT ([done])'
                   || '    AND ([schedcol]>''$2'')'
                   || '    AND ([table]_recurring_[table]_id=$1)'
                   || '    AND ([table]_id!=$1));';
    _delchildstmt  := REPLACE(_delchildstmt,  '[delfunc]', _rt.recurtype_delfunc);
    _delparentstmt := REPLACE(_delparentstmt, '[delfunc]', _rt.recurtype_delfunc);
  END IF;

  RAISE DEBUG '_delchildstmt has been set to %', _delchildstmt;

  _delchildstmt := REPLACE(_delchildstmt, '[fulltable]', _rt.recurtype_table);
  _delchildstmt := REPLACE(_delchildstmt, '[table]',
                            REGEXP_REPLACE(_rt.recurtype_table, E'.*\\.', ''));
  _delchildstmt := REPLACE(_delchildstmt, '[done]',  _rt.recurtype_donecheck);
  _delchildstmt := REPLACE(_delchildstmt, '[schedcol]', _rt.recurtype_schedcol);

  _delparentstmt := REPLACE(_delparentstmt, '[fulltable]', _rt.recurtype_table);
  _delparentstmt := REPLACE(_delparentstmt, '[table]',
                            REGEXP_REPLACE(_rt.recurtype_table, E'.*\\.', ''));
  _delparentstmt := REPLACE(_delparentstmt, '[done]',  _rt.recurtype_donecheck);
  _delparentstmt := REPLACE(_delparentstmt, '[schedcol]', _rt.recurtype_schedcol);

  RAISE DEBUG 'substitutions changed _delchildstmt to %', _delchildstmt;

  IF (_rt.recurtype_delfunc IS NULL) THEN
    -- 8.4+: EXECUTE _delchildstmt  USING pDatetime, pType;
    RAISE DEBUG '% with % and %', _delchildstmt, pType, pDatetime;
    EXECUTE REPLACE(REPLACE(_delchildstmt, '$1', pParentid::TEXT),
                                           '$2', pDatetime::TEXT);
    GET DIAGNOSTICS _count = ROW_COUNT;

    IF (pInclParent) THEN
      -- 8.4+: EXECUTE _delparentstmt USING pDatetime, pType;
      RAISE DEBUG '% with % and %', _delparentstmt, pType, pDatetime;
      EXECUTE REPLACE(REPLACE(_delparentstmt, '$1', pParentid::TEXT),
                                              '$2', pDatetime::TEXT);
      GET DIAGNOSTICS _tmp   = ROW_COUNT;
      _count := _count + _tmp;
    END IF;

  ELSE
    -- 8.4+: FOR _tmp IN EXECUTE _delchildstmt USING pDatetime, pType LOOP
    FOR _tmp IN EXECUTE REPLACE(REPLACE(_delchildstmt, '$1', pParentid::TEXT),
                                                       '$2', pDatetime::TEXT)
    LOOP
      IF _tmp < 0 THEN
        RETURN _tmp;
      END IF;
      _count := _count + 1;
    END LOOP;

    IF (pInclParent) THEN
      -- 8.4+: EXECUTE _delparentstmt INTO _tmp USING pDatetime, pType;
      EXECUTE REPLACE(REPLACE(_delparentstmt, '$1', pParentid::TEXT),
                                              '$2', pDatetime::TEXT) INTO _tmp;
      IF (_tmp < 0) THEN
        RETURN _tmp;
      END IF;
      _count := _count + 1;
    END IF;
  END IF;

  RAISE DEBUG 'deleteOpenrecurringItems() returning %', _count;
  RETURN _count;
END;
$_$;


ALTER FUNCTION public.deleteopenrecurringitems(integer, text, timestamp with time zone, boolean) OWNER TO admin;

--
-- TOC entry 1436 (class 1255 OID 146566004)
-- Dependencies: 4536 8
-- Name: deleteopportunity(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteopportunity(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pOpheadid ALIAS FOR $1;
  _test INTEGER;
BEGIN

  SELECT todoitem_id INTO _test
    FROM todoitem
   WHERE(todoitem_ophead_id=pOpheadid)
   LIMIT 1;
  IF(FOUND) THEN
    RETURN -1;
  END IF;

  SELECT quhead_id INTO _test
    FROM quhead
   WHERE(quhead_ophead_id=pOpheadid)
   LIMIT 1;
  IF(FOUND) THEN
    RETURN -2;
  END IF;

  SELECT cohead_id INTO _test
    FROM cohead
   WHERE(cohead_ophead_id=pOpheadid)
   LIMIT 1;
  IF(FOUND) THEN
    RETURN -3;
  END IF;

  DELETE
    FROM charass
   WHERE((charass_target_type='OPP')
     AND (charass_target_id=pOpheadid));

  DELETE
    FROM comment
   WHERE((comment_source='OPP')
     AND (comment_source_id=pOpheadid));

  DELETE
    FROM ophead
   WHERE(ophead_id=pOpheadid);

  return 0;
END;
$_$;


ALTER FUNCTION public.deleteopportunity(integer) OWNER TO admin;

--
-- TOC entry 1437 (class 1255 OID 146566005)
-- Dependencies: 4536 8
-- Name: deletepackage(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletepackage(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  ppkgheadid    ALIAS FOR $1;
  _i            INTEGER := 0;
  _pkgname      TEXT;
  _r            RECORD;
  _tabs         TEXT[] := ARRAY['cmd',  'cmdarg', 'image',  'metasql',
                                'priv', 'report', 'script', 'uiform'];
  _debug        BOOL := false;

BEGIN
  IF (EXISTS(SELECT *
             FROM pkgdep
             WHERE (pkgdep_parent_pkghead_id=ppkgheadid))) THEN
    RETURN -1;
  END IF;

  SELECT pkghead_name INTO _pkgname
  FROM pkghead
  WHERE (pkghead_id=ppkgheadid);
  IF (NOT FOUND) THEN
    RETURN -2;
  END IF;

  IF (LOWER(_pkgname) = 'public' OR LOWER(_pkgname) = 'api') THEN
    RETURN -3;
  END IF;

  FOR _i IN ARRAY_LOWER(_tabs,1)..ARRAY_UPPER(_tabs,1) LOOP
    EXECUTE 'ALTER TABLE ' || _pkgname || '.pkg' || _tabs[_i] ||
            ' DISABLE TRIGGER pkg' || _tabs[_i] || 'altertrigger;';
  END LOOP;

  DELETE FROM pkghead WHERE pkghead_id=ppkgheadid;

  RETURN ppkgheadid;
END;
$_$;


ALTER FUNCTION public.deletepackage(integer) OWNER TO admin;

--
-- TOC entry 1438 (class 1255 OID 146566006)
-- Dependencies: 4536 8
-- Name: deletepo(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletepo(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPoheadid ALIAS FOR $1;
  _poitemid INTEGER;

BEGIN

  IF ( ( SELECT pohead_status
         FROM pohead
         WHERE (pohead_id=pPoheadid) ) = 'U' ) THEN

    -- Unlink from any Sales Orders
    UPDATE coitem SET coitem_order_type=NULL,
                      coitem_order_id=NULL
    FROM poitem
    WHERE ( (coitem_order_type='P')
      AND   (coitem_order_id=poitem_id)
      AND   (poitem_pohead_id=pPoheadid) );

    DELETE FROM poitem
    WHERE (poitem_pohead_id=pPoheadid);

    DELETE FROM pohead
    WHERE (pohead_id=pPoheadid);

    RETURN TRUE;

  ELSE
    RETURN FALSE;
  END IF;

END;
$_$;


ALTER FUNCTION public.deletepo(integer) OWNER TO admin;

--
-- TOC entry 1439 (class 1255 OID 146566007)
-- Dependencies: 4536 8
-- Name: deletepoitem(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletepoitem(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPoitemid ALIAS FOR $1;
  _poheadid INTEGER := -1;
  _status CHARACTER;

BEGIN
  SELECT poitem_pohead_id, poitem_status INTO _poheadid, _status
  FROM poitem
  WHERE (poitem_id=pPoitemid);

  IF NOT(FOUND) THEN
    RETURN 0;
  END IF;

  IF ( _status = 'U' ) THEN
    DELETE FROM poitem
    WHERE (poitem_id=pPoitemid);
  ELSE
    IF ( _status = 'O' ) THEN
      PERFORM recv_id
      FROM recv
      WHERE ( (recv_order_type='PO')
       AND (recv_orderitem_id=pPoitemid) );
      IF (FOUND) THEN
        RETURN -10;
      ELSE
        RETURN -20;
      END IF;
    ELSE
      RETURN -10;
    END IF;
  END IF;

  PERFORM poitem_id
  FROM poitem
  WHERE poitem_pohead_id = _poheadid;

  IF NOT(FOUND) THEN
    DELETE FROM pohead
    WHERE (pohead_id = _poheadid);
  END IF;

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.deletepoitem(integer) OWNER TO admin;

--
-- TOC entry 1441 (class 1255 OID 146566009)
-- Dependencies: 4536 8
-- Name: deletepr(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletepr(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPrid ALIAS FOR $1;

BEGIN

  DELETE FROM pr
  WHERE ( (pr_status='O')
   AND (pr_id=pPrid) );

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.deletepr(integer) OWNER TO admin;

--
-- TOC entry 1440 (class 1255 OID 146566008)
-- Dependencies: 4536 8
-- Name: deletepr(character, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletepr(character, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pParentType ALIAS FOR $1;
  pParentId ALIAS FOR $2;

BEGIN

  DELETE FROM pr
  WHERE ((pr_status='O')
   AND (pr_order_type=pParentType)
   AND (pr_order_id=pParentId));

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.deletepr(character, integer) OWNER TO admin;

--
-- TOC entry 1442 (class 1255 OID 146566010)
-- Dependencies: 4536 8
-- Name: deleteproductcategory(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteproductcategory(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pProdcatid ALIAS FOR $1;
  _check INTEGER;

BEGIN

--  Check to see if any items are assigned to the passed classcode
  SELECT item_id INTO _check
  FROM item
  WHERE (item_prodcat_id=pProdcatid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -1;
  END IF;

--  Delete any assocated records
  DELETE FROM salesaccnt
  WHERE (salesaccnt_prodcat_id=pProdcatid);

--  Delete the passed prodcat
  DELETE FROM prodcat
  WHERE (prodcat_id=pProdcatid);

  RETURN pProdcatid;

END;
$_$;


ALTER FUNCTION public.deleteproductcategory(integer) OWNER TO admin;

--
-- TOC entry 1408 (class 1255 OID 146566011)
-- Dependencies: 4536 8
-- Name: deleteprofitcenter(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteprofitcenter(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pid ALIAS FOR $1;

BEGIN
  IF (EXISTS(SELECT accnt_id
             FROM accnt, prftcntr
             WHERE ((accnt_company=prftcntr_number)
               AND  (prftcntr_id=pid))
            )) THEN
    RETURN -1;
  END IF;

  DELETE FROM prftcntr
  WHERE (prftcntr_id=pid);

  RETURN pid;

END;
$_$;


ALTER FUNCTION public.deleteprofitcenter(integer) OWNER TO admin;

--
-- TOC entry 1444 (class 1255 OID 146566012)
-- Dependencies: 4536 8
-- Name: deleteproject(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteproject(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPrjid ALIAS FOR $1;
  _result INTEGER;
BEGIN

  SELECT quhead_id INTO _result
    FROM quhead
   WHERE (quhead_prj_id=pPrjid)
   LIMIT 1;
  IF (FOUND) THEN
    RETURN -1;
  END IF;

  SELECT cohead_id INTO _result
    FROM cohead
   WHERE (cohead_prj_id=pPrjid)
   LIMIT 1;
  IF (FOUND) THEN
    RETURN -2;
  END IF;

  SELECT wo_id INTO _result
    FROM wo
   WHERE (wo_prj_id=pPrjid)
   LIMIT 1;
  IF (FOUND) THEN
    RETURN -3;
  END IF;

  SELECT pr_id INTO _result
    FROM pr
   WHERE (pr_prj_id=pPrjid)
   LIMIT 1;
  IF (FOUND) THEN
    RETURN -4;
  END IF;

  SELECT poitem_id INTO _result
    FROM poitem
   WHERE (poitem_prj_id=pPrjid)
   LIMIT 1;
  IF (FOUND) THEN
    RETURN -5;
  END IF;

  SELECT invchead_id INTO _result
    FROM invchead
   WHERE (invchead_prj_id=pPrjid)
   LIMIT 1;
  IF (FOUND) THEN
    RETURN -6;
  END IF;

  DELETE FROM comment
  WHERE ((comment_source='J')
  AND (comment_source_id=pPrjid));

  DELETE FROM comment
  WHERE ((comment_source='TA')
  AND (comment_source_id IN (
    SELECT prjtask_id
    FROM prjtask
    WHERE (prjtask_prj_id=pPrjId))));

  DELETE FROM prjtask
   WHERE (prjtask_prj_id=pPrjid);

  UPDATE prj
     SET prj_recurring_prj_id=null
   WHERE(prj_recurring_prj_id=pPrjid);

  DELETE FROM prj
   WHERE (prj_id=pPrjid);
  RETURN pPrjid;
END;
$_$;


ALTER FUNCTION public.deleteproject(integer) OWNER TO admin;

--
-- TOC entry 1445 (class 1255 OID 146566013)
-- Dependencies: 4536 8
-- Name: deleteprojecttask(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteprojecttask(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPrjtaskid ALIAS FOR $1;
  _row RECORD;
  _result INTEGER;
BEGIN

  SELECT * INTO _row
    FROM prjtask
   WHERE (prjtask_id=pPrjtaskid)
   LIMIT 1;
  IF (NOT FOUND) THEN
    RETURN -1;
  END IF;

  IF (COALESCE(_row.prjtask_hours_actual, 0.0) > 0.0) THEN
    RETURN -2;
  END IF;

  IF (COALESCE(_row.prjtask_exp_actual, 0.0) > 0.0) THEN
    RETURN -3;
  END IF;

  DELETE FROM comment
  WHERE ((comment_source='TA')
  AND (comment_source_id=pPrjtaskid));

  DELETE FROM prjtask
   WHERE (prjtask_id=pPrjtaskid);

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.deleteprojecttask(integer) OWNER TO admin;

--
-- TOC entry 1446 (class 1255 OID 146566014)
-- Dependencies: 4536 8
-- Name: deleteqryhead(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteqryhead(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pqryheadid    ALIAS FOR $1;

BEGIN
  DELETE FROM qryitem WHERE (qryitem_qryhead_id=pqryheadid);
  DELETE FROM qryhead WHERE (qryhead_id=pqryheadid);

  RETURN pqryheadid;
END;
$_$;


ALTER FUNCTION public.deleteqryhead(integer) OWNER TO admin;

--
-- TOC entry 1448 (class 1255 OID 146566016)
-- Dependencies: 4536 8
-- Name: deletequote(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletequote(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pQuheadid ALIAS FOR $1;
BEGIN
  RETURN deleteQuote(pQuheadid, NULL::TEXT);
END;
$_$;


ALTER FUNCTION public.deletequote(integer) OWNER TO admin;

--
-- TOC entry 1447 (class 1255 OID 146566015)
-- Dependencies: 4536 8
-- Name: deletequote(integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletequote(integer, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pQuheadid	ALIAS FOR $1;
  pQuoteNumber	ALIAS FOR $2;

  _quNumberScheme	TEXT;
  _quoteNumber		TEXT;
  _quitemid             INTEGER;
  _result               INTEGER;

BEGIN

  SELECT fetchMetricText('QUNumberGeneration') INTO _quNumberScheme;

  IF (pQuoteNumber IS NULL) THEN
    SELECT quhead_number INTO _quoteNumber
    FROM quhead
    WHERE (quhead_id=pQuheadid);
  ELSE
    _quoteNumber := pQuoteNumber;
  END IF;

  PERFORM deleteQuoteItem(quitem_id)
  FROM quitem
  WHERE (quitem_quhead_id=pQuheadid);

  DELETE FROM charass
  WHERE (charass_target_type='QU')
    AND (charass_target_id=pQuheadid);

  DELETE FROM quhead
  WHERE (quhead_id=pQuheadid);

  IF (_quoteNumber IS NOT NULL) THEN
    IF (_quNumberScheme IN ('A', 'O')) THEN
      -- do not release quote # if quote converted to sales order
      IF (NOT EXISTS (SELECT cohead_id
		      FROM cohead
		      WHERE (cohead_number=_quoteNumber))) THEN
	_result = releaseQuNumber(_quoteNumber);
      END IF;
    ELSEIF (_quNumberScheme = 'S') THEN
      _result = releaseSoNumber(_quoteNumber);
    END IF;
  END IF;

  -- Don't care about result of release number
  RETURN 0;

END;
$_$;


ALTER FUNCTION public.deletequote(integer, text) OWNER TO admin;

--
-- TOC entry 1449 (class 1255 OID 146566017)
-- Dependencies: 4536 8
-- Name: deletequote(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletequote(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pQuheadid ALIAS FOR $1;
  pQuoteNumber	ALIAS FOR $2;
BEGIN
  RETURN deleteQuote(pQuheadid, pQuoteNumber::TEXT);
END;
$_$;


ALTER FUNCTION public.deletequote(integer, integer) OWNER TO admin;

--
-- TOC entry 1450 (class 1255 OID 146566018)
-- Dependencies: 4536 8
-- Name: deletequoteitem(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletequoteitem(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
  pQuitemid ALIAS FOR $1;

  _result               INTEGER;

BEGIN

  DELETE FROM charass
  WHERE (charass_target_type='QI')
    AND (charass_target_id=pQuitemid);

  DELETE FROM quitem
  WHERE (quitem_id=pQuitemid);

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.deletequoteitem(integer) OWNER TO admin;

--
-- TOC entry 1451 (class 1255 OID 146566019)
-- Dependencies: 4536 8
-- Name: deleterecvfororder(text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleterecvfororder(text, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pordertype	ALIAS FOR $1;
  porderid	ALIAS FOR $2;

BEGIN
  DELETE FROM recv
  USING orderitem
  WHERE ((recv_orderitem_id=orderitem_id)
    AND  (recv_order_type=orderitem_orderhead_type)
    AND  (NOT recv_posted)
    AND  (orderitem_orderhead_id=porderid)
    AND  (orderitem_orderhead_type=pordertype));

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.deleterecvfororder(text, integer) OWNER TO admin;

--
-- TOC entry 1452 (class 1255 OID 146566020)
-- Dependencies: 4536 8
-- Name: deletesalescategory(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletesalescategory(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSalescatid ALIAS FOR $1;

BEGIN

  PERFORM invcitem_salescat_id
  FROM invchead, invcitem
  WHERE ( (invcitem_invchead_id=invchead_id)
   AND (NOT invchead_posted)
   AND (invcitem_salescat_id=pSalescatid) );
  IF (FOUND) THEN
    RETURN -1;
  END IF;

  PERFORM invcitem_salescat_id
  FROM invchead, invcitem
  WHERE ( (invcitem_invchead_id=invchead_id)
   AND (invchead_posted)
   AND (invcitem_salescat_id=pSalescatid) );
  IF (FOUND) THEN
    RETURN -2;
  END IF;

  PERFORM aropen_salescat_id
     FROM aropen
    WHERE (aropen_salescat_id=pSalescatid);
  IF (FOUND) THEN
    RETURN -3;
  END IF;

  DELETE FROM salescat
  WHERE (salescat_id=pSalescatid);

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.deletesalescategory(integer) OWNER TO admin;

--
-- TOC entry 1453 (class 1255 OID 146566021)
-- Dependencies: 4536 8
-- Name: deleteshippingcharge(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteshippingcharge(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pShipchrgid ALIAS FOR $1;

BEGIN

  IF EXISTS(SELECT 1
              FROM custinfo
             WHERE (cust_shipchrg_id=pShipchrgid)) THEN
    RETURN -1;
  END IF;

  DELETE FROM shipchrg
  WHERE (shipchrg_id=pShipchrgid);

  RETURN pShipchrgid;

END;
$_$;


ALTER FUNCTION public.deleteshippingcharge(integer) OWNER TO admin;

--
-- TOC entry 1455 (class 1255 OID 146566022)
-- Dependencies: 4536 8
-- Name: deleteshippingchargetype(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteshippingchargetype(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pShipchrgid ALIAS FOR $1;
  _check INTEGER;

BEGIN

--  Check to see if the passed shipchrg is used as a default for any customers
  SELECT cust_id INTO _check
  FROM custinfo
  WHERE (cust_shipchrg_id=pShipchrgid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -1;
  END IF;

--  Check to see if the passed shipchrg is used as a default for any shiptos
  SELECT shipto_id INTO _check
  FROM shiptoinfo
  WHERE (shipto_shipchrg_id=pShipchrgid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -2;
  END IF;

--  Check to see if the passed shipchrg is used on any sales orders
  SELECT cohead_id INTO _check
  FROM cohead
  WHERE (cohead_shipchrg_id=pShipchrgid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -3;
  END IF;

--  Check to see if the passed shipchrg is used on any shippers
  SELECT shiphead_id INTO _check
  FROM shiphead
  WHERE (shiphead_shipchrg_id=pShipchrgid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -4;
  END IF;

--  Check to see if the passed shipchrg is used on any invoices
  SELECT invchead_id INTO _check
  FROM invchead
  WHERE (invchead_shipchrg_id=pShipchrgid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -5;
  END IF;

--  Delete the passed shipchrg
  DELETE FROM shipchrg
  WHERE (shipchrg_id=pShipchrgid);

  RETURN pShipchrgid;

END;
$_$;


ALTER FUNCTION public.deleteshippingchargetype(integer) OWNER TO admin;

--
-- TOC entry 1456 (class 1255 OID 146566023)
-- Dependencies: 4536 8
-- Name: deleteshipto(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteshipto(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pShiptoid ALIAS FOR $1;

BEGIN

  PERFORM asohist_id
  FROM asohist
  WHERE (asohist_shipto_id=pShiptoid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -1;
  END IF;

  PERFORM cohead_id
  FROM cohead
  WHERE (cohead_shipto_id=pShiptoid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -2;
  END IF;

  PERFORM cmhead_id
  FROM cmhead
  WHERE (cmhead_shipto_id=pShiptoid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -3;
  END IF;

  PERFORM cohist_id
  FROM cohist
  WHERE (cohist_shipto_id=pShiptoid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -4;
  END IF;

  PERFORM quhead_id
  FROM quhead
  WHERE (quhead_shipto_id=pShiptoid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -5;
  END IF;

  PERFORM invchead_id
  FROM invchead
  WHERE (invchead_shipto_id=pShiptoid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -6;
  END IF;

  DELETE FROM ipsass
  WHERE (ipsass_shipto_id=pShiptoid);

  DELETE FROM shiptoinfo
  WHERE (shipto_id=pShiptoid);

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.deleteshipto(integer) OWNER TO admin;

--
-- TOC entry 1457 (class 1255 OID 146566024)
-- Dependencies: 4536 8
-- Name: deleteso(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteso(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSoheadid    ALIAS FOR $1;
BEGIN
  RETURN deleteSo(pSoheadid, NULL);
END;
$_$;


ALTER FUNCTION public.deleteso(integer) OWNER TO admin;

--
-- TOC entry 1458 (class 1255 OID 146566025)
-- Dependencies: 4536 8
-- Name: deleteso(integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteso(integer, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSoheadid	ALIAS FOR $1;
  pSonumber	ALIAS FOR $2;

  _r            RECORD;
  _coitemid     INTEGER;
  _result       INTEGER;
  _poStatus     INTEGER := 0;

BEGIN
-- Get cohead
  SELECT * INTO _r FROM cohead WHERE (cohead_id=pSoheadid);

   IF (NOT FOUND) THEN
     RETURN 0;
   END IF;

-- Cannot delete if credit card payments
  IF (EXISTS(SELECT ccpay_id
	     FROM ccpay, payco
	     WHERE ((ccpay_status IN ('C'))
	       AND  (ccpay_id=payco_ccpay_id)
	       AND  (payco_cohead_id=pSoheadid)))) THEN
    RETURN -1;
  END IF;

-- Cannot delete if credit card history
  IF (EXISTS(SELECT ccpay_id
	     FROM ccpay, payco
	     WHERE ((ccpay_status != 'C')
	       AND  (ccpay_id=payco_ccpay_id)
	       AND  (payco_cohead_id=pSoheadid)))) THEN
    RETURN -2;
  END IF;

-- Delete Sales Order Items
  FOR _coitemid IN
    SELECT coitem_id
    FROM coitem
    WHERE ( (coitem_cohead_id=pSoheadid)
      AND   (coitem_subnumber=0) ) LOOP

    SELECT deleteSoItem(_coitemid) INTO _result;
    IF (_result < 0) THEN
      IF (_result = -20) THEN
        _poStatus := _poStatus - 1;
      ELSE
        RETURN _result;
      END IF;
    END IF;

  END LOOP;

  DELETE FROM pack
  WHERE (pack_head_id=pSoheadid and pack_head_type = 'SO');

  DELETE FROM charass
  WHERE (charass_target_type='SO')
    AND (charass_target_id=pSoheadid);

  DELETE FROM cohead
  WHERE (cohead_id=pSoheadid);

  IF (fetchMetricBool('AutoCreateProjectsForOrders')) THEN
    PERFORM deleteProject(_r.cohead_prj_id);
  END IF;

  DELETE FROM aropenalloc
  WHERE ((aropenalloc_doctype='S')
    AND  (aropenalloc_doc_id=pSoheadid));

  IF ( (NOT _r.cohead_wasquote) AND (NOT _r.cohead_imported) ) THEN
    IF (COALESCE(pSonumber,'') != '') THEN
      _result = releaseSoNumber(pSonumber);
    ELSEIF (_r.cohead_number IS NOT NULL) THEN
      _result = releaseSoNumber(_r.cohead_number);
    END IF;
  END IF;

  IF (_poStatus < 0) THEN
    RETURN -20;
  ELSE
    RETURN 0;
  END IF;

END;
$_$;


ALTER FUNCTION public.deleteso(integer, text) OWNER TO admin;

--
-- TOC entry 1459 (class 1255 OID 146566026)
-- Dependencies: 4536 8
-- Name: deletesoitem(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletesoitem(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSoitemid	ALIAS FOR $1;

  _r            RECORD;
  _s            RECORD;
  _result       INTEGER;
  _deletePO     INTEGER := 0;
  _recvId       INTEGER := -1;
  _poStatus     TEXT;
  _jobItem      BOOLEAN;

BEGIN
-- Get coitem
   SELECT * INTO _r FROM coitem WHERE (coitem_id=pSoitemid);

   IF (NOT FOUND) THEN
     RETURN -999;
   END IF;

-- Cannot delete if shipped
  IF (_r.coitem_qtyshipped > 0) THEN
    RETURN -101;
  END IF;

-- Cannot delete if issued to shipping
  SELECT shipitem_id INTO _result
  FROM shipitem JOIN shiphead ON (shiphead_id=shipitem_shiphead_id AND shiphead_order_type='SO')
  WHERE (shipitem_orderitem_id=pSoitemid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -102;
  END IF;

-- Cannot delete if returned
  IF (fetchMetricBool('MultiWhs')) THEN
    SELECT raitem_id INTO _result
    FROM raitem
    WHERE ( (raitem_orig_coitem_id=pSoitemid)
       OR   (raitem_new_coitem_id=pSoitemid) )
    LIMIT 1;
    IF (FOUND) THEN
      RETURN -103;
    END IF;
  END IF;

-- Cannot delete if any inventory history
  SELECT invhist_id INTO _result
  FROM invhist
  WHERE ( (invhist_ordnumber=formatSoNumber(pSoitemid))
    AND   (invhist_ordtype='SO') )
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -105;
  END IF;

-- If Kit, check deletion of component items
  IF (_r.coitem_subnumber = 0) THEN
    FOR _s IN
      SELECT *
      FROM coitem
      WHERE ((coitem_cohead_id = _r.coitem_cohead_id)
        AND  (coitem_linenumber = _r.coitem_linenumber)
        AND  (coitem_subnumber > 0))
    LOOP
      IF ((COALESCE(_s.coitem_order_id, -1) > 0)
       AND (_s.coitem_order_type = 'P')) THEN
        SELECT poitem_status, COALESCE(recv_id, -1)
          INTO _poStatus, _recvId
        FROM poitem LEFT OUTER JOIN recv
               ON ((recv_orderitem_id=poitem_id)
                 AND (recv_order_type='PO'))
        WHERE (poitem_id = _s.coitem_order_id);

        IF ((_recvId > 0) OR (_poStatus = 'C')) THEN
          RETURN -10;
        ELSIF ((_recvId = -1) AND (_poStatus = 'O')) THEN
          _deletePO := _deletePO - 1;
        END IF;
      END IF;
    END LOOP;
  END IF;


  SELECT (itemsite_costmethod='J') INTO _jobItem
  FROM coitem JOIN itemsite ON (itemsite_id=coitem_itemsite_id)
  WHERE (coitem_id=pSoitemid);

  IF (_jobItem AND _r.coitem_order_type='W') THEN
-- Delete associated Job Work Order
    SELECT deleteWo(_r.coitem_order_id, TRUE, TRUE) INTO _result;
    IF (_result < 0) THEN
      RETURN -104;
    END IF;
  ELSIF (_r.coitem_order_type='W') THEN
-- Delete associated Job Work Order
    SELECT deleteWo(_r.coitem_order_id, TRUE) INTO _result;
    IF (_result < 0) THEN
      -- Cannot delete so break association
      PERFORM changeWoProject(_r.coitem_order_id, -1, TRUE);
    END IF;
  ELSIF (_r.coitem_order_type='R') THEN
-- Delete associated Purchase Request
    PERFORM deletePr(_r.coitem_order_id);
  ELSIF (_r.coitem_order_type='P') THEN
-- Delete associated Purchase Order Item
    SELECT deletepoitem(_r.coitem_order_id) INTO _result;
    IF ((_result < 0) AND (_result <> -20)) THEN
      RETURN _result;
    ELSIF (_result = -20) THEN
      _deletePO := _deletePO - 1;
    END IF;
  END IF;

-- Delete characteristic assignments
  DELETE FROM charass
  WHERE (charass_target_type='SI')
    AND (charass_target_id=pSoitemid);

-- Delete reservations
  IF (fetchMetricBool('EnableSOReservationsByLocation')) THEN
    DELETE FROM reserve
    WHERE (reserve_demand_type='SO')
      AND (reserve_demand_id=pSoitemid);
  END IF;

-- Delete the coitem
  DELETE FROM coitem
  WHERE (coitem_id=pSoitemid);

  IF (_deletePO < 0) THEN
    RETURN -20;
  ELSE
    RETURN 0;
  END IF;

END;
$_$;


ALTER FUNCTION public.deletesoitem(integer) OWNER TO admin;

--
-- TOC entry 1460 (class 1255 OID 146566027)
-- Dependencies: 4536 8
-- Name: deletestandardjournal(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletestandardjournal(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pStdjrnlid ALIAS FOR $1;

BEGIN

  DELETE FROM stdjrnlitem
  WHERE (stdjrnlitem_stdjrnl_id=pStdjrnlid);

  DELETE FROM stdjrnlgrpitem
  WHERE (stdjrnlgrpitem_stdjrnl_id=pStdjrnlid);

  DELETE FROM stdjrnl
  WHERE (stdjrnl_id=pStdjrnlid);

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.deletestandardjournal(integer) OWNER TO admin;

--
-- TOC entry 1461 (class 1255 OID 146566028)
-- Dependencies: 4536 8
-- Name: deletestandardjournalgroup(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletestandardjournalgroup(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pStdjrnlgrpid ALIAS FOR $1;

BEGIN

  DELETE FROM stdjrnlgrpitem
  WHERE (stdjrnlgrpitem_stdjrnlgrp_id=pStdjrnlgrpid);

  DELETE FROM stdjrnlgrp
  WHERE (stdjrnlgrp_id=pStdjrnlgrpid);

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.deletestandardjournalgroup(integer) OWNER TO admin;

--
-- TOC entry 1462 (class 1255 OID 146566029)
-- Dependencies: 4536 8
-- Name: deletesubaccount(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletesubaccount(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pid ALIAS FOR $1;

BEGIN
  IF (EXISTS(SELECT accnt_id
             FROM accnt, subaccnt
             WHERE ((accnt_company=subaccnt_number)
               AND  (subaccnt_id=pid))
            )) THEN
    RETURN -1;
  END IF;

  DELETE FROM subaccnt
  WHERE (subaccnt_id=pid);

  RETURN pid;

END;
$_$;


ALTER FUNCTION public.deletesubaccount(integer) OWNER TO admin;

--
-- TOC entry 1433 (class 1255 OID 146566030)
-- Dependencies: 4536 8
-- Name: deletesubaccounttype(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletesubaccounttype(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSubAccntTypeid ALIAS FOR $1;
  _check INTEGER;

BEGIN

--  Check to see if the passed subaccnttype is used in any accounts
  SELECT accnt_id INTO _check
  FROM accnt, subaccnttype
  WHERE ( (accnt_subaccnttype_code=subaccnttype_code)
   AND (subaccnttype_id=pSubAccntTypeid) )
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -1;
  END IF;

--  Delete the Sub Account Type
  DELETE FROM subaccnttype
  WHERE (subaccnttype_id=pSubAccntTypeid);

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.deletesubaccounttype(integer) OWNER TO admin;

--
-- TOC entry 1464 (class 1255 OID 146566031)
-- Dependencies: 4536 8
-- Name: deletetax(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletetax(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  ptaxid	ALIAS FOR $1;
BEGIN
  -- these checks allow nice error reporting instead of throwing an SQL error
  IF EXISTS(SELECT taxass_id FROM taxass WHERE (taxass_tax_id=ptaxid)) THEN
    RETURN -10;
  END IF;
  IF EXISTS(SELECT taxhist_id FROM taxhist WHERE (taxhist_tax_id=ptaxid)) THEN
    RETURN -20;
  END IF;

  DELETE FROM taxrate WHERE (taxrate_tax_id = ptaxid);
  DELETE FROM tax WHERE (tax_id = ptaxid);

  RETURN ptaxid;

END;
$_$;


ALTER FUNCTION public.deletetax(integer) OWNER TO admin;

--
-- TOC entry 1465 (class 1255 OID 146566032)
-- Dependencies: 4536 8
-- Name: deletetaxclass(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletetaxclass(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
pTaxclassid ALIAS FOR $1;
_result INTEGER;

BEGIN

-- Check to find if the tax class is used in any tax code
SELECT tax_id INTO _result
FROM tax
WHERE (tax_taxclass_id = pTaxclassid);
IF (FOUND) THEN
   RETURN -1;
END IF;

-- Delete the tax class if the above condition doesn't match
DELETE FROM taxclass WHERE taxclass_id = pTaxclassid ;

RETURN pTaxclassid;

END;
$_$;


ALTER FUNCTION public.deletetaxclass(integer) OWNER TO admin;

--
-- TOC entry 1466 (class 1255 OID 146566033)
-- Dependencies: 4536 8
-- Name: deletetaxtype(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletetaxtype(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTaxtypeid ALIAS FOR $1;
  _result INTEGER;
BEGIN

  SELECT taxtype_id
    INTO _result
    FROM taxtype
   WHERE ((taxtype_sys)
     AND  (taxtype_id=pTaxtypeid));
  IF (FOUND) THEN
    RETURN -1;
  END IF;

  SELECT taxass_id
    INTO _result
    FROM taxass
   WHERE (taxass_taxtype_id=pTaxtypeid);
  IF (FOUND) THEN
    RETURN -2;
  END IF;

  SELECT taxhist_id
    INTO _result
    FROM taxhist
   WHERE (taxhist_taxtype_id=pTaxtypeid);
  IF (FOUND) THEN
    RETURN -3;
  END IF;

  DELETE
    FROM taxtype
   WHERE (taxtype_id=pTaxtypeid);

  RETURN pTaxtypeid;

END;
$_$;


ALTER FUNCTION public.deletetaxtype(integer) OWNER TO admin;

--
-- TOC entry 1467 (class 1255 OID 146566034)
-- Dependencies: 4536 8
-- Name: deletetaxzone(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletetaxzone(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
pTaxzoneid ALIAS FOR $1;
_result INTEGER;

BEGIN

-- Check to find if the tax zone is used in any tax assignment
SELECT taxass_id INTO _result
FROM taxass
WHERE (taxass_taxzone_id=pTaxzoneid);
IF (FOUND) THEN
   RETURN -1;
END IF;

-- Check to find if the tax zone has been referenced in any tax registration
SELECT taxreg_id INTO _result
FROM taxreg
WHERE (taxreg_taxzone_id=pTaxzoneid);
IF (FOUND) THEN
   RETURN -2;
END IF;

-- Delete the tax zone if none of the above conditions match
DELETE FROM taxzone WHERE taxzone_id = pTaxzoneid ;

RETURN pTaxzoneid;

END;
$_$;


ALTER FUNCTION public.deletetaxzone(integer) OWNER TO admin;

--
-- TOC entry 1468 (class 1255 OID 146566035)
-- Dependencies: 4536 8
-- Name: deletetodoitem(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletetodoitem(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  ptodoItemId ALIAS FOR $1;
BEGIN
  DELETE FROM alarm WHERE ( (alarm_source='TODO') AND (alarm_source_id=ptodoItemId) );
  DELETE FROM todoitem WHERE todoitem_id = ptodoItemId;
  RETURN 0;
END;
$_$;


ALTER FUNCTION public.deletetodoitem(integer) OWNER TO admin;

--
-- TOC entry 1469 (class 1255 OID 146566036)
-- Dependencies: 4536 8
-- Name: deleteunusedclasscodes(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteunusedclasscodes() RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  DELETE FROM classcode
  WHERE (classcode_id NOT IN (SELECT DISTINCT item_classcode_id FROM item));

  RETURN 0;

END;
$$;


ALTER FUNCTION public.deleteunusedclasscodes() OWNER TO admin;

--
-- TOC entry 1470 (class 1255 OID 146566037)
-- Dependencies: 4536 8
-- Name: deleteunusedfreightclasses(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteunusedfreightclasses() RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  DELETE FROM freightclass
  WHERE (freightclass_id NOT IN (SELECT DISTINCT COALESCE(item_freightclass_id, 0) FROM item));

  RETURN 0;

END;
$$;


ALTER FUNCTION public.deleteunusedfreightclasses() OWNER TO admin;

--
-- TOC entry 1471 (class 1255 OID 146566038)
-- Dependencies: 4536 8
-- Name: deleteunusedproductcategories(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteunusedproductcategories() RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

--  Delete any associated records
  DELETE FROM salesaccnt
  WHERE ( (salesaccnt_prodcat_id <> -1)
   AND (salesaccnt_prodcat_id NOT IN (SELECT DISTINCT item_prodcat_id FROM item)) );

  DELETE FROM prodcat
  WHERE (prodcat_id NOT IN (SELECT DISTINCT item_prodcat_id FROM item));

  RETURN 0;

END;
$$;


ALTER FUNCTION public.deleteunusedproductcategories() OWNER TO admin;

--
-- TOC entry 1472 (class 1255 OID 146566039)
-- Dependencies: 4536 8
-- Name: deleteuom(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteuom(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pUomid ALIAS FOR $1;

BEGIN

  DELETE FROM uomconv WHERE uomconv_from_uom_id=pUomid;
  DELETE FROM uomconv WHERE uomconv_to_uom_id=pUomid;
  DELETE FROM uom WHERE uom_id=pUomid;

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.deleteuom(integer) OWNER TO admin;

--
-- TOC entry 1473 (class 1255 OID 146566040)
-- Dependencies: 4536 8
-- Name: deleteuomconv(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteuomconv(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pUomconvid ALIAS FOR $1;

BEGIN
  DELETE FROM uomconv WHERE uomconv_id=pUomconvid;

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.deleteuomconv(integer) OWNER TO admin;

--
-- TOC entry 1474 (class 1255 OID 146566041)
-- Dependencies: 4536 8
-- Name: deleteurl(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteurl(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
declare
  pId ALIAS FOR $1;
begin
  delete from urlinfo
  where ( url_id in (
    select url_id
    from urlinfo
      join docass on (docass_target_id=url_id)
                 and (docass_target_type='URL')
      where ( docass_id = pId ) ) );

  delete from docass where docass_id = pId;

  return true;
end;
$_$;


ALTER FUNCTION public.deleteurl(integer) OWNER TO admin;

--
-- TOC entry 1475 (class 1255 OID 146566042)
-- Dependencies: 4536 8
-- Name: deleteuserpreference(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteuserpreference(text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPrefname ALIAS FOR $1;
  _return BOOLEAN;

BEGIN

  SELECT deleteUserPreference(getEffectiveXtUser(), pPrefname) INTO _return;

  RETURN _return;

END;
$_$;


ALTER FUNCTION public.deleteuserpreference(text) OWNER TO admin;

--
-- TOC entry 1476 (class 1255 OID 146566043)
-- Dependencies: 4536 8
-- Name: deleteuserpreference(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deleteuserpreference(text, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pUsername ALIAS FOR $1;
  pPrefname ALIAS FOR $2;

BEGIN

  DELETE FROM usrpref
  WHERE ( (usrpref_username=pUsername)
   AND (usrpref_name=pPrefname) );

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.deleteuserpreference(text, text) OWNER TO admin;

--
-- TOC entry 1479 (class 1255 OID 146566044)
-- Dependencies: 4536 8
-- Name: deletevendoraddress(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletevendoraddress(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVendaddrid ALIAS FOR $1;
  _test INTEGER;

BEGIN

--  Check to see if the passed vendor address is used in pohead
  SELECT pohead_id INTO _test
  FROM pohead
  WHERE (pohead_vendaddr_id=pVendaddrid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -1;
  END IF;

--  Delete the passed vendor address
  DELETE FROM vendaddrinfo
  WHERE (vendaddr_id=pVendaddrid);

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.deletevendoraddress(integer) OWNER TO admin;

--
-- TOC entry 1480 (class 1255 OID 146566045)
-- Dependencies: 4536 8
-- Name: deletevendortype(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletevendortype(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVendtypeid ALIAS FOR $1;
  _test INTEGER;

BEGIN

--  Check to see if the passed vendor type is used in vendinfo
  SELECT vend_id INTO _test
  FROM vendinfo
  WHERE (vend_vendtype_id=pVendtypeid)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -1;
  END IF;

--  Delete the passed vendor type
  DELETE FROM vendtype
  WHERE (vendtype_id=pVendtypeid);

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.deletevendortype(integer) OWNER TO admin;

--
-- TOC entry 1481 (class 1255 OID 146566046)
-- Dependencies: 4536 8
-- Name: deletewo(integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletewo(integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoid ALIAS FOR $1;
  deleteChildren ALIAS FOR $2;

BEGIN
  RETURN deleteWo(pWoid, deleteChildren, FALSE);
END;
$_$;


ALTER FUNCTION public.deletewo(integer, boolean) OWNER TO admin;

--
-- TOC entry 1482 (class 1255 OID 146566047)
-- Dependencies: 4536 8
-- Name: deletewo(integer, boolean, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletewo(integer, boolean, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoid ALIAS FOR $1;
  deleteChildren ALIAS FOR $2;
  deleteForce ALIAS FOR $3;
  woStatus CHAR(1);
  itemType CHAR(1);
  ordtype CHAR(1);
  ordid INTEGER;
  returnCode INTEGER;
  _wotcCnt	INTEGER;
  _routings BOOLEAN;

BEGIN
  SELECT wo_status, wo_ordtype, wo_ordid, item_type
  INTO   woStatus, ordtype, ordid, itemType
  FROM wo JOIN itemsite ON (itemsite_id=wo_itemsite_id)
          JOIN item ON (item_id=itemsite_item_id)
  WHERE (wo_id=pWoid);

  IF (NOT woStatus IN ('O', 'E', 'C')) THEN
    RETURN -3;
  END IF;

  IF (NOT deleteForce) THEN
    IF (itemType = 'J') THEN
      RETURN -2;
    END IF;
  END IF;

  SELECT fetchMetricBool('Routings') INTO _routings;

  IF _routings THEN
    SELECT count(*) INTO _wotcCnt
    FROM xtmfg.wotc
    WHERE (wotc_wo_id=pWoid);
    IF (_wotcCnt > 0) THEN
      RETURN -1;
    END IF;
  END IF;

  IF (woStatus = 'R') THEN
    PERFORM postEvent('RWoRequestCancel', 'W', wo_id,
                      itemsite_warehous_id, formatWoNumber(wo_id),
                      NULL, NULL, NULL, NULL)
    FROM wo JOIN itemsite ON (itemsite_id=wo_itemsite_id)
            JOIN item ON (item_id=itemsite_item_id)
    WHERE (wo_id=pWoid);

     RETURN 0;
  ELSE
    IF (woStatus = 'E') THEN
      returnCode := (SELECT implodeWo(pWoid, FALSE));
    END IF;
  END IF;

  IF (woStatus IN ('O', 'E', 'C')) THEN
    DELETE FROM womatl
    WHERE (womatl_wo_id=pWoid);

    IF _routings THEN
      DELETE FROM xtmfg.wooper
      WHERE (wooper_wo_id=pWoid);
    END IF;

    IF (ordtype = 'S') THEN
      UPDATE coitem SET coitem_order_type=NULL, coitem_order_id=NULL
      WHERE coitem_id=ordid;
    END IF;

    DELETE FROM wo
    WHERE (wo_id=pWoid);
  END IF;

  IF (deleteChildren) THEN
    returnCode := (SELECT MAX(deleteWo(wo_id, TRUE))
                   FROM wo
                   WHERE ((wo_ordtype='W')
                    AND (wo_ordid=pWoid)));
  END IF;

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.deletewo(integer, boolean, boolean) OWNER TO admin;

--
-- TOC entry 1483 (class 1255 OID 146566048)
-- Dependencies: 4536 8
-- Name: deletewomaterial(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION deletewomaterial(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWomatlid ALIAS FOR $1;

BEGIN

  UPDATE wo
  SET wo_adhoc=TRUE
  FROM womatl
  WHERE ((womatl_wo_id=wo_id)
   AND (womatl_id=pWomatlid));

--  Delete any created P/R for this Womatl
  PERFORM deletePr('W', pWomatlid);

  DELETE FROM womatl
  WHERE (womatl_id=pWomatlid);

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.deletewomaterial(integer) OWNER TO admin;

--
-- TOC entry 1484 (class 1255 OID 146566049)
-- Dependencies: 4536 8
-- Name: detachccpayfromso(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION detachccpayfromso(integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pcoheadid		ALIAS FOR $1;
  pwarehousid		ALIAS FOR $2;
  pcustid		ALIAS FOR $3;

BEGIN
  RAISE NOTICE 'detachCCPayFromSO(INTEGER, INTEGER, INTEGER): deprecated';
  RETURN 0;
END;
$_$;


ALTER FUNCTION public.detachccpayfromso(integer, integer, integer) OWNER TO admin;

--
-- TOC entry 1485 (class 1255 OID 146566050)
-- Dependencies: 4536 8
-- Name: detachcontact(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION detachcontact(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pcntctId    ALIAS FOR $1;
  pcrmacctId  ALIAS FOR $2;
BEGIN
  UPDATE cntct SET cntct_crmacct_id = NULL
  WHERE cntct_id = pcntctId
    AND cntct_crmacct_id = pcrmacctId;

  UPDATE crmacct SET crmacct_cntct_id_1 = NULL
  WHERE crmacct_id = pcrmacctId
    AND crmacct_cntct_id_1 = pcntctId;

  UPDATE crmacct SET crmacct_cntct_id_2 = NULL
  WHERE crmacct_id = pcrmacctId
    AND crmacct_cntct_id_2 = pcntctId;

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.detachcontact(integer, integer) OWNER TO admin;

--
-- TOC entry 1486 (class 1255 OID 146566051)
-- Dependencies: 4536 8
-- Name: detag(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION detag(text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSource ALIAS FOR $1;
  _result TEXT := '';

BEGIN
  SELECT regexp_replace(pSource, E'<[^>]*>', '', 'g') INTO _result;
  RETURN _result;
END;
$_$;


ALTER FUNCTION public.detag(text) OWNER TO admin;

--
-- TOC entry 1487 (class 1255 OID 146566052)
-- Dependencies: 4536 8
-- Name: detailednnqoh(integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION detailednnqoh(integer, boolean) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pABS ALIAS FOR $2;
  _qoh NUMERIC;

BEGIN

  IF (pABS) THEN
    SELECT SUM(noNeg(itemloc_qty)) INTO _qoh
    FROM itemloc, location
    WHERE ( (itemloc_location_id=location_id)
     AND (NOT location_netable)
     AND (itemloc_itemsite_id=pItemsiteid) );
  ELSE
    SELECT SUM(itemloc_qty) INTO _qoh
    FROM itemloc, location
    WHERE ( (itemloc_location_id=location_id)
     AND (NOT location_netable)
     AND (itemloc_itemsite_id=pItemsiteid) );
  END IF;

  IF (_qoh IS NULL) THEN
    _qoh := 0;
  END IF;

  RETURN _qoh;

END;
$_$;


ALTER FUNCTION public.detailednnqoh(integer, boolean) OWNER TO admin;

--
-- TOC entry 1488 (class 1255 OID 146566053)
-- Dependencies: 4536 8
-- Name: detailedqoh(integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION detailedqoh(integer, boolean) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pABS ALIAS FOR $2;
  _qoh NUMERIC;

BEGIN

  IF (pABS) THEN
    SELECT SUM(noNeg(itemloc_qty)) INTO _qoh
    FROM itemloc LEFT OUTER JOIN location ON (itemloc_location_id=location_id)
    WHERE ( ( (location_id IS NULL) OR (location_netable) )
     AND (itemloc_itemsite_id=pItemsiteid) );
  ELSE
    SELECT SUM(itemloc_qty) INTO _qoh
    FROM itemloc LEFT OUTER JOIN location ON (itemloc_location_id=location_id)
    WHERE ( ( (location_id IS NULL) OR (location_netable) )
     AND (itemloc_itemsite_id=pItemsiteid) );
  END IF;

  IF (_qoh IS NULL) THEN
    _qoh := 0;
  END IF;

  RETURN _qoh;

END;
$_$;


ALTER FUNCTION public.detailedqoh(integer, boolean) OWNER TO admin;

--
-- TOC entry 1491 (class 1255 OID 146566054)
-- Dependencies: 4536 8
-- Name: determinediscountdate(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION determinediscountdate(integer, date) RETURNS date
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTermsid ALIAS FOR $1;
  pSourceDate ALIAS FOR $2;
  _discDate DATE;
  _p RECORD;

BEGIN

  SELECT terms_type, terms_discdays, terms_cutoffday INTO _p
  FROM terms
  WHERE (terms_id=pTermsid);
  IF (NOT FOUND) THEN
    _discDate := pSourceDate;

--  Handle type D terms
  ELSIF (_p.terms_type = 'D') THEN
    _discDate := (pSourceDate + _p.terms_discdays);

--  Handle type P terms
  ELSIF (_p.terms_type = 'P') THEN
    IF (date_part('day', pSourceDate) <= _p.terms_cutoffday) THEN
      _discDate := (DATE(date_trunc('month', pSourceDate)) + (_p.terms_discdays - 1));
    ELSE
      _discDate := (DATE(date_trunc('month', pSourceDate)) + (_p.terms_discdays - 1) + INTERVAL '1 month');
    END IF;

--  Handle unknown terms
  ELSE
    _discDate := pSourceDate;
  END IF;

  RETURN _discDate;

END;
$_$;


ALTER FUNCTION public.determinediscountdate(integer, date) OWNER TO admin;

--
-- TOC entry 1492 (class 1255 OID 146566055)
-- Dependencies: 4536 8
-- Name: determineduedate(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION determineduedate(integer, date) RETURNS date
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTermsid ALIAS FOR $1;
  pSourceDate ALIAS FOR $2;
  _dueDate DATE;
  _p RECORD;

BEGIN

  SELECT terms_type, terms_duedays, terms_cutoffday INTO _p
  FROM terms
  WHERE (terms_id=pTermsid);
  IF (NOT FOUND) THEN
    _dueDate := pSourceDate;

--  Handle type D terms
  ELSIF (_p.terms_type = 'D') THEN
    _dueDate := (pSourceDate + _p.terms_duedays);

--  Handle type P terms
  ELSIF (_p.terms_type = 'P') THEN
    IF (date_part('day', pSourceDate) <= _p.terms_cutoffday) THEN
      _dueDate := (DATE(date_trunc('month', pSourceDate)) + (_p.terms_duedays - 1));
    ELSE
      _dueDate := (DATE(date_trunc('month', pSourceDate)) + (_p.terms_duedays - 1) + INTERVAL '1 month');
    END IF;

--  Handle unknown terms
  ELSE
    _dueDate := pSourceDate;
  END IF;

  RETURN _dueDate;

END;
$_$;


ALTER FUNCTION public.determineduedate(integer, date) OWNER TO admin;

--
-- TOC entry 1493 (class 1255 OID 146566056)
-- Dependencies: 8
-- Name: digest(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION digest(text, text) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgcrypto', 'pg_digest';


ALTER FUNCTION public.digest(text, text) OWNER TO admin;

--
-- TOC entry 1494 (class 1255 OID 146566057)
-- Dependencies: 8
-- Name: digest(bytea, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION digest(bytea, text) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgcrypto', 'pg_digest';


ALTER FUNCTION public.digest(bytea, text) OWNER TO admin;

--
-- TOC entry 1495 (class 1255 OID 146566058)
-- Dependencies: 4536 8
-- Name: disablepackage(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION disablepackage(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  ppkgname ALIAS FOR $1;
  _i       INTEGER := 0;
  _tabs    TEXT[] := ARRAY['cmd',  'cmdarg', 'image',  'metasql',
                           'priv', 'report', 'script', 'uiform'];

BEGIN
  IF (version() < 'PostgreSQL 8.2') THEN
    RETURN -1;
  END IF;

  FOR _i IN ARRAY_LOWER(_tabs,1)..ARRAY_UPPER(_tabs,1) LOOP
    EXECUTE 'ALTER TABLE ' || ppkgname || '.pkg' || _tabs[_i] ||
            ' NO INHERIT public.' || _tabs[_i] || ';';
  END LOOP;

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.disablepackage(text) OWNER TO admin;

--
-- TOC entry 1496 (class 1255 OID 146566059)
-- Dependencies: 4536 8
-- Name: disablepackage(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION disablepackage(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  ppkgheadid    ALIAS FOR $1;
  _pkgname      TEXT;

BEGIN
  SELECT pkghead_name INTO _pkgname
  FROM pkghead
  WHERE (pkghead_id=ppkgheadid);
  IF (NOT FOUND) THEN
    RETURN -2;
  END IF;

  RETURN disablePackage(_pkgname);
END;
$_$;


ALTER FUNCTION public.disablepackage(integer) OWNER TO admin;

--
-- TOC entry 1497 (class 1255 OID 146566060)
-- Dependencies: 4536 8
-- Name: distributeitemlocseries(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION distributeitemlocseries(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemlocSeries   ALIAS FOR $1;
  _distCounter     INTEGER;
  _itemlocdist     RECORD;
  _itemlocid       INTEGER;
  _invhistid       INTEGER;
  _check           BOOLEAN;
  _debug           BOOLEAN := true;
BEGIN

  IF (_debug) THEN
    RAISE NOTICE 'distributeItemlocSeries, series=%', pItemlocSeries;
  END IF;

  _distCounter := 0;

--  March through all of the itemlocdists for pItemlocSeries
  FOR _itemlocdist IN SELECT itemlocdist_id AS itemlocdistid,
                             itemlocdist_source_type AS type,
                             itemlocdist_source_id AS sourceid,
                             itemlocdist_qty AS qty,
                             itemlocdist_itemsite_id AS itemsiteid,
                             itemsite_freeze,
                             itemlocdist_invhist_id AS invhistid,
                             itemlocdist_ls_id AS lotserialid,
                             itemlocdist_expiration AS expiration,
                             itemlocdist_flush,
                             itemlocdist_warranty AS warranty,
                             itemlocdist_series AS series
                      FROM itemlocdist, itemsite
                      WHERE ( (itemlocdist_itemsite_id=itemsite_id)
                       AND (itemlocdist_series=pItemlocSeries) )
                      ORDER BY itemlocdist_flush DESC LOOP

    _distCounter := _distCounter + 1;
    IF (_debug) THEN
      RAISE NOTICE 'itemlocdist loop %', _distCounter;
      RAISE NOTICE 'itemlocdistid=%', _itemlocdist.itemlocdistid;
      RAISE NOTICE 'type=%', _itemlocdist.type;
      RAISE NOTICE 'sourceid=%', _itemlocdist.sourceid;
      RAISE NOTICE 'qty=%', _itemlocdist.qty;
      RAISE NOTICE 'itemsiteid=%', _itemlocdist.itemsiteid;
      RAISE NOTICE 'freeze=%', _itemlocdist.itemsite_freeze;
      RAISE NOTICE 'invhistid=%', _itemlocdist.invhistid;
      RAISE NOTICE 'lotserialid=%', _itemlocdist.lotserialid;
      RAISE NOTICE 'expiration=%', _itemlocdist.expiration;
      RAISE NOTICE 'flush=%', _itemlocdist.itemlocdist_flush;
      RAISE NOTICE 'warranty=%', _itemlocdist.warranty;
    END IF;

--  Commit invhist to itemsite
    IF (NOT _itemlocdist.itemsite_freeze) THEN
	PERFORM postInvHist(_itemlocdist.invhistid);
    END IF;

--  Mark the invhist tuple for the itemlocdist in question as having detail
    UPDATE invhist
    SET invhist_hasdetail=TRUE
    WHERE ( (NOT invhist_hasdetail)
     AND (invhist_id=_itemlocdist.invhistid) );

--  If this itemlocdist is a flush, write a invdetail tuple that records the empty
    IF (_itemlocdist.itemlocdist_flush) THEN
      INSERT INTO invdetail
      ( invdetail_invhist_id, invdetail_location_id, invdetail_ls_id,
        invdetail_qty, invdetail_qty_before, invdetail_qty_after, invdetail_expiration,
        invdetail_warrpurc )
      SELECT _itemlocdist.invhistid, itemloc_location_id, itemloc_ls_id,
             (itemloc_qty * -1), itemloc_qty, 0, itemloc_expiration,
             _itemlocdist.warranty
      FROM itemloc
      WHERE ( (itemloc_qty <> 0)
       AND (itemloc_id=_itemlocdist.sourceid) );

--  Delete the flushed itemloc if its parent itemsite is not frozen
      IF (NOT _itemlocdist.itemsite_freeze) THEN
        DELETE FROM itemloc
        WHERE (itemloc_id=_itemlocdist.sourceid);
      END IF;

    ELSE
--  If this is a location type distribution, check to see if the target itemloc
--  already exists
      IF (_itemlocdist.type = 'L') THEN
        SELECT itemloc_id INTO _itemlocid
        FROM itemloc
        WHERE ( (itemloc_itemsite_id=_itemlocdist.itemsiteid)
         AND (itemloc_location_id=_itemlocdist.sourceid)
         AND (COALESCE(itemloc_ls_id,-1)=COALESCE(_itemlocdist.lotserialid,-1))
         AND (COALESCE(itemloc_expiration,endOfTime())=COALESCE(_itemlocdist.expiration,endOfTime()))
         AND (COALESCE(itemloc_warrpurc,endoftime())=COALESCE(_itemlocdist.warranty,endoftime())) );

--  Nope, create it
        IF (NOT FOUND) THEN
          SELECT NEXTVAL('itemloc_itemloc_id_seq') INTO _itemlocid;

          INSERT INTO itemloc
          ( itemloc_id, itemloc_itemsite_id,
            itemloc_location_id, itemloc_qty,
            itemloc_ls_id, itemloc_expiration,
            itemloc_warrpurc )
          VALUES
          ( _itemlocid, _itemlocdist.itemsiteid,
            _itemlocdist.sourceid, 0,
            _itemlocdist.lotserialid, _itemlocdist.expiration,
            _itemlocdist.warranty );
        END IF;

      ELSE
        _itemlocid = _itemlocdist.sourceid;

        IF (_itemlocid IS NOT NULL AND (SELECT count(itemloc_id) = 0 FROM itemloc WHERE itemloc_id=_itemlocid)) THEN
          RAISE EXCEPTION 'No record to distribute against. Someone else may have already distributed this record.';
        END IF;
      END IF;

--  Record the invdetail
      INSERT INTO invdetail
      (invdetail_invhist_id, invdetail_location_id, invdetail_ls_id,
       invdetail_qty, invdetail_qty_before, invdetail_qty_after, invdetail_expiration,
       invdetail_warrpurc)
      SELECT _itemlocdist.invhistid, itemloc_location_id, _itemlocdist.lotserialid,
             _itemlocdist.qty, itemloc_qty, (itemloc_qty + _itemlocdist.qty),
             itemloc_expiration,_itemlocdist.warranty
      FROM itemloc
      WHERE (itemloc_id=_itemlocid);

--  Update the itemloc_qty if its parent itemsite is not frozen
      IF (NOT _itemlocdist.itemsite_freeze) THEN
        UPDATE itemloc
        SET itemloc_qty = (itemloc_qty + _itemlocdist.qty)
        WHERE (itemloc_id=_itemlocid);
      END IF;

--  Adjust QOH if this itemlocdist is to/from a non-netable location
      IF ( SELECT (NOT location_netable)
           FROM itemloc, location
           WHERE ( (itemloc_location_id=location_id)
            AND (itemloc_id=_itemlocid) ) ) THEN

--  Record the netable->non-netable (or visaveras) invhist
        SELECT NEXTVAL('invhist_invhist_id_seq') INTO _invhistid;
        INSERT INTO invhist
        ( invhist_id, invhist_itemsite_id,
          invhist_transtype, invhist_invqty,
          invhist_qoh_before, invhist_qoh_after,
          invhist_docnumber, invhist_comments,
          invhist_invuom, invhist_unitcost,
          invhist_costmethod, invhist_value_before, invhist_value_after,
          invhist_series )
        SELECT _invhistid, itemsite_id,
               'NN', (_itemlocdist.qty * -1),
               itemsite_qtyonhand, (itemsite_qtyonhand - _itemlocdist.qty),
               invhist_docnumber, invhist_comments,
               uom_name, stdCost(item_id),
               itemsite_costmethod, itemsite_value,
               (itemsite_value + (_itemlocdist.qty * -1 * CASE WHEN(itemsite_costmethod='A') THEN avgcost(itemsite_id)
                                                               ELSE stdCost(itemsite_item_id)
                                                          END)),
               _itemlocdist.series
        FROM item, itemsite, invhist, uom
        WHERE ((itemsite_item_id=item_id)
         AND (item_inv_uom_id=uom_id)
         AND (itemsite_controlmethod <> 'N')
         AND (itemsite_id=_itemlocdist.itemsiteid)
         AND (invhist_id=_itemlocdist.invhistid));

--  Adjust the parent itemsite
        IF (NOT _itemlocdist.itemsite_freeze) THEN
          UPDATE itemsite
          SET itemsite_qtyonhand = (itemsite_qtyonhand - _itemlocdist.qty),
              itemsite_nnqoh = (itemsite_nnqoh + _itemlocdist.qty)
          FROM itemloc
          WHERE ((itemloc_itemsite_id=itemsite_id)
           AND (itemloc_id=_itemlocid));
        END IF;
      END IF;

    END IF;

--  If, after the distribution, the target itemloc_qty = 0, delete the itemloc
--  if its parent itemsite is not frozen
    IF (NOT _itemlocdist.itemsite_freeze) THEN
      DELETE FROM itemloc
      WHERE ( (itemloc_qty=0)
       AND (itemloc_id=_itemlocid) );
    END IF;

  END LOOP;

  DELETE FROM itemlocdist
  WHERE (itemlocdist_series=pItemlocSeries);

  RETURN _distCounter;

END;
$_$;


ALTER FUNCTION public.distributeitemlocseries(integer) OWNER TO admin;

--
-- TOC entry 1498 (class 1255 OID 146566062)
-- Dependencies: 4536 8
-- Name: distributetodefault(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION distributetodefault(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemlocdistid ALIAS FOR $1;

BEGIN

  RETURN distributeToDefault(pItemlocdistid, 'O');

END;
$_$;


ALTER FUNCTION public.distributetodefault(integer) OWNER TO admin;

--
-- TOC entry 1499 (class 1255 OID 146566063)
-- Dependencies: 4536 8
-- Name: distributetodefault(integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION distributetodefault(integer, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemlocdistid ALIAS FOR $1;
  pTranstype ALIAS FOR $2;
  _locationid INTEGER;
  _itemlocdistid INTEGER;
  _qty NUMERIC;

BEGIN

--  Make sure that the itemsite in question has a default location
  SELECT CASE WHEN (pTranstype='R') THEN itemsite_recvlocation_id
              WHEN (pTranstype='I') THEN itemsite_issuelocation_id
              ELSE itemsite_location_id
         END INTO _locationid
  FROM itemlocdist, itemsite
  WHERE ( (itemlocdist_itemsite_id=itemsite_id)
   AND (itemlocdist_id=pItemlocdistid) );
  IF ( (NOT FOUND) OR (_locationid = -1) ) THEN
    RETURN -1;
  END IF;

--  Determine the remaining qty required to distribute
  SELECT (p.itemlocdist_qty - COALESCE(SUM(c.itemlocdist_qty), 0)) INTO _qty
  FROM itemlocdist AS p LEFT OUTER JOIN itemlocdist AS c ON (c.itemlocdist_itemlocdist_id=p.itemlocdist_id)
  WHERE (p.itemlocdist_id=pItemlocdistid)
  GROUP BY p.itemlocdist_qty;

  IF (_qty = 0) THEN
    RETURN -2;
  END IF;

--  Check to see if an itemlocdist with the correct location/lotserial/expiration already exists
  SELECT target.itemlocdist_id INTO _itemlocdistid
  FROM itemlocdist AS source, itemlocdist AS target, itemloc, itemsite
  WHERE ( (target.itemlocdist_source_type='L')
   AND (target.itemlocdist_source_id=_locationid)
   AND (target.itemlocdist_itemsite_id=source.itemlocdist_itemsite_id)
   AND (COALESCE(target.itemlocdist_ls_id)=COALESCE(source.itemlocdist_ls_id))
   AND (target.itemlocdist_expiration=source.itemlocdist_expiration)
   AND (target.itemlocdist_itemlocdist_id=source.itemlocdist_itemlocdist_id)
   AND (target.itemlocdist_itemsite_id=itemsite_id)
   AND (source.itemlocdist_id=pItemlocdistid) );

  IF (FOUND) THEN
    UPDATE itemlocdist
    SET itemlocdist_qty = (itemlocdist_qty + _qty)
    WHERE (itemlocdist_id=_itemlocdistid);

    RETURN _itemlocdistid;
  END IF;

--  Create a new itemlocdist
  SELECT NEXTVAL('itemlocdist_itemlocdist_id_seq') INTO _itemlocdistid;

  INSERT INTO itemlocdist
  ( itemlocdist_id, itemlocdist_itemlocdist_id, itemlocdist_source_type,
    itemlocdist_ls_id, itemlocdist_expiration,
    itemlocdist_source_id, itemlocdist_itemsite_id, itemlocdist_qty )
  SELECT _itemlocdistid, pItemlocdistid, 'L',
         itemlocdist_ls_id, itemlocdist_expiration,
         _locationid, itemlocdist_itemsite_id, _qty
  FROM itemlocdist
  WHERE (itemlocdist_id=pItemlocdistid);

  RETURN _itemlocdistid;

END;
$_$;


ALTER FUNCTION public.distributetodefault(integer, text) OWNER TO admin;

--
-- TOC entry 1500 (class 1255 OID 146566064)
-- Dependencies: 4536 8
-- Name: distributetodefaultitemloc(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION distributetodefaultitemloc(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemlocdistid ALIAS FOR $1;

BEGIN

  RETURN distributeToDefaultItemLoc(pItemlocdistid, 'O');

END;
$_$;


ALTER FUNCTION public.distributetodefaultitemloc(integer) OWNER TO admin;

--
-- TOC entry 1501 (class 1255 OID 146566065)
-- Dependencies: 4536 8
-- Name: distributetodefaultitemloc(integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION distributetodefaultitemloc(integer, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemlocdistid ALIAS FOR $1;
  pTranstype ALIAS FOR $2;
  _itemlocid INTEGER;
  _itemlocdistid INTEGER;
  _qty NUMERIC;

BEGIN

--  Make sure that the itemsite in question has a default location
  SELECT itemloc_id INTO _itemlocid
    FROM itemlocdist, itemsite, itemloc
   WHERE ((itemlocdist_itemsite_id=itemsite_id)
     AND ( (itemsite_location_id=itemloc_location_id AND pTranstype='O') OR
           (itemsite_recvlocation_id=itemloc_location_id AND pTranstype='R') OR
           (itemsite_issuelocation_id=itemloc_location_id AND pTranstype='I') )
     AND (itemloc_itemsite_id=itemsite_id)
     AND (itemlocdist_id=pItemlocdistid));
  IF ( (NOT FOUND) OR (_itemlocid = -1) ) THEN
    RETURN -1;
  END IF;

--  Determine the remaining qty required to distribute
  SELECT (p.itemlocdist_qty - COALESCE(SUM(c.itemlocdist_qty), 0)) INTO _qty
    FROM itemlocdist AS p LEFT OUTER JOIN itemlocdist AS c
      ON (c.itemlocdist_itemlocdist_id=p.itemlocdist_id)
   WHERE (p.itemlocdist_id=pItemlocdistid)
   GROUP BY p.itemlocdist_qty;

  IF (_qty = 0) THEN
    RETURN -2;
  END IF;

--  Check to see if an itemlocdist with the correct location/lotserial/expiration already exists
  SELECT target.itemlocdist_id INTO _itemlocdistid
  FROM itemlocdist AS source, itemlocdist AS target
  WHERE ( (target.itemlocdist_source_type='I')
   AND (target.itemlocdist_source_id=_itemlocid)
   AND (COALESCE(target.itemlocdist_ls_id,-1)=COALESCE(source.itemlocdist_ls_id,-1))
   AND (target.itemlocdist_expiration=source.itemlocdist_expiration)
   AND (target.itemlocdist_itemlocdist_id=source.itemlocdist_id)
   AND (source.itemlocdist_id=pItemlocdistid) );

  IF (FOUND) THEN
    UPDATE itemlocdist
    SET itemlocdist_qty = (itemlocdist_qty + _qty)
    WHERE (itemlocdist_id=_itemlocdistid);

    RETURN _itemlocdistid;
  END IF;

--  Create a new itemlocdist
  SELECT NEXTVAL('itemlocdist_itemlocdist_id_seq') INTO _itemlocdistid;

  INSERT INTO itemlocdist
  ( itemlocdist_id, itemlocdist_itemlocdist_id,
    itemlocdist_source_type, itemlocdist_source_id,
    itemlocdist_qty, itemlocdist_expiration )
  VALUES
  ( _itemlocdistid, pItemlocdistid,
    'I', _itemlocid,
    _qty, endOfTime() );

  RETURN _itemlocdistid;

END;
$_$;


ALTER FUNCTION public.distributetodefaultitemloc(integer, text) OWNER TO admin;

--
-- TOC entry 1502 (class 1255 OID 146566066)
-- Dependencies: 4536 8
-- Name: distributetolocations(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION distributetolocations(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemlocdistid ALIAS FOR $1;
  _distCounter INTEGER;
  _itemlocdist RECORD;
  _itemlocid INTEGER;
  _runningQty NUMERIC;
  _tmp RECORD;

BEGIN

  _distCounter := 0;
  _runningQty  := 0;

-- A scenario can occur where two people try to post distributions
-- to the same itemsite against two or more lot/serial/mlc locations
-- leading to a deadlock. This line tries to prevent that by locking
-- ahead of time all the itemsites that the transaction will need
-- before any of the other tables are locked individually.
  SELECT itemsite_id
    INTO _tmp
    FROM itemsite
   WHERE(itemsite_id in (SELECT DISTINCT itemlocdist_itemsite_id
                           FROM itemlocdist
                          WHERE(itemlocdist_id=pItemlocdistid)))
     FOR UPDATE;

--  March through all of the itemlocdist owned by the passed parent itemlocdist
  FOR _itemlocdist IN SELECT c.itemlocdist_id AS itemlocdistid,
                             c.itemlocdist_source_type AS type,
                             c.itemlocdist_source_id AS sourceid,
                             c.itemlocdist_qty AS qty,
                             p.itemlocdist_itemsite_id AS itemsiteid,
                             itemsite_freeze,
                             p.itemlocdist_invhist_id AS invhistid,
                             p.itemlocdist_ls_id AS lotserialid,
                             p.itemlocdist_expiration AS expiration,
                             p.itemlocdist_warranty AS warranty,
                             p.itemlocdist_order_type AS ordertype,
                             p.itemlocdist_order_id AS orderid,
                             p.itemlocdist_series AS series
                      FROM itemlocdist AS c, itemlocdist AS p, itemsite
                      WHERE ( (c.itemlocdist_itemlocdist_id=p.itemlocdist_id)
                       AND (p.itemlocdist_source_type='O')
                       AND (p.itemlocdist_itemsite_id=itemsite_id)
                       AND (p.itemlocdist_id=pItemlocdistid) ) LOOP

    _distCounter := _distCounter + 1;

--  If the target for this itemlocdist is a location, check to see if the
--  required itemloc already exists
    IF (_itemlocdist.type = 'L') THEN
      SELECT itemloc_id INTO _itemlocid
      FROM itemloc
      WHERE ( (itemloc_itemsite_id=_itemlocdist.itemsiteid)
       AND (itemloc_location_id=_itemlocdist.sourceid)
       AND (COALESCE(itemloc_ls_id, -1)=COALESCE(_itemlocdist.lotserialid, -1))
       AND (COALESCE(itemloc_expiration,endOfTime())=COALESCE(_itemlocdist.expiration,endOfTime()))
       AND (COALESCE(itemloc_warrpurc,endoftime())=COALESCE(_itemlocdist.warranty,endoftime())) );

--  Nope, make it
      IF (NOT FOUND) THEN
        SELECT NEXTVAL('itemloc_itemloc_id_seq') INTO _itemlocid;
        INSERT INTO itemloc
        ( itemloc_id, itemloc_itemsite_id,
          itemloc_location_id, itemloc_qty,
          itemloc_ls_id, itemloc_expiration,
          itemloc_warrpurc )
        VALUES
        ( _itemlocid, _itemlocdist.itemsiteid,
          _itemlocdist.sourceid, 0,
          _itemlocdist.lotserialid, _itemlocdist.expiration,
          _itemlocdist.warranty );
      END IF;

    ELSE
--  Yep, cache it
      _itemlocid = _itemlocdist.sourceid;

      IF (_itemlocid IS NOT NULL AND (SELECT count(itemloc_id) = 0 FROM itemloc WHERE itemloc_id=_itemlocid)) THEN
        RAISE EXCEPTION 'No record to distribute against. Someone else may have already distributed this record.';
      END IF;
    END IF;

--  Record the invdetail for this itemlocdist
    INSERT INTO invdetail
    ( invdetail_invhist_id, invdetail_location_id, invdetail_ls_id,
      invdetail_qty, invdetail_qty_before, invdetail_qty_after, invdetail_expiration,
      invdetail_warrpurc )
    SELECT _itemlocdist.invhistid, itemloc_location_id, itemloc_ls_id,
           _itemlocdist.qty, itemloc_qty, (itemloc_qty + _itemlocdist.qty),
           itemloc_expiration,_itemlocdist.warranty
    FROM itemloc
    WHERE (itemloc_id=_itemlocid);

--  Update the parent invhist to indicate that it has invdetail records
    UPDATE invhist
    SET invhist_hasdetail=TRUE
    WHERE ((invhist_hasdetail=FALSE)
     AND (invhist_id=_itemlocdist.invhistid));

--  Update the itemloc_qty if its parent itemsite is not frozen
    IF (NOT _itemlocdist.itemsite_freeze) THEN
      UPDATE itemloc
      SET itemloc_qty = (itemloc_qty + _itemlocdist.qty)
      WHERE (itemloc_id=_itemlocid);

      PERFORM postInvHist(_itemlocdist.invhistid);

--  Handle reservation data
      IF ( (SELECT fetchMetricBool('EnableSOReservationsByLocation')) AND
           (_itemlocdist.qty < 0) ) THEN

--  If a shipment on a sales order, record reservation change before updating
--  so it can be reversed later if necessary
        IF (_itemlocdist.ordertype = 'SO') THEN
          INSERT INTO shipitemlocrsrv
          SELECT nextval('shipitemlocrsrv_shipitemlocrsrv_id_seq'),
            shipitem_id, itemloc_itemsite_id, itemloc_location_id,
            itemloc_ls_id, itemloc_expiration, itemloc_warrpurc,
            least((_itemlocdist.qty * -1.0), reserve_qty)
          FROM shipitem, itemloc
            JOIN reserve ON (itemloc_id=reserve_supply_id AND reserve_supply_type='I')
          WHERE ( (shipitem_invhist_id=_itemlocdist.invhistid)
            AND   (itemloc_id=_itemlocid)
            AND   (reserve_demand_type=_itemlocdist.ordertype)
            AND   (reserve_demand_id=_itemlocdist.orderid) );
        END IF;

--  Update the reservation
        UPDATE reserve
        SET reserve_qty = (reserve_qty + _itemlocdist.qty)
        WHERE ( (reserve_supply_id=_itemlocid)
          AND   (reserve_supply_type='I')
          AND   (reserve_demand_type=_itemlocdist.ordertype)
          AND   (reserve_demand_id=_itemlocdist.orderid) );

--  Delete reservation if fully distributed
        DELETE FROM reserve
        WHERE ( (reserve_supply_id=_itemlocid)
          AND   (reserve_supply_type='I')
          AND   (reserve_demand_type=_itemlocdist.ordertype)
          AND   (reserve_demand_id=_itemlocdist.orderid)
          AND   (reserve_qty=0) );
      END IF;
    END IF;

--  Adjust QOH if this itemlocdist is to/from a non-netable location
    IF ( SELECT (NOT location_netable)
         FROM itemloc, location
         WHERE ((itemloc_location_id=location_id)
          AND (itemloc_id=_itemlocid)) ) THEN

--  Record the invhist record for the netable->non-netable (or visaversa)
      INSERT INTO invhist
      ( invhist_itemsite_id,
        invhist_transtype, invhist_invqty,
        invhist_qoh_before, invhist_qoh_after,
        invhist_docnumber, invhist_comments,
        invhist_invuom, invhist_unitcost,
        invhist_costmethod, invhist_value_before, invhist_value_after,
        invhist_series )
      SELECT itemsite_id,
             'NN', (_itemlocdist.qty * -1),
             itemsite_qtyonhand, (itemsite_qtyonhand - _itemlocdist.qty),
             invhist_docnumber, invhist_comments,
             uom_name, stdCost(item_id),
             itemsite_costmethod, itemsite_value,
             (itemsite_value + (_itemlocdist.qty * -1 * CASE WHEN(itemsite_costmethod='A') THEN avgcost(itemsite_id)
                                                             ELSE stdCost(itemsite_item_id)
                                                        END)),
             _itemlocdist.series
      FROM item, itemsite, invhist, uom
      WHERE ( (itemsite_item_id=item_id)
       AND (item_inv_uom_id=uom_id)
       AND (itemsite_controlmethod <> 'N')
       AND (itemsite_id=_itemlocdist.itemsiteid)
       AND (invhist_id=_itemlocdist.invhistid) );

--  Update the itemsite_qoh
      IF (NOT _itemlocdist.itemsite_freeze) THEN
        UPDATE itemsite
        SET itemsite_qtyonhand = (itemsite_qtyonhand - _itemlocdist.qty),
            itemsite_nnqoh = (itemsite_nnqoh + _itemlocdist.qty)
        FROM itemloc
        WHERE ((itemloc_itemsite_id=itemsite_id)
         AND (itemloc_id=_itemlocid));
      END IF;
    END IF;

--  Cache the running qty.
    _runningQty := _runningQty + _itemlocdist.qty;

--  Dene with the child itemlocdist, so delete it
    DELETE FROM itemlocdist
    WHERE (itemlocdist_id=_itemlocdist.itemlocdistid);

--  If the target itemloc is now at qty=0, delete it if its parent
--  itemsite is not frozen
    IF (NOT _itemlocdist.itemsite_freeze) THEN
      DELETE FROM itemloc
      WHERE ( (itemloc_qty=0)
       AND (itemloc_id=_itemlocid) );
    END IF;

  END LOOP;

--  If the running qty for the detailed distributions is the same as the
--  total qty to distribute indicated by the parent itemlocdist, then the
--  parent itemlocdist has been fully distributed and should be deleted.
  IF ( ( SELECT itemlocdist_qty
         FROM itemlocdist
         WHERE (itemlocdist_id=pItemlocdistid) ) = _runningQty) THEN
    DELETE FROM itemlocdist
    WHERE (itemlocdist_id=pItemlocdistid);
  ELSE
--  There is still some more qty to distribute in the parent itemlocdist.
--  Update the qty to distribute with the qty that has been distributed.
    UPDATE itemlocdist
    SET itemlocdist_qty = (itemlocdist_qty - _runningQty)
    WHERE (itemlocdist_id=pItemlocdistid);
  END IF;

  RETURN _distCounter;

END;
$_$;


ALTER FUNCTION public.distributetolocations(integer) OWNER TO admin;

--
-- TOC entry 1504 (class 1255 OID 146566068)
-- Dependencies: 4536 8
-- Name: distributevoucherline(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION distributevoucherline(integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVoucherId ALIAS FOR $1;
  pPoitemId ALIAS FOR $2;
  pCurrId ALIAS FOR $3;
  _count INTEGER;
  _costelemId INTEGER;
  _close BOOLEAN;
  _r RECORD;
  _qtyOrdered NUMERIC;
  _voitemId INTEGER;
  _taxtypeid INTEGER;

BEGIN

--  Make sure the P/O and Voucher are same currency

  SELECT COALESCE(COUNT(*),0) INTO _count
        FROM poitem JOIN pohead ON (pohead_id=poitem_pohead_id)
        WHERE ((poitem_id=pPoitemid)
        AND (pohead_curr_id=pCurrId));
  IF (_count = 0) THEN
        RETURN -3;
  END IF;

--  Validate and get cost element

        SELECT COALESCE(COUNT(*),0) INTO _count
                FROM itemcost, item, itemsite, poitem
                WHERE ((itemcost_item_id=item_id)
                AND (item_id=itemsite_item_id)
                AND (itemsite_id=poitem_itemsite_id)
                AND (poitem_id=pPoitemId));

        IF (_count > 1) THEN
                RETURN -5;
        ELSEIF (_count = 1) THEN
                SELECT itemcost_costelem_id INTO _costelemId
                        FROM itemcost, item, itemsite, poitem
                        WHERE ((itemcost_item_id=item_id)
                        AND (item_id=itemsite_item_id)
                        AND (itemsite_id=poitem_itemsite_id)
                        AND (poitem_id=pPoitemId));
        ELSE
                SELECT costelem_id INTO _costelemId
                        FROM costelem
                        WHERE (costelem_type='Material');
        END IF;


--  Clear previous distributions

        UPDATE recv SET recv_vohead_id=NULL, recv_voitem_id=NULL
                WHERE ((recv_vohead_id=pVoucherId)
                AND (recv_orderitem_id=pPoitemId)
		AND (recv_order_type='PO'));
        UPDATE poreject SET poreject_vohead_id=NULL, poreject_voitem_id=NULL
                WHERE ((poreject_vohead_id=pVoucherId)
                AND (poreject_poitem_id=pPoitemId));
        DELETE FROM vodist
                WHERE ((vodist_poitem_id=pPoitemId)
                AND (vodist_vohead_id=pVoucherId));
        DELETE FROM voitem
                WHERE ((voitem_poitem_id=pPoitemId)
                AND (voitem_vohead_id=pVoucherId));

--  Determine Line balances

        SELECT  COALESCE(SUM(qty_received),0) AS qty_received,
                COALESCE(SUM(qty_rejected),0) AS qty_rejected,
                COALESCE(SUM(qty_vouchered),0) AS qty_vouchered,
                round(COALESCE(SUM(balance),0),2) AS balance,
                round(COALESCE(SUM(freight),0),2) AS freight INTO _r
         FROM   (
                SELECT  recv_qty AS qty_received,
                        0 AS qty_rejected,
                        0 AS qty_vouchered,
                        (recv_qty * COALESCE(recv_purchcost, poitem_unitprice)) AS balance,
                        recv_freight AS freight
                FROM poitem JOIN recv ON ((recv_orderitem_id=poitem_id) AND
                                          (recv_order_type='PO'))
                WHERE ( (recv_vohead_id IS NULL)
                        AND (NOT recv_invoiced)
                        AND (recv_posted)
                        AND (poitem_id=pPoitemId) )

                UNION ALL

                SELECT  0 AS qty_received,
                        (poreject_qty) AS qty_rejected,
                        0 AS qty_vouchered,
                        (poreject_qty * -1 * COALESCE(recv_purchcost, poitem_unitprice)) AS balance,
                        0 AS freight
                FROM poitem JOIN poreject ON (poreject_poitem_id=poitem_id)
                            LEFT OUTER JOIN recv ON (recv_id=poreject_recv_id)
                WHERE ( (poreject_posted)
                        AND (poreject_vohead_id IS NULL)
                        AND (NOT poreject_invoiced)
                        AND (poitem_id=pPoitemId) )

                UNION ALL

                SELECT  0 AS qty_received,
                        0 AS qty_rejected,
                        voitem_qty AS qty_vouchered,
                        0 AS balance,
                        0 AS freight
                FROM voitem, poitem
                WHERE ( (voitem_poitem_id=pPoitemId)
                        AND (poitem_id=voitem_poitem_id) )
                ) AS data;

                SELECT poitem_qty_ordered INTO _qtyOrdered
                FROM poitem
                WHERE (poitem_id=pPoitemId);

        IF _r.balance < 0 THEN
                RETURN -4;
        ELSEIF ( ((_r.qty_received <> 0) OR (_r.qty_received <> 0)) AND (_r.qty_received - _r.qty_rejected = 0) ) THEN
                RETURN -2;
        ELSEIF ((_r.qty_received - _r.qty_rejected) = 0) THEN
                RETURN 0;
        END IF;

-- Determine whether to close P/O item

        IF (_r.qty_received -_r.qty_rejected + _r.qty_vouchered) >= _qtyOrdered THEN
                _close:=True;
        ELSE
                _close:=False;
        END IF;


-- Create distribution

        INSERT INTO vodist
                (vodist_poitem_id,vodist_vohead_id,vodist_costelem_id,vodist_amount,vodist_qty,vodist_expcat_id)
                VALUES (pPoitemId,pVoucherId,_costelemId,_r.balance,(_r.qty_received -_r.qty_rejected),-1);

-- Create voucher item
        SELECT poitem_taxtype_id INTO _taxtypeid
        FROM poitem
        WHERE (poitem_id=pPoitemId);

        SELECT NEXTVAL('voitem_voitem_id_seq') INTO _voitemId;

        INSERT INTO voitem (voitem_id,voitem_vohead_id,voitem_poitem_id,voitem_close,voitem_qty,voitem_freight, voitem_taxtype_id)
                VALUES (_voitemId,pVoucherId,pPoitemId,_close,(_r.qty_received -_r.qty_rejected),_r.freight, _taxtypeid);

-- Tag receipt records

        UPDATE recv
        SET recv_vohead_id=pVoucherId, recv_voitem_id=_voitemId
        WHERE ((recv_orderitem_id=pPoitemId)
	  AND  (recv_order_type='PO')
          AND  (recv_vohead_id IS NULL));

        UPDATE poreject
        SET poreject_vohead_id=pVoucherId,poreject_voitem_id=_voitemId
        WHERE ((poreject_poitem_id=pPoitemId)
        AND (NOT poreject_invoiced)
        AND (poreject_vohead_id IS NULL));


  RETURN 1;

END;
$_$;


ALTER FUNCTION public.distributevoucherline(integer, integer, integer) OWNER TO admin;

--
-- TOC entry 1505 (class 1255 OID 146566069)
-- Dependencies: 4536 8
-- Name: dopostcosts(boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION dopostcosts(boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE

  pMaterial ALIAS FOR $1;
  plowerMaterial ALIAS FOR $2;
  pdirectLabor ALIAS FOR $3;
  plowerDirectLabor ALIAS FOR $4;
  poverhead ALIAS FOR $5;
  plowerOverhead ALIAS FOR $6;
  pmachOverhead ALIAS FOR $7;
  plowerMachOverhead ALIAS FOR $8;
  pUser ALIAS FOR $9;
  plowerUser ALIAS FOR $10;
  prollUp ALIAS FOR $11;
  _item RECORD;
  _result INTEGER := 0;

BEGIN

  PERFORM resetLowLevelCode(-1);

  FOR _item IN SELECT costUpdate_item_id
            FROM costUpdate
            ORDER BY costUpdate_lowlevel_code DESC LOOP
    PERFORM doPostCosts(_item.costUpdate_item_id, FALSE,
		       pMaterial, plowerMaterial, pdirectLabor,
		       plowerDirectLabor, poverhead, plowerOverhead,
		       pmachOverhead, plowerMachOverhead,
		       puser, plowerUser, prollUp);
  END LOOP;

  RETURN _result;

END;
 $_$;


ALTER FUNCTION public.dopostcosts(boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean) OWNER TO admin;

--
-- TOC entry 1506 (class 1255 OID 146566070)
-- Dependencies: 4536 8
-- Name: dopostcosts(integer, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION dopostcosts(integer, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE

  pItemId ALIAS FOR $1;
  pResetLowLevel ALIAS FOR $2;
  pMaterial ALIAS FOR $3;
  plowerMaterial ALIAS FOR $4;
  pdirectLabor ALIAS FOR $5;
  plowerDirectLabor ALIAS FOR $6;
  poverhead ALIAS FOR $7;
  plowerOverhead ALIAS FOR $8;
  pmachOverhead ALIAS FOR $9;
  plowerMachOverhead ALIAS FOR $10;
  pUser ALIAS FOR $11;
  plowerUser ALIAS FOR $12;
  prollUp ALIAS FOR $13;
  _itemcost RECORD;
  _result INTEGER;

BEGIN

    IF (pResetLowLevel) THEN
	PERFORM resetLowLevelCode(pItemId);
    END IF;

    FOR _itemcost IN SELECT itemcost_id, costelem_sys, costelem_type,
			    itemcost_lowlevel,
			    costUpdate_lowlevel_code, costUpdate_item_type
            FROM itemcost, costelem, costUpdate
            WHERE itemcost_item_id = pItemId
	      AND costUpdate_item_id = itemcost_item_id
              AND itemcost_costelem_id = costelem_id LOOP
      IF (NOT _itemcost.costelem_sys) THEN
        IF ( (pUser) AND ( NOT _itemcost.itemcost_lowlevel) ) THEN
          PERFORM postCost(_itemcost.itemcost_id);
          _result := _result + 1;
        END IF;
        IF ( (plowerUser) AND ( _itemcost.itemcost_lowlevel) ) THEN
          PERFORM postCost(_itemcost.itemcost_id);
          _result := _result + 1;
        END IF;
      END IF;

      IF (_itemcost.costelem_type = 'Material') THEN
        IF ( (pMaterial) AND ( NOT _itemcost.itemcost_lowlevel) ) THEN
          PERFORM postCost(_itemcost.itemcost_id);
          _result := _result + 1;
        END IF;
        IF ( (plowerMaterial) AND ( _itemcost.itemcost_lowlevel) ) THEN
          PERFORM postCost(_itemcost.itemcost_id);
          _result := _result + 1;
        END IF;
      END IF;

      IF (_itemcost.costelem_type = 'Direct Labor') THEN
        IF ( (pdirectLabor) AND ( NOT _itemcost.itemcost_lowlevel) ) THEN
          PERFORM postCost(_itemcost.itemcost_id);
          _result := _result + 1;
        END IF;
        IF ( (plowerDirectLabor) AND ( _itemcost.itemcost_lowlevel) ) THEN
          PERFORM postCost(_itemcost.itemcost_id);
          _result := _result + 1;
        END IF;
      END IF;

      IF (_itemcost.costelem_type = 'Overhead') THEN
        IF ( (poverhead) AND ( NOT _itemcost.itemcost_lowlevel) ) THEN
          PERFORM postCost(_itemcost.itemcost_id);
          _result := _result + 1;
        END IF;
        IF ( (plowerOverhead) AND ( _itemcost.itemcost_lowlevel) ) THEN
          PERFORM postCost(_itemcost.itemcost_id);
          _result := _result + 1;
        END IF;
      END IF;

      IF (_itemcost.costelem_type = 'Machine Overhead') THEN
        IF ( (pmachOverhead) AND ( NOT _itemcost.itemcost_lowlevel) ) THEN
          PERFORM postCost(_itemcost.itemcost_id);
          _result := _result + 1;
        END IF;
        IF ( (plowerMachOverhead) AND ( _itemcost.itemcost_lowlevel) ) THEN
          PERFORM postCost(_itemcost.itemcost_id);
          _result := _result + 1;
        END IF;
      END IF;

    END LOOP;

    IF (prollUp) THEN
      PERFORM rollUpStandardCost(pItemId);
      _result := _result + 1;
    END IF;

    RETURN _result;

END;
 $_$;


ALTER FUNCTION public.dopostcosts(integer, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean) OWNER TO admin;

--
-- TOC entry 1507 (class 1255 OID 146566071)
-- Dependencies: 4536 8
-- Name: doupdatecosts(boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION doupdatecosts(boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE

  plowerMaterial ALIAS FOR $1;
  pdirectLabor ALIAS FOR $2;
  plowerDirectLabor ALIAS FOR $3;
  poverhead ALIAS FOR $4;
  plowerOverhead ALIAS FOR $5;
  pmachOverhead ALIAS FOR $6;
  plowerMachOverhead ALIAS FOR $7;
  plowerUser ALIAS FOR $8;
  prollUp ALIAS FOR $9;

BEGIN
  RETURN doUpdateCosts(plowerMaterial, pdirectLabor, plowerDirectLabor,
		       poverhead, plowerOverhead, pmachOverhead,
		       plowerMachOverhead, plowerUser, prollUp, TRUE);
END;
$_$;


ALTER FUNCTION public.doupdatecosts(boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean) OWNER TO admin;

--
-- TOC entry 1509 (class 1255 OID 146566073)
-- Dependencies: 4536 8
-- Name: doupdatecosts(boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION doupdatecosts(boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE

  plowerMaterial ALIAS FOR $1;
  pdirectLabor ALIAS FOR $2;
  plowerDirectLabor ALIAS FOR $3;
  poverhead ALIAS FOR $4;
  plowerOverhead ALIAS FOR $5;
  pmachOverhead ALIAS FOR $6;
  plowerMachOverhead ALIAS FOR $7;
  plowerUser ALIAS FOR $8;
  prollUp ALIAS FOR $9;
  pActual ALIAS FOR $10;
  _item RECORD;
  _bom RECORD;
  _result INTEGER := 0;

BEGIN

  PERFORM resetLowLevelCode(-1);

  FOR _item IN SELECT costUpdate_item_id
            FROM costUpdate
            ORDER BY costUpdate_lowlevel_code DESC LOOP
    PERFORM doUpdateCosts(_item.costUpdate_item_id, false, plowerMaterial,
		  pdirectLabor, plowerDirectLabor, poverhead, plowerOverhead,
		  pmachOverhead, plowerMachOverhead, plowerUser, prollUp,
		  pActual);
  END LOOP;

  RETURN _result;

END;
 $_$;


ALTER FUNCTION public.doupdatecosts(boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean) OWNER TO admin;

--
-- TOC entry 1508 (class 1255 OID 146566072)
-- Dependencies: 4536 8
-- Name: doupdatecosts(integer, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION doupdatecosts(integer, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE

  pItemId ALIAS FOR $1;
  pResetLowLevel ALIAS FOR $2;
  plowerMaterial ALIAS FOR $3;
  pdirectLabor ALIAS FOR $4;
  plowerDirectLabor ALIAS FOR $5;
  poverhead ALIAS FOR $6;
  plowerOverhead ALIAS FOR $7;
  pmachOverhead ALIAS FOR $8;
  plowerMachOverhead ALIAS FOR $9;
  plowerUser ALIAS FOR $10;
  prollUp ALIAS FOR $11;

BEGIN
    RETURN doUpdateCosts(pItemId, pResetLowLevel, plowerMaterial, pdirectLabor,
			 plowerDirectLabor, poverhead, plowerOverhead,
			 pmachOverhead, plowerMachOverhead, plowerUser, prollUp,
			 TRUE);
END;
$_$;


ALTER FUNCTION public.doupdatecosts(integer, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean) OWNER TO admin;

--
-- TOC entry 1510 (class 1255 OID 146566074)
-- Dependencies: 4536 8
-- Name: doupdatecosts(integer, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION doupdatecosts(integer, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE

  pItemId ALIAS FOR $1;
  pResetLowLevel ALIAS FOR $2;
  plowerMaterial ALIAS FOR $3;
  pdirectLabor ALIAS FOR $4;
  plowerDirectLabor ALIAS FOR $5;
  poverhead ALIAS FOR $6;
  plowerOverhead ALIAS FOR $7;
  pmachOverhead ALIAS FOR $8;
  plowerMachOverhead ALIAS FOR $9;
  plowerUser ALIAS FOR $10;
  prollUp ALIAS FOR $11;
  pUpdateActual ALIAS FOR $12;
  _item RECORD;
  _bom RECORD;
  _result INTEGER := 0;
  _resultFromReset INTEGER;
  _counterNum INTEGER;
  _feedBackNum INTEGER;

BEGIN

    IF (pResetLowLevel) THEN
	PERFORM resetLowLevelCode(pItemId);
    END IF;

    SELECT costUpdate_item_id AS item_id, costUpdate_item_type AS item_type
	INTO _item
    FROM costUpdate
    WHERE costUpdate_item_id = pItemId;

    IF ((plowerMaterial) AND ((_item.item_type <> 'P') AND (_item.item_type <> 'O'))) THEN
      PERFORM updateSorACost(_item.item_id, 'Material', TRUE, lowerCost(_item.item_id, 'Material', pUpdateActual), pUpdateActual);
    END IF;

    IF (pdirectLabor) THEN
      PERFORM updateSorACost(_item.item_id, 'Direct Labor', FALSE, xtmfg.directLaborCost(_item.item_id), pUpdateActual);
    END IF;

    IF (plowerDirectLabor) THEN
      PERFORM updateSorACost(_item.item_id, 'Direct Labor', TRUE, lowerCost(_item.item_id, 'Direct Labor', pUpdateActual), pUpdateActual);
    END IF;

    IF (poverhead) THEN
      PERFORM updateSorACost(_item.item_id, 'Overhead', FALSE, xtmfg.overheadCost(_item.item_id), pUpdateActual);
    END IF;

    IF (plowerOverhead) THEN
      PERFORM updateSorACost(_item.item_id, 'Overhead', TRUE, lowerCost(_item.item_id, 'Overhead', pUpdateActual), pUpdateActual);
    END IF;

    IF (pmachOverhead) THEN
      PERFORM updateSorACost(_item.item_id, 'Machine Overhead', FALSE, xtmfg.machineOverheadCost(_item.item_id), pUpdateActual);
    END IF;

    IF (plowerMachOverhead) THEN
      PERFORM updateSorACost(_item.item_id, 'Machine Overhead', TRUE, lowerCost(_item.item_id, 'Machine Overhead', pUpdateActual), pUpdateActual);
    END IF;

    IF (plowerUser) THEN
      PERFORM updateLowerUserCosts(_item.item_id, pUpdateActual);
    END IF;

    IF (prollUp) THEN
      PERFORM rollUpSorACost(_item.item_id, pUpdateActual);
    END IF;

    RETURN _result;

END;
 $_$;


ALTER FUNCTION public.doupdatecosts(integer, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean, boolean) OWNER TO admin;

--
-- TOC entry 1443 (class 1255 OID 146566075)
-- Dependencies: 4536 8
-- Name: dropifexists(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION dropifexists(text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN dropIfExists($1, $2, 'public');
END;
$_$;


ALTER FUNCTION public.dropifexists(text, text) OWNER TO admin;

--
-- TOC entry 1477 (class 1255 OID 146566076)
-- Dependencies: 4536 8
-- Name: dropifexists(text, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION dropifexists(text, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN dropIfExists($1, $2, $3, false);
END;
$_$;


ALTER FUNCTION public.dropifexists(text, text, text) OWNER TO admin;

--
-- TOC entry 1511 (class 1255 OID 146566077)
-- Dependencies: 4536 8
-- Name: dropifexists(text, text, text, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION dropifexists(text, text, text, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pType         ALIAS FOR $1;
  pObject       ALIAS FOR $2;
  pSchema       ALIAS FOR $3;
  pCascade      ALIAS FOR $4;
  _table	TEXT;
  _query	TEXT;
BEGIN
  IF (UPPER(pType) = 'INDEX') THEN
    _query = 'DROP INDEX ' || quote_ident(LOWER(pSchema)) || '.' || quote_ident(LOWER(pObject));

    BEGIN
      EXECUTE _query;
    EXCEPTION WHEN undefined_object OR invalid_schema_name THEN
		RETURN 0;
	      WHEN OTHERS THEN RAISE EXCEPTION '% %', SQLSTATE, SQLERRM;
    END;

  ELSEIF (UPPER(pType) = 'TABLE') THEN
    _query = 'DROP TABLE ' || quote_ident(LOWER(pSchema)) || '.' || quote_ident(LOWER(pObject));

    IF (pCascade) THEN
      _query = _query || ' CASCADE';
    END IF;

    BEGIN
      EXECUTE _query;
    EXCEPTION WHEN undefined_table OR invalid_schema_name THEN
		RETURN 0;
	      WHEN OTHERS THEN RAISE EXCEPTION '% %', SQLSTATE, SQLERRM;
    END;

  ELSIF (UPPER(pType) = 'VIEW') THEN
    _query = 'DROP VIEW ' || quote_ident(LOWER(pSchema)) || '.' || quote_ident(LOWER(pObject));

    IF (pCascade) THEN
      _query = _query || ' CASCADE';
    END IF;

    BEGIN
      EXECUTE _query;
    EXCEPTION WHEN undefined_table OR invalid_schema_name THEN
		RETURN 0;
	      WHEN OTHERS THEN RAISE EXCEPTION '% %', SQLSTATE, SQLERRM;
    END;

  ELSIF (UPPER(pType) = 'TRIGGER') THEN
    SELECT relname INTO _table
    FROM pg_trigger, pg_class
    WHERE ((tgrelid=pg_class.oid)
      AND  (UPPER(tgname)=UPPER(pObject)));
    IF (NOT FOUND) THEN
      _table := '[no table]';
    END IF;

    _query = 'DROP TRIGGER ' || quote_ident(LOWER(pObject)) ||
	     ' ON ' || quote_ident(LOWER(pSchema)) || '.' || quote_ident(LOWER(_table));
    BEGIN
      EXECUTE _query;
    EXCEPTION WHEN undefined_object THEN
		RETURN 0;
	      WHEN undefined_table OR invalid_schema_name THEN
		RETURN 0;
	      WHEN OTHERS THEN RAISE EXCEPTION '% %', SQLSTATE, SQLERRM;
    END;

  ELSIF (UPPER(pType) = 'FUNCTION') THEN
    _query = 'DROP FUNCTION ' || (LOWER(pSchema)) || '.' ||
                                   (LOWER(pObject));
    BEGIN
      EXECUTE _query;
    EXCEPTION WHEN undefined_object OR undefined_function OR invalid_schema_name THEN
		RETURN 0;
	      WHEN OTHERS THEN RAISE EXCEPTION '% %', SQLSTATE, SQLERRM;
    END;

  ELSIF (UPPER(pType) = 'CONSTRAINT') THEN
    IF( (SELECT count(*)
           FROM pg_constraint, pg_class, pg_namespace
          WHERE((conrelid=pg_class.oid)
            AND (connamespace=pg_namespace.oid)
            AND (conname=pObject)
            AND (nspname=pSchema))
         ) > 1 ) THEN
      RAISE EXCEPTION 'dropIfExists called on constraint name that matches more than 1 constraint.';
    END IF;
    SELECT relname INTO _table
    FROM pg_constraint, pg_class, pg_namespace
    WHERE ((conrelid=pg_class.oid)
      AND  (connamespace=pg_namespace.oid)
      AND  (conname=pObject)
      AND  (nspname=pSchema));
    IF (NOT FOUND) THEN
      RETURN 0;
    END IF;
    _query = 'ALTER TABLE ' || quote_ident(LOWER(pSchema)) || '.' || quote_ident(LOWER(_table))
             || ' DROP CONSTRAINT ' || quote_ident(LOWER(pObject));
    BEGIN
      EXECUTE _query;
    EXCEPTION WHEN undefined_table OR invalid_schema_name THEN
		RETURN 0;
	      WHEN OTHERS THEN RAISE EXCEPTION '% %', SQLSTATE, SQLERRM;
    END;

  ELSIF (UPPER(pType) = 'SCHEMA') THEN
    _query = 'DROP SCHEMA ' || quote_ident(LOWER(pObject));
    BEGIN
      EXECUTE _query;
    EXCEPTION WHEN invalid_schema_name THEN
                RETURN 0;
              WHEN OTHERS THEN RAISE EXCEPTION '% %', SQLSTATE, SQLERRM;
    END;

  ELSIF (UPPER(pType) = 'TYPE') THEN
    _query = 'DROP TYPE ' || quote_ident(LOWER(pSchema)) || '.' ||
                               quote_ident(LOWER(pObject));
    IF (pCascade) THEN
      _query = _query || ' CASCADE';
    END IF;

    BEGIN
      EXECUTE _query;
    EXCEPTION WHEN undefined_object OR invalid_schema_name THEN
                RETURN 0;
              WHEN OTHERS THEN RAISE EXCEPTION '% %', SQLSTATE, SQLERRM;
    END;

  ELSE
    RAISE EXCEPTION 'dropIfExists(%, %): unknown pType %', pType, pObject, pType;
  END IF;

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.dropifexists(text, text, text, boolean) OWNER TO admin;

--
-- TOC entry 1512 (class 1255 OID 146566078)
-- Dependencies: 4536 8
-- Name: dropifexists(text, text, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION dropifexists(text, text, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pType         ALIAS FOR $1;
  pObject       ALIAS FOR $2;
  pSchema       ALIAS FOR $3;
  pRelation     ALIAS FOR $4;
  _table        TEXT;
  _query	TEXT;
BEGIN
  IF (UPPER(pType) = 'CONSTRAINT') THEN
    SELECT relname INTO _table
    FROM pg_constraint, pg_class, pg_namespace
    WHERE ((conrelid=pg_class.oid)
      AND  (connamespace=pg_namespace.oid)
      AND  (conname=pObject)
      AND  (relname=pRelation)
      AND  (nspname=pSchema));
    IF (NOT FOUND) THEN
      RETURN 0;
    END IF;
    _query = 'ALTER TABLE ' || quote_ident(LOWER(pSchema)) || '.' || quote_ident(LOWER(pRelation))
             || ' DROP CONSTRAINT ' || quote_ident(LOWER(pObject));
    BEGIN
      EXECUTE _query;
    EXCEPTION WHEN undefined_table OR invalid_schema_name THEN
		RETURN 0;
	      WHEN OTHERS THEN RAISE EXCEPTION '% %', SQLSTATE, SQLERRM;
    END;

  ELSE
    RAISE EXCEPTION 'dropIfExists(%, %, %, %): pType % is not supported when relation is specified', pType, pObject, pSchema, pRelation, pType;
  END IF;

  RETURN 1;
END;
$_$;


ALTER FUNCTION public.dropifexists(text, text, text, text) OWNER TO admin;

--
-- TOC entry 1513 (class 1255 OID 146566079)
-- Dependencies: 4536 8
-- Name: dropstdopntable(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION dropstdopntable() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF((SELECT metric_value != 'Manufacturing' FROM metric WHERE metric_name = 'Application')) THEN
    PERFORM dropIfExists('TABLE', 'stdopn');
    RETURN true;
  END IF;
  RETURN false;
END;
$$;


ALTER FUNCTION public.dropstdopntable() OWNER TO admin;

--
-- TOC entry 1514 (class 1255 OID 146566080)
-- Dependencies: 4536 8
-- Name: editccnumber(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION editccnumber(text, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCcardnum ALIAS FOR $1;
  pCcardtype ALIAS FOR $2;
  card_length INTEGER;
  card_valid boolean := false;
  starting_digits TEXT;
  _sum INTEGER := 0;
  _digit INTEGER := 0;
  _timesTwo BOOLEAN := false;
BEGIN

-- Check the card type
  IF (pCcardtype NOT IN ('M', 'V', 'A', 'D')) THEN
-- Unknown Card Type
   RETURN -1;
  END IF;

  card_length := length(pCcardnum);

-- Process Master Card Checking length
-- Process Master Card Starting digits
  IF (pCcardtype = 'M') THEN
    IF (card_length != 16) THEN
-- Bad Card Length Card Type
      RETURN -2;
    END IF;
    starting_digits := substr(pCcardnum, 1, 2);
    IF (starting_digits < '51' OR starting_digits > '55') THEN
-- Bad Starting digits
      RETURN -6;
    END IF;
  END IF;

-- Process Visa Card Checking length
-- Process Visa Card Starting digits
  IF (pCcardtype = 'V') THEN
    IF (card_length != 13 AND card_length != 16) THEN
-- Bad Card Length Card Type
      RETURN -3;
    END IF;
    starting_digits := substr(pCcardnum, 1, 1);
    IF (starting_digits != '4') THEN
-- Bad Starting digits
      RETURN -7;
    END IF;
  END IF;

-- Process American Express Card Checking length
-- Process American Express Card Starting digits
  IF (pCcardtype = 'A') THEN
    IF (card_length != 15) THEN
-- Bad Card Length Card Type
      RETURN -4;
    END IF;
    starting_digits := substr(pCcardnum, 1, 2);
    IF (starting_digits != '34' AND starting_digits != '37') THEN
-- Bad Starting digits
      RETURN -8;
    END IF;
  END IF;

-- Process Discover Card Checking length
-- Process Discover Card Starting digits
  IF (pCcardtype = 'D') THEN
    IF (card_length != 16) THEN
-- Bad Card Length Card Type
      RETURN -5;
    END IF;
    starting_digits := substr(pCcardnum, 1, 4);
    IF (starting_digits != '6011') THEN
-- Bad Starting digits
      RETURN -9;
    END IF;
  END IF;

-- Now comes the fun part of doing the "check" for the check sum
-- perform a luhn checksum
  FOR i IN REVERSE card_length .. 1 LOOP
    _digit := int4(substr(pCcardnum, i, 1));
    IF (_timesTwo) THEN
      _digit := _digit * 2;
      IF (_digit > 9) THEN
        _digit := _digit - 9;
      END IF;
    END IF;
    _sum := _sum + _digit;
    _timesTwo := NOT _timesTwo;
  END LOOP;

  IF (mod(_sum, 10) != 0) THEN
    RETURN -10;
  END IF;

  RETURN 0; -- No Error

END;
$_$;


ALTER FUNCTION public.editccnumber(text, text) OWNER TO admin;

--
-- TOC entry 1515 (class 1255 OID 146566081)
-- Dependencies: 4536 8
-- Name: enablepackage(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION enablepackage(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  ppkgname  ALIAS FOR $1;
  _i        INTEGER := 0;
  _tabs     TEXT[] := ARRAY['cmd',  'cmdarg', 'image',  'metasql',
                            'priv', 'report', 'script', 'uiform'];

BEGIN
  IF (version() < 'PostgreSQL 8.2') THEN
    RETURN -1;
  END IF;

  FOR _i IN ARRAY_LOWER(_tabs,1)..ARRAY_UPPER(_tabs,1) LOOP
    EXECUTE 'ALTER TABLE ' || ppkgname || '.pkg' || _tabs[_i] ||
            ' INHERIT public.' || _tabs[_i] || ';';
  END LOOP;

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.enablepackage(text) OWNER TO admin;

--
-- TOC entry 1516 (class 1255 OID 146566082)
-- Dependencies: 4536 8
-- Name: enablepackage(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION enablepackage(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  ppkgheadid    ALIAS FOR $1;
  _pkgname      TEXT;

BEGIN
  SELECT pkghead_name INTO _pkgname
  FROM pkghead
  WHERE (pkghead_id=ppkgheadid);
  IF (NOT FOUND) THEN
    RETURN -2;
  END IF;

  RETURN enablePackage(_pkgname);
END;
$_$;


ALTER FUNCTION public.enablepackage(integer) OWNER TO admin;

--
-- TOC entry 1517 (class 1255 OID 146566083)
-- Dependencies: 8
-- Name: encrypt(bytea, bytea, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION encrypt(bytea, bytea, text) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgcrypto', 'pg_encrypt';


ALTER FUNCTION public.encrypt(bytea, bytea, text) OWNER TO admin;

--
-- TOC entry 1518 (class 1255 OID 146566084)
-- Dependencies: 8
-- Name: encrypt_iv(bytea, bytea, bytea, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION encrypt_iv(bytea, bytea, bytea, text) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgcrypto', 'pg_encrypt_iv';


ALTER FUNCTION public.encrypt_iv(bytea, bytea, bytea, text) OWNER TO admin;

--
-- TOC entry 1519 (class 1255 OID 146566085)
-- Dependencies: 8
-- Name: endoftime(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION endoftime() RETURNS date
    LANGUAGE sql IMMUTABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
SELECT DATE('2100-01-01') as result;
$$;


ALTER FUNCTION public.endoftime() OWNER TO admin;

--
-- TOC entry 1520 (class 1255 OID 146566086)
-- Dependencies: 4536 8
-- Name: entercount(integer, numeric, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION entercount(integer, numeric, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pInvcntid ALIAS FOR $1;
  pQty ALIAS FOR $2;
  pComments ALIAS FOR $3;
BEGIN

  UPDATE invcnt
  SET invcnt_qoh_after = pQty,
      invcnt_comments = CASE WHEN ( (LENGTH(invcnt_comments) = 0) AND
                                    (LENGTH(pComments) > 0) ) THEN pComments
                             WHEN (LENGTH(pComments) > 0) THEN (invcnt_comments || E'\n' || pComments)
                             ELSE invcnt_comments
                        END,
      invcnt_cntdate = CURRENT_TIMESTAMP,
      invcnt_cnt_username = getEffectiveXtUser()
  WHERE (invcnt_id=pInvcntid);

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.entercount(integer, numeric, text) OWNER TO admin;

--
-- TOC entry 1521 (class 1255 OID 146566087)
-- Dependencies: 4536 8
-- Name: enterporeceipt(integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION enterporeceipt(integer, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN enterReceipt('PO', $1, $2, 0.0, '', NULL, NULL);
END;
$_$;


ALTER FUNCTION public.enterporeceipt(integer, numeric) OWNER TO admin;

--
-- TOC entry 1522 (class 1255 OID 146566088)
-- Dependencies: 4536 8
-- Name: enterporeceipt(integer, numeric, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION enterporeceipt(integer, numeric, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN enterPoReceipt('PO', $1, $2, 0.0, $3, NULL, NULL);
END;
$_$;


ALTER FUNCTION public.enterporeceipt(integer, numeric, text) OWNER TO admin;

--
-- TOC entry 1489 (class 1255 OID 146566089)
-- Dependencies: 4536 8
-- Name: enterporeceipt(integer, numeric, numeric, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION enterporeceipt(integer, numeric, numeric, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN enterPoReceipt('PO', $1, $2, $3, $4, NULL, NULL);
END;
$_$;


ALTER FUNCTION public.enterporeceipt(integer, numeric, numeric, text) OWNER TO admin;

--
-- TOC entry 1490 (class 1255 OID 146566090)
-- Dependencies: 4536 8
-- Name: enterporeceipt(integer, numeric, numeric, text, integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION enterporeceipt(integer, numeric, numeric, text, integer, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN enterReceipt('PO', $1, $2, $3, $4, $5, $6);
END;
$_$;


ALTER FUNCTION public.enterporeceipt(integer, numeric, numeric, text, integer, date) OWNER TO admin;

--
-- TOC entry 1503 (class 1255 OID 146566091)
-- Dependencies: 4536 8
-- Name: enterporeturn(integer, numeric, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION enterporeturn(integer, numeric, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN enterPoReturn($1, $2, $3, NULL);
END;
$_$;


ALTER FUNCTION public.enterporeturn(integer, numeric, integer) OWNER TO admin;

--
-- TOC entry 1523 (class 1255 OID 146566092)
-- Dependencies: 4536 8
-- Name: enterporeturn(integer, numeric, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION enterporeturn(integer, numeric, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPoitemid ALIAS FOR $1;
  pQty ALIAS FOR $2;
  pRjctcodeid ALIAS FOR $3;
  pRecvid ALIAS FOR $4;
  _porejectid INTEGER;

BEGIN

  SELECT NEXTVAL('poreject_poreject_id_seq') INTO _porejectid;

  INSERT INTO poreject
  ( poreject_id, poreject_date, poreject_ponumber, poreject_poitem_id, poreject_trans_username,
    poreject_agent_username, poreject_itemsite_id,
    poreject_vend_id, poreject_vend_item_number, poreject_vend_item_descrip, poreject_vend_uom,
    poreject_qty, poreject_rjctcode_id, poreject_posted, poreject_invoiced, poreject_recv_id )
  SELECT _porejectid, CURRENT_TIMESTAMP, pohead_number, poitem_id, getEffectiveXtUser(),
         pohead_agent_username, poitem_itemsite_id,
         pohead_vend_id, poitem_vend_item_number, poitem_vend_item_descrip, poitem_vend_uom,
         pQty, pRjctcodeid, FALSE, FALSE, pRecvid
  FROM poitem JOIN pohead ON (pohead_id=poitem_pohead_id)
  WHERE (poitem_id=pPoitemid);

  RETURN _porejectid;

END;
$_$;


ALTER FUNCTION public.enterporeturn(integer, numeric, integer, integer) OWNER TO admin;

--
-- TOC entry 1524 (class 1255 OID 146566093)
-- Dependencies: 4536 8
-- Name: enterreceipt(text, integer, numeric, numeric, text, integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION enterreceipt(text, integer, numeric, numeric, text, integer, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN enterReceipt($1, $2, $3, $4, $5, $6, $7, NULL);
END;
$_$;


ALTER FUNCTION public.enterreceipt(text, integer, numeric, numeric, text, integer, date) OWNER TO admin;

--
-- TOC entry 1525 (class 1255 OID 146566094)
-- Dependencies: 4536 8
-- Name: enterreceipt(text, integer, numeric, numeric, text, integer, date, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION enterreceipt(text, integer, numeric, numeric, text, integer, date, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pordertype	ALIAS FOR $1;
  porderitemid	ALIAS FOR $2;
  pQty		ALIAS FOR $3;
  pFreight	ALIAS FOR $4;
  pNotes	ALIAS FOR $5;
  pcurrid	ALIAS FOR $6;	-- NULL is handled by SELECT ... INTO _o
  precvdate	ALIAS FOR $7;	-- NULL is handled by INSERT INTO recv
  pRecvCost	ALIAS FOR $8;
  _timestamp    TIMESTAMP;
  _o		RECORD;
  _recvid	INTEGER;
  _warehouseid 	INTEGER;
  _recvcost	NUMERIC;

BEGIN
  IF(precvdate IS NULL OR precvdate = CURRENT_DATE) THEN
    _timestamp := CURRENT_TIMESTAMP;
  ELSE
    _timestamp := precvdate;
  END IF;
  SELECT NEXTVAL('recv_recv_id_seq') INTO _recvid;

  DELETE FROM recv
  WHERE ((NOT recv_posted)
    AND  (recv_order_type=pordertype)
    AND  (recv_orderitem_id=porderitemid) );

  IF (pQty > 0) THEN
    IF (pordertype='PO') THEN
      SELECT pohead_number AS orderhead_number,
  	   poitem_id AS orderitem_id,
	   pohead_agent_username AS orderhead_agent_username,
	   CASE WHEN (poitem_itemsite_id = -1) THEN NULL
		ELSE poitem_itemsite_id
	   END AS itemsite_id,
	   vend_id,
	   COALESCE(poitem_vend_item_number, '') AS vend_item_number,
	   COALESCE(poitem_vend_item_descrip, '') AS vend_item_descrip,
	   COALESCE(poitem_vend_uom, '') AS vend_uom,
	   poitem_duedate AS duedate,
	   poitem_unitprice AS orderitem_unitcost,
	   pohead_curr_id AS orderitem_unitcost_curr_id,
	   pohead_curr_id AS freight_curr_id,
	   poitem_rlsd_duedate AS rlsd_duedate INTO _o
        FROM pohead
          JOIN poitem ON (pohead_id=poitem_pohead_id)
          JOIN vendinfo ON (pohead_vend_id=vend_id)
        WHERE (poitem_id=porderitemid);

    ELSIF (pordertype='RA') THEN
       SELECT rahead_number AS orderhead_number,
  	   raitem_id AS orderitem_id,
	   ''::text AS orderhead_agent_username,
	   raitem_itemsite_id AS itemsite_id,
	   NULL::integer AS vend_id,
	   ''::text AS vend_item_number,
	   ''::text AS vend_item_descrip,
	   ''::text AS vend_uom,
	   raitem_scheddate AS duedate,
	   raitem_unitprice AS orderitem_unitcost,
	   rahead_curr_id AS orderitem_unitcost_curr_id,
	   rahead_curr_id AS freight_curr_id,
           raitem_scheddate AS rlsd_duedate INTO _o
        FROM rahead
          JOIN raitem ON (rahead_id=raitem_rahead_id)
        WHERE (raitem_id=porderitemid);

    ELSIF (pordertype='TO') THEN
         SELECT tohead_number AS orderhead_number,
  	   toitem_id AS orderitem_id,
	   tohead_agent_username AS orderhead_agent_username,
	   itemsite_id,
	   NULL::integer AS vend_id,
	   ''::text AS vend_item_number,
	   ''::text AS vend_item_descrip,
	   ''::text AS vend_uom,
	   toitem_duedate AS duedate,
	   toitem_stdcost AS orderitem_unitcost,
	   baseCurrId() AS orderitem_unitcost_curr_id,
	   toitem_freight_curr_id AS freight_curr_id,
           toitem_duedate AS rlsd_duedate INTO _o
        FROM itemsite, tohead
          JOIN toitem ON (tohead_id=toitem_tohead_id)
        WHERE ((toitem_id=porderitemid)
          AND  (tohead_dest_warehous_id=itemsite_warehous_id)
          AND  (toitem_item_id=itemsite_item_id));
    END IF;

    --Make sure user has site privileges
     IF ((FOUND) AND (_o.itemsite_id IS NOT NULL)) THEN
       SELECT warehous_id INTO _warehouseid
       FROM itemsite,site()
       WHERE ((itemsite_id=_o.itemsite_id)
         AND (warehous_id=itemsite_warehous_id));

       IF (NOT FOUND) THEN
         RETURN 0;
        END IF;
      END IF;

    --Make sure we aren't trying to receive a Kit
    IF ((FOUND) AND (_o.itemsite_id IS NOT NULL)) THEN
      IF (SELECT (item_type='K')
          FROM itemsite, item
          WHERE ((itemsite_id=_o.itemsite_id)
            AND  (item_id=itemsite_item_id))) THEN
        RETURN 0;
      END IF;
    END IF;

    IF (NOT FOUND) THEN
      RETURN -1;
    END IF;

    -- default to orderitem_unitcost if recv_purchcost is not specified
    IF(pRecvCost IS NULL) THEN
      _recvcost := _o.orderitem_unitcost;
    ELSE
      _recvcost := pRecvCost;
    END IF;

    INSERT INTO recv
    ( recv_id, recv_date,
      recv_order_number, recv_order_type, recv_orderitem_id,
      recv_trans_usr_name, recv_agent_username, recv_itemsite_id,
      recv_vend_id, recv_vend_item_number, recv_vend_item_descrip,
      recv_vend_uom, recv_qty, recv_duedate,
      recv_purchcost, recv_purchcost_curr_id,
      recv_notes, recv_freight, recv_freight_curr_id, recv_rlsd_duedate
    ) VALUES (
      _recvid, _timestamp,
      _o.orderhead_number, pordertype, _o.orderitem_id::INTEGER,
      getEffectiveXtUser(), _o.orderhead_agent_username, _o.itemsite_id::INTEGER,
      _o.vend_id::INTEGER, _o.vend_item_number, _o.vend_item_descrip,
      _o.vend_uom, pQty, _o.duedate,
      _recvcost, _o.orderitem_unitcost_curr_id::INTEGER,
      pNotes, pFreight, _o.freight_curr_id::INTEGER, _o.rlsd_duedate);
  END IF;

  RETURN _recvid;

END;
$_$;


ALTER FUNCTION public.enterreceipt(text, integer, numeric, numeric, text, integer, date, numeric) OWNER TO admin;

--
-- TOC entry 1526 (class 1255 OID 146566095)
-- Dependencies: 4536 8
-- Name: expirecreditcard(integer, bytea); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION expirecreditcard(integer, bytea) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCust ALIAS FOR $1;
  pKey ALIAS FOR $2;
  num_updated INTEGER;
  cc_year INTEGER;
  cc_month INTEGER;
  cc_year_t TEXT;
  cc_month_t TEXT;
  _dr RECORD;
  _cc RECORD;
  bf TEXT;

BEGIN

  num_updated := 0;
  bf := 'bf';

  select cast(date_part('year', CURRENT_DATE) AS INTEGER) AS check_year, cast(date_part('month', CURRENT_DATE) AS INTEGER) AS check_month INTO _dr;

  FOR _cc IN SELECT ccard_id,
                    decrypt(setbytea(ccard_month_expired), setbytea(pKey), 'bf') AS ccard_month_expired,
                    decrypt(setbytea(ccard_year_expired), setbytea(pKey), 'bf') AS ccard_year_expired
      FROM ccard
      WHERE ( (ccard_cust_id=pCust)
        AND   (ccard_active) ) LOOP

      SELECT formatbytea(_cc.ccard_month_expired) INTO cc_month_t;
      SELECT formatbytea(_cc.ccard_year_expired) INTO cc_year_t;
      SELECT cast(cc_month_t AS INTEGER) INTO cc_month;
      SELECT cast(cc_year_t AS INTEGER) INTO cc_year;

      IF (cc_year < _dr.check_year) THEN
--  We have an expired card
        UPDATE ccard set ccard_active = FALSE where ccard_id = _cc.ccard_id;
        num_updated := num_updated + 1;
      ELSIF (cc_year = _dr.check_year AND cc_month < _dr.check_month) THEN
--  We have an expired card
        UPDATE ccard set ccard_active = FALSE where ccard_id = _cc.ccard_id;
        num_updated := num_updated + 1;
      END IF;

  END LOOP;

  RETURN num_updated;

END;
$_$;


ALTER FUNCTION public.expirecreditcard(integer, bytea) OWNER TO admin;

--
-- TOC entry 1527 (class 1255 OID 146566096)
-- Dependencies: 4536 8
-- Name: explodebom(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION explodebom(integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pParentid ALIAS FOR $2;
  pLevel ALIAS FOR $3;
  _revid INTEGER;

BEGIN

  SELECT getActiveRevId('BOM',pItemid) INTO _revid;

  RETURN explodeBOM(pItemid, _revid, pParentid, pLevel);

END;
$_$;


ALTER FUNCTION public.explodebom(integer, integer, integer) OWNER TO admin;

--
-- TOC entry 1528 (class 1255 OID 146566097)
-- Dependencies: 4536 8
-- Name: explodebom(integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION explodebom(integer, integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pRevisionid ALIAS FOR $2;
  pParentid ALIAS FOR $3;
  pLevel ALIAS FOR $4;
  _bomworkid INTEGER;
  _level INTEGER;
  _p RECORD;
  _r RECORD;
  _temp TEXT;

BEGIN

  _level := (pLevel + 1);

--  Cache some parameters about the parent
  SELECT bomwork_item_id, bomwork_set_id, bomwork_qtyreq,
         bomwork_seqnumber, bomwork_effective, bomwork_expires INTO _p
  FROM bomwork
  WHERE (bomwork_id=pParentid);

--  Step through all of the components of the parent component
  FOR _r IN SELECT bomitem.*,
                   item_id,
                   (itemuomtouomratio(bomitem_item_id, bomitem_uom_id, NULL) * bomitem_qtyfxd) AS qtyfxd,
                   (itemuomtouomratio(bomitem_item_id, bomitem_uom_id, NULL) * bomitem_qtyper) AS qtyper,
                   CASE WHEN (_p.bomwork_effective > bomitem_effective) THEN _p.bomwork_effective
                        ELSE bomitem_effective
                   END AS effective,
                   CASE WHEN (_p.bomwork_expires < bomitem_expires) THEN _p.bomwork_expires
                        ELSE bomitem_expires
                   END AS expires,
                   stdcost(item_id, bomitem_id) AS standardcost, actcost(item_id, bomitem_id) AS actualcost
  FROM bomitem(pItemid, pRevisionid), item
  WHERE ( (bomitem_item_id=item_id)
  AND (bomitem_expires > _p.bomwork_effective) ) LOOP

--  Insert the current component and some bomitem parameters into the bomwork set
    SELECT NEXTVAL('bomwork_bomwork_id_seq') INTO _bomworkid;
    INSERT INTO bomwork
    ( bomwork_id, bomwork_set_id, bomwork_parent_id, bomwork_level,
      bomwork_parent_seqnumber, bomwork_seqnumber,
      bomwork_item_id, bomwork_createwo, bomwork_qtyreq,
      bomwork_qtyfxd, bomwork_qtyper, bomwork_scrap, bomwork_issuemethod,
      bomwork_effective, bomwork_expires,
      bomwork_stdunitcost, bomwork_actunitcost,
      bomwork_notes, bomwork_ref,
      bomwork_bomitem_id, bomwork_ecn )
    VALUES
    ( _bomworkid, _p.bomwork_set_id, pParentid, _level,
      _p.bomwork_seqnumber, _r.bomitem_seqnumber,
      _r.item_id, _r.bomitem_createwo, (_p.bomwork_qtyreq * _r.qtyper + _r.qtyfxd),
      _r.qtyfxd, _r.qtyper, _r.bomitem_scrap, _r.bomitem_issuemethod,
      _r.effective, _r.expires,
      _r.standardcost, _r.actualcost,
      _r.bomitem_notes, _r.bomitem_ref,
      _r.bomitem_id, _r.bomitem_ecn );

--  Recursively repeat for this component's components
    PERFORM explodeBOM(_r.item_id, _bomworkid, _level);
  END LOOP;

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.explodebom(integer, integer, integer, integer) OWNER TO admin;

--
-- TOC entry 1529 (class 1255 OID 146566098)
-- Dependencies: 4536 8
-- Name: explodekit(integer, integer, integer, integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION explodekit(integer, integer, integer, integer, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSoheadid ALIAS FOR $1;
  pLinenumber ALIAS FOR $2;
  pSubnumber ALIAS FOR $3;
  pItemsiteid ALIAS FOR $4;
  pQty ALIAS FOR $5;
BEGIN
  RETURN explodeKit(pSoheadid, pLinenumber, pSubnumber, pItemsiteid, pQty, CURRENT_DATE, NULL);
END;
$_$;


ALTER FUNCTION public.explodekit(integer, integer, integer, integer, numeric) OWNER TO admin;

--
-- TOC entry 1434 (class 1255 OID 146566099)
-- Dependencies: 4536 8
-- Name: explodekit(integer, integer, integer, integer, numeric, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION explodekit(integer, integer, integer, integer, numeric, date, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSoheadid ALIAS FOR $1;
  pLinenumber ALIAS FOR $2;
  pSubnumber ALIAS FOR $3;
  pItemsiteid ALIAS FOR $4;
  pQty ALIAS FOR $5;
  pScheddate ALIAS FOR $6;
  pPromdate ALIAS FOR $7;
BEGIN
  RETURN explodeKit(pSoheadid, pLinenumber, pSubnumber, pItemsiteid, pQty, CURRENT_DATE, NULL, '');
END;
$_$;


ALTER FUNCTION public.explodekit(integer, integer, integer, integer, numeric, date, date) OWNER TO admin;

--
-- TOC entry 1454 (class 1255 OID 146566100)
-- Dependencies: 4536 8
-- Name: explodekit(integer, integer, integer, integer, numeric, date, date, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION explodekit(integer, integer, integer, integer, numeric, date, date, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSoheadid ALIAS FOR $1;
  pLinenumber ALIAS FOR $2;
  pSubnumber ALIAS FOR $3;
  pItemsiteid ALIAS FOR $4;
  pQty ALIAS FOR $5;
  pScheddate ALIAS FOR $6;
  pPromdate ALIAS FOR $7;
  pMemo ALIAS FOR $8;
  _subnumber INTEGER := COALESCE(pSubnumber,0);
  _revid INTEGER;
  _itemid INTEGER;
  _warehousid INTEGER;
  _item RECORD;
  _type TEXT;
  _coitemid INTEGER;
  _count INTEGER;
  _orderid INTEGER := 0;
  _itemsrcid INTEGER;
BEGIN

  SELECT getActiveRevId('BOM',itemsite_item_id), itemsite_warehous_id, itemsite_item_id
    INTO _revid, _warehousid, _itemid
    FROM itemsite
   WHERE(itemsite_id=pItemsiteid);
  IF(NOT FOUND) THEN
    RAISE EXCEPTION 'No Item Site for the specified line was found.';
  END IF;

  FOR _item IN
  SELECT bomitem_id,
         itemsite_id,
         itemsite_warehous_id,
         COALESCE((itemsite_active AND item_active), false) AS active,
         COALESCE((itemsite_sold AND item_sold), false) AS sold,
         item_id,
         item_type,
         item_price_uom_id,
         itemsite_createsopr,itemsite_createwo,itemsite_createsopo, itemsite_dropship,
         bomitem_uom_id,
         itemuomtouomratio(item_id, bomitem_uom_id, item_inv_uom_id) AS invuomratio,
         roundQty(itemuomfractionalbyuom(bomitem_item_id, bomitem_uom_id),(bomitem_qtyfxd + bomitem_qtyper * pQty) * (1 + bomitem_scrap)) AS qty
    FROM bomitem JOIN item ON (item_id=bomitem_item_id)
                  LEFT OUTER JOIN itemsite ON ((itemsite_item_id=item_id) AND (itemsite_warehous_id=_warehousid))
   WHERE((bomitem_parent_item_id=_itemid)
     AND (bomitem_rev_id=_revid)
     AND (CURRENT_DATE BETWEEN bomitem_effective AND (bomitem_expires - 1)))
   ORDER BY bomitem_seqnumber LOOP
    IF (NOT _item.active) THEN
      RAISE EXCEPTION 'One or more of the components for the kit is inactive for the selected item site.';
    ELSIF (NOT _item.sold) THEN
      RAISE EXCEPTION 'One or more of the components for the kit is not sold for the selected item site.';
    ELSIF (_item.item_type='F') THEN
      SELECT explodeKit(pSoheadid, pLinenumber, _subnumber, _item.itemsite_id, _item.qty)
        INTO _subnumber;
    ELSE
      IF (_item.itemsite_createsopr) THEN
        _type := 'R';
      ELSIF (_item.itemsite_createsopo) THEN
        _type := 'P';
      ELSIF (_item.itemsite_createwo) THEN
        _type := 'W';
      ELSE
        _type := NULL;
      END IF;
      _subnumber := _subnumber + 1;
      _coitemid = nextval('coitem_coitem_id_seq');
      raise notice 'coitem id: %',_coitemid;
      INSERT INTO coitem
            (coitem_id, coitem_cohead_id,
             coitem_linenumber, coitem_subnumber,
             coitem_itemsite_id, coitem_status,
             coitem_scheddate, coitem_promdate,
             coitem_qtyord, coitem_qty_uom_id, coitem_qty_invuomratio,
             coitem_qtyshipped, coitem_qtyreturned,
             coitem_unitcost, coitem_custprice,
             coitem_price, coitem_price_uom_id, coitem_price_invuomratio,
             coitem_order_type, coitem_order_id,
             coitem_custpn, coitem_memo,
             coitem_prcost)
      VALUES (_coitemid, pSoheadid,
             pLinenumber, _subnumber,
             _item.itemsite_id, 'O',
             pScheddate, pPromdate,
             _item.qty, _item.bomitem_uom_id, _item.invuomratio,
             0, 0,
             stdCost(_item.item_id), 0,
             0, _item.item_price_uom_id, 1,
             _type, -1,
             '', pMemo,
             0);

      IF (_item.itemsite_createsopr) THEN
        SELECT createPR(cohead_number::INTEGER, 'S', _coitemid) INTO _orderid
        FROM cohead
        WHERE (cohead_id=pSoheadid);
        IF (_orderid > 0) THEN
          UPDATE coitem SET coitem_order_id=_orderid
          WHERE (coitem_id=_coitemid);
        ELSE
          RAISE EXCEPTION 'Could not explode kit. CreatePR failed, result=%', _orderid;
        END IF;
      END IF;

      IF (_item.itemsite_createsopo) THEN
        SELECT itemsrc_id INTO _itemsrcid
        FROM itemsrc
        WHERE ((itemsrc_item_id=_item.item_id)
        AND (itemsrc_default));

        GET DIAGNOSTICS _count = ROW_COUNT;
        IF (_count > 0) THEN
          PERFORM createPurchaseToSale(_coitemid, _itemsrcid, _item.itemsite_dropship);
        ELSE
          RAISE WARNING 'One or more Kit items are flagged as purchase-to-order for this site, but no default item source is defined.';
        END IF;
      END IF;

    END IF;
  END LOOP;

  RETURN _subnumber;
END;
$_$;


ALTER FUNCTION public.explodekit(integer, integer, integer, integer, numeric, date, date, text) OWNER TO admin;

--
-- TOC entry 1530 (class 1255 OID 146566102)
-- Dependencies: 4536 8
-- Name: explodephantomorder(integer, integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION explodephantomorder(integer, integer, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPlanordid ALIAS FOR $1;
  pPhantomid ALIAS FOR $2;
  pQty       ALIAS FOR $3;
  _b RECORD;

BEGIN
  FOR _b IN SELECT planord_number, c.itemsite_id AS componentsiteid,
                   calculatenextworkingdate(c.itemsite_warehous_id, planord_startdate, (c.itemsite_leadtime * -1)) AS startdate,
                   planord_startdate AS duedate,
                   bomitem_createwo, c.itemsite_planning_type AS planningtype,
                   (itemuomtouom(bomitem_item_id, bomitem_uom_id, NULL, (bomitem_qtyfxd + pQty * bomitem_qtyper) * (1 + bomitem_scrap))) AS qtyreq,
                   item_type
              FROM bomitem, planord, itemsite AS p, itemsite AS c, item
             WHERE ((bomitem_parent_item_id=p.itemsite_item_id)
               AND (bomitem_rev_id=getActiveRevId('BOM',bomitem_parent_item_id))
               AND (bomitem_item_id=c.itemsite_item_id)
               AND (p.itemsite_warehous_id=c.itemsite_warehous_id)
               AND (c.itemsite_item_id=item_id)
               AND (woEffectiveDate(planord_startdate) BETWEEN bomitem_effective AND (bomitem_expires - 1))
               AND (p.itemsite_id=pPhantomid)
               AND (planord_id=pPlanordid)) LOOP

    IF (_b.item_type = 'F') THEN
      PERFORM explodePhantomOrder(pPlanordid, _b.componentsiteid, _b.qtyreq);
    ELSE
--  Create the Planned Requirement
      INSERT INTO planreq
      ( planreq_source, planreq_source_id,
        planreq_itemsite_id, planreq_qty )
      VALUES
      ( 'P', pPlanordid,
        _b.componentsiteid, _b.qtyreq );

      IF (_b.bomitem_createwo AND _b.planningtype != 'N') THEN
        PERFORM createPlannedOrder( pPlanordid, _b.planord_number, _b.componentsiteid,
                                    _b.qtyreq, _b.startdate, _b.duedate,
                                    FALSE, FALSE, NULL, NULL);
      END IF;
    END IF;

  END LOOP;

  RETURN pPlanordid;
END;
$_$;


ALTER FUNCTION public.explodephantomorder(integer, integer, numeric) OWNER TO admin;

--
-- TOC entry 1531 (class 1255 OID 146566103)
-- Dependencies: 4536 8
-- Name: explodewo(integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION explodewo(integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoid ALIAS FOR $1;
  pExplodeChildren ALIAS FOR $2;
  resultCode INTEGER;
  newWo RECORD;
  _newwoid INTEGER;
  _p RECORD;
  _r RECORD;
  _bbom BOOLEAN;

BEGIN
-- Find out if Breeder BOMs are enabled
  SELECT metric_value='t' INTO _bbom
         FROM metric
         WHERE (metric_name='BBOM');

--  Make sure that this W/O is Open
  SELECT wo_id INTO resultCode
  FROM wo
  WHERE ((wo_status='O')
   AND (wo_id=pWoid));
  IF (NOT FOUND) THEN
    RETURN -4;
  END IF;

--  Make sure that all Component Item Sites exist and are valid
--  Item Sites must be active and not Job Costed
  SELECT bomitem_id INTO resultCode
  FROM wo, bomitem, itemsite
  WHERE ( (wo_itemsite_id=itemsite_id)
   AND (itemsite_item_id=bomitem_parent_item_id)
   AND (woEffectiveDate(wo_startdate) BETWEEN bomitem_effective AND (bomitem_expires - 1))
   AND (wo_id=pWoid)
   AND (bomitem_rev_id=wo_bom_rev_id)
   AND (bomitem_item_id NOT IN
        ( SELECT component.itemsite_item_id
          FROM itemsite AS component, itemsite AS parent
          WHERE ( (wo_itemsite_id=parent.itemsite_id)
           AND (parent.itemsite_item_id=bomitem_parent_item_id)
           AND (bomitem_item_id=component.itemsite_item_id)
           AND (woEffectiveDate(wo_startdate) BETWEEN bomitem_effective AND (bomitem_expires - 1))
           AND (component.itemsite_active)
           AND (component.itemsite_warehous_id=parent.itemsite_warehous_id) ) ) ) )
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -2;
  END IF;

--  If the Parent Item is a Breeder, make sure that all the
--  Co-Product/By-Product Item Sites exist
  IF (_bbom) THEN

    IF ( ( SELECT (item_type='B')
           FROM wo, itemsite, item
           WHERE ( (wo_itemsite_id=itemsite_id)
            AND (itemsite_item_id=item_id)
            AND (wo_id=pWoid) ) ) ) THEN
      SELECT bbomitem_id INTO resultCode
      FROM wo, xtmfg.bbomitem, itemsite
      WHERE ( (wo_itemsite_id=itemsite_id)
       AND (itemsite_item_id=bbomitem_parent_item_id)
       AND (woEffectiveDate(wo_startdate) BETWEEN bbomitem_effective AND (bbomitem_expires - 1))
       AND (wo_id=pWoid)
       AND (bbomitem_item_id NOT IN
            ( SELECT component.itemsite_item_id
              FROM itemsite AS component, itemsite AS parent
              WHERE ( (wo_itemsite_id=parent.itemsite_id)
               AND (parent.itemsite_item_id=bbomitem_parent_item_id)
               AND (bbomitem_item_id=component.itemsite_item_id)
               AND (woEffectiveDate(wo_startdate) BETWEEN bbomitem_effective AND (bbomitem_expires - 1))
               AND (component.itemsite_active)
               AND (component.itemsite_warehous_id=parent.itemsite_warehous_id) ) ) ) )
      LIMIT 1;
      IF (FOUND) THEN
        RETURN -3;
      END IF;
    END IF;
  END IF;

--  Create the W/O Material Requirements
  INSERT INTO womatl
  ( womatl_wo_id, womatl_bomitem_id, womatl_wooper_id, womatl_schedatwooper,
    womatl_itemsite_id, womatl_duedate,
    womatl_uom_id, womatl_qtyfxd, womatl_qtyper, womatl_scrap,
    womatl_qtyreq,
    womatl_qtyiss, womatl_qtywipscrap,
    womatl_lastissue, womatl_lastreturn, womatl_cost,
    womatl_picklist, womatl_createwo, womatl_issuewo,
    womatl_issuemethod, womatl_notes, womatl_ref,
    womatl_price )
  SELECT wo_id, bomitem_id, bomitem_booitem_seq_id, bomitem_schedatwooper,
         matl_itemsite, duedate,
         bomitem_uom_id, bomitem_qtyfxd, bomitem_qtyper, bomitem_scrap,
         qtyreq, 0, 0,
         startOfTime(), startOfTime(), 0,
         item_picklist, ( (item_type='M') AND (bomitem_createwo) ), issuewo,
         bomitem_issuemethod, bomitem_notes, bomitem_ref,
         CASE WHEN (price=-9999.0) THEN 0.0
              ELSE price
         END
  FROM (SELECT *, cs.itemsite_id AS matl_itemsite,
               CASE WHEN bomitem_schedatwooper THEN COALESCE(calcWooperStartStub(wo_id,bomitem_booitem_seq_id), wo_startdate)
                    ELSE wo_startdate
               END AS duedate,
               roundQty(itemuomfractionalbyuom(bomitem_item_id, bomitem_uom_id), (bomitem_qtyfxd + bomitem_qtyper * wo_qtyord) * (1 + bomitem_scrap)) AS qtyreq,
               CASE WHEN ( (item_type='M') AND (bomitem_issuewo) ) THEN TRUE
                    WHEN (cs.itemsite_costmethod='J') THEN TRUE
                    ELSE FALSE
               END AS issuewo,
               CASE WHEN (cohead_id IS NULL) THEN item_listprice
                    ELSE (SELECT itemprice_price
                          FROM itemIpsPrice(item_id, cohead_cust_id, cohead_shipto_id,
                                      roundQty(itemuomfractionalbyuom(bomitem_item_id, bomitem_uom_id), (bomitem_qtyfxd + bomitem_qtyper * wo_qtyord) * (1 + bomitem_scrap)),
                                      bomitem_uom_id, bomitem_uom_id, cohead_curr_id, CURRENT_DATE, CURRENT_DATE, cohead_warehous_id) LIMIT 1)
               END AS price
        FROM wo JOIN itemsite ps ON (ps.itemsite_id=wo_itemsite_id)
                JOIN bomitem ON (bomitem_parent_item_id=ps.itemsite_item_id AND
                                 bomitem_rev_id=wo_bom_rev_id AND
                                 woEffectiveDate(wo_startdate) BETWEEN bomitem_effective and (bomitem_expires - 1))
                JOIN itemsite cs ON (cs.itemsite_item_id=bomitem_item_id AND
                                     cs.itemsite_warehous_id=ps.itemsite_warehous_id)
                JOIN item ON (item_id=cs.itemsite_item_id)
                LEFT OUTER JOIN coitem ON (wo_ordtype='S' AND
                                           wo_ordid=coitem_id)
                LEFT OUTER JOIN cohead ON (cohead_id=coitem_cohead_id)
        WHERE ( (wo_id=pWoid)
          AND   ((bomitem_char_id IS NULL)
             OR  EXISTS (
                 SELECT charass_id
                 FROM coitem,charass
                 WHERE ((charass_target_type='SI')
                   AND  (charass_target_id=coitem_id)
                   AND  (charass_char_id=bomitem_char_id)
                   AND  (charass_value=bomitem_value)
                   AND  (wo_ordtype='S')
                   AND  (coitem_id=wo_ordid)))) )
        ) AS data;

--  Update any created P/R's the have the project id as the parent WO.
  UPDATE pr SET pr_prj_id=wo_prj_id
    FROM womatl, wo
   WHERE ((wo_id=pWoid)
     AND  (womatl_wo_id=wo_id)
     AND  (pr_order_type='W')
     AND  (pr_order_id=womatl_id));

--  If the parent Item is a Breeder, create the brddist
--  records for the Co-Products and By-Products
  IF (_bbom) THEN

    INSERT INTO xtmfg.brddist
    ( brddist_wo_id, brddist_wo_qty, brddist_itemsite_id,
      brddist_stdqtyper, brddist_qty, brddist_posted )
    SELECT wo_id, 0, cs.itemsite_id,
           bbomitem_qtyper, 0, FALSE
    FROM wo, xtmfg.bbomitem,
         itemsite AS ps, itemsite AS cs, item
    WHERE ( (bbomitem_parent_item_id=ps.itemsite_item_id)
     AND (wo_itemsite_id=ps.itemsite_id)
     AND (ps.itemsite_item_id=item_id)
     AND (item_type='B')
     AND (bbomitem_item_id=cs.itemsite_item_id)
     AND (cs.itemsite_warehous_id=ps.itemsite_warehous_id)
     AND (wo_id=pWoid) );

  END IF;

--  Insert the W/O Operations if routings enabled
  IF ( ( SELECT (metric_value='t')
         FROM metric
         WHERE (metric_name='Routings') ) ) THEN

    INSERT INTO xtmfg.wooper
    ( wooper_wo_id, wooper_booitem_id, wooper_seqnumber,
      wooper_wrkcnt_id, wooper_stdopn_id,
      wooper_descrip1, wooper_descrip2, wooper_toolref,
      wooper_sutime, wooper_sucosttype, wooper_surpt,
      wooper_rntime, wooper_rncosttype, wooper_rnrpt,
      wooper_rnqtyper,
      wooper_produom, wooper_invproduomratio,
      wooper_issuecomp, wooper_rcvinv,
      wooper_suconsumed, wooper_sucomplete,
      wooper_rnconsumed, wooper_rncomplete,
      wooper_qtyrcv, wooper_instruc, wooper_scheduled,
      wooper_wip_location_id, wooper_price )
    SELECT wo_id, booitem_id, booitem_seqnumber,
           booitem_wrkcnt_id, booitem_stdopn_id,
           booitem_descrip1, booitem_descrip2, booitem_toolref,
           CASE WHEN (booitem_surpt) THEN booitem_sutime
                ELSE 0
           END, booitem_sucosttype, booitem_surpt,
           CASE WHEN ((booitem_rnqtyper = 0) OR (booitem_invproduomratio = 0)) THEN 0
                WHEN (NOT booitem_rnrpt) THEN 0
                ELSE ( ( booitem_rntime /
                         booitem_rnqtyper /
                         booitem_invproduomratio ) * wo_qtyord )
           END, booitem_rncosttype, booitem_rnrpt,
           CASE WHEN (booitem_rnqtyper = 0) THEN 0
                WHEN (NOT booitem_rnrpt) THEN 0
                ELSE (booitem_rntime / booitem_rnqtyper)
           END,
           booitem_produom, booitem_invproduomratio,
           booitem_issuecomp, booitem_rcvinv,
           0::NUMERIC, FALSE,
           0::NUMERIC, FALSE,
           0::NUMERIC, booitem_instruc,
           calculatenextworkingdate(itemsite_warehous_id,wo_startdate,booitem_execday-1),
           booitem_wip_location_id,
           (xtmfg.directlaborcostoper(booitem_id) + xtmfg.overheadcostoper(booitem_id) + xtmfg.machineoverheadcostoper(booitem_id))
    FROM xtmfg.booitem, wo, itemsite
    WHERE ((wo_itemsite_id=itemsite_id)
     AND (itemsite_item_id=booitem_item_id)
     AND (booitem_rev_id=wo_boo_rev_id)
     AND (woEffectiveDate(wo_startdate) BETWEEN booitem_effective AND (booitem_expires - 1))
     AND (wo_id=pWoid));

--  Update womatls item to link to wooper items when the respective
--  bomitem record indicates a booitem issue link.
    UPDATE womatl
    SET womatl_wooper_id=wooper_id
    FROM wo,xtmfg.wooper,xtmfg.booitem
    WHERE ((womatl_wooper_id=booitem_seq_id)
     AND (wooper_booitem_id=booitem_id)
     AND (womatl_wo_id=wo_id)
     AND (wooper_wo_id=wo_id)
     AND (wo_boo_rev_id=booitem_rev_id)
     AND (wo_id=pWoid));
    END IF;

-- Handle all of the Phantom material requirements
  WHILE ( ( SELECT COUNT(*)
            FROM womatl, itemsite, item
            WHERE ( (womatl_itemsite_id=itemsite_id)
             AND (itemsite_item_id=item_id)
             AND (womatl_wo_id=pWoid)
             AND (item_type='F') ) ) > 0 ) LOOP

    FOR _p IN SELECT wo_qtyord, wo_startdate, womatl_id, womatl_wooper_id
              FROM wo, womatl, itemsite, item
              WHERE ( (womatl_itemsite_id=itemsite_id)
               AND (itemsite_item_id=item_id)
               AND (item_type='F')
               AND (womatl_wo_id=wo_id)
               AND (wo_id=pWoid) ) LOOP

      INSERT INTO womatl
      ( womatl_wo_id, womatl_itemsite_id, womatl_wooper_id,
        womatl_schedatwooper, womatl_duedate,
        womatl_uom_id, womatl_qtyfxd, womatl_qtyper, womatl_scrap,
        womatl_qtyreq,
        womatl_qtyiss, womatl_qtywipscrap,
        womatl_lastissue, womatl_lastreturn,
        womatl_cost, womatl_picklist,
        womatl_createwo, womatl_issuewo,
        womatl_issuemethod, womatl_notes, womatl_ref )
      SELECT pWoid, cs.itemsite_id, _p.womatl_wooper_id,
             womatl_schedatwooper, womatl_duedate,
             bomitem_uom_id, bomitem_qtyfxd, (bomitem_qtyper * womatl_qtyper), bomitem_scrap,
             roundQty(itemuomfractionalbyuom(bomitem_item_id, bomitem_uom_id),
                     (bomitem_qtyfxd + _p.wo_qtyord * bomitem_qtyper * womatl_qtyper) * (1 + bomitem_scrap)),
             0, 0,
             startOfTime(), startOfTime(),
             0, ci.item_picklist,
             ( (ci.item_type='M') AND (bomitem_createwo) ), ( (ci.item_type='M') AND (bomitem_issuewo) ),
             bomitem_issuemethod, bomitem_notes, bomitem_ref
      FROM womatl JOIN wo ON (wo_id=womatl_wo_id)
                  JOIN itemsite ps ON (ps.itemsite_id=womatl_itemsite_id)
                  JOIN item pi ON (pi.item_id=ps.itemsite_item_id)
                  JOIN bomitem ON ( (bomitem_parent_item_id=pi.item_id) AND
                                    (woEffectiveDate(_p.wo_startdate) BETWEEN bomitem_effective AND (bomitem_expires - 1)) AND
                                    (bomitem_rev_id=getActiveRevId('BOM', pi.item_id)) )
                  JOIN item ci ON (ci.item_id=bomitem.bomitem_item_id)
                  JOIN itemsite cs ON ( (cs.itemsite_item_id=ci.item_id) AND
                                        (cs.itemsite_warehous_id=ps.itemsite_warehous_id) )
      WHERE (womatl_id=_p.womatl_id);

      DELETE FROM womatl
      WHERE (womatl_id=_p.womatl_id);

    END LOOP;
  END LOOP;

--  Create W/Os for manufactured component items
  FOR newWo IN SELECT wo_number, nextWoSubnumber(wo_number) AS nextSubnumber,
                      itemsite_id, itemsite_leadtime, womatl_duedate,
                      womatl_wo_id, womatl_qtyreq, womatl_uom_id, wo_prj_id,
                      item_id, item_inv_uom_id, womatl_id
               FROM womatl, wo, itemsite, item
               WHERE ( (womatl_wo_id=wo_id)
                AND (womatl_itemsite_id=itemsite_id)
                AND (womatl_createwo)
                AND (itemsite_wosupply)
                AND (itemsite_item_id=item_id)
                AND (wo_id=pWoid) )
               ORDER BY womatl_id LOOP

    SELECT createWo( newWo.wo_number, newWo.itemsite_id, 1,
                     itemuomtouom(newWo.item_id,newWo.womatl_uom_id,newWo.item_inv_uom_id,newWo.womatl_qtyreq),
                      newWo.itemsite_leadtime, newWo.womatl_duedate, '',
                      'W', newWo.womatl_wo_id, newWo.wo_prj_id ) INTO _newwoid;

    UPDATE wo SET wo_womatl_id = newWo.womatl_id WHERE wo_id=_newwoid;

  END LOOP;

  UPDATE wo
  SET wo_status='E', wo_adhoc=FALSE
  WHERE (wo_id=pWoid);

  IF (pExplodeChildren) THEN
    SELECT MAX(explodeWo(wo_id, TRUE)) INTO resultCode
    FROM wo
    WHERE ( (wo_ordtype='W')
     AND (wo_ordid=pWoid) );
  END IF;

  RETURN pWoid;
END;
$_$;


ALTER FUNCTION public.explodewo(integer, boolean) OWNER TO admin;

--
-- TOC entry 1532 (class 1255 OID 146566105)
-- Dependencies: 4536 8
-- Name: explodewoeffective(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION explodewoeffective() RETURNS text
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _value TEXT;

BEGIN

  SELECT metric_value INTO _value
  FROM metric
  WHERE (metric_name='ExplodeWOEffective');

  RETURN _value;

END;
$$;


ALTER FUNCTION public.explodewoeffective() OWNER TO admin;

--
-- TOC entry 1533 (class 1255 OID 146566106)
-- Dependencies: 8
-- Name: fetchapmemonumber(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetchapmemonumber() RETURNS integer
    LANGUAGE sql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT fetchNextNumber('APMemoNumber')::INTEGER;
$$;


ALTER FUNCTION public.fetchapmemonumber() OWNER TO admin;

--
-- TOC entry 1534 (class 1255 OID 146566107)
-- Dependencies: 8
-- Name: fetcharmemonumber(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetcharmemonumber() RETURNS text
    LANGUAGE sql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT fetchNextNumber('ARMemoNumber');
$$;


ALTER FUNCTION public.fetcharmemonumber() OWNER TO admin;

--
-- TOC entry 1535 (class 1255 OID 146566108)
-- Dependencies: 8
-- Name: fetchcashrcptnumber(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetchcashrcptnumber() RETURNS text
    LANGUAGE sql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT fetchNextNumber('CashRcptNumber');
$$;


ALTER FUNCTION public.fetchcashrcptnumber() OWNER TO admin;

--
-- TOC entry 1536 (class 1255 OID 146566109)
-- Dependencies: 8
-- Name: fetchcmnumber(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetchcmnumber() RETURNS text
    LANGUAGE sql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT fetchNextNumber('CmNumber');
$$;


ALTER FUNCTION public.fetchcmnumber() OWNER TO admin;

--
-- TOC entry 1537 (class 1255 OID 146566110)
-- Dependencies: 8
-- Name: fetchcrmaccountnumber(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetchcrmaccountnumber() RETURNS integer
    LANGUAGE sql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT fetchNextNumber('CRMAccountNumber')::INTEGER;
$$;


ALTER FUNCTION public.fetchcrmaccountnumber() OWNER TO admin;

--
-- TOC entry 1538 (class 1255 OID 146566111)
-- Dependencies: 8
-- Name: fetchdefaultfob(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetchdefaultfob(pwarehousid integer) RETURNS text
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT warehous_fob
    FROM whsinfo
   WHERE (warehous_id=$1);
$_$;


ALTER FUNCTION public.fetchdefaultfob(pwarehousid integer) OWNER TO admin;

--
-- TOC entry 1539 (class 1255 OID 146566112)
-- Dependencies: 4536 8
-- Name: fetchdefaultshipvia(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetchdefaultshipvia() RETURNS text
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal TEXT;
BEGIN
  SELECT shipvia_code INTO _returnVal
  FROM shipvia
  WHERE shipvia_id=
	(SELECT CAST(metric_value AS integer)
	FROM metric
	WHERE metric_name = 'DefaultShipViaId');
  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.fetchdefaultshipvia() OWNER TO admin;

--
-- TOC entry 1540 (class 1255 OID 146566113)
-- Dependencies: 4536 8
-- Name: fetchglsequence(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetchglsequence() RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _sequence INTEGER;

BEGIN

    SELECT NEXTVAL('gltrans_sequence_seq') INTO _sequence;
    RETURN _sequence;

END;
$$;


ALTER FUNCTION public.fetchglsequence() OWNER TO admin;

--
-- TOC entry 1541 (class 1255 OID 146566114)
-- Dependencies: 8
-- Name: fetchincidentnumber(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetchincidentnumber() RETURNS integer
    LANGUAGE sql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT fetchNextNumber('IncidentNumber')::integer;
$$;


ALTER FUNCTION public.fetchincidentnumber() OWNER TO admin;

--
-- TOC entry 1542 (class 1255 OID 146566115)
-- Dependencies: 8
-- Name: fetchinvcnumber(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetchinvcnumber() RETURNS integer
    LANGUAGE sql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT fetchNextNumber('InvcNumber')::integer;
$$;


ALTER FUNCTION public.fetchinvcnumber() OWNER TO admin;

--
-- TOC entry 1543 (class 1255 OID 146566116)
-- Dependencies: 4536 8
-- Name: fetchitemuomconvtypes(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetchitemuomconvtypes(integer) RETURNS text[]
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemUomConvId ALIAS FOR $1;
  _p RECORD;
  _result text[];
  _cnt INTEGER;

BEGIN

  _cnt := 0;

  FOR _p IN SELECT
    uomtype_name
  FROM itemuomconv, itemuom, uomtype
  WHERE ((itemuomconv_id=pItemUomConvId)
  AND (itemuomconv_id=itemuom_itemuomconv_id)
  AND (itemuom_uomtype_id=uomtype_id))
  LOOP
    _result[_cnt] := _p.uomtype_name;
    _cnt := _cnt + 1;
  END LOOP;

  RETURN _result;
END;
$_$;


ALTER FUNCTION public.fetchitemuomconvtypes(integer) OWNER TO admin;

--
-- TOC entry 1544 (class 1255 OID 146566117)
-- Dependencies: 4536 8
-- Name: fetchjournalnumber(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetchjournalnumber(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pUse ALIAS FOR $1;
  _number INTEGER;

BEGIN

  SELECT nextval('journal_number_seq') INTO _number;

  INSERT INTO jrnluse
  (jrnluse_date, jrnluse_number, jrnluse_use)
  VALUES
  (CURRENT_TIMESTAMP, _number, pUse);

  RETURN _number;

END;
$_$;


ALTER FUNCTION public.fetchjournalnumber(text) OWNER TO admin;

--
-- TOC entry 1545 (class 1255 OID 146566118)
-- Dependencies: 4536 8
-- Name: fetchmetricbool(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetchmetricbool(text) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _pMetricName ALIAS FOR $1;
  _returnVal BOOLEAN;
BEGIN
  SELECT CASE
    WHEN MIN(metric_value) = 't' THEN
     true
    ELSE
     false
    END INTO _returnVal
    FROM metric
   WHERE metric_name = _pMetricName;
  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.fetchmetricbool(text) OWNER TO admin;

--
-- TOC entry 1546 (class 1255 OID 146566119)
-- Dependencies: 4536 8
-- Name: fetchmetrictext(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetchmetrictext(text) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _pMetricName ALIAS FOR $1;
  _returnVal TEXT;
BEGIN
  SELECT metric_value::TEXT INTO _returnVal
    FROM metric
   WHERE metric_name = _pMetricName;
  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.fetchmetrictext(text) OWNER TO admin;

--
-- TOC entry 1547 (class 1255 OID 146566120)
-- Dependencies: 4536 8
-- Name: fetchmetricvalue(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetchmetricvalue(text) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _pMetricName ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  SELECT CASE WHEN (isNumeric(metric_value)) THEN metric_value::INTEGER
              ELSE NULL
         END INTO _returnVal
    FROM metric
   WHERE metric_name = _pMetricName;
  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.fetchmetricvalue(text) OWNER TO admin;

--
-- TOC entry 1548 (class 1255 OID 146566121)
-- Dependencies: 4536 8
-- Name: fetchnextchecknumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetchnextchecknumber(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pBankaccntid ALIAS FOR $1;
  _nextChkNumber INTEGER;

BEGIN

  SELECT bankaccnt_nextchknum INTO _nextChkNumber
  FROM bankaccnt
  WHERE (bankaccnt_id=pBankaccntid);

  UPDATE bankaccnt
  SET bankaccnt_nextchknum = (bankaccnt_nextchknum + 1)
  WHERE (bankaccnt_id=pBankaccntid);

  RETURN _nextChkNumber;

END;
$_$;


ALTER FUNCTION public.fetchnextchecknumber(integer) OWNER TO admin;

--
-- TOC entry 1549 (class 1255 OID 146566122)
-- Dependencies: 4536 8
-- Name: fetchnextnumber(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetchnextnumber(text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  psequence	ALIAS FOR $1;
  _number	TEXT;
  _numcol	TEXT;
  _select	TEXT;
  _table	TEXT;
  _test		TEXT;
  _nextnum	INTEGER;
  _seqiss       seqiss;
  __seqiss      seqiss[];
  _not_issued       BOOLEAN;

BEGIN
  SELECT CAST(orderseq_number AS text), orderseq_number, orderseq_table, orderseq_numcol, COALESCE(orderseq_seqiss, ARRAY[]::seqiss[])
    INTO _number, _nextnum, _table, _numcol, __seqiss
  FROM orderseq
  WHERE (orderseq_name=psequence) FOR UPDATE;

  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Invalid orderseq_name %', psequence;
  END IF;

  LOOP

    _seqiss := (_nextnum, now());

    SELECT count(*) = 0 INTO _not_issued
    FROM (SELECT UNNEST(__seqiss) AS issued) data
    WHERE (issued).seqiss_number = _nextnum;

    _nextnum := _nextnum + 1;

    -- Test if the number has been issued, but not committed
    IF (_not_issued) THEN

      -- Test if the number has been committed
      _select := 'SELECT ' || quote_ident(_numcol) ||
	         ' FROM '  || quote_ident(_table) ||
	         ' WHERE (' || quote_ident(_numcol) || '=' ||
                 quote_literal(_number) || ');';

      EXECUTE _select INTO _test;

      IF (_test IS NULL OR NOT FOUND) THEN
        EXIT;
      END IF;

    END IF;

    -- Number in use, try again
    _number = _nextnum::text;

  END LOOP;

  UPDATE orderseq SET
    orderseq_number = _nextnum
  WHERE (orderseq_name=psequence);

  IF (fetchMetricBool('EnableGaplessNumbering')) THEN
    UPDATE orderseq SET
      orderseq_seqiss = orderseq_seqiss || _seqiss
    WHERE (orderseq_name=psequence);
  END IF;

  RETURN _number;

END;
$_$;


ALTER FUNCTION public.fetchnextnumber(text) OWNER TO admin;

--
-- TOC entry 1550 (class 1255 OID 146566123)
-- Dependencies: 8
-- Name: fetchponumber(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetchponumber() RETURNS text
    LANGUAGE sql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT fetchNextNumber('PoNumber');
$$;


ALTER FUNCTION public.fetchponumber() OWNER TO admin;

--
-- TOC entry 1551 (class 1255 OID 146566124)
-- Dependencies: 4536 8
-- Name: fetchprefwarehousid(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetchprefwarehousid() RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _result INTEGER;
BEGIN
    SELECT CAST(usrpref_value AS INTEGER) INTO _result
    FROM usrpref
    WHERE ((usrpref_username=getEffectiveXtUser())
    AND (usrpref_name='PreferredWarehouse'));

    RETURN _result;
END;
$$;


ALTER FUNCTION public.fetchprefwarehousid() OWNER TO admin;

--
-- TOC entry 1552 (class 1255 OID 146566125)
-- Dependencies: 8
-- Name: fetchprnumber(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetchprnumber() RETURNS integer
    LANGUAGE sql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT fetchNextNumber('PrNumber')::INTEGER;
$$;


ALTER FUNCTION public.fetchprnumber() OWNER TO admin;

--
-- TOC entry 1553 (class 1255 OID 146566126)
-- Dependencies: 8
-- Name: fetchqunumber(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetchqunumber() RETURNS text
    LANGUAGE sql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT fetchNextNumber('QuNumber');
$$;


ALTER FUNCTION public.fetchqunumber() OWNER TO admin;

--
-- TOC entry 1554 (class 1255 OID 146566127)
-- Dependencies: 4536 8
-- Name: fetchshipmentnumber(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetchshipmentnumber() RETURNS text
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _number		TEXT;
  _test			INTEGER;

BEGIN
  LOOP

    SELECT CAST(nextval('shipment_number_seq') AS TEXT) INTO _number;

    SELECT shiphead_id INTO _test
      FROM shiphead
     WHERE (shiphead_number=_number);
    IF (NOT FOUND) THEN
      EXIT;
    END IF;

  END LOOP;

  RETURN _number;

END;
$$;


ALTER FUNCTION public.fetchshipmentnumber() OWNER TO admin;

--
-- TOC entry 1555 (class 1255 OID 146566128)
-- Dependencies: 8
-- Name: fetchsonumber(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetchsonumber() RETURNS text
    LANGUAGE sql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT fetchNextNumber('SoNumber');
$$;


ALTER FUNCTION public.fetchsonumber() OWNER TO admin;

--
-- TOC entry 1556 (class 1255 OID 146566129)
-- Dependencies: 8
-- Name: fetchtonumber(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetchtonumber() RETURNS text
    LANGUAGE sql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT fetchNextNumber('ToNumber');
$$;


ALTER FUNCTION public.fetchtonumber() OWNER TO admin;

--
-- TOC entry 1557 (class 1255 OID 146566130)
-- Dependencies: 4536 8
-- Name: fetchusrprefbool(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetchusrprefbool(text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _pPrefName ALIAS FOR $1;
  _returnVal BOOLEAN;
BEGIN
  SELECT CASE
    WHEN MIN(usrpref_value) = 't' THEN
     true
    ELSE
     false
    END INTO _returnVal
  FROM usrpref
  WHERE ( (usrpref_username=getEffectiveXtUser())
    AND   (usrpref_name=_pPrefName) );
  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.fetchusrprefbool(text) OWNER TO admin;

--
-- TOC entry 1558 (class 1255 OID 146566131)
-- Dependencies: 8
-- Name: fetchvonumber(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetchvonumber() RETURNS integer
    LANGUAGE sql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT fetchNextNumber('VcNumber')::INTEGER;
$$;


ALTER FUNCTION public.fetchvonumber() OWNER TO admin;

--
-- TOC entry 1559 (class 1255 OID 146566132)
-- Dependencies: 8
-- Name: fetchwonumber(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fetchwonumber() RETURNS integer
    LANGUAGE sql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT fetchNextNumber('WoNumber')::INTEGER;
$$;


ALTER FUNCTION public.fetchwonumber() OWNER TO admin;

--
-- TOC entry 1560 (class 1255 OID 146566133)
-- Dependencies: 4536 8
-- Name: financialreport(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION financialreport(integer, integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pFlheadid ALIAS FOR $1;
  pPeriodid ALIAS FOR $2;
  pPrjid    ALIAS FOR $3;
  _result bool;

BEGIN

  SELECT financialreport(pFlheadid,pPeriodid,'M', pPrjid) INTO _result;

  RETURN _result;
END;
$_$;


ALTER FUNCTION public.financialreport(integer, integer, integer) OWNER TO admin;

--
-- TOC entry 1561 (class 1255 OID 146566134)
-- Dependencies: 4536 8
-- Name: financialreport(integer, integer, character, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION financialreport(integer, integer, character, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pFlheadid ALIAS FOR $1;
  pPeriodid ALIAS FOR $2;
  pInterval ALIAS FOR $3;
  pPrjid    ALIAS FOR $4;

  _r RECORD;
  _t RECORD;
  _s RECORD;

BEGIN

-- Validate Interval
   IF pInterval <> 'M' AND pInterval <> 'Q' AND pInterval <> 'Y' THEN
     RAISE EXCEPTION 'Invalid Interval --> %', pInterval;
   END IF;

-- Get rid of any old reporting done by this user for the specified criteria
  DELETE FROM flrpt
   WHERE ((flrpt_flhead_id=pFlheadid)
     AND  (flrpt_period_id=pPeriodId)
     AND  (flrpt_interval=pInterval)
     AND  (flrpt_username=getEffectiveXtUser()));

-- Find out if we need to show a Grand Total and which if any of the values
-- we want to show in that grand total.
  SELECT flhead_showtotal,
         CASE WHEN(flhead_showstart) THEN 0.00
              ELSE NULL
         END AS beginning,
         CASE WHEN(flhead_showend) THEN 0.00
              ELSE NULL
         END AS ending,
         CASE WHEN(flhead_showdelta) THEN 0.00
              ELSE NULL
         END AS debits,
         CASE WHEN(flhead_showdelta) THEN 0.00
              ELSE NULL
         END AS credits,
         CASE WHEN(flhead_showbudget) THEN 0.00
              ELSE NULL
         END AS budget,
         CASE WHEN(flhead_showdiff) THEN 0.00
              ELSE NULL
         END AS diff,
         CASE WHEN(flhead_showcustom) THEN 0.00
              ELSE NULL
         END AS custom,
         CASE WHEN(flhead_usealttotal) THEN flhead_alttotal
              ELSE NULL
         END AS altname INTO _r
    FROM flhead
   WHERE (flhead_id=pFlheadid);
  IF (NOT FOUND) THEN
    return FALSE;
  END IF;

-- If showing a Grand Total then create a record as a Group which acts
-- as a parent to the whole report. This allows the code to update as
-- it would for normal group total values.
  IF (_r.flhead_showtotal) THEN
    INSERT INTO flrpt
           (flrpt_flhead_id, flrpt_period_id, flrpt_username,
            flrpt_order, flrpt_level, flrpt_type, flrpt_type_id,
            flrpt_beginning, flrpt_ending,
            flrpt_debits, flrpt_credits, flrpt_budget, flrpt_diff,
            flrpt_custom, flrpt_altname, flrpt_interval )
    VALUES (pFlheadid, pPeriodid, getEffectiveXtUser(),
            0, -1, 'G', -1,
            _r.beginning, _r.ending,
            _r.debits, _r.credits, _r.budget, _r.diff,
            _r.custom, _r.altname, pInterval );
  END IF;

  PERFORM insertFlGroup(pFlheadid, pPeriodid, -1, 0, FALSE, pInterval, pPrjid);

-- go through the list of records that need percentages calculated and perform
-- those calculations.
  FOR _t IN SELECT flrpt_order, CASE WHEN(flgrp_prcnt_flgrp_id = -1) THEN flgrp_flgrp_id ELSE flgrp_prcnt_flgrp_id END AS flgrp_id
              FROM flrpt, flgrp
             WHERE ((flrpt_flhead_id=pFlheadid)
               AND  (flrpt_period_id=pPeriodid)
               AND  (flrpt_interval=pInterval)
               AND  (flrpt_username=getEffectiveXtUser())
               AND  (flrpt_type='G')
               AND  (flrpt_type_id=flgrp_id))
             UNION
            SELECT flrpt_order, CASE WHEN(flitem_prcnt_flgrp_id = -1) THEN flitem_flgrp_id ELSE flitem_prcnt_flgrp_id END AS flgrp_id
              FROM flrpt, flitem
             WHERE ((flrpt_flhead_id=pFlheadid)
               AND  (flrpt_period_id=pPeriodid)
               AND  (flrpt_interval=pInterval)
               AND  (flrpt_username=getEffectiveXtUser())
               AND  (flrpt_type='I')
               AND  (flrpt_type_id=flitem_id))
             UNION
            SELECT flrpt_order, CASE WHEN(flspec_prcnt_flgrp_id = -1) THEN flspec_flgrp_id ELSE flspec_prcnt_flgrp_id END AS flgrp_id
              FROM flrpt, flspec
             WHERE ((flrpt_flhead_id=pFlheadid)
               AND  (flrpt_period_id=pPeriodid)
               AND  (flrpt_interval=pInterval)
               AND  (flrpt_username=getEffectiveXtUser())
               AND  (flrpt_type='S')
               AND  (flrpt_type_id=flspec_id)) LOOP

    IF( (_t.flgrp_id=-1) OR (NOT (SELECT flgrp_summarize FROM flgrp WHERE flgrp_id=_t.flgrp_id)) ) THEN
      SELECT COALESCE(SUM(flrpt_beginning),0) AS beginningTotal,
             COALESCE(SUM(flrpt_ending),0) AS endingTotal,
             COALESCE(SUM(flrpt_debits),0) AS debitsTotal,
             COALESCE(SUM(flrpt_credits),0) AS creditsTotal,
             COALESCE(SUM(flrpt_budget),0) AS budgetTotal,
             COALESCE(SUM(flrpt_diff), 0) AS diffTotal,
             COALESCE(SUM(flrpt_custom), 0) AS customTotal INTO _s
        FROM flrpt
       WHERE ((flrpt_flhead_id=pFlheadid)
         AND  (flrpt_period_id=pPeriodid)
         AND  (flrpt_interval=pInterval)
         AND  (flrpt_username=getEffectiveXtUser())
         AND  (flrpt_type != 'T')
         AND  (flrpt_parent_id=_t.flgrp_id));
    ELSE
      SELECT COALESCE(SUM(flrpt_beginning),0) AS beginningTotal,
             COALESCE(SUM(flrpt_ending),0) AS endingTotal,
             COALESCE(SUM(flrpt_debits),0) AS debitsTotal,
             COALESCE(SUM(flrpt_credits),0) AS creditsTotal,
             COALESCE(SUM(flrpt_budget),0) AS budgetTotal,
             COALESCE(SUM(flrpt_diff), 0) AS diffTotal,
             COALESCE(SUM(flrpt_custom), 0) AS customTotal INTO _s
        FROM flrpt
       WHERE ((flrpt_flhead_id=pFlheadid)
         AND  (flrpt_period_id=pPeriodid)
         AND  (flrpt_interval=pInterval)
         AND  (flrpt_username=getEffectiveXtUser())
         AND  (flrpt_type = 'G')
         AND  (flrpt_type_id=_t.flgrp_id));
    END IF;

    UPDATE flrpt SET flrpt_beginningprcnt = flrpt_beginningprcnt + flrpt_beginning / CASE WHEN (_s.beginningTotal=0) THEN 1 ELSE _s.beginningTotal END,
                     flrpt_endingprcnt = flrpt_endingprcnt + flrpt_ending / CASE WHEN (_s.endingTotal=0) THEN 1 ELSE _s.endingTotal END,
                     flrpt_debitsprcnt = flrpt_debitsprcnt + flrpt_debits / CASE WHEN (_s.debitsTotal=0) THEN 1 ELSE _s.debitsTotal END,
                     flrpt_creditsprcnt = flrpt_creditsprcnt + flrpt_credits / CASE WHEN (_s.creditsTotal=0) THEN 1 ELSE _s.creditsTotal END,
                     flrpt_budgetprcnt = flrpt_budgetprcnt + flrpt_budget / CASE WHEN (_s.budgetTotal=0) THEN 1 ELSE _s.budgetTotal END,
                     flrpt_diffprcnt = flrpt_diffprcnt + flrpt_diff / CASE WHEN (_s.diffTotal=0) THEN 1 ELSE _s.diffTotal END,
                     flrpt_customprcnt = flrpt_customprcnt + flrpt_custom / CASE WHEN (_s.customTotal=0) THEN 1 ELSE _s.customTotal END
     WHERE ((flrpt_flhead_id=pFlheadid)
       AND  (flrpt_period_id=pPeriodid)
       AND  (flrpt_interval=pInterval)
       AND  (flrpt_username=getEffectiveXtUser())
       AND  (flrpt_order=_t.flrpt_order));
  END LOOP;


-- Update any subtotal records to reflect the percentage values of the parents
-- since those are calculated after the subtotal records were created.
  FOR _t IN SELECT a.flrpt_order AS flrpt_order,
                   b.flrpt_beginningprcnt AS flrpt_beginningprcnt,
                   b.flrpt_endingprcnt AS flrpt_endingprcnt,
                   b.flrpt_debitsprcnt AS flrpt_debitsprcnt,
                   b.flrpt_creditsprcnt AS flrpt_creditsprcnt,
                   b.flrpt_budgetprcnt AS flrpt_budgetprcnt,
                   b.flrpt_diffprcnt AS flrpt_diffprcnt,
                   b.flrpt_customprcnt AS flrpt_customprcnt
              FROM flrpt AS a, flrpt AS b
             WHERE ((a.flrpt_flhead_id=pFlheadid)
               AND  (a.flrpt_period_id=pPeriodid)
               AND  (a.flrpt_interval=pInterval)
               AND  (a.flrpt_username=getEffectiveXtUser())
               AND  (a.flrpt_type='T')
               AND  (b.flrpt_flhead_id=a.flrpt_flhead_id)
               AND  (b.flrpt_period_id=a.flrpt_period_id)
               AND  (b.flrpt_interval=pInterval)
               AND  (b.flrpt_username=a.flrpt_username)
               AND  (b.flrpt_type='G')
               AND  (b.flrpt_type_id=a.flrpt_parent_id)) LOOP
    UPDATE flrpt SET flrpt_beginningprcnt=flrpt_beginningprcnt + _t.flrpt_beginningprcnt,
                     flrpt_endingprcnt=flrpt_endingprcnt + _t.flrpt_endingprcnt,
                     flrpt_debitsprcnt=flrpt_debitsprcnt + _t.flrpt_debitsprcnt,
                     flrpt_creditsprcnt=flrpt_creditsprcnt + _t.flrpt_creditsprcnt,
                     flrpt_budgetprcnt=flrpt_budgetprcnt + _t.flrpt_budgetprcnt,
                     flrpt_diffprcnt=flrpt_diffprcnt + _t.flrpt_diffprcnt,
                     flrpt_customprcnt=flrpt_customprcnt + _t.flrpt_customprcnt
               WHERE ((flrpt_flhead_id=pFlheadid)
                 AND  (flrpt_period_id=pPeriodid)
                 AND  (flrpt_interval=pInterval)
                 AND  (flrpt_username=getEffectiveXtUser())
                 AND  (flrpt_order=_t.flrpt_order));
  END LOOP;

-- If showing a Grand total then move the record we created early to the
-- end of the report and marked as a Total record.
  IF (_r.flhead_showtotal) THEN
    UPDATE flrpt
       SET flrpt_order = COALESCE((SELECT MAX(flrpt_order)
                                     FROM flrpt
                                    WHERE ((flrpt_flhead_id=pFlheadid)
                                      AND  (flrpt_period_id=pPeriodid)
                                      AND  (flrpt_interval=pInterval)
                                      AND  (flrpt_username=getEffectiveXtUser()))
                                  ), 0) + 1,
           flrpt_level = 0,
           flrpt_type = 'T'
     WHERE ((flrpt_flhead_id=pFlheadid)
       AND  (flrpt_period_id=pPeriodid)
       AND  (flrpt_interval=pInterval)
       AND  (flrpt_username=getEffectiveXtUser())
       AND  (flrpt_order=0)
       AND  (flrpt_level = -1)
       AND  (flrpt_type = 'G')
       AND  (flrpt_type_id=-1));
  END IF;

  return TRUE;
END;
$_$;


ALTER FUNCTION public.financialreport(integer, integer, character, integer) OWNER TO admin;

--
-- TOC entry 1463 (class 1255 OID 146566136)
-- Dependencies: 2678 4536 8
-- Name: financialreport(integer, integer[], character, boolean, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION financialreport(integer, integer[], character, boolean, integer) RETURNS SETOF fltrenditem
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pFlheadId ALIAS FOR $1;
  pPeriodIds ALIAS FOR $2;
  pInterval ALIAS FOR $3;
  pShowNumbers ALIAS FOR $4;
  pPrjid ALIAS FOR $5;
  _row fltrenditem%ROWTYPE;
  _type CHAR;
  _p RECORD;
  _count INTEGER;
  _n NUMERIC;
  _fld NUMERIC[];
  _grndttl NUMERIC;
  _i INTEGER;
  _first BOOLEAN;
  _prevlevel INTEGER;
  _subgrp INTEGER;

BEGIN
        _first := true;
        _subgrp := 0;

        IF ARRAY_UPPER(pPeriodIds,1) <= 12 THEN
                _count := ARRAY_UPPER(pPeriodIds,1);
        ELSE
                _count := 12;
        END IF;

        --Get Type
        SELECT flhead_type FROM flhead INTO _type WHERE flhead_id=pFlheadId;

        --Build Financial Data
        FOR _i IN 1.._count
        LOOP
                PERFORM financialreport(pFlheadId,pPeriodIds[_i],pInterval,pPrjid);
        END LOOP;

        --Get Row Data
        FOR _p IN
        SELECT flrpt_flhead_id,
                flrpt_username,
                flrpt_order,
                flrpt_level,
                flrpt_type,
                flrpt_type_id,
                flrpt_parent_id,
                flrpt_accnt_id,
                formatindent(flgrp.flgrp_name,flrpt.flrpt_level) AS flrpt_name,
                CASE
                        WHEN (flgrp_summarize AND (_type IN ('I','C'))) THEN
                                (COALESCE(flrpt_diff,0))
                        WHEN (flgrp_summarize AND (_type = 'B')) THEN
                                (COALESCE(flrpt_ending,0))
                        ELSE NULL
                END AS f_fld1,
                flgrp_summarize AS display
        FROM flrpt,flgrp
        WHERE ((flrpt_flhead_id=pFlheadId)
        AND (flgrp_id=flrpt_type_id)
        AND (flrpt_type='G')
        AND (flrpt_period_id=pPeriodIds[1])
        AND (flrpt_interval=pInterval)
        AND (flrpt_username=getEffectiveXtUser()))
        UNION
        SELECT flrpt_flhead_id,
                flrpt_username,
                flrpt_order,
                flrpt_level,
                flrpt_type,
                flrpt_type_id,
                flrpt_parent_id,
                flrpt_accnt_id,
                formatindent(accnt_descrip,flrpt.flrpt_level) AS flrpt_name,
                CASE
                        WHEN (_type IN ('I','C')) THEN
                                (COALESCE(flrpt_diff,0))
                        WHEN (_type = 'B') THEN
                                (COALESCE(flrpt_ending,0))
                        ELSE NULL
                END AS f_fld1,
                true AS display
        FROM flrpt,flitem,accnt
        WHERE ((flrpt_flhead_id=pFlheadId)
        AND (flrpt_accnt_id=accnt_id)
        AND (flitem_id=flrpt_type_id)
        AND (flrpt_type='I')
        AND (flrpt_period_id=pPeriodIds[1])
        AND (flrpt_interval=pInterval)
        AND (flrpt_username=getEffectiveXtUser()))
        UNION
        SELECT flrpt_flhead_id,
                flrpt_username,
                flrpt_order,
                flrpt_level,
                flrpt_type,
                flrpt_type_id,
                flrpt_parent_id,
                flrpt_accnt_id,
                CASE
                        WHEN (flrpt.flrpt_type='T' AND flrpt.flrpt_level=0) THEN
                                COALESCE(flrpt.flrpt_altname, 'Total')
                        WHEN (flrpt.flrpt_type='T') THEN
                                formatindent(COALESCE(flrpt.flrpt_altname, 'Subtotal') ,flrpt.flrpt_level)

                        ELSE
                                formatindent(('Type ' || flrpt.flrpt_type || ' ' || text(flrpt.flrpt_type_id)), flrpt.flrpt_level)
                END AS flstmtitem_name,
                CASE
                        WHEN (_type IN ('I','C')) THEN
                                (COALESCE(flrpt_diff,0))
                        WHEN (_type = 'B') THEN
                                (COALESCE(flrpt_ending,0))
                        ELSE NULL
                END AS f_fld1,
                true AS display
        FROM flrpt
        WHERE ((flrpt_flhead_id=pFlheadId)
        AND (flrpt_type NOT IN ('I','S','G'))
        AND (flrpt_period_id=pPeriodIds[1])
        AND (flrpt_interval=pInterval)
        AND (flrpt_username=getEffectiveXtUser()))
        ORDER BY flrpt_order
        LOOP

                IF _type IN ('I','C') THEN
                        _grndttl := _p.f_fld1;
                END IF;

                --Loop through and calculate period column values
                IF (_p.display) THEN
                        FOR _i IN 2.._count
                        LOOP
                                SELECT
                                CASE
                                        WHEN (_type IN ('I','C')) THEN
                                                COALESCE(flrpt_diff,0)
                                        WHEN (_type = 'B') THEN
                                                COALESCE(flrpt_ending,0)
                                        ELSE NULL
                                END INTO _n
                                FROM flrpt
                                WHERE ((flrpt_flhead_id=pFlheadId)
                                AND (flrpt_period_id=pPeriodIds[_i])
                                AND (flrpt_interval=pInterval)
                                AND (flrpt_username=getEffectiveXtUser())
                                AND (flrpt_order=_p.flrpt_order));
                                _fld[_i-1] := _n;
                                IF _type IN ('I','C') THEN
                                        _grndttl := _grndttl+_n;
                                END IF;
                        END LOOP;
                END IF;

                --Send it all back to the caller
                IF _prevlevel > _p.flrpt_level THEN
                        _subgrp := _subgrp+1;
                END IF;
                _prevlevel:=_p.flrpt_level;
                _row.fltrenditem_subgrp := _subgrp;

                IF NOT _first THEN
                        RETURN NEXT _row;
                END IF;

                _first := FALSE;

                _row.fltrenditem_flhead_id := _p.flrpt_flhead_id;
                _row.fltrenditem_username := _p.flrpt_username;
                _row.fltrenditem_order := _p.flrpt_order;
                _row.fltrenditem_level := _p.flrpt_level;
                _row.fltrenditem_type := _p.flrpt_type;
                _row.fltrenditem_type_id := _p.flrpt_type_id;
                _row.fltrenditem_parent_id := _p.flrpt_parent_id;
                _row.fltrenditem_accnt_id := _p.flrpt_accnt_id;
                _row.fltrenditem_name := _p.flrpt_name;
                IF (_p.display) THEN
                        _row.fltrenditem_fld1 := (_p.f_fld1);
                        _row.fltrenditem_fld2 := (_fld[1]);
                        _row.fltrenditem_fld3 := (_fld[2]);
                        _row.fltrenditem_fld4 := (_fld[3]);
                        _row.fltrenditem_fld5 := (_fld[4]);
                        _row.fltrenditem_fld6 := (_fld[5]);
                        _row.fltrenditem_fld7 := (_fld[6]);
                        _row.fltrenditem_fld8 := (_fld[7]);
                        _row.fltrenditem_fld9 := (_fld[8]);
                        _row.fltrenditem_fld10 := (_fld[9]);
                        _row.fltrenditem_fld11 := (_fld[10]);
                        _row.fltrenditem_fld12 := (_fld[11]);
                        _row.fltrenditem_grndttl := (_grndttl);
                ELSE
                        _row.fltrenditem_fld1 := NULL;
                        _row.fltrenditem_fld2 := NULL;
                        _row.fltrenditem_fld3 := NULL;
                        _row.fltrenditem_fld4 := NULL;
                        _row.fltrenditem_fld5 := NULL;
                        _row.fltrenditem_fld6 := NULL;
                        _row.fltrenditem_fld7 := NULL;
                        _row.fltrenditem_fld8 := NULL;
                        _row.fltrenditem_fld9 := NULL;
                        _row.fltrenditem_fld10 := NULL;
                        _row.fltrenditem_fld11 := NULL;
                        _row.fltrenditem_fld12 := NULL;
                        _row.fltrenditem_grndttl := NULL;
                END IF;

        END LOOP;

        _row.fltrenditem_subgrp := _subgrp + 1;
        RETURN NEXT _row;

END;
$_$;


ALTER FUNCTION public.financialreport(integer, integer[], character, boolean, integer) OWNER TO admin;

--
-- TOC entry 1478 (class 1255 OID 146566138)
-- Dependencies: 2672 4536 8
-- Name: financialreport(integer, integer, boolean, boolean, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION financialreport(integer, integer, boolean, boolean, integer) RETURNS SETOF flstmtitem
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pFlcolid ALIAS FOR $1;
  pPeriodid ALIAS FOR $2;
  pShowNumbers ALIAS FOR $3;
  pIndentName ALIAS FOR $4;
  pPrjid ALIAS FOR $5;
  _row flstmtitem%ROWTYPE;
  _p RECORD;
  _x RECORD;
  _priorMoPeriodId INTEGER;
  _priorQtPeriodId INTEGER;
  _priorYrPeriodId INTEGER;
  _first BOOLEAN;
  _prevlevel INTEGER;
  _subgrp INTEGER;
  _qtrInterval TEXT;
  _yrInterval TEXT;

BEGIN

  _priorMoPeriodId := -1;
  _priorQtPeriodId := -1;
  _priorYrPeriodId := -1;
  _first := TRUE;
  _prevlevel :=0;
  _subgrp := 0;

--Get Layout Data
  SELECT flhead_id,flhead_type,
        flcol_month,flcol_quarter,flcol_year,flcol_priortype,
        flcol_priormonth,flcol_priorquarter,flcol_prioryear,
        flcol_priordiff,flcol_priordiffprcnt,flcol_priorprcnt,
        flcol_budget,flcol_budgetdiff,flcol_budgetdiffprcnt,
        flcol_budgetprcnt INTO _p
  FROM flhead,flcol
  WHERE ((flcol_id=pFlcolid)
  AND (flhead_id=flcol_flhead_id));

  IF (_p.flhead_type='B') THEN
    _qtrInterval := 'M';
    _yrInterval := 'M';
  ELSE
    _qtrInterval := 'Q';
    _yrInterval := 'Y';
  END IF;

--Delete old data from all periods
  DELETE FROM flrpt
  WHERE ((flrpt_username=getEffectiveXtUser())
  AND (flrpt_flhead_id=_p.flhead_id));

--Populate report data...
--...for Month
        IF (_p.flcol_month) THEN

        PERFORM financialreport(_p.flhead_id,pPeriodid,'M',pPrjid);

                IF ((_p.flcol_priortype = 'P') AND (_p.flcol_priormonth)) THEN

                        SELECT COALESCE(pp.period_id,-1) INTO _priorMoPeriodId
                        FROM period cp, period pp
                        WHERE ((cp.period_id=pPeriodId)
                        AND (cp.period_start > pp.period_start))
                        ORDER BY pp.period_start DESC LIMIT 1;

                        IF (_priorMoPeriodId IS NOT NULL) THEN
                                PERFORM financialreport(_p.flhead_id,_priorMoPeriodId,'M',pPrjid);
                        END IF;

                        ELSE IF ((_p.flcol_priortype='Y')AND (_p.flcol_priormonth)) THEN

                                SELECT COALESCE(pp.period_id,-1) INTO _priorMoPeriodId
                                FROM period cp, period pp
                                WHERE ((cp.period_id=pPeriodId)
                                AND (cp.period_id != pp.period_id)
                                AND (cp.period_start > pp.period_start)
                                AND (cp.period_number = pp.period_number))
                                ORDER BY pp.period_start DESC LIMIT 1;

                                IF (_priorMoPeriodId IS NOT NULL) THEN
                                        PERFORM financialreport(_p.flhead_id,_priorMoPeriodId,'M',pPrjid);
                                END IF;

                        END IF;

                END IF;
        END IF;

--...for Quarter
        IF (_p.flcol_quarter) THEN

        PERFORM financialreport(_p.flhead_id,pPeriodid,'Q',pPrjid);

        END IF;

        IF ((_p.flcol_priortype='P') AND (_p.flcol_priorquarter)) THEN

                SELECT COALESCE(pp.period_id,-1) INTO _priorQtPeriodId
                FROM period cp, period pp
                WHERE ((cp.period_id=pPeriodId)
                AND (cp.period_start > pp.period_start)
                AND (pp.period_quarter=
                        CASE WHEN cp.period_quarter > 1 THEN
                                cp.period_quarter - 1
                        ELSE 4 END)
                AND (pp.period_start >= cp.period_start - interval '1 year'))
                ORDER BY pp.period_start DESC LIMIT 1;

                IF (_priorQtPeriodId IS NOT NULL) THEN
                        PERFORM financialreport(_p.flhead_id,_priorQtPeriodId,'Q',pPrjid);
                END IF;

                ELSE IF ((_p.flcol_priortype='Y')AND (_p.flcol_priorquarter)) THEN

                        SELECT pp.period_id INTO _priorQtPeriodId
                        FROM period cp, period pp, yearperiod cy, yearperiod py
                        WHERE ((cp.period_id=pPeriodId)
                        AND (cp.period_yearperiod_id=cy.yearperiod_id)
                        AND (pp.period_yearperiod_id=py.yearperiod_id)
                        AND (cp.period_quarter=pp.period_quarter)
                        AND (cy.yearperiod_start > py.yearperiod_start))
                        ORDER BY py.yearperiod_start DESC, pp.period_start DESC LIMIT 1;

                        IF (_priorQtPeriodId IS NOT NULL) THEN
                                PERFORM financialreport(_p.flhead_id,_priorQtPeriodId,'Q',pPrjid);
                        END IF;

                END IF;
        END IF;

--...for Year
        IF (_p.flcol_year) THEN

                PERFORM financialreport(_p.flhead_id,pPeriodid,'Y',pPrjid);

        END IF;

        IF (_p.flcol_prioryear='D') THEN

                SELECT COALESCE(pp.period_id,-1) INTO _priorYrPeriodId
                FROM period cp, period pp
                WHERE ((cp.period_id = pPeriodId)
                AND (cp.period_number = pp.period_number)
                AND (cp.period_start > pp.period_start))
                ORDER BY pp.period_start DESC LIMIT 1;

                IF (_priorYrPeriodId IS NOT NULL) THEN
                        PERFORM financialreport(_p.flhead_id,_priorYrPeriodId,'Y',pPrjid);
                END IF;

                ELSE IF (_p.flcol_prioryear='F') THEN

                        SELECT pp.period_id INTO _priorYrPeriodId
                        FROM period cp, period pp, yearperiod cy, yearperiod py
                        WHERE ((cp.period_id=pPeriodId)
                        AND (cp.period_yearperiod_id=cy.yearperiod_id)
                        AND (pp.period_yearperiod_id=py.yearperiod_id)
                        AND (cy.yearperiod_start > py.yearperiod_start))
                        ORDER BY pp.period_start DESC LIMIT 1;

                        IF (_priorYrPeriodId IS NOT NULL) THEN
                                PERFORM financialreport(_p.flhead_id,_priorYrPeriodId,'Y',pPrjid);
                        END IF;

                END IF;
        END IF;

--Return the data
  FOR _x IN
        SELECT
        flrpt.flrpt_flhead_id AS flstmtitem_flhead_id,
        flrpt.flrpt_period_id AS flstmtitem_period_id,
        flrpt.flrpt_username AS flstmtitem_username,
        flrpt.flrpt_order AS flstmtitem_order,
        flrpt.flrpt_level AS flstmtitem_level,
        flrpt.flrpt_type AS flstmtitem_type,
        flrpt.flrpt_type_id AS flstmtitem_type_id,
        flrpt.flrpt_parent_id AS flstmtitem_parent_id,
        NULL AS flstmtitem_accnt_id,
        CASE
                WHEN (pIndentName) THEN
                        formatindent(flgrp.flgrp_name,flrpt.flrpt_level)
                ELSE flgrp.flgrp_name
        END AS flstmtitem_name,
        CASE
                WHEN (flgrp_summarize AND (flhead_type IN ('I','C'))) THEN
                        (COALESCE(flrptmo.flrpt_diff,0))
                WHEN (flgrp_summarize AND (flhead_type = 'B')) THEN
                        (COALESCE(flrptmo.flrpt_ending,0))
                ELSE NULL
        END AS flstmtitem_month,
        CASE
                WHEN (flgrp_summarize) THEN
                        (COALESCE(flrptmo.flrpt_debits,0))
                ELSE NULL
        END AS flstmtitem_monthdb,
        CASE
                WHEN (flgrp_summarize) THEN
                        (COALESCE(flrptmo.flrpt_credits,0))
                ELSE NULL
        END AS flstmtitem_monthcr,
        CASE
                WHEN (flgrp_summarize AND flgrp_showdiffprcnt) THEN
                        (COALESCE(flrptmo.flrpt_diffprcnt,0))
                WHEN (flgrp_summarize AND flgrp_showendprcnt) THEN
                        (COALESCE(flrptmo.flrpt_endingprcnt,0))
                ELSE NULL
        END AS flstmtitem_monthprcnt,
        CASE
                WHEN (flgrp_summarize) THEN
                        (flrptmo.flrpt_budget)
                ELSE NULL
        END AS flstmtitem_monthbudget,
        CASE
                WHEN (flgrp_summarize) THEN
                        (flrptmo.flrpt_budgetprcnt)
                ELSE NULL
        END AS flstmtitem_monthbudgetprcnt,
        CASE
                WHEN (flgrp_summarize AND flhead_type IN ('I','C')) THEN
                        (COALESCE((flrptmo.flrpt_diff-flrptmo.flrpt_budget),0))
                WHEN (flgrp_summarize AND flhead_type = 'B') THEN
                        (COALESCE((flrptmo.flrpt_ending-flrptmo.flrpt_budget),0))
                ELSE NULL
        END AS flstmtitem_monthbudgetdiff,
        CASE
                WHEN (flgrp_summarize AND (flhead_type IN ('I','C')) AND (flrptmo.flrpt_budget > 0)) THEN
                        (COALESCE(((flrptmo.flrpt_diff-flrptmo.flrpt_budget)/flrptmo.flrpt_budget),0))
                WHEN (flgrp_summarize AND (flhead_type='B') AND (flrptmo.flrpt_budget > 0)) THEN
                        (COALESCE(((flrptmo.flrpt_ending-flrptmo.flrpt_budget)/flrptmo.flrpt_budget),0))
                WHEN (flgrp_summarize AND (flrptmo.flrpt_budget = 0)) THEN
                        NULL
                ELSE NULL
        END AS flstmtitem_monthbudgetdiffprcnt,
        CASE
                WHEN (flgrp_summarize AND flhead_type IN ('I','C')) THEN
                        (COALESCE(flrptqt.flrpt_diff,0))
                WHEN (flgrp_summarize AND flhead_type = 'B') THEN
                        (COALESCE(flrptqt.flrpt_ending,0))
                ELSE NULL
        END AS flstmtitem_qtr,
        CASE
                WHEN (flgrp_summarize) THEN
                        (COALESCE(flrptqt.flrpt_debits,0))
                ELSE NULL
        END AS flstmtitem_qtrdb,
        CASE
                WHEN (flgrp_summarize) THEN
                        (COALESCE(flrptqt.flrpt_credits,0))
                ELSE NULL
        END AS flstmtitem_qtrcr,
        CASE
                WHEN (flgrp_summarize AND flgrp_showdiffprcnt) THEN
                        (flrptqt.flrpt_diffprcnt)
                WHEN (flgrp_summarize AND flgrp_showendprcnt) THEN
                        (flrptqt.flrpt_endingprcnt)
                ELSE NULL
        END AS flstmtitem_qtrprcnt,
        CASE
                WHEN (flgrp_summarize) THEN
                        (COALESCE(flrptqt.flrpt_budget,0))
                ELSE NULL
        END AS flstmtitem_qtrbudget,
        CASE
                WHEN (flgrp_summarize) THEN
                        (flrptqt.flrpt_budgetprcnt)
                ELSE NULL
        END AS flstmtitem_qtrbudgetprcnt,
        CASE
                WHEN (flgrp_summarize AND flhead_type IN ('I','C')) THEN
                        (COALESCE((flrptqt.flrpt_diff-flrptqt.flrpt_budget),0))
                WHEN (flgrp_summarize AND flhead_type = 'B') THEN
                        (COALESCE((flrptqt.flrpt_ending-flrptqt.flrpt_budget),0))
                ELSE NULL
        END AS flstmtitem_qtrbudgetdiff,
        CASE
                WHEN (flgrp_summarize AND (flhead_type IN ('I','C')) AND (flrptqt.flrpt_budget > 0)) THEN
                        (COALESCE(((flrptqt.flrpt_diff-flrptqt.flrpt_budget)/flrptqt.flrpt_budget),0))
                WHEN (flgrp_summarize AND (flhead_type='B') AND (flrptqt.flrpt_budget > 0)) THEN
                        (COALESCE(((flrptqt.flrpt_ending-flrptqt.flrpt_budget)/flrptqt.flrpt_budget),0))
                ELSE NULL
        END AS flstmtitem_qtrbudgetdiffprcnt,
        CASE
                WHEN (flgrp_summarize AND flhead_type IN ('I','C')) THEN
                        (COALESCE(flrptyr.flrpt_diff,0))
                WHEN (flgrp_summarize AND flhead_type = 'B') THEN
                        (COALESCE(flrptyr.flrpt_ending,0))
                ELSE NULL
        END AS flstmtitem_year,
        CASE
                WHEN (flgrp_summarize) THEN
                        (COALESCE(flrptyr.flrpt_debits,0))
                ELSE NULL
        END AS flstmtitem_yeardb,
        CASE
                WHEN (flgrp_summarize) THEN
                        (COALESCE(flrptyr.flrpt_credits,0))
                ELSE NULL
        END AS flstmtitem_yearcr,
        CASE
                WHEN (flgrp_summarize AND flgrp_showdiffprcnt) THEN
                        (COALESCE(flrptyr.flrpt_diffprcnt,0))
                WHEN (flgrp_summarize AND flgrp_showendprcnt) THEN
                        (COALESCE(flrptyr.flrpt_endingprcnt,0))
                ELSE NULL
        END AS flstmtitem_yearprcnt,
        CASE
                WHEN (flgrp_summarize) THEN
                        (flrptyr.flrpt_budget)
                ELSE NULL
        END AS  flstmtitem_yearbudget,
        CASE
                WHEN (flgrp_summarize) THEN
                        (flrptyr.flrpt_budgetprcnt)
                ELSE NULL
        END AS flstmtitem_yearbudgetprcnt,
        CASE
                WHEN (flgrp_summarize AND flhead_type IN ('I','C')) THEN
                        (COALESCE((flrptyr.flrpt_diff-flrptyr.flrpt_budget),0))
                WHEN (flgrp_summarize AND flhead_type = 'B') THEN
                        (COALESCE((flrptyr.flrpt_ending-flrptyr.flrpt_budget),0))
                ELSE NULL
        END AS flstmtitem_yearbudgetdiff,
        CASE
                WHEN (flgrp_summarize AND (flhead_type IN ('I','C')) AND (flrptyr.flrpt_budget > 0)) THEN
                        (COALESCE(((flrptyr.flrpt_diff-flrptyr.flrpt_budget)/flrptyr.flrpt_budget),0))
                WHEN (flgrp_summarize AND (flhead_type = 'B') AND (flrptyr.flrpt_budget > 0)) THEN
                        (COALESCE(((flrptyr.flrpt_ending-flrptyr.flrpt_budget)/flrptyr.flrpt_budget),0))
                WHEN (flgrp_summarize AND (flrptyr.flrpt_budget = 0)) THEN
                        NULL
                ELSE NULL
        END AS flstmtitem_yearbudgetdiffprcnt,
        CASE
                WHEN (flgrp_summarize AND flhead_type IN ('I','C')) THEN
                        (COALESCE(flrptprmo.flrpt_diff,0))
                WHEN (flgrp_summarize AND flhead_type = 'B') THEN
                        (COALESCE(flrptprmo.flrpt_ending,0))
                ELSE NULL
        END AS flstmtitem_prmonth,
        CASE
                WHEN (flgrp_summarize AND flgrp_showdiffprcnt) THEN
                        (flrptprmo.flrpt_diffprcnt)
                WHEN (flgrp_summarize AND flgrp_showendprcnt) THEN
                        (flrptprmo.flrpt_endingprcnt)
                ELSE NULL
        END AS flstmtitem_prmonthprcnt,
        CASE
                WHEN (flgrp_summarize AND flhead_type IN ('I','C')) THEN
                        (COALESCE(flrptmo.flrpt_diff-flrptprmo.flrpt_diff,0))
                WHEN (flgrp_summarize AND flhead_type = 'B') THEN
                        (COALESCE(flrptmo.flrpt_ending-flrptprmo.flrpt_ending,0))
                ELSE NULL
        END AS flstmtitem_prmonthdiff,
        CASE
                WHEN (flgrp_summarize AND (flhead_type IN ('I','C')) AND (flrptprmo.flrpt_diff > 0)) THEN
                        (COALESCE((flrptmo.flrpt_diff-flrptprmo.flrpt_diff)/flrptprmo.flrpt_diff,0))
                WHEN (flgrp_summarize AND (flhead_type = 'B') AND (flrptprmo.flrpt_ending > 0)) THEN
                        (COALESCE((flrptmo.flrpt_ending-flrptprmo.flrpt_ending)/flrptprmo.flrpt_ending,0))
                WHEN (flgrp_summarize AND (flrptprmo.flrpt_ending = 0)) THEN
                        NULL
                ELSE NULL
        END AS flstmtitem_prmonthdiffprcnt,
        CASE
                WHEN (flgrp_summarize AND flhead_type IN ('I','C')) THEN
                        (COALESCE(flrptprqt.flrpt_diff,0))
                WHEN (flgrp_summarize AND flhead_type = 'B') THEN
                        (COALESCE(flrptprqt.flrpt_ending,0))
                ELSE NULL
        END AS flstmtitem_prqtr,
        CASE
                WHEN (flgrp_summarize AND flgrp_showdiffprcnt) THEN
                        (flrptprqt.flrpt_diffprcnt)
                WHEN (flgrp_summarize AND flgrp_showendprcnt) THEN
                        (flrptprqt.flrpt_endingprcnt)
                ELSE NULL
        END AS flstmtitem_prqtrprcnt,
        CASE
                WHEN (flgrp_summarize AND flhead_type IN ('I','C')) THEN
                        (COALESCE(flrptqt.flrpt_diff-flrptprqt.flrpt_diff,0))
                WHEN (flgrp_summarize AND flhead_type = 'B') THEN
                        (COALESCE(flrptqt.flrpt_ending-flrptprqt.flrpt_ending,0))
                ELSE NULL
        END AS flstmtitem_prqtrdiff,
        CASE
                WHEN (flgrp_summarize AND (flhead_type IN ('I','C')) AND (flrptprqt.flrpt_diff > 0)) THEN
                        (COALESCE((flrptqt.flrpt_diff-flrptprqt.flrpt_diff)/flrptprqt.flrpt_diff,0))
                WHEN (flgrp_summarize AND (flhead_type = 'B') AND (flrptprqt.flrpt_ending > 0)) THEN
                        (COALESCE((flrptqt.flrpt_ending-flrptprqt.flrpt_ending)/flrptprqt.flrpt_ending,0))
                WHEN (flgrp_summarize AND (flrptprqt.flrpt_ending = 0)) THEN
                        NULL
                ELSE NULL
        END AS flstmtitem_prqtrdiffprcnt,
        CASE
                WHEN (flgrp_summarize AND flhead_type IN ('I','C')) THEN
                        (COALESCE(flrptpryr.flrpt_diff,0))
                WHEN (flgrp_summarize AND flhead_type = 'B') THEN
                        (COALESCE(flrptpryr.flrpt_ending,0))
                ELSE NULL
        END AS flstmtitem_pryear,
        CASE
                WHEN (flgrp_summarize AND flgrp_showdiffprcnt) THEN
                        (flrptpryr.flrpt_diffprcnt)
                WHEN (flgrp_summarize AND flgrp_showendprcnt) THEN
                        (flrptpryr.flrpt_endingprcnt)
                ELSE NULL
        END AS flstmtitem_pryearprcnt,
        CASE
                WHEN (flgrp_summarize AND flhead_type IN ('I','C')) THEN
                        (COALESCE(flrptyr.flrpt_diff-flrptpryr.flrpt_diff,0))
                WHEN (flgrp_summarize AND flhead_type = 'B') THEN
                        (COALESCE(flrptyr.flrpt_ending-flrptpryr.flrpt_ending,0))
                ELSE NULL
        END AS flstmtitem_pryeardiff,
        CASE
                WHEN (flgrp_summarize AND (flhead_type IN ('I','C')) AND (flrptpryr.flrpt_diff > 0)) THEN
                        (COALESCE((flrptyr.flrpt_diff-flrptpryr.flrpt_diff)/flrptpryr.flrpt_diff,0))
                WHEN (flgrp_summarize AND (flhead_type = 'B' ) AND (flrptpryr.flrpt_ending > 0)) THEN
                        (COALESCE((flrptyr.flrpt_ending-flrptpryr.flrpt_ending)/flrptpryr.flrpt_ending,0))
                WHEN (flgrp_summarize AND (flrptpryr.flrpt_ending = 0)) THEN
                        NULL
                ELSE NULL
        END AS flstmtitem_pryeardiffprcnt
        FROM flgrp,flhead,
                (SELECT DISTINCT
                        flrpt_flhead_id,
                        flrpt_period_id,
                        flrpt_username,
                        flrpt_order,
                        flrpt_level,
                        flrpt_type,
                        flrpt_type_id,
                        flrpt_parent_id
                FROM flrpt
                WHERE ((flrpt_type='G')
                AND (flrpt_flhead_id=_p.flhead_id)
                AND (flrpt_period_id=pPeriodId)
                AND (flrpt_username=getEffectiveXtUser()))) AS flrpt
                        LEFT OUTER JOIN flrpt flrptmo
                                ON ((flrptmo.flrpt_type=flrpt.flrpt_type)
                                AND (flrptmo.flrpt_type_id=flrpt.flrpt_type_id)
                                AND (flrptmo.flrpt_flhead_id=flrpt.flrpt_flhead_id)
                                AND (flrptmo.flrpt_period_id=flrpt.flrpt_period_id)
                                AND (flrptmo.flrpt_interval='M')
                                AND (flrptmo.flrpt_username=flrpt.flrpt_username)
                                AND (flrptmo.flrpt_order=flrpt.flrpt_order))
                        LEFT OUTER JOIN flrpt flrptqt
                                ON ((flrptqt.flrpt_type=flrpt.flrpt_type)
                                AND (flrptqt.flrpt_type_id=flrpt.flrpt_type_id)
                                AND (flrptqt.flrpt_flhead_id=flrpt.flrpt_flhead_id)
                                AND (flrptqt.flrpt_period_id=flrpt.flrpt_period_id)
                                AND (flrptqt.flrpt_interval=_qtrInterval)
                                AND (flrptqt.flrpt_username=flrpt.flrpt_username)
                                AND (flrptqt.flrpt_order=flrpt.flrpt_order))
                        LEFT OUTER JOIN flrpt flrptyr
                                ON ((flrptyr.flrpt_type=flrpt.flrpt_type)
                                AND (flrptyr.flrpt_type_id=flrpt.flrpt_type_id)
                                AND (flrptyr.flrpt_flhead_id=flrpt.flrpt_flhead_id)
                                AND (flrptyr.flrpt_period_id=flrpt.flrpt_period_id)
                                AND (flrptyr.flrpt_interval=_yrInterval)
                                AND (flrptyr.flrpt_username=flrpt.flrpt_username)
                                AND (flrptyr.flrpt_order=flrpt.flrpt_order))
                        LEFT OUTER JOIN flrpt flrptprmo
                                ON ((flrptprmo.flrpt_type=flrpt.flrpt_type)
                                AND (flrptprmo.flrpt_type_id=flrpt.flrpt_type_id)
                                AND (flrptprmo.flrpt_flhead_id=flrpt.flrpt_flhead_id)
                                AND (flrptprmo.flrpt_period_id=_priorMoPeriodId)
                                AND (flrptprmo.flrpt_interval='M')
                                AND (flrptprmo.flrpt_username=flrpt.flrpt_username)
                                AND (flrptprmo.flrpt_order=flrpt.flrpt_order))
                        LEFT OUTER JOIN flrpt flrptprqt
                                ON ((flrptprqt.flrpt_type=flrpt.flrpt_type)
                                AND (flrptprqt.flrpt_type_id=flrpt.flrpt_type_id)
                                AND (flrptprqt.flrpt_flhead_id=flrpt.flrpt_flhead_id)
                                AND (flrptprqt.flrpt_period_id=_priorQtPeriodId)
                                AND (flrptprqt.flrpt_interval='Q')
                                AND (flrptprqt.flrpt_username=flrpt.flrpt_username)
                                AND (flrptprqt.flrpt_order=flrpt.flrpt_order))
                        LEFT OUTER JOIN flrpt flrptpryr
                                ON ((flrptpryr.flrpt_type=flrpt.flrpt_type)
                                AND (flrptpryr.flrpt_type_id=flrpt.flrpt_type_id)
                                AND (flrptpryr.flrpt_flhead_id=flrpt.flrpt_flhead_id)
                                AND (flrptpryr.flrpt_period_id=_priorYrPeriodId)
                                AND (flrptpryr.flrpt_interval='Y')
                                AND (flrptpryr.flrpt_username=flrpt.flrpt_username)
                                AND (flrptpryr.flrpt_order=flrpt.flrpt_order))
        WHERE ((flgrp_id = flrpt.flrpt_type_id)
        AND (flhead_id = flgrp_flhead_id))
        UNION
        SELECT
        flrpt.flrpt_flhead_id AS flstmtitem_flhead_id,
        flrpt.flrpt_period_id AS flstmtitem_period_id,
        flrpt.flrpt_username AS flstmtitem_username,
        flrpt.flrpt_order AS flstmtitem_order,
        flrpt.flrpt_level AS flstmtitem_level,
        flrpt.flrpt_type AS flstmtitem_type,
        flrpt.flrpt_type_id AS flstmtitem_type_id,
        flrpt.flrpt_parent_id AS flstmtitem_parent_id,
        flrpt.flrpt_accnt_id AS flstmtitem_accnt_id,
        CASE
                WHEN (pIndentName) THEN
                        formatindent(flrpt.flrpt_name,flrpt.flrpt_level)
                ELSE flrpt.flrpt_name
        END AS flstmtitem_name,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (COALESCE(flrptmo.flrpt_diff,0))
                ELSE (COALESCE(flrptmo.flrpt_ending,0))
        END AS flstmtitem_month,
        (COALESCE(flrptmo.flrpt_debits,0)) AS flstmtitem_monthdb,
        (COALESCE(flrptmo.flrpt_credits,0)) AS flstmtitem_monthcr,
        CASE
                WHEN (flitem_showdiffprcnt) THEN
                        (flrptmo.flrpt_diffprcnt)
                WHEN (flitem_showendprcnt) THEN
                        (flrptmo.flrpt_endingprcnt)
                ELSE NULL
        END AS flstmtitem_monthprcnt,
        (COALESCE(flrptmo.flrpt_budget,0)) AS flstmtitem_monthbudget,
        (flrptmo.flrpt_budgetprcnt) AS flstmtitem_monthbudgetprcnt,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (COALESCE((flrptmo.flrpt_diff-flrptmo.flrpt_budget),0))
                ELSE (COALESCE((flrptmo.flrpt_ending-flrptmo.flrpt_budget),0))
        END AS flstmtitem_monthbudgetdiff,
        CASE
                WHEN ((flhead_type IN ('I','C')) AND (flrptmo.flrpt_budget > 0)) THEN
                        (COALESCE(((flrptmo.flrpt_diff-flrptmo.flrpt_budget)/flrptmo.flrpt_budget),0))
                WHEN ((flhead_type='B') AND (flrptmo.flrpt_budget > 0)) THEN
                        (COALESCE(((flrptmo.flrpt_ending-flrptmo.flrpt_budget)/flrptmo.flrpt_budget),0))
                ELSE NULL
        END AS flstmtitem_monthbudgetdiffprcnt,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (COALESCE(flrptqt.flrpt_diff,0))
                ELSE (COALESCE(flrptqt.flrpt_ending,0))
        END AS flstmtitem_qtr,
        (COALESCE(flrptqt.flrpt_debits,0)) AS flstmtitem_qtrdb,
        (COALESCE(flrptqt.flrpt_credits,0)) AS flstmtitem_qtrcr,
        CASE
                WHEN (flitem_showdiffprcnt) THEN
                        (COALESCE(flrptqt.flrpt_diffprcnt,0))
                WHEN (flitem_showendprcnt) THEN
                        (COALESCE(flrptqt.flrpt_endingprcnt,0))
                ELSE NULL
        END AS flstmtitem_qtrprcnt,
        (COALESCE(flrptqt.flrpt_budget,0)) AS flstmtitem_qtrbudget,
        (flrptqt.flrpt_budgetprcnt) AS flstmtitem_qtrbudgetprcnt,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (COALESCE((flrptqt.flrpt_diff-flrptqt.flrpt_budget),0))
                ELSE (COALESCE((flrptqt.flrpt_ending-flrptqt.flrpt_budget),0))
        END AS flstmtitem_qtrbudgetdiff,
        CASE
                WHEN ((flhead_type IN ('I','C')) AND (flrptqt.flrpt_budget > 0)) THEN
                        (COALESCE(((flrptqt.flrpt_diff-flrptqt.flrpt_budget)/flrptqt.flrpt_budget),0))
                WHEN ((flhead_type='B') AND (flrptqt.flrpt_budget > 0)) THEN
                        (COALESCE(((flrptqt.flrpt_ending-flrptqt.flrpt_budget)/flrptqt.flrpt_budget),0))
                ELSE NULL
        END AS flstmtitem_qtrbudgetdiffprcnt,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (COALESCE(flrptyr.flrpt_diff,0))
                ELSE (COALESCE(flrptyr.flrpt_ending,0))
        END AS flstmtitem_year,
        (COALESCE(flrptyr.flrpt_debits,0)) AS flstmtitem_yeardb,
        (COALESCE(flrptyr.flrpt_credits,0)) AS flstmtitem_yearcr,
        CASE
                WHEN (flitem_showdiffprcnt) THEN
                        (flrptyr.flrpt_diffprcnt)
                WHEN (flitem_showendprcnt) THEN
                        (flrptyr.flrpt_endingprcnt)
                ELSE NULL
        END AS flstmtitem_yearprcnt,
        (COALESCE(flrptyr.flrpt_budget,0)) AS  flstmtitem_yearbudget,
        (flrptyr.flrpt_budgetprcnt) AS flstmtitem_yearbudgetprcnt,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (COALESCE((flrptyr.flrpt_diff-flrptyr.flrpt_budget),0))
                ELSE (COALESCE((flrptyr.flrpt_ending-flrptyr.flrpt_budget),0))
        END AS flstmtitem_yearbudgetdiff,
        CASE
                WHEN ((flhead_type IN ('I','C')) AND (flrptyr.flrpt_budget > 0)) THEN
                        (COALESCE(((flrptyr.flrpt_diff-flrptyr.flrpt_budget)/flrptyr.flrpt_budget),0))
                WHEN ((flhead_type = 'B') AND (flrptyr.flrpt_budget > 0)) THEN
                        (COALESCE(((flrptyr.flrpt_ending-flrptyr.flrpt_budget)/flrptyr.flrpt_budget),0))
                ELSE NULL
        END AS flstmtitem_yearbudgetdiffprcnt,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (COALESCE(flrptprmo.flrpt_diff,0))
                ELSE (COALESCE(flrptprmo.flrpt_ending,0))
        END AS flstmtitem_prmonth,
        CASE
                WHEN (flitem_showdiffprcnt) THEN
                        (flrptprmo.flrpt_diffprcnt)
                WHEN (flitem_showendprcnt) THEN
                        (flrptprmo.flrpt_endingprcnt)
                ELSE NULL
        END AS flstmtitem_prmonthprcnt,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (COALESCE(flrptmo.flrpt_diff-flrptprmo.flrpt_diff,0))
                ELSE (COALESCE(flrptmo.flrpt_ending-flrptprmo.flrpt_ending,0))
        END AS flstmtitem_prmonthdiff,
        CASE
                WHEN ((flhead_type IN ('I','C')) AND (flrptprmo.flrpt_diff > 0)) THEN
                        (COALESCE((flrptmo.flrpt_diff-flrptprmo.flrpt_diff)/flrptprmo.flrpt_diff,0))
                WHEN ((flhead_type = 'B') AND (flrptprmo.flrpt_ending > 0)) THEN
                        (COALESCE((flrptmo.flrpt_ending-flrptprmo.flrpt_ending)/flrptprmo.flrpt_ending,0))
                ELSE NULL
        END AS flstmtitem_prmonthdiffprcnt,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (COALESCE(flrptprqt.flrpt_diff,0))
                ELSE (COALESCE(flrptprqt.flrpt_ending,0))
        END AS flstmtitem_prqtr,
        CASE
                WHEN (flitem_showdiffprcnt) THEN
                        (flrptprqt.flrpt_diffprcnt)
                WHEN (flitem_showendprcnt) THEN
                        (flrptprqt.flrpt_endingprcnt)
                ELSE NULL
        END AS flstmtitem_prqtrprcnt,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (COALESCE(flrptqt.flrpt_diff-flrptprqt.flrpt_diff,0))
                ELSE (COALESCE(flrptqt.flrpt_ending-flrptprqt.flrpt_ending,0))
        END AS flstmtitem_prqtrdiff,
        CASE
                WHEN ((flhead_type IN ('I','C')) AND (flrptprqt.flrpt_diff > 0)) THEN
                        (COALESCE((flrptqt.flrpt_diff-flrptprqt.flrpt_diff)/flrptprqt.flrpt_diff,0))
                WHEN ((flhead_type = 'B') AND (flrptprqt.flrpt_ending > 0)) THEN
                        (COALESCE((flrptqt.flrpt_ending-flrptprqt.flrpt_ending)/flrptprqt.flrpt_ending,0))
                ELSE NULL
        END AS flstmtitem_prqtrdiffprcnt,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (COALESCE(flrptpryr.flrpt_diff,0))
                ELSE (COALESCE(flrptpryr.flrpt_ending,0))
        END AS flstmtitem_pryear,
        CASE
                WHEN (flitem_showdiffprcnt) THEN
                        (flrptpryr.flrpt_diffprcnt)
                WHEN (flitem_showendprcnt) THEN
                        (flrptpryr.flrpt_endingprcnt)
                ELSE NULL
        END AS flstmtitem_pryearprcnt,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (COALESCE((flrptyr.flrpt_diff-flrptpryr.flrpt_diff),0))
                ELSE (COALESCE((flrptyr.flrpt_ending-flrptpryr.flrpt_ending),0))
        END AS flstmtitem_pryeardiff,
        CASE
                WHEN ((flhead_type IN ('I','C')) AND (flrptpryr.flrpt_diff > 0)) THEN
                        (COALESCE((flrptyr.flrpt_diff-flrptpryr.flrpt_diff)/flrptpryr.flrpt_diff,0))
                WHEN ((flhead_type = 'B' ) AND (flrptpryr.flrpt_ending > 0)) THEN
                        (COALESCE((flrptyr.flrpt_ending-flrptpryr.flrpt_ending)/flrptpryr.flrpt_ending,0))
                ELSE NULL
        END AS flstmtitem_pryeardiffprcnt
        FROM flitem,flhead,
                (SELECT DISTINCT
                        flrpt_flhead_id,
                        flrpt_period_id,
                        flrpt_username,
                        flrpt_order,
                        flrpt_level,
                        flrpt_type,
                        flrpt_type_id,
                        flrpt_parent_id,
                        accnt_id AS flrpt_accnt_id,
                        CASE WHEN (pShowNumbers) THEN
                                (formatGLAccount(accnt_id) || '-' || accnt_descrip)
                        ELSE accnt_descrip END AS flrpt_name
                FROM flrpt,accnt
                WHERE ((flrpt_type='I')
                AND (flrpt_flhead_id=_p.flhead_id)
                AND (flrpt_period_id=pPeriodid)
                AND (flrpt_username=getEffectiveXtUser())
                AND (accnt_id=flrpt_accnt_id))) AS flrpt
                        LEFT OUTER JOIN flrpt flrptmo
                                ON ((flrptmo.flrpt_type=flrpt.flrpt_type)
                                AND (flrptmo.flrpt_type_id=flrpt.flrpt_type_id)
                                AND (flrptmo.flrpt_flhead_id=flrpt.flrpt_flhead_id)
                                AND (flrptmo.flrpt_period_id=flrpt.flrpt_period_id)
                                AND (flrptmo.flrpt_interval='M')
                                AND (flrptmo.flrpt_username=flrpt.flrpt_username)
                                AND (flrptmo.flrpt_order=flrpt.flrpt_order))
                        LEFT OUTER JOIN flrpt flrptqt
                                ON ((flrptqt.flrpt_type=flrpt.flrpt_type)
                                AND (flrptqt.flrpt_type_id=flrpt.flrpt_type_id)
                                AND (flrptqt.flrpt_flhead_id=flrpt.flrpt_flhead_id)
                                AND (flrptqt.flrpt_period_id=flrpt.flrpt_period_id)
                                AND (flrptqt.flrpt_interval=_qtrInterval)
                                AND (flrptqt.flrpt_username=flrpt.flrpt_username)
                                AND (flrptqt.flrpt_order=flrpt.flrpt_order))
                        LEFT OUTER JOIN flrpt flrptyr
                                ON ((flrptyr.flrpt_type=flrpt.flrpt_type)
                                AND (flrptyr.flrpt_type_id=flrpt.flrpt_type_id)
                                AND (flrptyr.flrpt_flhead_id=flrpt.flrpt_flhead_id)
                                AND (flrptyr.flrpt_period_id=flrpt.flrpt_period_id)
                                AND (flrptyr.flrpt_interval=_yrInterval)
                                AND (flrptyr.flrpt_username=flrpt.flrpt_username)
                                AND (flrptyr.flrpt_order=flrpt.flrpt_order))
                        LEFT OUTER JOIN flrpt flrptprmo
                                ON ((flrptprmo.flrpt_type=flrpt.flrpt_type)
                                AND (flrptprmo.flrpt_type_id=flrpt.flrpt_type_id)
                                AND (flrptprmo.flrpt_flhead_id=flrpt.flrpt_flhead_id)
                                AND (flrptprmo.flrpt_period_id=_priorMoPeriodId)
                                AND (flrptprmo.flrpt_interval='M')
                                AND (flrptprmo.flrpt_username=flrpt.flrpt_username)
                                AND (flrptprmo.flrpt_order=flrpt.flrpt_order))
                        LEFT OUTER JOIN flrpt flrptprqt
                                ON ((flrptprqt.flrpt_type=flrpt.flrpt_type)
                                AND (flrptprqt.flrpt_type_id=flrpt.flrpt_type_id)
                                AND (flrptprqt.flrpt_flhead_id=flrpt.flrpt_flhead_id)
                                AND (flrptprqt.flrpt_period_id=_priorQtPeriodId)
                                AND (flrptprqt.flrpt_interval='Q')
                                AND (flrptprqt.flrpt_username=flrpt.flrpt_username)
                                AND (flrptprqt.flrpt_order=flrpt.flrpt_order))
                        LEFT OUTER JOIN flrpt flrptpryr
                                ON ((flrptpryr.flrpt_type=flrpt.flrpt_type)
                                AND (flrptpryr.flrpt_type_id=flrpt.flrpt_type_id)
                                AND (flrptpryr.flrpt_flhead_id=flrpt.flrpt_flhead_id)
                                AND (flrptpryr.flrpt_period_id=_priorYrPeriodId)
                                AND (flrptpryr.flrpt_interval='Y')
                                AND (flrptpryr.flrpt_username=flrpt.flrpt_username)
                                AND (flrptpryr.flrpt_order=flrpt.flrpt_order) )
        WHERE ((flitem_id = flrpt.flrpt_type_id)
        AND (flhead_id = flitem_flhead_id))
        UNION
        SELECT
        flrpt.flrpt_flhead_id AS flstmtitem_flhead_id,
        flrpt.flrpt_period_id AS flstmtitem_period_id,
        flrpt.flrpt_username AS flstmtitem_username,
        flrpt.flrpt_order AS flstmtitem_order,
        flrpt.flrpt_level AS flstmtitem_level,
        flrpt.flrpt_type AS flstmtitem_type,
        flrpt.flrpt_type_id AS flstmtitem_type_id,
        flrpt.flrpt_parent_id AS flstmtitem_parent_id,
        NULL AS flstmtitem_accnt_id,
        CASE WHEN(flrpt.flrpt_type='T' AND flrpt.flrpt_level=0) THEN
                        COALESCE(flrpt.flrpt_altname, 'Total')
                WHEN(flrpt.flrpt_type='T') THEN
                        formatindent(COALESCE(flrpt.flrpt_altname, 'Subtotal') ,
                        (CASE WHEN pIndentName THEN flrpt.flrpt_level ELSE 0 END))
                ELSE formatindent(('Type ' || flrpt.flrpt_type || ' ' || text(flrpt.flrpt_type_id)),
                        (CASE WHEN pIndentName THEN flrpt.flrpt_level ELSE 0 END))
                END AS flstmtitem_name,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (COALESCE(flrptmo.flrpt_diff,0))
                ELSE (COALESCE(flrptmo.flrpt_ending,0))
        END AS flstmtitem_month,
        (COALESCE(flrptmo.flrpt_debits,0)) AS flstmtitem_monthdb,
        (COALESCE(flrptmo.flrpt_credits,0)) AS flstmtitem_monthcr,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (flrptmo.flrpt_diffprcnt)
                ELSE (flrptmo.flrpt_endingprcnt)
        END AS flstmtitem_monthprcnt,
        (COALESCE(flrptmo.flrpt_budget,0)) AS flstmtitem_monthbudget,
        (flrptmo.flrpt_budgetprcnt) AS flstmtitem_monthbudgetprcnt,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (COALESCE((flrptmo.flrpt_diff-flrptmo.flrpt_budget),0))
                ELSE (COALESCE((flrptmo.flrpt_ending-flrptmo.flrpt_budget),0))
        END AS flstmtitem_monthbudgetdiff,
        CASE
                WHEN ((flhead_type IN ('I','C')) AND (flrptmo.flrpt_budget > 0)) THEN
                        (COALESCE(((flrptmo.flrpt_diff-flrptmo.flrpt_budget)/flrptmo.flrpt_budget),0))
                WHEN ((flhead_type='B') AND (flrptmo.flrpt_budget > 0)) THEN
                        (COALESCE(((flrptmo.flrpt_ending-flrptmo.flrpt_budget)/flrptmo.flrpt_budget),0))
                ELSE NULL
        END AS flstmtitem_monthbudgetdiffprcnt,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (COALESCE(flrptqt.flrpt_diff,0))
                ELSE (COALESCE(flrptqt.flrpt_ending,0))
        END AS flstmtitem_qtr,
        (COALESCE(flrptqt.flrpt_debits,0)) AS flstmtitem_qtrdb,
        (COALESCE(flrptqt.flrpt_credits,0)) AS flstmtitem_qtrcr,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (flrptqt.flrpt_diffprcnt)
                ELSE (flrptqt.flrpt_endingprcnt)
        END AS flstmtitem_qtrprcnt,
        (COALESCE(flrptqt.flrpt_budget,0)) AS flstmtitem_qtrbudget,
        (flrptqt.flrpt_budgetprcnt) AS flstmtitem_qtrbudgetprcnt,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (COALESCE((flrptqt.flrpt_diff-flrptqt.flrpt_budget),0))
                ELSE (COALESCE((flrptqt.flrpt_ending-flrptqt.flrpt_budget),0))
        END AS flstmtitem_qtrbudgetdiff,
        CASE
                WHEN ((flhead_type IN ('I','C')) AND (flrptqt.flrpt_budget > 0)) THEN
                        (COALESCE(((flrptqt.flrpt_diff-flrptqt.flrpt_budget)/flrptqt.flrpt_budget),0))
                WHEN ((flhead_type='B') AND (flrptqt.flrpt_budget > 0)) THEN
                        (COALESCE(((flrptqt.flrpt_ending-flrptqt.flrpt_budget)/flrptqt.flrpt_budget),0))
                ELSE NULL
        END AS flstmtitem_qtrbudgetdiffprcnt,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (COALESCE(flrptyr.flrpt_diff,0))
                ELSE (COALESCE(flrptyr.flrpt_ending,0))
        END AS flstmtitem_year,
        (COALESCE(flrptyr.flrpt_debits,0)) AS flstmtitem_yeardb,
        (COALESCE(flrptyr.flrpt_credits,0)) AS flstmtitem_yearcr,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (flrptyr.flrpt_diffprcnt)
                ELSE (flrptyr.flrpt_endingprcnt)
        END AS flstmtitem_yearprcnt,
        (COALESCE(flrptyr.flrpt_budget,0)) AS  flstmtitem_yearbudget,
        (flrptyr.flrpt_budgetprcnt) AS flstmtitem_yearbudgetprcnt,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (COALESCE((flrptyr.flrpt_diff-flrptyr.flrpt_budget),0))
                ELSE (COALESCE((flrptyr.flrpt_ending-flrptyr.flrpt_budget),0))
        END AS flstmtitem_yearbudgetdiff,
        CASE
                WHEN ((flhead_type IN ('I','C')) AND (flrptyr.flrpt_budget > 0)) THEN
                        (COALESCE(((flrptyr.flrpt_diff-flrptyr.flrpt_budget)/flrptyr.flrpt_budget),0))
                WHEN ((flhead_type = 'B') AND (flrptyr.flrpt_budget > 0)) THEN
                        (COALESCE(((flrptyr.flrpt_ending-flrptyr.flrpt_budget)/flrptyr.flrpt_budget),0))
                ELSE NULL
        END AS flstmtitem_yearbudgetdiffprcnt,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (COALESCE(flrptprmo.flrpt_diff,0))
                ELSE (COALESCE(flrptprmo.flrpt_ending,0))
        END AS flstmtitem_prmonth,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (flrptprmo.flrpt_diffprcnt)
                ELSE (flrptprmo.flrpt_endingprcnt)
        END AS flstmtitem_prmonthprcnt,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (COALESCE(flrptmo.flrpt_diff-flrptprmo.flrpt_diff,0))
                ELSE (COALESCE(flrptmo.flrpt_ending-flrptprmo.flrpt_ending,0))
        END AS flstmtitem_prmonthdiff,
        CASE
                WHEN ((flhead_type IN ('I','C')) AND (flrptprmo.flrpt_diff > 0)) THEN
                        (COALESCE((flrptmo.flrpt_diff-flrptprmo.flrpt_diff)/flrptprmo.flrpt_diff,0))
                WHEN ((flhead_type = 'B') AND (flrptprmo.flrpt_ending > 0)) THEN
                        (COALESCE((flrptmo.flrpt_ending-flrptprmo.flrpt_ending)/flrptprmo.flrpt_ending,0))
                ELSE NULL
        END AS flstmtitem_prmonthdiffprcnt,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (COALESCE(flrptprqt.flrpt_diff,0))
                ELSE (COALESCE(flrptprqt.flrpt_ending,0))
        END AS flstmtitem_prqtr,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (flrptprqt.flrpt_diffprcnt)
                ELSE (flrptprqt.flrpt_endingprcnt)
        END AS flstmtitem_prqtrprcnt,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (COALESCE(flrptqt.flrpt_diff-flrptprqt.flrpt_diff,0))
                ELSE (COALESCE(flrptqt.flrpt_ending-flrptprqt.flrpt_ending,0))
        END AS flstmtitem_prqtrdiff,
        CASE
                WHEN ((flhead_type IN ('I','C')) AND (flrptprqt.flrpt_diff > 0)) THEN
                        (COALESCE((flrptqt.flrpt_diff-flrptprqt.flrpt_diff)/flrptprqt.flrpt_diff,0))
                WHEN ((flhead_type = 'B') AND (flrptprqt.flrpt_ending > 0)) THEN
                        (COALESCE((flrptqt.flrpt_ending-flrptprqt.flrpt_ending)/flrptprqt.flrpt_ending,0))
                ELSE NULL
        END AS flstmtitem_prqtrdiffprcnt,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (COALESCE(flrptpryr.flrpt_diff,0))
                ELSE (COALESCE(flrptpryr.flrpt_ending,0))
        END AS flstmtitem_pryear,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (flrptpryr.flrpt_diffprcnt)
                ELSE (flrptpryr.flrpt_endingprcnt)
        END AS flstmtitem_pryearprcnt,
        CASE
                WHEN (flhead_type IN ('I','C')) THEN
                        (COALESCE(flrptyr.flrpt_diff-flrptpryr.flrpt_diff,0))
                ELSE (COALESCE(flrptyr.flrpt_ending-flrptpryr.flrpt_ending,0))
        END AS flstmtitem_pryeardiff,
        CASE
                WHEN ((flhead_type IN ('I','C')) AND (flrptpryr.flrpt_diff > 0)) THEN
                        (COALESCE((flrptyr.flrpt_diff-flrptpryr.flrpt_diff)/flrptpryr.flrpt_diff,0))
                WHEN ((flhead_type = 'B' ) AND (flrptpryr.flrpt_ending > 0)) THEN
                        (COALESCE((flrptyr.flrpt_ending-flrptpryr.flrpt_ending)/flrptpryr.flrpt_ending,0))
                ELSE NULL
        END AS flstmtitem_pryeardiffprcnt
        FROM flhead CROSS JOIN (SELECT DISTINCT
                        flrpt_flhead_id,
                        flrpt_period_id,
                        flrpt_username,
                        flrpt_order,
                        flrpt_level,
                        flrpt_type,
                        flrpt_type_id,
                        flrpt_parent_id,
                        flrpt_altname
                FROM flrpt
                WHERE ((NOT (flrpt_type IN ('G','I','S')))
                AND (flrpt_flhead_id=_p.flhead_id)
                AND (flrpt_period_id=pPeriodId)
                AND (flrpt_username=getEffectiveXtUser()))) AS flrpt
                        LEFT OUTER JOIN flrpt flrptmo
                                ON ((flrptmo.flrpt_type=flrpt.flrpt_type)
                                AND (flrptmo.flrpt_order=flrpt.flrpt_order)
                                AND (flrptmo.flrpt_flhead_id=flrpt.flrpt_flhead_id)
                                AND (flrptmo.flrpt_period_id=flrpt.flrpt_period_id)
                                AND (flrptmo.flrpt_interval='M')
                                AND (flrptmo.flrpt_username=flrpt.flrpt_username))
                        LEFT OUTER JOIN flrpt flrptqt
                                ON ((flrptqt.flrpt_type=flrpt.flrpt_type)
                                AND (flrptqt.flrpt_order=flrpt.flrpt_order)
                                AND (flrptqt.flrpt_flhead_id=flrpt.flrpt_flhead_id)
                                AND (flrptqt.flrpt_period_id=flrpt.flrpt_period_id)
                                AND (flrptqt.flrpt_interval=_qtrInterval)
                                AND (flrptqt.flrpt_username=flrpt.flrpt_username))
                        LEFT OUTER JOIN flrpt flrptyr
                                ON ((flrptyr.flrpt_type=flrpt.flrpt_type)
                                AND (flrptyr.flrpt_order=flrpt.flrpt_order)
                                AND (flrptyr.flrpt_flhead_id=flrpt.flrpt_flhead_id)
                                AND (flrptyr.flrpt_period_id=flrpt.flrpt_period_id)
                                AND (flrptyr.flrpt_interval=_yrInterval)
                                AND (flrptyr.flrpt_username=flrpt.flrpt_username))
                        LEFT OUTER JOIN flrpt flrptprmo
                                ON ((flrptprmo.flrpt_type=flrpt.flrpt_type)
                                AND (flrptprmo.flrpt_order=flrpt.flrpt_order)
                                AND (flrptprmo.flrpt_flhead_id=flrpt.flrpt_flhead_id)
                                AND (flrptprmo.flrpt_period_id=_priorMoPeriodId)
                                AND (flrptprmo.flrpt_interval='M')
                                AND (flrptprmo.flrpt_username=flrpt.flrpt_username))
                        LEFT OUTER JOIN flrpt flrptprqt
                                ON ((flrptprqt.flrpt_type=flrpt.flrpt_type)
                                AND (flrptprqt.flrpt_order=flrpt.flrpt_order)
                                AND (flrptprqt.flrpt_flhead_id=flrpt.flrpt_flhead_id)
                                AND (flrptprqt.flrpt_period_id=_priorQtPeriodId)
                                AND (flrptprqt.flrpt_interval='Q')
                                AND (flrptprqt.flrpt_username=flrpt.flrpt_username))
                        LEFT OUTER JOIN flrpt flrptpryr
                                ON ((flrptpryr.flrpt_type=flrpt.flrpt_type)
                                AND (flrptpryr.flrpt_order=flrpt.flrpt_order)
                                AND (flrptpryr.flrpt_flhead_id=flrpt.flrpt_flhead_id)
                                AND (flrptpryr.flrpt_period_id=_priorYrPeriodId)
                                AND (flrptpryr.flrpt_interval='Y')
                                AND (flrptpryr.flrpt_username=flrpt.flrpt_username))
        WHERE (flhead_id=flrpt.flrpt_flhead_id)
        ORDER BY flstmtitem_order
        LOOP
                IF _prevlevel > _x.flstmtitem_level THEN
                        _subgrp := _subgrp+1;
                END IF;
                _prevlevel:=_x.flstmtitem_level;
                _row.flstmtitem_subgrp := _subgrp;

                IF NOT _first THEN
                        RETURN NEXT _row;
                END IF;

                _first := FALSE;

                _row.flstmtitem_flhead_id := _x.flstmtitem_flhead_id;
                _row.flstmtitem_period_id := _x.flstmtitem_period_id;
                _row.flstmtitem_username := _x.flstmtitem_username;
                _row.flstmtitem_order := _x.flstmtitem_order;
                _row.flstmtitem_level := _x.flstmtitem_level;
                _row.flstmtitem_type := _x.flstmtitem_type;
                _row.flstmtitem_type_id := _x.flstmtitem_type_id;
                _row.flstmtitem_parent_id := _x.flstmtitem_parent_id;
                _row.flstmtitem_accnt_id := _x.flstmtitem_accnt_id;
                _row.flstmtitem_name := _x.flstmtitem_name;
                _row.flstmtitem_month := _x.flstmtitem_month;
                _row.flstmtitem_monthdb := _x.flstmtitem_monthdb;
                _row.flstmtitem_monthcr := _x.flstmtitem_monthcr;
                _row.flstmtitem_monthprcnt := _x.flstmtitem_monthprcnt;
                _row.flstmtitem_monthbudget := _x.flstmtitem_monthbudget;
                _row.flstmtitem_monthbudgetprcnt := _x.flstmtitem_monthbudgetprcnt;
                _row.flstmtitem_monthbudgetdiff := _x.flstmtitem_monthbudgetdiff;
                _row.flstmtitem_monthbudgetdiffprcnt := _x.flstmtitem_monthbudgetdiffprcnt;
                _row.flstmtitem_qtr := _x.flstmtitem_qtr;
                _row.flstmtitem_qtrdb := _x.flstmtitem_qtrdb;
                _row.flstmtitem_qtrcr := _x.flstmtitem_qtrcr;
                _row.flstmtitem_qtrprcnt := _x.flstmtitem_qtrprcnt;
                _row.flstmtitem_qtrbudget := _x.flstmtitem_qtrbudget;
                _row.flstmtitem_qtrbudgetprcnt := _x.flstmtitem_qtrbudgetprcnt;
                _row.flstmtitem_qtrbudgetdiff := _x.flstmtitem_qtrbudgetdiff;
                _row.flstmtitem_qtrbudgetdiffprcnt := _x.flstmtitem_qtrbudgetdiffprcnt;
                _row.flstmtitem_year := _x.flstmtitem_year;
                _row.flstmtitem_yeardb := _x.flstmtitem_yeardb;
                _row.flstmtitem_yearcr := _x.flstmtitem_yearcr;
                _row.flstmtitem_yearprcnt := _x.flstmtitem_yearprcnt;
                _row.flstmtitem_yearbudget := _x.flstmtitem_yearbudget;
                _row.flstmtitem_yearbudgetprcnt := _x.flstmtitem_yearbudgetprcnt;
                _row.flstmtitem_yearbudgetdiff := _x.flstmtitem_yearbudgetdiff;
                _row.flstmtitem_yearbudgetdiffprcnt := _x.flstmtitem_yearbudgetdiffprcnt;
                _row.flstmtitem_prmonth := _x.flstmtitem_prmonth;
                _row.flstmtitem_prmonthprcnt := _x.flstmtitem_prmonthprcnt;
                _row.flstmtitem_prmonthdiff := _x.flstmtitem_prmonthdiff;
                _row.flstmtitem_prmonthdiffprcnt := _x.flstmtitem_prmonthdiffprcnt;
                _row.flstmtitem_prqtr := _x.flstmtitem_prqtr;
                _row.flstmtitem_prqtrprcnt := _x.flstmtitem_prqtrprcnt;
                _row.flstmtitem_prqtrdiff := _x.flstmtitem_prqtrdiff;
                _row.flstmtitem_prqtrdiffprcnt := _x.flstmtitem_prqtrdiffprcnt;
                _row.flstmtitem_pryear := _x.flstmtitem_pryear;
                _row.flstmtitem_pryearprcnt := _x.flstmtitem_pryearprcnt;
                _row.flstmtitem_pryeardiff := _x.flstmtitem_pryeardiff;
                _row.flstmtitem_pryeardiffprcnt := _x.flstmtitem_pryeardiffprcnt;

        END LOOP;

        _row.flstmtitem_subgrp := _subgrp + 1;
        RETURN NEXT _row;
END;
$_$;


ALTER FUNCTION public.financialreport(integer, integer, boolean, boolean, integer) OWNER TO admin;

--
-- TOC entry 1562 (class 1255 OID 146566140)
-- Dependencies: 4536 8
-- Name: findapaccount(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION findapaccount(integer) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVendid ALIAS FOR $1;
  _accntid INTEGER;

BEGIN

  IF (NOT fetchMetricBool('InterfaceAPToGL')) THEN
    RETURN 0;
  END IF;

  SELECT apaccnt_ap_accnt_id INTO _accntid
    FROM apaccnt
    JOIN vendinfo ON (apaccnt_vendtype_id=vend_vendtype_id)
  WHERE (vend_id=pVendid);
  IF (FOUND) THEN
    RETURN _accntid;
  END IF;

  SELECT apaccnt_ap_accnt_id INTO _accntid
    FROM apaccnt
    JOIN vendtype ON (vendtype_code ~ apaccnt_vendtype)
    JOIN vendinfo ON (vend_vendtype_id=vendtype_id)
  WHERE ((apaccnt_vendtype_id=-1)
     AND (vend_id=pVendid));
  IF (FOUND) THEN
    RETURN _accntid;
  END IF;

  RETURN -1;

END;
$_$;


ALTER FUNCTION public.findapaccount(integer) OWNER TO admin;

--
-- TOC entry 1563 (class 1255 OID 146566141)
-- Dependencies: 4536 8
-- Name: findapdiscountaccount(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION findapdiscountaccount(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVendid ALIAS FOR $1;
  _accntid INTEGER;

BEGIN

  IF (NOT fetchMetricBool('InterfaceAPToGL')) THEN
    RETURN 0;
  END IF;

  SELECT apaccnt_discount_accnt_id INTO _accntid
    FROM apaccnt
    JOIN vendinfo ON (apaccnt_vendtype_id=vend_vendtype_id)
  WHERE (vend_id=pVendid);
  IF (FOUND) THEN
    RETURN _accntid;
  END IF;

  SELECT apaccnt_discount_accnt_id INTO _accntid
    FROM apaccnt
    JOIN vendtype ON (vendtype_code ~ apaccnt_vendtype)
    JOIN vendinfo ON (vend_vendtype_id=vendtype_id)
  WHERE ((apaccnt_vendtype_id=-1)
     AND (vend_id=pVendid));
  IF (FOUND) THEN
    RETURN _accntid;
  END IF;

  RETURN -1;

END;
$_$;


ALTER FUNCTION public.findapdiscountaccount(integer) OWNER TO admin;

--
-- TOC entry 1564 (class 1255 OID 146566142)
-- Dependencies: 4536 8
-- Name: findapprepaidaccount(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION findapprepaidaccount(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVendid ALIAS FOR $1;
  _accntid INTEGER;

BEGIN

  IF (NOT fetchMetricBool('InterfaceAPToGL')) THEN
    RETURN 0;
  END IF;

--  Check for a Vendor Type specific Account
  SELECT apaccnt_prepaid_accnt_id INTO _accntid
    FROM apaccnt
    JOIN vendinfo ON (apaccnt_vendtype_id=vend_vendtype_id)
  WHERE (vend_id=pVendid);
  IF (FOUND) THEN
    RETURN _accntid;
  END IF;

--  Check for a Vendor Type pattern
  SELECT apaccnt_prepaid_accnt_id INTO _accntid
    FROM apaccnt
    JOIN vendtype ON (vendtype_code ~ apaccnt_vendtype)
    JOIN vendinfo ON (vend_vendtype_id=vendtype_id)
  WHERE ((apaccnt_vendtype_id=-1)
     AND (vend_id=pVendid));
  IF (FOUND) THEN
    RETURN _accntid;
  END IF;

  RETURN -1;

END;
$_$;


ALTER FUNCTION public.findapprepaidaccount(integer) OWNER TO admin;

--
-- TOC entry 1565 (class 1255 OID 146566143)
-- Dependencies: 4536 8
-- Name: findaraccount(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION findaraccount(integer) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCustid ALIAS FOR $1;
  _accntid INTEGER;

BEGIN

  IF (NOT fetchMetricBool('InterfaceARToGL')) THEN
    RETURN 0;
  END IF;

--  Check for a Customer Type specific Account
  SELECT araccnt_ar_accnt_id INTO _accntid
  FROM araccnt, custinfo
  WHERE ( (araccnt_custtype_id=cust_custtype_id)
   AND (cust_id=pCustid) );
  IF (FOUND) THEN
    RETURN _accntid;
  END IF;

--  Check for a Customer Type pattern
  SELECT araccnt_ar_accnt_id INTO _accntid
  FROM araccnt, custinfo, custtype
  WHERE ( (custtype_code ~ araccnt_custtype)
   AND (araccnt_custtype_id=-1)
   AND (cust_custtype_id=custtype_id)
   AND (cust_id=pCustid) );
  IF (FOUND) THEN
    RETURN _accntid;
  END IF;

  RETURN -1;

END;
$_$;


ALTER FUNCTION public.findaraccount(integer) OWNER TO admin;

--
-- TOC entry 1566 (class 1255 OID 146566144)
-- Dependencies: 4536 8
-- Name: findardiscountaccount(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION findardiscountaccount(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCustid ALIAS FOR $1;
  _accntid INTEGER;

BEGIN

  IF (NOT fetchMetricBool('InterfaceARToGL')) THEN
    RETURN 0;
  END IF;

--  Check for a Customer Type specific Account
  SELECT araccnt_discount_accnt_id INTO _accntid
  FROM araccnt, custinfo
  WHERE ( (araccnt_custtype_id=cust_custtype_id)
   AND (cust_id=pCustid) );
  IF (FOUND) THEN
    RETURN _accntid;
  END IF;

--  Check for a Customer Type pattern
  SELECT araccnt_discount_accnt_id INTO _accntid
  FROM araccnt, custinfo, custtype
  WHERE ( (custtype_code ~ araccnt_custtype)
   AND (cust_custtype_id=custtype_id)
   AND (araccnt_custtype_id=-1)
   AND (cust_id=pCustid) );
  IF (FOUND) THEN
    RETURN _accntid;
  END IF;

  RETURN -1;

END;
$_$;


ALTER FUNCTION public.findardiscountaccount(integer) OWNER TO admin;

--
-- TOC entry 1567 (class 1255 OID 146566145)
-- Dependencies: 4536 8
-- Name: findcalendarorigin(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION findcalendarorigin(integer) RETURNS date
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCalheadid ALIAS FOR $1;
  _originType CHAR(1);
  _origin DATE;

BEGIN

  SELECT calhead_origin INTO _originType
  FROM calhead
  WHERE (calhead_id=pCalheadid);

  IF (NOT FOUND) THEN
    _origin := NULL;

  ELSIF (_originType = 'D') THEN
    _origin := CURRENT_DATE;

  ELSIF (_originType = 'E') THEN
    _origin := (CURRENT_DATE + 1);

  ELSIF (_originType = 'W') THEN
    _origin := (CURRENT_DATE - EXTRACT(DOW FROM CURRENT_DATE)::INTEGER);

  ELSIF (_originType = 'X') THEN
    _origin := ((CURRENT_DATE - EXTRACT(DOW FROM CURRENT_DATE)::INTEGER) + INTERVAL '1 week');

  ELSIF (_originType = 'M') THEN
    _origin := date_trunc('month', CURRENT_DATE);

  ELSIF (_originType = 'N') THEN
    _origin := (date_trunc('month', CURRENT_DATE) + INTERVAL '1 month');

  ELSIF (_originType = 'L') THEN
    _origin := (date_trunc('year', CURRENT_DATE) - INTERVAL '1 year');

  ELSIF (_originType = 'Y') THEN
    _origin := date_trunc('year', CURRENT_DATE);

  ELSIF (_originType = 'Z') THEN
    _origin := (date_trunc('year', CURRENT_DATE) + INTERVAL '1 year');

  ELSE
    _origin := NULL;
  END IF;

  RETURN _origin;

  END;
$_$;


ALTER FUNCTION public.findcalendarorigin(integer) OWNER TO admin;

--
-- TOC entry 1568 (class 1255 OID 146566146)
-- Dependencies: 4536 8
-- Name: findcustomerform(integer, character); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION findcustomerform(integer, character) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCustid ALIAS FOR $1;
  pFormtype ALIAS FOR $2;
  _f RECORD;
  _found BOOLEAN;

BEGIN

--  Check for a Customer Type specific Form
  SELECT custform.* INTO _f
    FROM custform
    JOIN custinfo ON (custform_custtype_id=cust_custtype_id)
  WHERE (cust_id=pCustid);

  IF (FOUND) THEN
    _found := TRUE;
  ELSE
--  Check for a Customer Type pattern
    SELECT custform.* INTO _f
      FROM custform
      JOIN custtype ON (custtype_code ~ custform_custtype)
      JOIN custinfo ON (cust_custtype_id=custtype_id)
    WHERE ((custform_custtype_id=-1)
       AND (cust_id=pCustid));

    IF (FOUND) THEN
      _found := TRUE;
    ELSE
      _found := FALSE;
    END IF;
  END IF;

  IF (_found) THEN
    IF ( (pFormType = 'I') AND (_f.custform_invoice_report_name IS NOT NULL) ) THEN
      RETURN _f.custform_invoice_report_name;

    ELSIF ( (pFormType = 'C') AND (_f.custform_creditmemo_report_name IS NOT NULL) ) THEN
      RETURN _f.custform_creditmemo_report_name;

    ELSIF ( (pFormType = 'S') AND (_f.custform_statement_report_name IS NOT NULL) ) THEN
      RETURN _f.custform_statement_report_name;

    ELSIF ( (pFormType = 'Q') AND (_f.custform_quote_report_name IS NOT NULL) ) THEN
      RETURN _f.custform_quote_report_name;

    ELSIF ( (pFormType = 'P') AND (_f.custform_packinglist_report_name IS NOT NULL) ) THEN
      RETURN _f.custform_packinglist_report_name;

    ELSIF ( (pFormType = 'L') AND (_f.custform_sopicklist_report_name IS NOT NULL) ) THEN
      RETURN _f.custform_sopicklist_report_name;
    END IF;

  END IF;

  IF (pFormType = 'I') THEN
    RETURN 'Invoice';
  ELSIF (pFormType = 'C') THEN
    RETURN 'CreditMemo';
  ELSIF (pFormType = 'S') THEN
    RETURN 'Statement';
  ELSIF (pFormType = 'Q') THEN
    RETURN 'Quote';
  ELSIF (pFormType = 'P') THEN
    RETURN 'PackingList-Shipment';
  ELSIF (pFormType = 'L') THEN
    RETURN 'PackingList';
  END IF;

END;
$_$;


ALTER FUNCTION public.findcustomerform(integer, character) OWNER TO admin;

--
-- TOC entry 1570 (class 1255 OID 146566147)
-- Dependencies: 4536 8
-- Name: finddeferredaccount(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION finddeferredaccount(integer) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCustid ALIAS FOR $1;
  _accntid INTEGER;

BEGIN

  IF (NOT fetchMetricBool('InterfaceARToGL')) THEN
    RETURN 0;
  END IF;

--  Check for a Customer Type specific Account
  SELECT araccnt_deferred_accnt_id INTO _accntid
    FROM araccnt
    JOIN custinfo ON (araccnt_custtype_id=cust_custtype_id)
  WHERE (cust_id=pCustid);
  IF (FOUND) THEN
    RETURN _accntid;
  END IF;

--  Check for a Customer Type pattern
  SELECT araccnt_deferred_accnt_id INTO _accntid
    FROM araccnt
    JOIN custtype ON (custtype_code ~ araccnt_custtype)
    JOIN custinfo ON (cust_custtype_id=custtype_id)
  WHERE ((araccnt_custtype_id=-1)
     AND (cust_id=pCustid));
  IF (FOUND) THEN
    RETURN _accntid;
  END IF;

  RETURN -1;

END;
$_$;


ALTER FUNCTION public.finddeferredaccount(integer) OWNER TO admin;

--
-- TOC entry 1571 (class 1255 OID 146566148)
-- Dependencies: 4536 8
-- Name: findfreightaccount(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION findfreightaccount(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCustid ALIAS FOR $1;
  _accntid INTEGER;

BEGIN

  IF (NOT fetchMetricBool('InterfaceARToGL')) THEN
    RETURN 0;
  END IF;

--  Check for a Customer Type specific Account
  SELECT araccnt_freight_accnt_id INTO _accntid
  FROM araccnt, custinfo
  WHERE ( (araccnt_custtype_id=cust_custtype_id)
   AND (cust_id=pCustid) );
  IF (FOUND) THEN
    RETURN _accntid;
  END IF;

--  Check for a Customer Type pattern
  SELECT araccnt_freight_accnt_id INTO _accntid
  FROM araccnt, custinfo, custtype
  WHERE ( (custtype_code ~ araccnt_custtype)
   AND (cust_custtype_id=custtype_id)
   AND (araccnt_custtype_id=-1)
   AND (cust_id=pCustid) );
  IF (FOUND) THEN
    RETURN _accntid;
  END IF;

--  Find the default
  SELECT metric_value::INTEGER INTO _accntid
  FROM metric
  WHERE (metric_name='FreightAccount');
  IF (FOUND) THEN
    RETURN _accntid;
  END IF;

  RETURN -1;

END;
$_$;


ALTER FUNCTION public.findfreightaccount(integer) OWNER TO admin;

--
-- TOC entry 1572 (class 1255 OID 146566149)
-- Dependencies: 4536 8
-- Name: findperiodend(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION findperiodend(integer) RETURNS date
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCalitemid ALIAS FOR $1;
  _calType CHAR(1);
  _calItem RECORD;
  _start DATE;
  _loop INTEGER;

BEGIN

  SELECT calhead_type INTO _calType
  FROM calhead, acalitem
  WHERE ((acalitem_calhead_id=calhead_id)
   AND (acalitem_id=pCalitemid));

  IF (NOT FOUND) THEN
    SELECT calhead_type INTO _calType
    FROM calhead, rcalitem
    WHERE ((rcalitem_calhead_id=calhead_id)
     AND (rcalitem_id=pCalitemid));

    IF (NOT FOUND) THEN
      RETURN NULL;
    END IF;
  END IF;

  IF (_calType = 'A') THEN
    RETURN ( SELECT (findPeriodStart(acalitem_id) + acalitem_periodlength - 1)
             FROM acalitem
             WHERE (acalitem_id=pCalitemid) );

  ELSIF (_calType = 'R') THEN

--  Grab the relative calitem's particulars
    SELECT rcalitem_periodtype, rcalitem_periodcount INTO _calitem
    FROM rcalitem
    WHERE (rcalitem_id=pCalitemid);

    IF (NOT FOUND) THEN
      RETURN NULL;
    END If;

--  Grab the origin of the calitem
    SELECT findPeriodStart(pCalitemid) INTO _start;

    IF (_start IS NULL) THEN

--  If days...
    ELSIF (_calitem.rcalitem_periodtype = 'D') THEN
      _start := (_start + _calitem.rcalitem_periodcount - 1);

--  If weeks... (gotta be a better way)
    ELSIF (_calitem.rcalitem_periodtype = 'W') THEN
      _loop := _calitem.rcalitem_periodcount;

      WHILE (_loop > 0) LOOP
        _start := (_start + INTERVAL '1 week');
        _loop := (_loop - 1);
      END LOOP;

      _start := (_start - 1);

--  If months... (gotta be a better way)
    ELSIF (_calitem.rcalitem_periodtype = 'M') THEN
      _loop := _calitem.rcalitem_periodcount;

      WHILE (_loop > 0) LOOP
        _start := (_start + INTERVAL '1 month');
        _loop := (_loop - 1);
      END LOOP;

      _start := (_start - 1);

--  If years... (gotta be a better way)
    ELSIF (_calitem.rcalitem_periodtype = 'Y') THEN
      _loop := _calitem.rcalitem_periodcount;

      WHILE (_loop > 0) LOOP
        _start := (_start + INTERVAL '1 year');
        _loop := (_loop - 1);
      END LOOP;

      _start := (_start - 1);

    ELSE
      _start := NULL;
    END IF;

  ELSE
    _start := NULL;
  END IF;

  RETURN _start;

END;
$_$;


ALTER FUNCTION public.findperiodend(integer) OWNER TO admin;

--
-- TOC entry 1573 (class 1255 OID 146566150)
-- Dependencies: 4536 8
-- Name: findperiodstart(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION findperiodstart(integer) RETURNS date
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCalitemid ALIAS FOR $1;
  _calType CHAR(1);
  _calItem RECORD;
  _start DATE;
  _loop INTEGER;

BEGIN

  SELECT calhead_type INTO _calType
  FROM calhead, acalitem
  WHERE ((acalitem_calhead_id=calhead_id)
   AND (acalitem_id=pCalitemid));

  IF (NOT FOUND) THEN
    SELECT calhead_type INTO _calType
    FROM calhead, rcalitem
    WHERE ((rcalitem_calhead_id=calhead_id)
     AND (rcalitem_id=pCalitemid));

    IF (NOT FOUND) THEN
      RETURN NULL;
    END IF;
  END IF;

  IF (_calType = 'A') THEN
    RETURN ( SELECT acalitem_periodstart
             FROM acalitem
             WHERE (acalitem_id=pCalitemid) );

  ELSIF (_calType = 'R') THEN

--  Grab the relative calitem's particulars
    SELECT rcalitem_offsettype, rcalitem_offsetcount INTO _calitem
    FROM rcalitem
    WHERE (rcalitem_id=pCalitemid);

    IF (NOT FOUND) THEN
      RETURN NULL;
    END If;

--  Grab the origin of the calitem's parend calhead
    SELECT findCalendarOrigin(calhead_id) INTO _start
    FROM calhead, rcalitem
    WHERE ((rcalitem_calhead_id=calhead_id)
     AND (rcalitem_id=pCalitemid));

--  If days...
    IF (_calitem.rcalitem_offsettype = 'D') THEN
      _start := (_start + _calitem.rcalitem_offsetcount);

--  If weeks...
    ELSIF (_calitem.rcalitem_offsettype = 'W') THEN
      _start := (_start + (_calitem.rcalitem_offsetcount * 7));

--  If months... (gotta be a better way)
    ELSIF (_calitem.rcalitem_offsettype = 'M') THEN
      _loop := _calitem.rcalitem_offsetcount;

      IF (_loop > 0) THEN
        WHILE (_loop > 0) LOOP
          _start := (_start + INTERVAL '1 month');
          _loop := _loop - 1;
        END LOOP;
      ELSE
        WHILE (_loop < 0) LOOP
          _start := (_start - INTERVAL '1 month');
          _loop := _loop + 1;
        END LOOP;
      END IF;

--  If years... (gotta be a better way)
    ELSIF (_calitem.rcalitem_offsettype = 'Y') THEN
      _loop := _calitem.rcalitem_offsetcount;

      IF (_loop > 0) THEN
        WHILE (_loop > 0) LOOP
          _start := (_start + INTERVAL '1 year');
          _loop := _loop - 1;
        END LOOP;
      ELSE
        WHILE (_loop < 0) LOOP
          _start := (_start - INTERVAL '1 year');
          _loop := _loop + 1;
        END LOOP;
      END IF;

    ELSE
      _start := NULL;
    END IF;

  ELSE
    _start := NULL;
  END IF;

  RETURN _start;

END;
$_$;


ALTER FUNCTION public.findperiodstart(integer) OWNER TO admin;

--
-- TOC entry 1574 (class 1255 OID 146566151)
-- Dependencies: 4536 8
-- Name: findprepaidaccount(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION findprepaidaccount(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCustid ALIAS FOR $1;
  _accntid INTEGER;

BEGIN

  IF (NOT fetchMetricBool('InterfaceARToGL')) THEN
    RETURN 0;
  END IF;

--  Check for a Customer Type specific Account
  SELECT araccnt_prepaid_accnt_id INTO _accntid
    FROM araccnt
    JOIN custinfo ON (araccnt_custtype_id=cust_custtype_id)
  WHERE (cust_id=pCustid);
  IF (FOUND) THEN
    RETURN _accntid;
  END IF;

--  Check for a Customer Type pattern
  SELECT araccnt_prepaid_accnt_id INTO _accntid
    FROM araccnt
    JOIN custtype ON (custtype_code ~ araccnt_custtype)
    JOIN custinfo ON (cust_custtype_id=custtype_id)
  WHERE ((araccnt_custtype_id=-1)
     AND (cust_id=pCustid) );
  IF (FOUND) THEN
    RETURN _accntid;
  END IF;

  RETURN -1;

END;
$_$;


ALTER FUNCTION public.findprepaidaccount(integer) OWNER TO admin;

--
-- TOC entry 1575 (class 1255 OID 146566152)
-- Dependencies: 4536 8
-- Name: findsalesaccnt(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION findsalesaccnt(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN findSalesAccnt($1, 'IS', $2, NULL, NULL);
END;
$_$;


ALTER FUNCTION public.findsalesaccnt(integer, integer) OWNER TO admin;

--
-- TOC entry 1576 (class 1255 OID 146566153)
-- Dependencies: 4536 8
-- Name: findsalesaccnt(integer, text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION findsalesaccnt(integer, text, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN findSalesAccnt($1, $2, $3, NULL, NULL);
END;
$_$;


ALTER FUNCTION public.findsalesaccnt(integer, text, integer) OWNER TO admin;

--
-- TOC entry 1577 (class 1255 OID 146566154)
-- Dependencies: 4536 8
-- Name: findsalesaccnt(integer, text, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION findsalesaccnt(pid integer, pidtype text, pcustid integer, psaletypeid integer, pshipzoneid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _s RECORD;

BEGIN

  IF (pidType = 'I') THEN
    --  Check for a custtype specific rule
    SELECT salesaccnt_id,
           CASE WHEN (salesaccnt_warehous_id<>-1) THEN 1 ELSE 0 END +
           CASE WHEN (salesaccnt_custtype_id<>-1) THEN 2 ELSE 0 END +
           CASE WHEN (salesaccnt_prodcat_id<>-1) THEN 3 ELSE 0 END +
           CASE WHEN (salesaccnt_shipzone_id<>-1) THEN 4 ELSE 0 END +
           CASE WHEN (salesaccnt_saletype_id<>-1) THEN 5 ELSE 0 END AS orderby
    INTO _s
    FROM salesaccnt, item, prodcat, custinfo, custtype
    WHERE ( (salesaccnt_warehous_id=-1)
      AND  (item_prodcat_id=prodcat_id)
      AND  (cust_custtype_id=custtype_id)
      AND  ( (salesaccnt_prodcat='.*') OR
	    ( (salesaccnt_prodcat_id=-1) AND
	      (salesaccnt_prodcat<>'') AND
	      (prodcat_code ~ salesaccnt_prodcat) ) OR
	    ( (salesaccnt_prodcat_id=prodcat_id) ) )
      AND  ( (salesaccnt_custtype='.*') OR
	    ( (salesaccnt_custtype_id=-1) AND
	      (salesaccnt_custtype<>'') AND
	      (custtype_code ~ salesaccnt_custtype) ) OR
	    ( (salesaccnt_custtype_id=custtype_id) ) )
      AND  ( (salesaccnt_shipzone_id=-1) OR
	     (salesaccnt_shipzone_id=pShipzoneid) )
      AND  ( (salesaccnt_saletype_id=-1) OR
	     (salesaccnt_saletype_id=pSaletypeid) )
      AND (item_id=pid)
      AND (cust_id=pCustid) )
    ORDER BY orderby DESC, salesaccnt_custtype DESC, salesaccnt_prodcat DESC,
             salesaccnt_saletype_id DESC, salesaccnt_shipzone_id DESC
     LIMIT 1;

  ELSIF (pidType = 'IS') THEN
    --  Check for a custtype specific rule
    SELECT salesaccnt_id,
           CASE WHEN (salesaccnt_warehous_id<>-1) THEN 1 ELSE 0 END +
           CASE WHEN (salesaccnt_custtype_id<>-1) THEN 2 ELSE 0 END +
           CASE WHEN (salesaccnt_prodcat_id<>-1) THEN 3 ELSE 0 END +
           CASE WHEN (salesaccnt_shipzone_id<>-1) THEN 4 ELSE 0 END +
           CASE WHEN (salesaccnt_saletype_id<>-1) THEN 5 ELSE 0 END AS orderby
    INTO _s
    FROM salesaccnt, itemsite, item, prodcat, custinfo, custtype
    WHERE ( ( (salesaccnt_warehous_id=-1) OR
	      (salesaccnt_warehous_id=itemsite_warehous_id) )
     AND (itemsite_item_id=item_id)
     AND (item_prodcat_id=prodcat_id)
     AND (cust_custtype_id=custtype_id)
     AND ( (salesaccnt_prodcat='.*') OR
	   ( (salesaccnt_prodcat_id=-1) AND
	     (salesaccnt_prodcat<>'') AND
	     (prodcat_code ~ salesaccnt_prodcat) ) OR
	   ( (salesaccnt_prodcat_id=prodcat_id) ) )
     AND ( (salesaccnt_custtype='.*') OR
	   ( (salesaccnt_custtype_id=-1) AND
	     (salesaccnt_custtype<>'') AND
	     (custtype_code ~ salesaccnt_custtype) ) OR
	   ( (salesaccnt_custtype_id=custtype_id) ) )
     AND  ( (salesaccnt_shipzone_id=-1) OR
            (salesaccnt_shipzone_id=pShipzoneid) )
     AND  ( (salesaccnt_saletype_id=-1) OR
            (salesaccnt_saletype_id=pSaletypeid) )
     AND (itemsite_id=pid)
     AND (cust_id=pCustid) )
    ORDER BY orderby DESC, salesaccnt_custtype DESC, salesaccnt_prodcat DESC, salesaccnt_warehous_id DESC,
             salesaccnt_saletype_id DESC, salesaccnt_shipzone_id DESC
    LIMIT 1;

  ELSE
    RETURN -2;	-- invalid pidType
  END IF;

  IF (FOUND) THEN
    RETURN _s.salesaccnt_id;
  END IF;

  RETURN -1;

END;
$$;


ALTER FUNCTION public.findsalesaccnt(pid integer, pidtype text, pcustid integer, psaletypeid integer, pshipzoneid integer) OWNER TO admin;

--
-- TOC entry 1579 (class 1255 OID 146566155)
-- Dependencies: 4536 8
-- Name: findspecialfinancial(text, text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION findspecialfinancial(text, text, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pUnit ALIAS FOR $1;
  pType ALIAS FOR $2;
  pPeriodid ALIAS FOR $3;

  _value NUMERIC;
BEGIN

  _value := 0.00;

  IF ('OpenAR' = pType) THEN
    IF ( pUnit IN ('D','E') ) THEN
      SELECT SUM( CASE WHEN (aropen_doctype IN ('C', 'R')) THEN ((aropen_amount - aropen_paid) * -1)
                       ELSE (aropen_amount - aropen_paid) END ) INTO _value
        FROM aropen, period
       WHERE ((aropen_open)
         AND  (aropen_duedate BETWEEN period_start AND period_end)
         AND  (period_id=pPeriodid));

      IF ('E' = pUnit) THEN
        _value := 0.00 - _value;
      END IF;
    END IF;
  END IF;

  IF ('OpenAP' = pType) THEN
    IF ( pUnit IN ('C','E') ) THEN
      SELECT SUM( CASE WHEN (apopen_doctype='C') THEN ((apopen_amount - apopen_paid) * -1)
                       ELSE (apopen_amount - apopen_paid) END ) INTO _value
        FROM apopen, period
       WHERE ((apopen_open)
         AND  (apopen_duedate BETWEEN period_start AND period_end)
         AND  (period_id=pPeriodid));
    END IF;
  END IF;

  RETURN _value;

END;
$_$;


ALTER FUNCTION public.findspecialfinancial(text, text, integer) OWNER TO admin;


--
-- TOC entry 1581 (class 1255 OID 146566157)
-- Dependencies: 8
-- Name: first_agg(anyelement, anyelement); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION first_agg(anyelement, anyelement) RETURNS anyelement
    LANGUAGE sql STABLE
    AS $_$
  SELECT CASE WHEN $1 IS NULL THEN $2 ELSE $1 END;
$_$;


ALTER FUNCTION public.first_agg(anyelement, anyelement) OWNER TO admin;

--
-- TOC entry 1582 (class 1255 OID 146566158)
-- Dependencies: 4536 8
-- Name: firstline(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION firstline(text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSource ALIAS FOR $1;
  _result TEXT := '';

BEGIN
  SELECT regexp_replace(pSource, E'^(\r?\n)*([^\r\n]*)\r?\n.*', E'\\2') INTO _result;
  RETURN _result;
END;
$_$;


ALTER FUNCTION public.firstline(text) OWNER TO admin;

--
-- TOC entry 1583 (class 1255 OID 146566159)
-- Dependencies: 4536 8
-- Name: fixacl(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION fixacl() RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _r        RECORD;
  _count    INTEGER := 0;
  _oldgrp   BOOLEAN := false;
  _objtype  TEXT;
  _table    TEXT;
  _schema   TEXT;

BEGIN
  IF EXISTS(SELECT 1 FROM pg_group WHERE groname = 'openmfg') THEN
    _oldgrp := true;
  END IF;

  FOR _r IN SELECT relname, nspname, relkind,
                   CASE relkind WHEN 'r' THEN 1
                                WHEN 'v' THEN 2
                                WHEN 'S' THEN 3
                                ELSE 4
                   END AS seq
            FROM pg_catalog.pg_class c, pg_namespace n
            WHERE ((n.oid=c.relnamespace)
              AND  (nspname in ('public', 'api') OR
                    nspname in (SELECT pkghead_name FROM pkghead))
              AND  (relkind in ('S', 'r', 'v')))
            ORDER BY seq
  LOOP
    _schema := quote_ident(_r.nspname);
    _table  := quote_ident(_r.relname);

    RAISE DEBUG '%.%', _schema, _table;

    IF (_oldgrp) THEN
      EXECUTE 'REVOKE ALL ON ' || _schema || '.' || _table || ' FROM openmfg;';
    END IF;
    EXECUTE 'REVOKE ALL ON ' || _schema || '.' || _table || ' FROM PUBLIC;';
    EXECUTE 'GRANT ALL ON '  || _schema || '.' || _table || ' TO GROUP xtrole;';
    _count := _count + 1;

    _objtype := CASE _r.relkind WHEN 'S' THEN 'SEQUENCE'
                                WHEN 'r' THEN 'TABLE'
                                WHEN 'v' THEN 'VIEW'
                                ELSE NULL
                END;
    IF (_objtype IS NOT NULL) THEN
      BEGIN
        EXECUTE 'ALTER ' || _objtype || ' ' ||
                _schema || '.' || _table || ' OWNER TO admin;';
      EXCEPTION WHEN OTHERS THEN
        RAISE WARNING 'Could not change ownership of %.% to admin',
                      _schema, _table;
      END;
    END IF;

  END LOOP;

  RETURN _count;
END;
$$;


ALTER FUNCTION public.fixacl() OWNER TO admin;

--
-- TOC entry 1584 (class 1255 OID 146566160)
-- Dependencies: 2648 4536 8
-- Name: formatabachecks(integer, integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatabachecks(integer, integer, text) RETURNS SETOF achline
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pbankaccntid     ALIAS FOR $1;   -- all unprinted checks for this bankaccnt
  pcheckheadid     ALIAS FOR $2;   -- but if 2nd arg not null then just 1 check
  penckey          ALIAS FOR $3;
  _bank            RECORD;
  _batchcount      INTEGER := 0;
  _batchdate       DATE;
  _check           RECORD;
  _vendnumber      TEXT;
  _vendname        TEXT;
  _filenum         TEXT;
  _prevsec         TEXT;
  _row             achline%ROWTYPE;
  _totalcr         NUMERIC := 0;
  _totaldb         NUMERIC := 0;
  _detailcount     INTEGER := 0;     -- count of type 1 entries
  _vendbsb         TEXT;

BEGIN
  -- General notes:
  -- Numeric values are formatted using RPAD(TO_CHAR(#, '0..0SG', #)).
  --    TO_CHAR(#, ...) (at least in the default server locale) puts a space at
  --    the beginning of the string for numbers >= 0 and '-' for numbers < 0.
  --    'SG' pushes the sign char to the end, then RPAD cuts it off.
  -- This whole thing is for Australian bank transactions only, and generates entries for an ABA file.
  -- Currently restricted to checks to Vendor; there's no support for checks to
  --    customers or tax authorities, or for debits or corrections.
  -- This function has been adapted from the US-centric ACH formatACHChecks function.

  IF (NOT fetchMetricBool('ACHEnabled')) THEN
    RAISE EXCEPTION 'Cannot format the ABA file because the system is not configured for ABA file generation.';
  END IF;
  IF (LENGTH(COALESCE(penckey, '')) <= 0) THEN
    RAISE EXCEPTION 'Cannot format the ABA file because there is no encryption key.';
  END IF;

  SELECT * INTO _bank
  FROM bankaccnt
  WHERE (bankaccnt_id=pbankaccntid);

  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Could not find the bank information to create the ABA file.';
  ELSIF (NOT _bank.bankaccnt_ach_enabled) THEN
    RAISE EXCEPTION 'Cannot format the ABA file because the Bank Account % is not configured for ABA transactions.',
      _bank.bankaccnt_name;
  ELSIF (LENGTH(COALESCE(_bank.bankaccnt_routing, '')) <= 0) THEN
    RAISE EXCEPTION 'Cannot format the ABA file because the Bank Account % has no BSB number.', _bank.bankaccnt_name;
  END IF;

  -- Check the BSB number is in the right format and then re-format for output.
  -- Valid format is \d{3}-\d{3}|\d{6}000
  IF (_bank.bankaccnt_routing ~ E'^(\\d{3})(?:-(?=\\d{3}$)|(?=\\d{3}0{3}$))(\\d{3})(0{3})?$') THEN
    _bank.bankaccnt_routing := regexp_replace(
      _bank.bankaccnt_routing,
      E'^(\\d{3})(?:-(?=\\d{3}$)|(?=\\d{3}0{3}$))(\\d{3})(0{3})?$', E'\\1-\\2'
    );
  ELSE RAISE EXCEPTION 'Cannot format the ABA file because the Bank Account % has an invalid BSB number.',
    _bank.bankaccnt_name;
  END IF;


  _filenum := LPAD(fetchNextNumber('ACHBatch'), 8, '0');

  IF (COALESCE(_bank.bankaccnt_ach_lastdate,startOfTime()) < CURRENT_DATE
    OR _bank.bankaccnt_ach_lastfileid IS NULL) THEN
    _bank.bankaccnt_ach_lastfileid = '0';
  ELSIF (_bank.bankaccnt_ach_lastfileid = '9') THEN
    _bank.bankaccnt_ach_lastfileid = 'A';
  ELSIF (_bank.bankaccnt_ach_lastfileid = 'Z') THEN
    RAISE EXCEPTION 'Cannot write % check % to an ABA file because too many files have been written for this bank already today.',
      _bank.bankaccnt_name, _check.checkhead_number;
  ELSE
    _bank.bankaccnt_ach_lastfileid = CHR(ASCII(_bank.bankaccnt_ach_lastfileid) + 1);
  END IF;


  _row.achline_checkhead_id := NULL;
  _row.achline_batch := _filenum;
  _row.achline_type := 'HEADER';
  _row.achline_value := RPAD(
    RPAD('0',18)                                    -- Record Type 0 blank filled with 17 spaces
    || '01'                                         -- Reel sequence number
    || RPAD(_bank.bankaccnt_bankname,3)             -- Approved financial instition abbreviation.
    || RPAD('',7)                                   -- blank filled
    || RPAD(fetchMetricText('ACHCompanyName'), 26)  -- Name of user supplying ABA file
    || LPAD(fetchMetricText('ACHCompanyId'),6)      -- User identification number APCA issued
    || RPAD('PAYMENT',12)                           -- description of entries on file
                                                    --  currently only use payment description
    || TO_CHAR(CURRENT_DATE,      'DDMMYY'),        -- date to be processed
    120                                             -- blank filled to 120 characters
  );
  RETURN NEXT _row;

  FOR _check IN SELECT *
    FROM checkhead
    JOIN vendinfo ON (checkhead_recip_type='V'
      AND checkhead_recip_id=vend_id
      AND vend_ach_enabled)
    JOIN curr_symbol ON (checkhead_curr_id=curr_id)
    LEFT OUTER JOIN crmacct ON (crmacct_vend_id=vend_id)
    WHERE ((checkhead_bankaccnt_id=pbankaccntid)
      AND (checkhead_amount > 0)
      AND (checkhead_id=pcheckheadid OR pcheckheadid IS NULL)
      AND NOT checkhead_posted
      AND NOT checkhead_replaced
      AND NOT checkhead_deleted
      AND NOT checkhead_void
      AND NOT checkhead_printed
      AND (LENGTH(COALESCE(checkhead_ach_batch,'')) <= 0)
      AND (curr_abbr='AUD'))
    ORDER BY checkhead_checkdate, vend_name LOOP

    IF (COALESCE(_check.checkhead_number, -1) <= 0
      AND _bank.bankaccnt_ach_genchecknum) THEN
        _check.checkhead_number := fetchNextCheckNumber(_check.checkhead_bankaccnt_id);
    END IF;

    -- Although a crmacct record is not required for used in this function
    -- this code is retained for consistancy with the original formatachchecks function.
    IF (_check.crmacct_id IS NULL) THEN
      RAISE NOTICE 'Vendor % does not have a corresponding crmacct record.',
        _check.checkhead_recip_id;
    ELSIF (_check.crmacct_type IS NULL) THEN
      RAISE NOTICE 'crmacct for vendor % does not have a valid crmacct_type.',
         _check.checkhead_recip_id;
    END IF;

    _vendnumber := CASE WHEN _check.vend_ach_use_vendinfo THEN _check.vend_number
      ELSE _check.vend_ach_indiv_number
      END;
    _vendname := CASE WHEN _check.vend_ach_use_vendinfo THEN _check.vend_name
      ELSE _check.vend_ach_indiv_name
      END;

    IF (COALESCE(_check.vend_ach_routingnumber, '') = '') THEN
      RAISE EXCEPTION 'Cannot write % check % to an ABA file because the BSB number for % has not been supplied.',
        _bank.bankaccnt_name, _check.checkhead_number, _vendnumber;
    ELSIF (COALESCE(_check.vend_ach_accntnumber, '') = '') THEN
      RAISE EXCEPTION 'Cannot write % check % to an ABA file because the account number for % has not been supplied.',
        _bank.bankaccnt_name, _check.checkhead_number, _vendnumber;
    END IF;
    _check.vend_ach_routingnumber := decrypt(setbytea(_check.vend_ach_routingnumber),
      setbytea(penckey), 'bf');
    _check.vend_ach_accntnumber   := decrypt(setbytea(_check.vend_ach_accntnumber),
      setbytea(penckey), 'bf');

    -- Check the BSB number is in the right format and then re-format for output.
    -- Valid format is \d{3}-\d{3}|\d{6}000
    IF (formatbytea(_check.vend_ach_routingnumber) ~ E'^(\\d{3})(?:-(?=\\d{3}$)|(?=\\d{3}0{3}$))(\\d{3})(0{3})?$') THEN
      _vendbsb := regexp_replace(
        formatbytea(_check.vend_ach_routingnumber),
        E'^(\\d{3})(?:-(?=\\d{3}$)|(?=\\d{3}0{3}$))(\\d{3})(0{3})?$', E'\\1-\\2'
      );
    ELSE RAISE EXCEPTION 'Cannot write % check % to an ABA file because the BSB number for % is not valid.',
      _bank.bankaccnt_name, _check.checkhead_number, _vendnumber;
    END IF;

    _row.achline_checkhead_id := _check.checkhead_id;
    _row.achline_batch        := _filenum;
    _row.achline_type         := 'DETAIL';

    _totaldb      := _totaldb + _check.checkhead_amount;                -- Total debits for balancing entry
    _detailcount  := _detailcount + 1;                                  -- Detail record counter (type 1)
    _totalcr      := _totalcr + _check.checkhead_amount;                -- Total credits from payments

    _row.achline_value := RPAD('1'                                      -- record type 1
      || _vendbsb                                                       -- vendor BSB #
      || LPAD(formatbytea(_check.vend_ach_accntnumber), 9)              -- vendor account no.
      ||' '                                                             -- withholding tax indicator
      ||'50'                                                            -- transaction code, this should be calculated.
      || LPAD(to_char(_check.checkhead_amount,'FM99999999V99'),10,'0')  -- amount
      || RPAD(_vendname,   32)                                          -- vendor name
      || RPAD('Deposit',8) || RPAD('#'  , 2) || LPAD (_filenum,8,' ')   -- Lodgement Reference
      || _bank.bankaccnt_routing                                        -- BSB #
      || RPAD(_bank.bankaccnt_accntnumber, 9)                           -- company account number
      || RPAD(fetchMetricText('ACHCompanyName'), 16)                    -- company account name
      || LPAD('', 8, '0'),                                              -- Witholding Tax Amount
      120                                                               -- line width
    );
    RETURN NEXT _row;

    UPDATE checkhead
    SET checkhead_ach_batch=_filenum,
      checkhead_number=_check.checkhead_number
    WHERE (checkhead_id=_check.checkhead_id);

  END LOOP;

  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Cannot write an ABA file for % because there are no checks pending in AUD for EFT-enabled Vendors.',
      _bank.bankaccnt_name;
  END IF;

  -- Place a final balancing detail record.
  -- Check that the balancing record actually balances.
  IF (_totalcr != _totaldb) THEN
    RAISE EXCEPTION 'Cannot write an ABA file for % because the total credits: % does not equal the total debits: %, file will not balance.',
    _bank.bankaccnt_name, _totalcr, _totaldb;
  END IF;


  _detailcount := _detailcount + 1;
  _row.achline_checkhead_id := NULL;
  _row.achline_batch := _filenum;
  _row.achline_type := 'BALANCING';
  -- keep in sync with the other batchcontrol record format above
  -- THE FOLLOWING IS THE DEBIT BALANCING RECORD
  _row.achline_value := RPAD('1'                          -- record type 1
    || _bank.bankaccnt_routing                            -- Austalian BSB #
    || LPAD(_bank.bankaccnt_accntnumber, 9)               -- company account no.
    || ' '                                                -- withholding tax indicator
    || '13'                                               -- transaction code
    || to_char(_totaldb,'FM09999999V99')                  -- the balancing amount
    || RPAD(fetchMetricText('ACHCompanyName'),   32)      -- company name
    || RPAD('DIRECT DEPOSIT',18)
    || _bank.bankaccnt_routing                            -- Austalian BSB #
    || RPAD(_bank.bankaccnt_accntnumber, 9)               -- company account number
    || RPAD(fetchMetricText('ACHCompanyName'), 16)        -- company account name
    || LPAD('', 8, '0'),                                  -- Witholding Tax Amount
    120                                                   -- line width
  );
  RETURN NEXT _row;

  RAISE DEBUG 'formatABAChecks building TRAILER with _totaldb %, _totalcr %, _detailcount %',
               _totaldb, _totalcr, _detailcount;
  -- file control record
  _row.achline_checkhead_id := NULL;
  _row.achline_batch := _filenum;
  _row.achline_type := 'TRAILER';
  _row.achline_value := RPAD('7'                                    -- record type 7
    || RPAD('999-999',   7)                                         -- BSB format filler
    || RPAD('' , 12)                                                -- blank
    || LPAD(to_char((_totaldb - _totalcr),'FM09999999V99'),10,'0')  -- net total amount
    || LPAD(to_char(_totalcr, 'FM09999999V99'),10,'0')              -- total credit amount
    || LPAD(to_char(_totaldb, 'FM09999999V99'),10,'0')              -- total debit amount
    || RPAD('', 24)                                                 -- blank
    || RPAD(to_char(_detailcount, 'FM000000'), 6,'0'),              -- count of type 1 records
    120                                                             -- blank fill
  );

  RETURN NEXT _row;


  UPDATE bankaccnt
  SET bankaccnt_ach_lastdate=CURRENT_DATE,
    bankaccnt_ach_lastfileid=_bank.bankaccnt_ach_lastfileid
  WHERE (bankaccnt_id=_bank.bankaccnt_id);

  RETURN;

END;
$_$;


ALTER FUNCTION public.formatabachecks(integer, integer, text) OWNER TO admin;

--
-- TOC entry 1585 (class 1255 OID 146566162)
-- Dependencies: 2648 4536 8
-- Name: formatachchecks(integer, integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatachchecks(integer, integer, text) RETURNS SETOF achline
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pbankaccntid     ALIAS FOR $1;   -- all unprinted checks for this bankaccnt
  pcheckheadid     ALIAS FOR $2;   -- but if 2nd arg not null then just 1 check
  penckey          ALIAS FOR $3;
  _bank            RECORD;
  _batchcount      INTEGER := 0;
  _batchcr         NUMERIC := 0;
  _batchdate       DATE;
  _batchdb         NUMERIC := 0;
  _batchhash       INTEGER := 0;
  _check           RECORD;
  _ccdnumber       TEXT;
  _ccdname         TEXT;
  _entrycount      INTEGER := 0;
  _filenum         TEXT;
  _prevsec         TEXT;
  _row             achline%ROWTYPE;
  _rowcount        INTEGER := 0;
  _sec             TEXT;
  _serviceclass    TEXT := '200';    -- 220 = credits, 225 = debits, 200 = mixed
  _totalcr         NUMERIC := 0;
  _totaldb         NUMERIC := 0;
  _totalentrycnt   INTEGER := 0;
  _totalhash       INTEGER := 0;
  _transactionprefix TEXT;

BEGIN
  -- General notes:
  -- Numeric values are formatted using RPAD(TO_CHAR(#, '0..0SG', #)).
  --    TO_CHAR(#, ...) (at least in the default server locale) puts a space at
  --    the beginning of the string for numbers >= 0 and '-' for numbers < 0.
  --    'SG' pushes the sign char to the end, then RPAD cuts it off.
  -- This whole thing is US-centric, as that's where the NACHA is.
  -- Currently restricted to checks to Vendor; there's no support for checks to
  --    customers or tax authorities, or for debits or corrections.

  IF (NOT fetchMetricBool('ACHEnabled')) THEN
    RAISE EXCEPTION 'Cannot format the ACH file because the system is not configured for ACH file generation.';
  END IF;
  IF (LENGTH(COALESCE(penckey, '')) <= 0) THEN
    RAISE EXCEPTION 'Cannot format the ACH file because there is no encryption key.';
  END IF;

  SELECT * INTO _bank
  FROM bankaccnt
  WHERE (bankaccnt_id=pbankaccntid);

  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Could not find the bank information to create the ACH file.';
  ELSIF (NOT _bank.bankaccnt_ach_enabled) THEN
    RAISE EXCEPTION 'Cannot format the ACH file because the Bank Account % is not configured for ACH transactions.',
      _bank.bankaccnt_name;
  ELSIF (LENGTH(COALESCE(_bank.bankaccnt_routing, '')) <= 0) THEN
    RAISE EXCEPTION 'Cannot format the ACH file because the Bank Account % has no routing number.',
      _bank.bankaccnt_name;
  END IF;

  _filenum := LPAD(fetchNextNumber('ACHBatch'), 8, '0');

  IF (COALESCE(_bank.bankaccnt_ach_lastdate,startOfTime()) < CURRENT_DATE
      OR _bank.bankaccnt_ach_lastfileid IS NULL) THEN
    _bank.bankaccnt_ach_lastfileid = '0';
  ELSIF (_bank.bankaccnt_ach_lastfileid = '9') THEN
    _bank.bankaccnt_ach_lastfileid = 'A';
  ELSIF (_bank.bankaccnt_ach_lastfileid = 'Z') THEN
    RAISE EXCEPTION 'Cannot write % check % to an ACH file because too many files have been written for this bank already today.',
                  _bank.bankaccnt_name, _check.checkhead_number;
  ELSE
    _bank.bankaccnt_ach_lastfileid = CHR(ASCII(_bank.bankaccnt_ach_lastfileid) + 1);
  END IF;

  _rowcount := _rowcount + 1;
  _row.achline_checkhead_id := NULL;
  _row.achline_batch := _filenum;
  _row.achline_type := 'FILEHEADER';
  _row.achline_value := RPAD('1'
                          || '01'
                          || RPAD(CASE WHEN _bank.bankaccnt_ach_desttype = 'B' THEN ' ' || _bank.bankaccnt_routing
                                       WHEN _bank.bankaccnt_ach_desttype = 'F' THEN ' ' || _bank.bankaccnt_ach_fed_dest
                                       ELSE _bank.bankaccnt_ach_dest END, 10)
                          || RPAD(CASE WHEN _bank.bankaccnt_ach_origintype = 'B' THEN ' ' || _bank.bankaccnt_routing
                                       WHEN _bank.bankaccnt_ach_origintype = 'I' THEN formatAchCompanyId()
                                       ELSE _bank.bankaccnt_ach_origin END, 10)
                          || TO_CHAR(CURRENT_DATE,      'YYMMDD')
                          || TO_CHAR(CURRENT_TIMESTAMP, 'HH24MM')
                          || UPPER(_bank.bankaccnt_ach_lastfileid)
                          || '094'
                          || '10'
                          || '1'
                          || RPAD(CASE WHEN _bank.bankaccnt_ach_desttype = 'B' THEN _bank.bankaccnt_bankname
                                       WHEN _bank.bankaccnt_ach_desttype = 'F' THEN 'Federal Reserve'
                                       ELSE _bank.bankaccnt_ach_destname END, 23)
                          || RPAD(CASE WHEN _bank.bankaccnt_ach_origintype = 'B' THEN ' ' || _bank.bankaccnt_bankname
                                       WHEN _bank.bankaccnt_ach_origintype = 'I' THEN fetchMetricText('ACHCompanyName')
                                       ELSE _bank.bankaccnt_ach_originname END, 23)
                          || RPAD(_filenum, 8),
                          94);
  RETURN NEXT _row;

  FOR _check IN SELECT *
                FROM checkhead
                JOIN vendinfo ON (checkhead_recip_type='V'
                              AND checkhead_recip_id=vend_id
                              AND vend_ach_enabled)
                JOIN curr_symbol ON (checkhead_curr_id=curr_id)
                LEFT OUTER JOIN crmacct ON (crmacct_vend_id=vend_id)
                WHERE ((checkhead_bankaccnt_id=pbankaccntid)
                   AND (checkhead_amount > 0)
                   AND (checkhead_id=pcheckheadid OR pcheckheadid IS NULL)
                   AND NOT checkhead_posted
                   AND NOT checkhead_replaced
                   AND NOT checkhead_deleted
                   AND NOT checkhead_void
                   AND NOT checkhead_printed
                   AND (LENGTH(COALESCE(checkhead_ach_batch,'')) <= 0)
                   AND (curr_abbr='USD'))
                ORDER BY checkhead_checkdate, vend_name LOOP

    IF (COALESCE(_check.checkhead_number, -1) <= 0
        AND _bank.bankaccnt_ach_genchecknum) THEN
      _check.checkhead_number := fetchNextCheckNumber(_check.checkhead_bankaccnt_id);
    END IF;

    _prevsec := _sec;

    IF (_check.crmacct_type = 'I') THEN
      _sec := 'PPD';
    ELSE
      _sec := 'CCD';
      IF (_check.crmacct_id IS NULL) THEN
        RAISE NOTICE 'Vendor % does not have a corresponding crmacct record.',
                     _check.checkhead_recip_id;
      ELSIF (_check.crmacct_type IS NULL) THEN
        RAISE NOTICE 'crmacct for vendor % does not have a valid crmacct_type.',
                     _check.checkhead_recip_id;
      END IF;
    END IF;

    _ccdnumber := CASE WHEN _check.vend_ach_use_vendinfo THEN _check.vend_number
                       ELSE _check.vend_ach_indiv_number
                  END;
    _ccdname := CASE WHEN _check.vend_ach_use_vendinfo THEN _check.vend_name
                     ELSE _check.vend_ach_indiv_name
                END;

    IF (COALESCE(_check.vend_ach_routingnumber, '') = '') THEN
      RAISE EXCEPTION 'Cannot write % check % to an ACH file because the routing number for % has not been supplied.',
                  _bank.bankaccnt_name, _check.checkhead_number, _ccdnumber;
    ELSIF (COALESCE(_check.vend_ach_accntnumber, '') = '') THEN
      RAISE EXCEPTION 'Cannot write % check % to an ACH file because the account number for % has not been supplied.',
                  _bank.bankaccnt_name, _check.checkhead_number, _ccdnumber;
    END IF;
    _check.vend_ach_routingnumber := decrypt(setbytea(_check.vend_ach_routingnumber),
                                         setbytea(penckey), 'bf');
    _check.vend_ach_accntnumber   := decrypt(setbytea(_check.vend_ach_accntnumber),
                                         setbytea(penckey), 'bf');
    _transactionprefix := CASE WHEN (_check.vend_ach_accnttype = 'K') THEN '2'
                               WHEN (_check.vend_ach_accnttype = 'C') THEN '3'
                          END;

    -- create separate batches for each check date and for PPD vs CCD
    IF (COALESCE(_batchdate, startOfTime()) != _check.checkhead_checkdate
        OR (_prevsec != _sec)) THEN
      IF (_batchcount > 0) THEN
        _rowcount := _rowcount + 1;
        _row.achline_checkhead_id := NULL;
        _row.achline_batch := _filenum;
        _row.achline_type := 'BATCHCONTROL';
        -- keep in sync with the other batchcontrol record format below
        _row.achline_value := RPAD('8'
                                || _serviceclass
                                || RPAD(TO_CHAR(_entrycount, '000000SG'), 6)
                                || RPAD(TO_CHAR(_batchhash % 10000000000,
                                                '0000000000SG'), 10)
                                || RPAD(TO_CHAR(_batchdb, '0000000000V99SG'), 12)
                                || RPAD(TO_CHAR(_batchcr, '0000000000V99SG'), 12)
                                || RPAD(formatAchCompanyId(), 10)
                                || RPAD(' ', 19)
                                || RPAD(' ',  6)
                                || RPAD(_bank.bankaccnt_routing, 8)
                                || RPAD(TO_CHAR(_batchcount, '0000000SG'), 7),
                                94);
        RETURN NEXT _row;
      END IF;

      _batchhash     := 0;
      _batchcr       := 0;
      _batchdb       := 0;
      _batchdate     := _check.checkhead_checkdate;
      _entrycount    := 0;
      _rowcount      := _rowcount + 1;
      _batchcount    := _batchcount + 1;
      _row.achline_checkhead_id := NULL;
      _row.achline_batch := _filenum;
      _row.achline_type := 'BATCHHEADER';

      -- effective entry date = 1 or 2 banking days after the banking day
      -- of processing (the following accounts for weekends but not holidays)

      _row.achline_value := RPAD('5'
                              || _serviceclass
                              || RPAD(fetchMetricText('ACHCompanyName'), 16)
                              || RPAD('', 20)   -- TODO: find a use
                              || RPAD(formatAchCompanyId(), 10)
                              || _sec
                              || RPAD('xTuple ERP', 10)
                              || TO_CHAR(_check.checkhead_checkdate, 'YYMMDD')
                              || TO_CHAR(CURRENT_DATE +
                                         COALESCE(_bank.bankaccnt_ach_leadtime,1) +
                                         CASE WHEN EXTRACT(DOW FROM CURRENT_DATE) = 5 THEN 2
                                              WHEN EXTRACT(DOW FROM CURRENT_DATE) = 6 THEN 1
                                              ELSE 0 END,
                                         'YYMMDD')
                              || RPAD('', 3)
                              || '1'
                              || RPAD(_bank.bankaccnt_routing, 8)
                              || RPAD(TO_CHAR(_batchcount, '0000000SG'), 7),
                              94);
      RETURN NEXT _row;
    END IF;

    _row.achline_checkhead_id := _check.checkhead_id;
    _row.achline_batch        := _filenum;
    _row.achline_type         := _sec;

    IF (_sec = 'CCD' OR _sec = 'PPD') THEN
      _rowcount      := _rowcount + 1;
      _entrycount    := _entrycount + 1;
      _totalentrycnt := _totalentrycnt + 1;
      _batchhash     := _batchhash + CAST(SUBSTRING(_bank.bankaccnt_routing FOR 8) AS INTEGER);
      _totalhash     := _totalhash + CAST(SUBSTRING(_bank.bankaccnt_routing FOR 8) AS INTEGER);
      _batchdb       := _batchdb + _check.checkhead_amount;
      _totaldb       := _totaldb + _check.checkhead_amount;

      _row.achline_value := RPAD('6'
                              || _transactionprefix || '7'              -- debit
                              || RPAD(_bank.bankaccnt_routing,      9)  -- 2 fields
                              || RPAD(_bank.bankaccnt_accntnumber, 17)
                              || RPAD(TO_CHAR(_check.checkhead_amount,
                                              '00000000V99SG'), 10)
                              || RPAD(fetchMetricText('ACHCompanyId'),   15)
                              || RPAD(fetchMetricText('ACHCompanyName'), 22)
                              || RPAD(TO_CHAR(_check.checkhead_id % 100, '00SG'),
                                      2)        -- last 2 digits of checkhead_id
                              || '0'
                              || RPAD(_bank.bankaccnt_routing, 9)  -- split field
                              || RPAD(TO_CHAR(_entrycount, '000000SG'), 15-9),
                              94);
      RETURN NEXT _row;

      _rowcount      := _rowcount + 1;
      _entrycount    := _entrycount + 1;
      _totalentrycnt := _totalentrycnt + 1;
      _batchhash     := _batchhash + CAST(SUBSTRING(formatbytea(_check.vend_ach_routingnumber) FOR 8) AS INTEGER);
      _totalhash     := _totalhash + CAST(SUBSTRING(formatbytea(_check.vend_ach_routingnumber) FOR 8) AS INTEGER);
      _totalcr       := _totalcr + _check.checkhead_amount;
      _batchcr       := _batchcr + _check.checkhead_amount;
      _row.achline_value := RPAD('6'
                              || _transactionprefix || '2'              -- credit
                              || RPAD(formatbytea(_check.vend_ach_routingnumber), 9)   -- 2 fields
                              || RPAD(formatbytea(_check.vend_ach_accntnumber), 17)
                              || RPAD(TO_CHAR(_check.checkhead_amount,
                                              '00000000V99SG'), 10)
                              || RPAD(_ccdnumber, 15)
                              || RPAD(_ccdname,   22)
                              || RPAD(TO_CHAR(_check.checkhead_id % 100, '00SG'),
                                      2)        -- last 2 digits of checkhead_id
                              || '0'
                              || RPAD(_bank.bankaccnt_routing, 9)  -- split field
                              || RPAD(TO_CHAR(_entrycount, '000000SG'), 15-9),
                              94);
      RETURN NEXT _row;

    ELSE
      RAISE EXCEPTION 'Cannot write % check % to an ACH file because % is not a supported SEC code.',
                    _bank.bankaccnt_name, _check.checkhead_number, _sec;
    END IF;

    UPDATE checkhead
    SET checkhead_ach_batch=_filenum,
        checkhead_number=_check.checkhead_number
    WHERE (checkhead_id=_check.checkhead_id);

  END LOOP;

  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Cannot write an ACH file for % because there are no checks pending in USD for ACH-enabled Vendors.',
                    _bank.bankaccnt_name;
  END IF;

  -- place a final batch control record
  IF (_batchcount > 0) THEN
    _rowcount := _rowcount + 1;
    _row.achline_checkhead_id := NULL;
    _row.achline_batch := _filenum;
    _row.achline_type := 'BATCHCONTROL';
    -- keep in sync with the other batchcontrol record format above
    _row.achline_value := RPAD('8'
                            || _serviceclass
                            || RPAD(TO_CHAR(_entrycount, '000000SG'), 6)
                            || RPAD(TO_CHAR(_batchhash % 10000000000,
                                            '0000000000SG'), 10)
                            || RPAD(TO_CHAR(_batchdb, '0000000000V99SG'), 12)
                            || RPAD(TO_CHAR(_batchcr, '0000000000V99SG'), 12)
                            || RPAD(formatAchCompanyId(), 10)
                            || RPAD(' ', 19)
                            || RPAD(' ',  6)
                            || RPAD(_bank.bankaccnt_routing, 8)
                            || RPAD(TO_CHAR(_batchcount, '0000000SG'), 7),
                            94);
    RETURN NEXT _row;
  END IF;

  -- and end with a file control record
  _rowcount := _rowcount + 1;
  _row.achline_checkhead_id := NULL;
  _row.achline_batch := _filenum;
  _row.achline_type := 'FILECONTROL';
  _row.achline_value := RPAD('9'
                          || RPAD(TO_CHAR(_batchcount,    '000000SG'),   6)
                          || RPAD(TO_CHAR(_rowcount,      '000000SG'),   6)
                          || RPAD(TO_CHAR(_totalentrycnt, '00000000SG'), 8)
                          || RPAD(TO_CHAR(_totalhash % 10000000000,
                                          '0000000000SG'), 10)
                          || RPAD(TO_CHAR(_totaldb, '0000000000V99SG'), 12)
                          || RPAD(TO_CHAR(_totalcr, '0000000000V99SG'), 12)
                          || RPAD('', 39),
                          94);

  RETURN NEXT _row;

  -- file must be a multiple of 10 lines long
  _row.achline_checkhead_id := NULL;
  _row.achline_batch := _filenum;
  _row.achline_type := 'BLOCKFILL';
  WHILE (_rowcount % 10 > 0) LOOP
    _rowcount := _rowcount + 1;
    _row.achline_value := RPAD('99999999999999999999'
                            || '99999999999999999999'
                            || '99999999999999999999'
                            || '99999999999999999999'
                            || '99999999999999999999', 94);
    RETURN NEXT _row;
  END LOOP;

  UPDATE bankaccnt
  SET bankaccnt_ach_lastdate=CURRENT_DATE,
      bankaccnt_ach_lastfileid=_bank.bankaccnt_ach_lastfileid
  WHERE (bankaccnt_id=_bank.bankaccnt_id);

  RETURN;

END;
$_$;


ALTER FUNCTION public.formatachchecks(integer, integer, text) OWNER TO admin;

--
-- TOC entry 1586 (class 1255 OID 146566164)
-- Dependencies: 4536 8
-- Name: formatachcompanyid(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatachcompanyid() RETURNS text
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN CASE WHEN fetchMetricText('ACHCompanyIdType') = 'D' THEN '3'
              WHEN fetchMetricText('ACHCompanyIdType') = 'E' THEN '1'
              WHEN fetchMetricText('ACHCompanyIdType') = 'O' THEN '9'
         END ||
         CASE WHEN fetchMetricText('ACHCompanyIdType') = 'D' OR
                   fetchMetricText('ACHCompanyIdType') = 'E' THEN
                 REPLACE(fetchMetricText('ACHCompanyId'), '-', '')
              ELSE fetchMetricText('ACHCompanyId')
         END;
END;
$$;


ALTER FUNCTION public.formatachcompanyid() OWNER TO admin;

--
-- TOC entry 1569 (class 1255 OID 146566168)
-- Dependencies: 4536 8
-- Name: formataddr(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formataddr(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pAddrId       ALIAS FOR $1;
  _return       TEXT;

BEGIN
  -- US conventions
  SELECT formatAddr(addr_line1, addr_line2, addr_line3,
                    addr_city || ', ' || addr_state || ' ' || addr_postalcode,
                    addr_country) INTO _return
  FROM addr
  WHERE (addr_id=pAddrId);

  RETURN _return;
END;
$_$;


ALTER FUNCTION public.formataddr(integer) OWNER TO admin;

--
-- TOC entry 1587 (class 1255 OID 146566165)
-- Dependencies: 4536 8
-- Name: formataddr(text, text, text, text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formataddr(text, text, text, text, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  f_addr1 ALIAS FOR $1;
  f_addr2 ALIAS FOR $2;
  f_addr3 ALIAS FOR $3;
  csz     ALIAS FOR $4;
  line    ALIAS FOR $5;

BEGIN
  RETURN formatAddr(f_addr1, f_addr2, f_addr3, csz, '', line);
END;
$_$;


ALTER FUNCTION public.formataddr(text, text, text, text, integer) OWNER TO admin;

--
-- TOC entry 1589 (class 1255 OID 146566167)
-- Dependencies: 4536 8
-- Name: formataddr(text, text, text, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formataddr(text, text, text, text, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  f_addr1 ALIAS FOR $1;
  f_addr2 ALIAS FOR $2;
  f_addr3 ALIAS FOR $3;
  csz     ALIAS FOR $4;
  country ALIAS FOR $5;
  addr TEXT:='';

BEGIN

  IF (LENGTH(TRIM(both from f_addr1)) > 0) THEN
    addr:=f_addr1;
  END IF;

  IF (LENGTH(TRIM(both from f_addr2)) > 0)  THEN
        IF (LENGTH(TRIM(both from addr)) > 0) THEN
                addr:=addr || E'\n';
        END IF;
    addr:=addr || f_addr2;
  END IF;

  IF (LENGTH(TRIM(both from f_addr3)) > 0)  THEN
        IF (LENGTH(TRIM(both from addr)) > 0) THEN
                addr:=addr || E'\n';
        END IF;
    addr:=addr || f_addr3;
  END IF;

  IF (LENGTH(TRIM(both from csz)) > 0)  THEN
        IF (LENGTH(TRIM(both from addr)) > 0) THEN
                addr:=addr || E'\n';
        END IF;
    addr:=addr || csz;
  END IF;

  IF (LENGTH(TRIM(both from country)) > 0)  THEN
        IF (LENGTH(TRIM(both from addr)) > 0) THEN
                addr:=addr || E'\n';
        END IF;
    addr:=addr || country;
  END IF;

  RETURN addr;

END;
$_$;


ALTER FUNCTION public.formataddr(text, text, text, text, text) OWNER TO admin;

--
-- TOC entry 1588 (class 1255 OID 146566166)
-- Dependencies: 4536 8
-- Name: formataddr(text, text, text, text, text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formataddr(text, text, text, text, text, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  f_addr1 ALIAS FOR $1;
  f_addr2 ALIAS FOR $2;
  f_addr3 ALIAS FOR $3;
  csz     ALIAS FOR $4;
  country ALIAS FOR $5;
  line    ALIAS FOR $6;

  i int:=0;

BEGIN

  IF (LENGTH(TRIM(both from f_addr1)) > 0) THEN
    i:=i+1;
  END IF;

  IF (i=line) THEN
    RETURN f_addr1;
  END IF;

  IF (LENGTH(TRIM(both from f_addr2)) > 0)  THEN
    i:=i+1;
  END IF;

  IF (i=line) THEN
    RETURN f_addr2;
  END IF;

  IF (LENGTH(TRIM(both from f_addr3)) > 0) THEN
    i:=i+1;
  END IF;

  IF (i=line) THEN
    RETURN f_addr3;
  END IF;

  IF (LENGTH(TRIM(both from csz)) > 0) THEN
    i:=i+1;
  END IF;

  IF (i=line) THEN
    RETURN csz;
  END IF;

  IF (LENGTH(TRIM(both from country)) > 0) THEN
    i:=i+1;
  END IF;

  IF (i=line) THEN
    RETURN country;
  END IF;

  RETURN ' ';

END;
$_$;


ALTER FUNCTION public.formataddr(text, text, text, text, text, integer) OWNER TO admin;

--
-- TOC entry 1578 (class 1255 OID 146566169)
-- Dependencies: 4536 8
-- Name: formatboolyn(boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatboolyn(boolean) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE pBool ALIAS FOR $1;
BEGIN
  IF (pBool) THEN
    RETURN 'Yes';
  ELSE
    RETURN 'No';
  END IF;
END;
$_$;


ALTER FUNCTION public.formatboolyn(boolean) OWNER TO admin;

--
-- TOC entry 1591 (class 1255 OID 146566170)
-- Dependencies: 4536 8
-- Name: formatbooseq(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatbooseq(integer, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pBooitemSeqId ALIAS FOR $2;
  _result TEXT;

BEGIN

  IF (fetchMetricBool('Routings')) THEN
    SELECT booitem_seqnumber::text INTO _result
    FROM xtmfg.booitem(pItemid)
    WHERE (booitem_seq_id=pBooitemSeqId);

    RETURN _result;
  ELSE
    RETURN NULL;
  END IF;

END;
$_$;


ALTER FUNCTION public.formatbooseq(integer, integer) OWNER TO admin;

--
-- TOC entry 1592 (class 1255 OID 146566171)
-- Dependencies: 4536 8
-- Name: formatbytea(bytea); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatbytea(bytea) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pField ALIAS FOR $1;
  output_field TEXT;

BEGIN

  output_field := pField;

  RETURN output_field;

END;
$_$;


ALTER FUNCTION public.formatbytea(bytea) OWNER TO admin;

--
-- TOC entry 1593 (class 1255 OID 146566172)
-- Dependencies: 4536 8
-- Name: formatccdashes(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatccdashes(text, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCCard ALIAS FOR $1;
  pCCardType ALIAS FOR $2;
  _returnCard text;
  card_length integer;

BEGIN

  IF (pCCardType = 'A')  THEN
    _returnCard := pCCard;
    RETURN _returnCard;
  END IF;

  card_length := length(pCcard);

  if (card_length = 16) THEN
    _returnCard := substr(pCCard, 1, 4) || '-' || substr(pCCard, 5, 4) || '-' || substr(pCCard, 9, 4) || '-' || substr(pCCard, 13, 4);
  ELSE
    _returnCard := substr(pCCard, 1, 4) || '-' || substr(pCCard, 5, 4) || '-' || substr(pCCard, 9, 4) || '-' || substr(pCCard, 13, 1);
  END IF;

  RETURN _returnCard;

END;
$_$;


ALTER FUNCTION public.formatccdashes(text, text) OWNER TO admin;

--
-- TOC entry 1594 (class 1255 OID 146566173)
-- Dependencies: 4536 8
-- Name: formatccnumber(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatccnumber(text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCcardnum ALIAS FOR $1;
  card_length INTEGER;
  output_cardnum TEXT;

BEGIN

  card_length := length(pCcardnum);

  IF (card_length = 13) THEN
    output_cardnum := '*********' || substr(pCcardnum, 10, 4);
  END IF;

  IF (card_length = 14) THEN
    output_cardnum := '**********' || substr(pCcardnum, 11, 4);
  END IF;

  IF (card_length = 15) THEN
    output_cardnum := '***********' || substr(pCcardnum, 12, 4);
  END IF;

  IF (card_length = 16) THEN
    output_cardnum := '************' || substr(pCcardnum, 13, 4);
  END IF;

  RETURN output_cardnum;

END;
$_$;


ALTER FUNCTION public.formatccnumber(text) OWNER TO admin;

--
-- TOC entry 1595 (class 1255 OID 146566174)
-- Dependencies: 4536 8
-- Name: formatccnumber(bytea); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatccnumber(bytea) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCcardnum ALIAS FOR $1;
  card_length INTEGER;
  output_cardnum TEXT;

BEGIN

  card_length := length(pCcardnum);

  IF (card_length = 13) THEN
    output_cardnum := '*********' || substr(pCcardnum, 10, 4);
  END IF;

  IF (card_length = 14) THEN
    output_cardnum := '**********' || substr(pCcardnum, 11, 4);
  END IF;

  IF (card_length = 15) THEN
    output_cardnum := '***********' || substr(pCcardnum, 12, 4);
  END IF;

  IF (card_length = 16) THEN
    output_cardnum := '************' || substr(pCcardnum, 13, 4);
  END IF;

  RETURN output_cardnum;

END;
$_$;


ALTER FUNCTION public.formatccnumber(bytea) OWNER TO admin;

--
-- TOC entry 1596 (class 1255 OID 146566175)
-- Dependencies: 4536 8
-- Name: formatcntctname(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatcntctname(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCntctId ALIAS FOR $1;
  _r RECORD;
  _rows NUMERIC;

BEGIN

  SELECT cntct_honorific, cntct_first_name, cntct_middle,
    cntct_last_name, cntct_suffix INTO _r
  FROM cntct
  WHERE (cntct_id=pCntctId);

  GET DIAGNOSTICS _rows = ROW_COUNT;
  IF (_rows = 0) THEN
    RETURN '';
  END IF;

  RETURN formatCntctName(_r.cntct_honorific, _r.cntct_first_name, _r.cntct_middle, _r.cntct_last_name, _r.cntct_suffix);

END;
$_$;


ALTER FUNCTION public.formatcntctname(integer) OWNER TO admin;

--
-- TOC entry 1597 (class 1255 OID 146566176)
-- Dependencies: 4536 8
-- Name: formatcntctname(text, text, text, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatcntctname(text, text, text, text, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pHonorific ALIAS FOR $1;
  pFirstName ALIAS FOR $2;
  pMiddle ALIAS FOR $3;
  pLastName ALIAS FOR $4;
  pSuffix ALIAS FOR $5;
  _name TEXT := '';

BEGIN

  IF (LENGTH(TRIM(both from COALESCE(pHonorific,''))) > 0) THEN
    IF (POSITION('.' IN COALESCE(pHonorific, '')) > 0) THEN
      _name:= pHonorific;
    ELSE
      _name:= pHonorific || '.';
    END IF;
  END IF;

  IF (LENGTH(TRIM(both from COALESCE(pFirstName,''))) > 0)  THEN
        IF (LENGTH(TRIM(both from _name)) > 0) THEN
                _name:=_name || ' ';
        END IF;
    _name:=_name || pFirstName;
  END IF;

  IF (LENGTH(TRIM(both from COALESCE(pMiddle,''))) > 0)  THEN
        IF (LENGTH(TRIM(both from _name)) > 0) THEN
                _name:=_name || ' ';
        END IF;
    IF (POSITION('.' IN COALESCE(pHonorific, '')) > 0) THEN
      _name:=_name || pMiddle;
    ELSE
      _name:=_name || pMiddle || '.';
    END IF;
  END IF;

  IF (LENGTH(TRIM(both from COALESCE(pLastName,''))) > 0)  THEN
        IF (LENGTH(TRIM(both from _name)) > 0) THEN
                _name:=_name || ' ';
        END IF;
    _name:=_name || pLastName;
  END IF;

  IF (LENGTH(TRIM(both from COALESCE(pSuffix,''))) > 0)  THEN
        IF (LENGTH(TRIM(both from _name)) > 0) THEN
                _name:=_name || ' ';
        END IF;
    _name:=_name || pSuffix;
  END IF;

  RETURN _name;

END;
$_$;


ALTER FUNCTION public.formatcntctname(text, text, text, text, text) OWNER TO admin;

--
-- TOC entry 1598 (class 1255 OID 146566177)
-- Dependencies: 4536 8
-- Name: formatcost(numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatcost(numeric) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN formatNumeric($1, 'cost');
END;$_$;


ALTER FUNCTION public.formatcost(numeric) OWNER TO admin;

--
-- TOC entry 1599 (class 1255 OID 146566178)
-- Dependencies: 4536 8
-- Name: formatcounttagbarcode(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatcounttagbarcode(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCnttagid ALIAS FOR $1;
  _barcode TEXT;
BEGIN

  SELECT ( E'\138CTXX' ||
           LTRIM(TO_CHAR(LENGTH(invcnt_tagnumber), '00')) || invcnt_tagnumber ) INTO _barcode
  FROM invcnt
  WHERE (invcnt_id=pCnttagid);

  RETURN _barcode;

END;
$_$;


ALTER FUNCTION public.formatcounttagbarcode(integer) OWNER TO admin;

--
-- TOC entry 1600 (class 1255 OID 146566179)
-- Dependencies: 4536 8
-- Name: formatcreditmemonumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatcreditmemonumber(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCmheadid ALIAS FOR $1;

BEGIN
  RETURN ( SELECT COALESCE(cmhead_number::TEXT, '')
           FROM cmhead
           WHERE (cmhead_id=pCmheadid) );
END;
$_$;


ALTER FUNCTION public.formatcreditmemonumber(integer) OWNER TO admin;

--
-- TOC entry 1601 (class 1255 OID 146566180)
-- Dependencies: 8
-- Name: formatdate(date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatdate(date) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
SELECT TO_CHAR($1, COALESCE((SELECT locale_dateformat
                             FROM locale, usr
                             WHERE ((usr_locale_id=locale_id)
                              AND (usr_username=getEffectiveXtUser())) ),
                            'yyyy-mm-dd') ) AS result
$_$;


ALTER FUNCTION public.formatdate(date) OWNER TO admin;

--
-- TOC entry 1603 (class 1255 OID 146566182)
-- Dependencies: 8
-- Name: formatdate(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatdate(timestamp with time zone) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
SELECT TO_CHAR($1, COALESCE((SELECT locale_dateformat
                             FROM locale, usr
                             WHERE ((usr_locale_id=locale_id)
                              AND (usr_username=getEffectiveXtUser())) ),
                            'yyyy-mm-dd' )) AS result
$_$;


ALTER FUNCTION public.formatdate(timestamp with time zone) OWNER TO admin;

--
-- TOC entry 1602 (class 1255 OID 146566181)
-- Dependencies: 4536 8
-- Name: formatdate(date, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatdate(date, text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pDate ALIAS FOR $1;
  pString ALIAS FOR $2;

BEGIN

  IF ( (pDate = startOfTime()) OR
       (pDate = endOfTime()) OR
       (pDate IS NULL) ) THEN
    RETURN pString;
  ELSE
    RETURN formatDate(pDate);
  END IF;

END;
$_$;


ALTER FUNCTION public.formatdate(date, text) OWNER TO admin;

--
-- TOC entry 1604 (class 1255 OID 146566183)
-- Dependencies: 8
-- Name: formatdatetime(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatdatetime(timestamp with time zone) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
SELECT TO_CHAR($1, COALESCE((SELECT locale_timestampformat
                             FROM locale, usr
                             WHERE ((usr_locale_id=locale_id)
                              AND (usr_username=getEffectiveXtUser())) ),
                            'yyyy-mm-dd HH24:MI:SS')) AS result
$_$;


ALTER FUNCTION public.formatdatetime(timestamp with time zone) OWNER TO admin;

--
-- TOC entry 1605 (class 1255 OID 146566184)
-- Dependencies: 8
-- Name: formatdatetime(timestamp without time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatdatetime(timestamp without time zone) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
SELECT TO_CHAR($1, COALESCE((SELECT locale_timestampformat
                             FROM locale, usr
                             WHERE ((usr_locale_id=locale_id)
                              AND (usr_username=getEffectiveXtUser())) ),
                            'yyyy-mm-dd HH24:MI:SS')) AS result
$_$;


ALTER FUNCTION public.formatdatetime(timestamp without time zone) OWNER TO admin;

--
-- TOC entry 1606 (class 1255 OID 146566185)
-- Dependencies: 4536 8
-- Name: formatextprice(numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatextprice(numeric) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN formatNumeric($1, 'extprice');
END;$_$;


ALTER FUNCTION public.formatextprice(numeric) OWNER TO admin;

--
-- TOC entry 1607 (class 1255 OID 146566186)
-- Dependencies: 4536 8
-- Name: formatflitemdescrip(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatflitemdescrip(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pFlitemId ALIAS FOR $1;
  _x RECORD;
  _descrip TEXT;

BEGIN
  SELECT flitem_accnt_id, flitem_company, flitem_profit, flitem_number,
        flitem_sub, flitem_type, flitem_subaccnttype_code,
        accnt_id, accnt_descrip INTO _x
  FROM flitem LEFT OUTER JOIN accnt
        ON flitem_accnt_id=accnt_id
  WHERE flitem_id=pFlitemId;

  IF _x.flitem_accnt_id > -1 THEN

    SELECT (formatGLAccount(_x.accnt_id) || '-' || _x.accnt_descrip) INTO _descrip;

  ELSE

    _descrip:='';

    IF _x.flitem_type = 'A' THEN
      _descrip:='Type=' || 'Asset';
      ELSE IF _x.flitem_type='L' THEN
        _descrip:='Type=' || 'Liability';
        ELSE IF _x.flitem_type='R' THEN
          _descrip:='Type=' || 'Revenue';
          ELSE IF _x.flitem_type='E' THEN
            _descrip:='Type=' || 'Expense';
            ELSE IF _x.flitem_type='Q' THEN
              _descrip:='Type=' || 'Equity';
            END IF;
          END IF;
        END IF;
      END IF;
    END IF;

    IF _x.flitem_subaccnttype_code <> 'All' THEN
      IF (LENGTH(TRIM(both from _descrip)) > 0) THEN
        _descrip:=_descrip || ', ';
      END IF;
      _descrip:=_descrip || 'Sub Accnt Type=' || _x.flitem_subaccnttype_code;
    END IF;

    IF _x.flitem_company <> 'All' THEN
      IF (LENGTH(TRIM(both from _descrip)) > 0) THEN
        _descrip:=_descrip || ', ';
      END IF;
      _descrip:=_descrip || 'Company=' || _x.flitem_company;
    END IF;

    IF _x.flitem_profit <> 'All' THEN
      IF (LENGTH(TRIM(both from _descrip)) > 0) THEN
        _descrip:=_descrip || ', ';
      END IF;
      _descrip:=_descrip || 'Profit=' || _x.flitem_profit;
    END IF;

    IF _x.flitem_number <> 'All' THEN
      IF (LENGTH(TRIM(both from _descrip)) > 0) THEN
        _descrip:=_descrip || ', ';
      END IF;
      _descrip:=_descrip || 'Number=' || _x.flitem_number;
    END IF;

    IF _x.flitem_sub <> 'All' THEN
      IF (LENGTH(TRIM(both from _descrip)) > 0) THEN
        _descrip:=_descrip || ', ';
      END IF;
      _descrip:=_descrip || 'Sub Accnt=' || _x.flitem_sub;
    END IF;
  END IF;

  RETURN _descrip;

END;
$_$;


ALTER FUNCTION public.formatflitemdescrip(integer) OWNER TO admin;

--
-- TOC entry 1608 (class 1255 OID 146566187)
-- Dependencies: 4536 8
-- Name: formatglaccount(text, text, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatglaccount(text, text, text, text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCompany ALIAS FOR $1;
  pProfit ALIAS FOR $2;
  pNumber ALIAS FOR $3;
  pSub    ALIAS FOR $4;
  _number TEXT := '';

BEGIN

  IF ( ( SELECT metric_value::INTEGER
         FROM metric
         WHERE (metric_name='GLCompanySize') ) > 0 ) THEN
    _number := pCompany || '-';
  END IF;

  IF ( ( SELECT metric_value::INTEGER
         FROM metric
         WHERE (metric_name='GLProfitSize') ) > 0 ) THEN
    _number := _number || pProfit || '-';
  END IF;

  _number := _number || pNumber;

  IF ( ( SELECT metric_value::INTEGER
         FROM metric
         WHERE (metric_name='GLSubaccountSize') ) > 0 ) THEN
    _number := _number || '-' || pSub;
  END IF;

  RETURN _number;

END;
$_$;


ALTER FUNCTION public.formatglaccount(text, text, text, text) OWNER TO admin;

--
-- TOC entry 1609 (class 1255 OID 146566188)
-- Dependencies: 4536 8
-- Name: formatglaccountlong(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatglaccountlong(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pAccntid ALIAS FOR $1;
  _result TEXT;

BEGIN

  SELECT (formatGLAccount(accnt_id) || '-' || accnt_descrip) INTO _result
  FROM accnt
  WHERE (accnt_id=pAccntid);

  RETURN _result;

END;
$_$;


ALTER FUNCTION public.formatglaccountlong(integer) OWNER TO admin;

--
-- TOC entry 1610 (class 1255 OID 146566189)
-- Dependencies: 4536 8
-- Name: formatindent(text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatindent(text, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pText ALIAS FOR $1;
  pIndent ALIAS FOR $2;
  _i INTEGER;
  _result TEXT;

BEGIN
  _result := '';
  _i := 0;

  WHILE _i < pIndent LOOP
    _result := _result || '  ';
    _i := _i + 1;
  END LOOP;

  _result := _result || pText;
  RETURN _result;
END;
$_$;


ALTER FUNCTION public.formatindent(text, integer) OWNER TO admin;

--
-- TOC entry 1611 (class 1255 OID 146566190)
-- Dependencies: 8
-- Name: formatinterval(numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatinterval(numeric) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT TO_CHAR(('@ ' || trunc($1) || ' min ' ||
                             ($1 - trunc($1)) * 60 || ' sec')::INTERVAL,
                 ( SELECT locale_intervalformat
                       FROM locale, usr
                       WHERE ((usr_locale_id=locale_id)
                         AND  (usr_username=getEffectiveXtUser())) ) ) AS result
$_$;


ALTER FUNCTION public.formatinterval(numeric) OWNER TO admin;

--
-- TOC entry 1612 (class 1255 OID 146566191)
-- Dependencies: 8
-- Name: formatinterval(interval); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatinterval(interval) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT TO_CHAR($1, ( SELECT locale_intervalformat
                       FROM locale, usr
                       WHERE ((usr_locale_id=locale_id)
                         AND  (usr_username=getEffectiveXtUser())) ) ) AS result
$_$;


ALTER FUNCTION public.formatinterval(interval) OWNER TO admin;

--
-- TOC entry 1613 (class 1255 OID 146566192)
-- Dependencies: 4536 8
-- Name: formatinvcnumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatinvcnumber(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCobmiscid ALIAS FOR $1;

BEGIN
  RETURN ( SELECT COALESCE(cobmisc_invcnumber::TEXT, '')
           FROM cobmisc
           WHERE (cobmisc_id=pCobmiscid) );
END;
$_$;


ALTER FUNCTION public.formatinvcnumber(integer) OWNER TO admin;

--
-- TOC entry 1614 (class 1255 OID 146566193)
-- Dependencies: 4536 8
-- Name: formatitemsitebarcode(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatitemsitebarcode(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  _barcode TEXT;
BEGIN

  SELECT ( E'\138ISXX' ||
           LTRIM(TO_CHAR(LENGTH(item_number), '00')) || LENGTH(warehous_code)::TEXT ||
           item_number || warehous_code ) INTO _barcode
  FROM itemsite, item, whsinfo
  WHERE ( (itemsite_item_id=item_id)
   AND (itemsite_warehous_id=warehous_id)
   AND (itemsite_id=pItemsiteid) );

  RETURN _barcode;

END;
$_$;


ALTER FUNCTION public.formatitemsitebarcode(integer) OWNER TO admin;

--
-- TOC entry 1615 (class 1255 OID 146566194)
-- Dependencies: 4536 8
-- Name: formatlocationbarcode(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatlocationbarcode(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pLocationid ALIAS FOR $1;
  _barcode TEXT;
BEGIN

  SELECT ( E'\138LOXX' ||
           LENGTH(warehous_code)::TEXT || LTRIM(TO_CHAR(LENGTH(location_name::TEXT), '00')) ||
           warehous_code || location_name ) INTO _barcode
  FROM location, whsinfo
  WHERE ( (location_warehous_id=warehous_id)
   AND (location_id=pLocationid) );

  RETURN _barcode;

END;
$_$;


ALTER FUNCTION public.formatlocationbarcode(integer) OWNER TO admin;

--
-- TOC entry 1616 (class 1255 OID 146566195)
-- Dependencies: 4536 8
-- Name: formatlocationcontentsbarcode(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatlocationcontentsbarcode(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pLocationid ALIAS FOR $1;
  _barcode TEXT;
BEGIN

  SELECT ( E'\138LOCN' ||
           LENGTH(warehous_code)::TEXT || LTRIM(TO_CHAR(LENGTH(location_name), '00')) ||
           warehous_code || location_name ) INTO _barcode
  FROM location, whsinfo
  WHERE ( (location_warehous_id=warehous_id)
   AND (location_id=pLocationid) );

  RETURN _barcode;

END;
$_$;


ALTER FUNCTION public.formatlocationcontentsbarcode(integer) OWNER TO admin;

--
-- TOC entry 1617 (class 1255 OID 146566196)
-- Dependencies: 4536 8
-- Name: formatlocationissuebarcode(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatlocationissuebarcode(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pLocationid ALIAS FOR $1;
  _barcode TEXT;
BEGIN

  SELECT ( E'\138LOIS' ||
           LENGTH(warehous_code)::TEXT || LTRIM(TO_CHAR(LENGTH(location_name), '00')) ||
           warehous_code || location_name ) INTO _barcode
  FROM location, whsinfo
  WHERE ( (location_warehous_id=warehous_id)
   AND (location_id=pLocationid) );

  RETURN _barcode;

END;
$_$;


ALTER FUNCTION public.formatlocationissuebarcode(integer) OWNER TO admin;

--
-- TOC entry 1618 (class 1255 OID 146566197)
-- Dependencies: 4536 8
-- Name: formatlotserialnumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatlotserialnumber(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pLotSerialId ALIAS FOR $1;
  _lotserial TEXT;

BEGIN
  --See if lot serial control turned on (Postbooks will not ever have this)
  IF (fetchmetricbool('LotSerialControl')) THEN
    SELECT ls_number INTO _lotserial
    FROM ls
    WHERE (ls_id=pLotSerialId);
  END IF;

  RETURN COALESCE(_lotserial,'');

END;
$_$;


ALTER FUNCTION public.formatlotserialnumber(integer) OWNER TO admin;

--
-- TOC entry 1619 (class 1255 OID 146566198)
-- Dependencies: 4536 8
-- Name: formatmoney(numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatmoney(numeric) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN formatNumeric($1, 'curr');
END;$_$;


ALTER FUNCTION public.formatmoney(numeric) OWNER TO admin;

--
-- TOC entry 1620 (class 1255 OID 146566199)
-- Dependencies: 4536 8
-- Name: formatnumeric(numeric, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatnumeric(numeric, text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _value        NUMERIC := $1;
  _type         TEXT    := LOWER(COALESCE($2, 'curr'));
  _abs          NUMERIC;
  _magnitudecnt NUMERIC(1000);
  _wholefmt     TEXT    := '0';
  _scale        INTEGER;
  _neg          TEXT;
  _decimal      TEXT;
  _group        TEXT;
  _string       TEXT;
  _debug        BOOL := false;
  _r            RECORD;

BEGIN
  -- If the value passed in is NULL then we want to pass back an empty string
  IF(_value IS NULL) THEN
    RETURN '';
  END IF;

  SELECT * INTO _r
  FROM locale
  WHERE (locale_id=getUsrLocaleId());

  _decimal := COALESCE(SUBSTRING(_r.locale_qtyformat FROM 1 FOR 1), '.');
  _neg     := COALESCE(SUBSTRING(_r.locale_qtyformat FROM 2 FOR 1), '-');
  _group   := COALESCE(SUBSTRING(_r.locale_qtyformat FROM 3 FOR 1), ',');

  _scale   := CASE WHEN _type = 'cost'       THEN _r.locale_cost_scale
                   WHEN _type = 'extprice'   THEN _r.locale_extprice_scale
                   WHEN _type = 'percent'    THEN _r.locale_percent_scale
                   WHEN _type = 'purchprice' THEN _r.locale_purchprice_scale
                   WHEN _type = 'qty'        THEN _r.locale_qty_scale
                   WHEN _type = 'qtyper'     THEN _r.locale_qtyper_scale
                   WHEN _type = 'salesprice' THEN _r.locale_salesprice_scale
                   WHEN _type = 'uomratio'   THEN _r.locale_uomratio_scale
                   WHEN _type = 'weight'     THEN _r.locale_weight_scale
                   WHEN SUBSTRING(_type FOR 4) = 'curr' THEN _r.locale_curr_scale
                   ELSE 2
              END;

  _value        := round(_value, _scale);
  _abs          := ABS(_value);
  _magnitudecnt := TRUNC(_abs / 10);

  IF (_debug) THEN
    RAISE NOTICE '_value % _abs % _scale % _neg % _decimal % _group % ',
                 _value, _abs, _scale, _decimal, _group, _scale;
  END IF;

  IF (_value < 0) THEN
    _string := _neg;
  ELSE
    _string := '';
  END IF;

  WHILE (_magnitudecnt >= 1) LOOP
    _magnitudecnt := TRUNC(_magnitudecnt / 10);
    IF (LENGTH(_wholefmt) % 3 = 0) THEN
      _wholefmt := '"' || _group || '"' || _wholefmt;
    END IF;
    _wholefmt := '9' || _wholefmt;
  END LOOP;

  IF (_scale > 0) THEN
    _abs := (_abs * (10 ^ _scale));
    _abs := TRUNC(_abs);
    _wholefmt := _wholefmt || '"' || _decimal || '"' || REPEAT('0', _scale);
  END IF;

  _wholefmt := 'FM' || _wholefmt;
  _string := _string || to_char(_abs, _wholefmt);

  RETURN _string;
END;$_$;


ALTER FUNCTION public.formatnumeric(numeric, text) OWNER TO admin;

--
-- TOC entry 1621 (class 1255 OID 146566200)
-- Dependencies: 4536 8
-- Name: formatperiodname(integer, character); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatperiodname(integer, character) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPeriodId ALIAS FOR $1;
  pInterval ALIAS FOR $2;
  _result TEXT;

BEGIN

--...for Month

   IF (pInterval='M') THEN
        SELECT
          (CASE
                      WHEN period_name='' THEN
                        formatdate(period_start) || '-' || formatdate(period_end)
                      ELSE period_name
          END) INTO _result
        FROM period
        WHERE (period_id=pPeriodId);

        RETURN _result;

--...for Quarter

        ELSE IF (pInterval='Q') THEN
                SELECT
                        ('Q' || period_quarter || '-' || EXTRACT(year from yearperiod_end)) INTO _result
                FROM period, yearperiod
                WHERE ((period_id=pPeriodId)
                AND (period_yearperiod_id=yearperiod_id));

                RETURN _result;
--...for Year
        ELSE
                SELECT
                        EXTRACT(year FROM yearperiod_end) INTO _result
                FROM period,yearperiod
                WHERE ((period_id=pPeriodId)
                AND (period_yearperiod_id=yearperiod_id));

                RETURN _result;
        END IF;
   END IF;

   RETURN 'Err';

END;
$_$;


ALTER FUNCTION public.formatperiodname(integer, character) OWNER TO admin;

--
-- TOC entry 1622 (class 1255 OID 146566201)
-- Dependencies: 4536 8
-- Name: formatplonumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatplonumber(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPlanordid ALIAS FOR $1;
  _result TEXT;

BEGIN

  SELECT (TEXT(planord_number) || '-' || TEXT(planord_subnumber)) INTO _result
  FROM planord
  WHERE (planord_id=pPlanordid);

  RETURN _result;

END;
$_$;


ALTER FUNCTION public.formatplonumber(integer) OWNER TO admin;

--
-- TOC entry 1623 (class 1255 OID 146566202)
-- Dependencies: 8
-- Name: formatprcnt(numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatprcnt(numeric) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
SELECT formatNumeric($1 * 100, 'percent')  AS result
$_$;


ALTER FUNCTION public.formatprcnt(numeric) OWNER TO admin;

--
-- TOC entry 1624 (class 1255 OID 146566203)
-- Dependencies: 8
-- Name: formatprice(numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatprice(numeric) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT formatNumeric($1, 'salesprice') AS result;
$_$;


ALTER FUNCTION public.formatprice(numeric) OWNER TO admin;

--
-- TOC entry 1625 (class 1255 OID 146566204)
-- Dependencies: 4536 8
-- Name: formatpurchprice(numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatpurchprice(numeric) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN formatNumeric($1, 'purchprice');
END;$_$;


ALTER FUNCTION public.formatpurchprice(numeric) OWNER TO admin;

--
-- TOC entry 1626 (class 1255 OID 146566205)
-- Dependencies: 4536 8
-- Name: formatqty(numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatqty(numeric) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN formatNumeric($1, 'qty');
END;$_$;


ALTER FUNCTION public.formatqty(numeric) OWNER TO admin;

--
-- TOC entry 1627 (class 1255 OID 146566206)
-- Dependencies: 4536 8
-- Name: formatqtyper(numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatqtyper(numeric) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN formatNumeric($1, 'qtyper');
END;$_$;


ALTER FUNCTION public.formatqtyper(numeric) OWNER TO admin;

--
-- TOC entry 1590 (class 1255 OID 146566207)
-- Dependencies: 8
-- Name: formatratio(numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatratio(numeric) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT formatNumeric($1, 'uomratio');
$_$;


ALTER FUNCTION public.formatratio(numeric) OWNER TO admin;

--
-- TOC entry 1628 (class 1255 OID 146566208)
-- Dependencies: 4536 8
-- Name: formatrevnumber(text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatrevnumber(text, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pRevType 	ALIAS FOR $1;
  pRevId 	ALIAS FOR $2;
  _revision 	TEXT;

BEGIN
  --See if revision control turned on (Postbooks will not ever have this)
  IF (fetchmetricbool('RevControl')) THEN
    SELECT rev_number INTO _revision
    FROM rev
    WHERE ((rev_target_type=pRevType)
    AND (rev_id=pRevId));
  END IF;

  RETURN COALESCE(_revision,'');

END;
$_$;


ALTER FUNCTION public.formatrevnumber(text, integer) OWNER TO admin;

--
-- TOC entry 1629 (class 1255 OID 146566209)
-- Dependencies: 4536 8
-- Name: formatsalesprice(numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatsalesprice(numeric) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN formatNumeric($1, 'salesprice');
END;$_$;


ALTER FUNCTION public.formatsalesprice(numeric) OWNER TO admin;

--
-- TOC entry 1630 (class 1255 OID 146566210)
-- Dependencies: 8
-- Name: formatscrap(numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatscrap(numeric) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT formatNumeric(($1 * 100), 'percent') AS result
$_$;


ALTER FUNCTION public.formatscrap(numeric) OWNER TO admin;

--
-- TOC entry 1631 (class 1255 OID 146566211)
-- Dependencies: 4536 8
-- Name: formatshipmentnumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatshipmentnumber(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pshipheadid    ALIAS FOR $1;
BEGIN
  RETURN ( SELECT COALESCE(shiphead_number::TEXT, '')
           FROM shiphead
           WHERE (shiphead_id=pshipheadid) );
END;
$_$;


ALTER FUNCTION public.formatshipmentnumber(integer) OWNER TO admin;

--
-- TOC entry 1632 (class 1255 OID 146566212)
-- Dependencies: 4536 8
-- Name: formatsobarcode(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatsobarcode(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSoheadid ALIAS FOR $1;
  _barcode TEXT;
BEGIN

  SELECT ( E'\138SOXX' ||
           LENGTH(TEXT(cohead_number)) || TEXT(cohead_number) ) INTO _barcode
  FROM cohead
  WHERE (cohead_id=pSoheadid);

  RETURN _barcode;

END;
$_$;


ALTER FUNCTION public.formatsobarcode(integer) OWNER TO admin;

--
-- TOC entry 1633 (class 1255 OID 146566213)
-- Dependencies: 4536 8
-- Name: formatsoitembarcode(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatsoitembarcode(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSoitemid ALIAS FOR $1;
  _barcode TEXT;
BEGIN

  SELECT ( E'\138SOLI' ||
           LENGTH(TEXT(cohead_number)) || LENGTH(formatsolinenumber(coitem_id)) ||
           TEXT(cohead_number) || formatsolinenumber(coitem_id) ) INTO _barcode
  FROM cohead, coitem
  WHERE ( (coitem_cohead_id=cohead_id)
   AND (coitem_id=pSoitemid) );

  RETURN _barcode;

END;
$_$;


ALTER FUNCTION public.formatsoitembarcode(integer) OWNER TO admin;

--
-- TOC entry 1634 (class 1255 OID 146566214)
-- Dependencies: 4536 8
-- Name: formatsoitemnumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatsoitemnumber(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  targetSoitemid ALIAS FOR $1;
BEGIN
  RETURN ( SELECT (cohead_number::TEXT || '-' || formatsolinenumber(coitem_id))
           FROM cohead, coitem
           WHERE ((coitem_cohead_id=cohead_id)
            AND (coitem_id=targetSoitemid)) );
END;
$_$;


ALTER FUNCTION public.formatsoitemnumber(integer) OWNER TO admin;

--
-- TOC entry 1635 (class 1255 OID 146566215)
-- Dependencies: 8
-- Name: formatsonumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatsonumber(integer) RETURNS text
    LANGUAGE sql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
SELECT COALESCE((SELECT (text(cohead_number) || '-' || formatSoLineNumber(coitem_id))
                   FROM coitem JOIN cohead ON (coitem_cohead_id=cohead_id)
                  WHERE (coitem_id=($1))),'DELETED');
$_$;


ALTER FUNCTION public.formatsonumber(integer) OWNER TO admin;

--
-- TOC entry 1636 (class 1255 OID 146566216)
-- Dependencies: 8
-- Name: formattime(timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formattime(timestamp with time zone) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT TO_CHAR($1, ( SELECT locale_timeformat
                       FROM locale, usr
                       WHERE ((usr_locale_id=locale_id)
                        AND (usr_username=getEffectiveXtUser())) ) ) AS result
$_$;


ALTER FUNCTION public.formattime(timestamp with time zone) OWNER TO admin;

--
-- TOC entry 1637 (class 1255 OID 146566217)
-- Dependencies: 8
-- Name: formattime(numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formattime(numeric) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT LTRIM(TO_CHAR(COALESCE($1, 0), '999999990.0'));
$_$;


ALTER FUNCTION public.formattime(numeric) OWNER TO admin;

--
-- TOC entry 1638 (class 1255 OID 146566218)
-- Dependencies: 4536 8
-- Name: formatuomratio(numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatuomratio(numeric) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN formatNumeric($1, 'uomratio');
END;$_$;


ALTER FUNCTION public.formatuomratio(numeric) OWNER TO admin;

--
-- TOC entry 1639 (class 1255 OID 146566219)
-- Dependencies: 4536 8
-- Name: formatuserbarcode(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatuserbarcode(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pUserid ALIAS FOR $1;
  _barcode TEXT;
BEGIN

  SELECT formatUserBarcode(usr_username) INTO _barcode
    FROM usr
   WHERE(usr_id=pUserid);

  RETURN _barcode;

END;
$_$;


ALTER FUNCTION public.formatuserbarcode(integer) OWNER TO admin;

--
-- TOC entry 1640 (class 1255 OID 146566220)
-- Dependencies: 4536 8
-- Name: formatuserbarcode(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatuserbarcode(text) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pUsername ALIAS FOR $1;
  _barcode TEXT;
BEGIN

  _barcode := ( E'\138USER' || LENGTH(pUsername)::TEXT || pUsername );

  RETURN _barcode;

END;
$_$;


ALTER FUNCTION public.formatuserbarcode(text) OWNER TO admin;

--
-- TOC entry 1641 (class 1255 OID 146566221)
-- Dependencies: 8
-- Name: formatweight(numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatweight(numeric) RETURNS text
    LANGUAGE sql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
SELECT formatNumeric($1, 'weight') AS result
$_$;


ALTER FUNCTION public.formatweight(numeric) OWNER TO admin;

--
-- TOC entry 1642 (class 1255 OID 146566222)
-- Dependencies: 4536 8
-- Name: formatwobarcode(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatwobarcode(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoid ALIAS FOR $1;
  _barcode TEXT;
BEGIN

  SELECT ( E'\138WOXX' ||
           LENGTH(wo_number::TEXT) || LENGTH(wo_subnumber::TEXT) ||
           wo_number::TEXT || wo_subnumber::TEXT ) INTO _barcode
  FROM wo
  WHERE (wo_id=pWoid);

  RETURN _barcode;

END;
$_$;


ALTER FUNCTION public.formatwobarcode(integer) OWNER TO admin;

--
-- TOC entry 1643 (class 1255 OID 146566223)
-- Dependencies: 4536 8
-- Name: formatwonumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatwonumber(integer) RETURNS text
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoid ALIAS FOR $1;

BEGIN

  RETURN ( SELECT (wo_number::TEXT || '-' || wo_subnumber::TEXT)
           FROM wo
           WHERE (wo_id=pWoid) );

END;
$_$;


ALTER FUNCTION public.formatwonumber(integer) OWNER TO admin;

--
-- TOC entry 1644 (class 1255 OID 146566224)
-- Dependencies: 4536 8
-- Name: formatwooperseq(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION formatwooperseq(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWooperId  ALIAS FOR $1;
  _result    TEXT;

BEGIN

  IF pWooperId = -1 THEN
    RETURN '';
  ELSE
    SELECT wooper_seqnumber INTO _result
    FROM xtmfg.wooper
    WHERE (wooper_id=pWooperId);
  END IF;

  RETURN _result;
END;
$_$;


ALTER FUNCTION public.formatwooperseq(integer) OWNER TO admin;

--
-- TOC entry 1645 (class 1255 OID 146566225)
-- Dependencies: 4536 8
-- Name: forwardupdateaccount(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION forwardupdateaccount(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pAccntid ALIAS FOR $1;
  _r RECORD;
  _trialbalid INTEGER;

BEGIN
  SELECT trialbal_id, trialbal_dirty,
         CASE WHEN (trialbal_dirty) THEN 0
              ELSE 1
         END AS dirty_seq INTO _r
    FROM trialbal, period
   WHERE ((trialbal_period_id=period_id)
     AND  (trialbal_accnt_id=pAccntid))
   ORDER BY dirty_seq, period_start
   LIMIT 1;
  IF (FOUND) THEN
    IF (_r.trialbal_dirty) THEN
      RETURN forwardUpdateTrialBalance(_r.trialbal_id);
    ELSE
      RETURN _r.trialbal_id;
    END IF;
  ELSE
      _trialbalid := nextval('trialbal_trialbal_id_seq');

      INSERT INTO trialbal
      ( trialbal_id,
        trialbal_period_id, trialbal_accnt_id,
        trialbal_beginning, trialbal_ending,
        trialbal_debits, trialbal_credits, trialbal_dirty )
      SELECT
        _trialbalid,
        period_id, pAccntid,
        0, 0,
        0, 0, FALSE
      FROM period
      ORDER BY period_start LIMIT 1;

      RETURN forwardUpdateTrialBalance(_trialbalid);
  END IF;

  RETURN -1;
END;
$_$;


ALTER FUNCTION public.forwardupdateaccount(integer) OWNER TO admin;

--
-- TOC entry 1646 (class 1255 OID 146566226)
-- Dependencies: 4536 8
-- Name: forwardupdateinvbalance(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION forwardupdateinvbalance(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pInvbalid ALIAS FOR $1;
  _p RECORD;
  _r RECORD;
  _qohEnding NUMERIC;
  _valueEnding NUMERIC;
  _nnEnding NUMERIC;
  _nnvalEnding NUMERIC;

BEGIN

  SELECT invbal_itemsite_id,
         invbal_qoh_ending,
         invbal_value_ending,
         invbal_nn_ending,
         invbal_nnval_ending,
         period_end INTO _p
  FROM invbal
    JOIN period ON (invbal_period_id=period_id)
    JOIN itemsite ON (invbal_itemsite_id=itemsite_id)
  WHERE (invbal_id=pInvbalid);

  _qohEnding = _p.invbal_qoh_ending;
  _valueEnding = _p.invbal_value_ending;
  _nnEnding = _p.invbal_nn_ending;
  _nnvalEnding = _p.invbal_nnval_ending;

--  Find all of the subsequent periods and their inventory balance, if they exist
  FOR _r IN SELECT period_id, period_end,
                   invbal_id,
                   invbal_qty_in, invbal_qty_out,
                   invbal_value_in, invbal_value_out,
                   invbal_nn_in, invbal_nn_out,
                   invbal_nnval_in, invbal_nnval_out
            FROM period
              LEFT OUTER JOIN invbal
                 ON ( (invbal_period_id=period_id) AND (invbal_itemsite_id=_p.invbal_itemsite_id) )
            WHERE (period_start > _p.period_end)
            ORDER BY period_start LOOP

    IF (_r.invbal_id IS NULL) THEN

      INSERT INTO invbal
      ( invbal_period_id, invbal_itemsite_id,
        invbal_qoh_beginning, invbal_qoh_ending,
        invbal_qty_in, invbal_qty_out,
        invbal_value_beginning, invbal_value_ending,
        invbal_value_in, invbal_value_out,
        invbal_nn_beginning, invbal_nn_ending,
        invbal_nn_in, invbal_nn_out,
        invbal_nnval_beginning, invbal_nnval_ending,
        invbal_nnval_in, invbal_nnval_out,
        invbal_dirty )
      VALUES
      ( _r.period_id, _p.invbal_itemsite_id,
        _qohEnding, _qohEnding,
        0, 0,
        _valueEnding, _valueEnding,
        0, 0,
        _nnEnding, _nnEnding,
        0, 0,
        _nnvalEnding, _nnvalEnding,
        0, 0,
        FALSE );
    ELSE
      UPDATE invbal
      SET invbal_qoh_beginning = (_qohEnding),
          invbal_qoh_ending = (_qohEnding + _r.invbal_qty_in - _r.invbal_qty_out),
          invbal_value_beginning = (_valueEnding),
          invbal_value_ending = (_valueEnding + _r.invbal_value_in - _r.invbal_value_out),
          invbal_nn_beginning = (_nnEnding),
          invbal_nn_ending = (_nnEnding + _r.invbal_nn_in - _r.invbal_nn_out),
          invbal_nnval_beginning = (_nnvalEnding),
          invbal_nnval_ending = (_nnvalEnding + _r.invbal_nnval_in - _r.invbal_nnval_out),
          invbal_dirty = FALSE
      WHERE (invbal_id=_r.invbal_id);

      _qohEnding = (_qohEnding + _r.invbal_qty_in - _r.invbal_qty_out);
      _valueEnding = (_valueEnding + _r.invbal_value_in - _r.invbal_value_out);
      _nnEnding = (_nnEnding + _r.invbal_nn_in - _r.invbal_nn_out);
      _nnvalEnding = (_nnvalEnding + _r.invbal_nnval_in - _r.invbal_nnval_out);
    END IF;
  END LOOP;

  UPDATE invbal
  SET invbal_dirty = false
  WHERE (invbal_id=pInvbalid);

  RETURN pInvbalid;

END;
$_$;


ALTER FUNCTION public.forwardupdateinvbalance(integer) OWNER TO admin;

--
-- TOC entry 1647 (class 1255 OID 146566227)
-- Dependencies: 4536 8
-- Name: forwardupdateitemsite(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION forwardupdateitemsite(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteId ALIAS FOR $1;
  _r RECORD;
  _invbalid INTEGER;

BEGIN
  SELECT invbal_id INTO _r
  FROM invbal
      JOIN period ON (invbal_period_id=period_id)
  WHERE (invbal_itemsite_id=pItemsiteid)
  ORDER BY period_start
  LIMIT 1;

  IF (FOUND) THEN
    RETURN forwardUpdateInvbalance(_r.invbal_id);
  ELSE
      _invbalid := nextval('invbal_invbal_id_seq');

      INSERT INTO invbal
      ( invbal_id,
        invbal_period_id, invbal_itemsite_id,
        invbal_qoh_beginning, invbal_qoh_ending,
        invbal_qty_in, invbal_qty_out,
        invbal_value_beginning, invbal_value_ending,
        invbal_value_in, invbal_value_out,
        invbal_nn_beginning, invbal_nn_ending,
        invbal_nn_in, invbal_nn_out,
        invbal_nnval_beginning, invbal_nnval_ending,
        invbal_nnval_in, invbal_nnval_out,
        invbal_dirty )
      SELECT
        _invbalid,
        period_id, pItemsiteid,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        false
      FROM period
      ORDER BY period_start LIMIT 1;

      RETURN forwardUpdateInvbalance(_invbalid);
  END IF;

  RETURN -1;
END;
$_$;


ALTER FUNCTION public.forwardupdateitemsite(integer) OWNER TO admin;

--
-- TOC entry 1648 (class 1255 OID 146566228)
-- Dependencies: 4536 8
-- Name: forwardupdatetrialbalance(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION forwardupdatetrialbalance(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTrialbalid ALIAS FOR $1;
  _p RECORD;
  _r RECORD;
  _ending NUMERIC;
  _prevYear INTEGER;
  _currYear INTEGER;
  _prevYearClosed BOOLEAN;
  _currYearClosed BOOLEAN;
  _result INTEGER;

BEGIN

  SELECT trialbal_accnt_id, trialbal_ending,
         yearperiod_id, yearperiod_closed,
         period_end, accnt_type IN ('E', 'R') AS revexp INTO _p
  FROM trialbal, period, yearperiod, accnt
  WHERE ( (trialbal_period_id=period_id)
   AND (yearperiod_id=period_yearperiod_id)
   AND (trialbal_accnt_id=accnt_id)
   AND (trialbal_id=pTrialbalid) );

  _ending = _p.trialbal_ending;

  SELECT yearperiod_id, yearperiod_closed INTO _prevYear, _prevYearClosed
    FROM yearperiod
   WHERE (_p.period_end BETWEEN yearperiod_start AND yearperiod_end);
  IF (NOT FOUND) THEN
    _prevYear := -1;
    _prevYearClosed := false;
  END IF;

--  Find all of the subsequent periods and their trialbal, if they exist
  FOR _r IN SELECT period_id, period_end,
                   trialbal_id, trialbal_debits, trialbal_credits,
                   trialbal_yearend
            FROM period LEFT OUTER JOIN trialbal
                 ON ( (trialbal_period_id=period_id) AND (trialbal_accnt_id=_p.trialbal_accnt_id) )
            WHERE (period_start > _p.period_end)
            ORDER BY period_start LOOP

    SELECT yearperiod_id, yearperiod_closed INTO _currYear, _currYearClosed
      FROM yearperiod
     WHERE (_r.period_end BETWEEN yearperiod_start AND yearperiod_end);
    IF (NOT FOUND) THEN
      _currYear := -1;
      _currYearClosed := false;
    END IF;

    IF (_p.revexp AND _currYear != _prevYear) THEN
      _ending := 0;
      IF (_prevYearClosed) THEN
        SELECT updateRetainedEarnings(_prevYear) INTO _result;
        IF (_result < 0) THEN
          RETURN _result;
        END IF;
      END IF;
    END IF;

    _prevYear := _currYear;
    _prevYearClosed := _currYearClosed;

    IF (_r.trialbal_id IS NULL) THEN
      -- SELECT SUM(gltrans_amount) INTO _glAmount
       -- FROM gltrans
       -- WHERE ( (gltrans_date BETWEEN _r.period_start and _r.period_end )
         -- AND   (gltrans_accnt_id=_p.trialbal_accnt_id)
         -- AND   (gltrans_posted) );
        -- and change 2nd and 3rd VALUES line of INSERT to read
        --      _ending, _ending + _glAmount,
        --      noneg(0 - _glAmount), noneg(_glAmount), FALSE );

      INSERT INTO trialbal
      ( trialbal_period_id, trialbal_accnt_id,
        trialbal_beginning, trialbal_ending,
        trialbal_debits, trialbal_credits, trialbal_dirty )
      VALUES
      ( _r.period_id, _p.trialbal_accnt_id,
        _ending, _ending,
        0, 0, FALSE );
    ELSE
      UPDATE trialbal
      SET trialbal_beginning = (_ending + trialbal_yearend),
          trialbal_ending = (_ending + trialbal_yearend - _r.trialbal_debits + _r.trialbal_credits),
          trialbal_dirty = FALSE
      WHERE (trialbal_id=_r.trialbal_id);

      _ending = (_ending + _r.trialbal_yearend - _r.trialbal_debits + _r.trialbal_credits);
    END IF;
  END LOOP;

  UPDATE trialbal
  SET trialbal_dirty = FALSE
  WHERE (trialbal_id=pTrialbalid);

  RETURN pTrialbalid;

END;
$_$;


ALTER FUNCTION public.forwardupdatetrialbalance(integer) OWNER TO admin;

--
-- TOC entry 1649 (class 1255 OID 146566229)
-- Dependencies: 4536 8
-- Name: freezeaccountingperiod(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION freezeaccountingperiod(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPeriodid ALIAS FOR $1;

BEGIN

--  Check to make use that the period is not already frozen
  IF ( ( SELECT period_freeze
         FROM period
         WHERE (period_id=pPeriodid) ) ) THEN
    RETURN -2;
  END IF;

--  Set the period_freeze flag
  UPDATE period
  SET period_freeze=TRUE
  WHERE (period_id=pPeriodid);

  RETURN pPeriodid;

END;
$_$;


ALTER FUNCTION public.freezeaccountingperiod(integer) OWNER TO admin;

--
-- TOC entry 1652 (class 1255 OID 146566230)
-- Dependencies: 2681 4536 8
-- Name: freightdetail(text, integer, integer, integer, date, text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION freightdetail(text, integer, integer, integer, date, text, integer) RETURNS SETOF freightdata
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pOrderType ALIAS FOR $1;
  pOrderId ALIAS FOR $2;
  pCustId ALIAS FOR $3;
  pShiptoId ALIAS FOR $4;
  pOrderDate ALIAS FOR $5;
  pShipVia ALIAS FOR $6;
  pCurrId ALIAS FOR $7;

  _row freightData%ROWTYPE;
  _order RECORD;
  _weights RECORD;
  _includepkgweight BOOLEAN := FALSE;
  _qry TEXT;
  _debug BOOLEAN := FALSE;

BEGIN
  IF (_debug) THEN
    RAISE NOTICE 'pOrderType = %', pOrderType;
    RAISE NOTICE 'pOrderId = %', pOrderId;
    RAISE NOTICE 'pCustId = %', pCustId;
    RAISE NOTICE 'pShiptoId = %', pShiptoId;
    RAISE NOTICE 'pOrderDate = %', pOrderDate;
    RAISE NOTICE 'pShipVia = %', pShipVia;
    RAISE NOTICE 'pCurrId = %', pCurrId;
  END IF;

  SELECT fetchMetricBool('IncludePackageWeight') INTO _includepkgweight;

  --Get the order header information need to match
  --against price schedules
  IF (pOrderType = 'SO') THEN
    SELECT
      cust_id AS cust_id,
      custtype_id,
      custtype_code,
      COALESCE(shipto_id, -1) AS shipto_id,
      COALESCE(shipto_num, '') AS shipto_num,
      COALESCE(pOrderDate, cohead_orderdate) AS orderdate,
      COALESCE(pShipVia, cohead_shipvia) AS shipvia,
      shipto_shipzone_id AS shipzone_id,
      COALESCE(pCurrId, cohead_curr_id) AS curr_id,
      currConcat(COALESCE(pCurrId, cohead_curr_id)) AS currAbbr
    INTO _order
      FROM cohead
      JOIN custinfo ON (cust_id=COALESCE(pCustId, cohead_cust_id))
      JOIN custtype ON (custtype_id=cust_custtype_id)
      LEFT OUTER JOIN shiptoinfo ON (shipto_id=COALESCE(pShiptoId, cohead_shipto_id))
    WHERE (cohead_id=pOrderId);

  ELSIF (pOrderType = 'QU') THEN
    SELECT
      quhead_cust_id AS cust_id,
      custtype_id,
      custtype_code,
      COALESCE(shipto_id, -1) AS shipto_id,
      COALESCE(shipto_num, '') AS shipto_num,
      quhead_quotedate AS orderdate,
      quhead_shipvia AS shipvia,
      shipto_shipzone_id AS shipzone_id,
      quhead_curr_id AS curr_id,
      currConcat(quhead_curr_id) AS currAbbr
    INTO _order
      FROM quhead
      JOIN custinfo ON (cust_id=quhead_cust_id)
      JOIN custtype ON (custtype_id=cust_custtype_id)
      LEFT OUTER JOIN shiptoinfo ON (shipto_id=quhead_shipto_id)
    WHERE (quhead_id=pOrderId);

  ELSIF (pOrderType = 'RA') THEN
    SELECT
      cust_id AS cust_id,
      custtype_id,
      custtype_code,
      COALESCE(shipto_id, -1) AS shipto_id,
      COALESCE(shipto_num, '') AS shipto_num,
      COALESCE(pOrderDate, rahead_authdate) AS orderdate,
      ''::text AS shipvia,
      shipto_shipzone_id AS shipzone_id,
      COALESCE(pCurrId, rahead_curr_id) AS curr_id,
      currConcat(COALESCE(pCurrId, rahead_curr_id)) AS currAbbr
    INTO _order
      FROM rahead
      JOIN custinfo ON (cust_id=COALESCE(pCustId, rahead_cust_id))
      JOIN custtype ON (custtype_id=cust_custtype_id)
      LEFT OUTER JOIN shiptoinfo ON (shipto_id=COALESCE(pShiptoId, rahead_shipto_id))
    WHERE (rahead_id=pOrderId);

  ELSE
    RAISE EXCEPTION 'Invalid order type.';
  END IF;

  IF (_debug) THEN
    RAISE NOTICE 'cust_id = %', _order.cust_id;
    RAISE NOTICE 'custtype_id = %', _order.custtype_id;
    RAISE NOTICE 'shipto_id = %', _order.shipto_id;
    RAISE NOTICE 'shipto_num = %', _order.shipto_num;
    RAISE NOTICE 'orderdate = %', _order.orderdate;
    RAISE NOTICE 'shipvia = %', _order.shipvia;
    RAISE NOTICE 'shipzone_id = %', _order.shipzone_id;
    RAISE NOTICE 'curr_id = %', _order.curr_id;
    RAISE NOTICE 'currAbbr = %', _order.currAbbr;
  END IF;

  --Get a list of aggregated weights from sites and
  --freight classes used on order lines

  IF (_includePkgWeight) THEN
    _qry := 'SELECT SUM(orderitem_qty_ordered * orderitem_qty_invuomratio * (item_prodweight + item_packweight)) AS weight, ';
  ELSE
    _qry := 'SELECT SUM(orderitem_qty_ordered * orderitem_qty_invuomratio * item_prodweight) AS weight, ';
  END IF;

  _qry := _qry || 'itemsite_warehous_id, COALESCE(item_freightclass_id, -1) AS item_freightclass_id
    FROM orderitem
    JOIN itemsite ON (itemsite_id=orderitem_itemsite_id)
    JOIN item ON (item_id=itemsite_item_id) ';

  IF (pOrderType = 'RA') THEN
    _qry := _qry || 'JOIN raitem ON ((orderitem_id=raitem_id)
    AND (raitem_disposition IN (''C'',''R'',''P''))) ';
  END IF;

  _qry := _qry || '
    WHERE ( (orderitem_orderhead_type=' || quote_literal(pOrderType) || ')
      AND (orderitem_orderhead_id=' || quote_literal(pOrderId) || ')
      AND (orderitem_status <> ''X'') )
    GROUP BY itemsite_warehous_id, item_freightclass_id;';

  FOR _weights IN
    EXECUTE _qry LOOP

    _row := calculateFreightDetail(
      _order.cust_id, --pCustId
      _order.custtype_id, --pCustTypeId
      _order.custtype_code, --pCustTypeCode
      _order.shipto_id, --pShiptoId
      _order.shipzone_id, --pShipZoneId
      _order.shipto_num, --pShiptoNum
      _order.orderdate, --pOrderDate
      _order.shipvia, --pShipVia
      _order.curr_id, --pCurrId
      _order.currAbbr, --pCurrAbbr
      _weights.itemsite_warehous_id, --pItemSiteWhsId
      _weights.item_freightclass_id, --pItemFreightclassId
      _weights.weight --pWeight
      );

    RETURN NEXT _row;

  END LOOP;
  RETURN;
END;
$_$;


ALTER FUNCTION public.freightdetail(text, integer, integer, integer, date, text, integer) OWNER TO admin;

--
-- TOC entry 1653 (class 1255 OID 146566231)
-- Dependencies: 2681 4536 8
-- Name: freightdetailquote(integer, text, integer, text, date, text, text, text[]); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION freightdetailquote(integer, text, integer, text, date, text, text, text[]) RETURNS SETOF freightdata
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCustId ALIAS FOR $1;
  pCustNumber ALIAS FOR $2;
  pShiptoId ALIAS FOR $3;
  pShiptoNum ALIAS FOR $4;
  pOrderDate ALIAS FOR $5;
  pShipVia ALIAS FOR $6;
  pItemArrayType ALIAS FOR $7;
  pItemQty ALIAS FOR $8;
    -- Array item_id format = ARRAY[['300','3'],['310','50']]
    -- Array item_number format = ARRAY[['YTRUCK1','3'],['RTRUCK1','50']]
    -- Array itemsite_id format = ARRAY[['293','3'],['302','50']]

  _cust RECORD;
  _shipto RECORD;
  _curr RECORD;
  _includepkgweight BOOLEAN := FALSE;
  _order_date DATE;
  _ship_via TEXT;
  _item_num RECORD;
  _item_id RECORD;
  _weights RECORD;
  _row freightData%ROWTYPE;
  _debug BOOLEAN := FALSE;

BEGIN
-- Parameters are setup to allow this function to be called multiple ways.
-- Check parameters and lookup what is NULL.

  -- Check pCustId and pCustNumber.
  IF (pCustId IS NULL AND (pCustNumber IS NULL OR pCustNumber = '')) THEN
    RAISE EXCEPTION 'You must specify a Customer ID or Number to get a freight quote.';
  ELSIF (pCustId IS NULL AND pCustNumber IS NOT NULL) THEN
    -- Get customer info using pCustNumber.
    SELECT
      cust_id,
      cust_number,
      custtype_id,
      custtype_code,
      cust_curr_id,
      cust_shipvia
    INTO _cust
    FROM custinfo
    LEFT JOIN custtype ON cust_custtype_id = custtype_id
    WHERE 1=1
      AND cust_number = pCustNumber;
  ELSE
    -- Get customer info using pCustId.
    SELECT
      cust_id,
      cust_number,
      custtype_id,
      custtype_code,
      cust_curr_id,
      cust_shipvia
    INTO _cust
    FROM custinfo
    LEFT JOIN custtype ON cust_custtype_id = custtype_id
    WHERE 1=1
      AND cust_id = pCustId;
  END IF;

  IF(NOT FOUND) THEN
    RAISE EXCEPTION 'Invalid Customer specified when trying to get a freight quote.';
  END IF;

  -- Check pShiptoId and pShiptoNum.
  IF (pShiptoId IS NULL AND (pShiptoNum IS NULL OR pShiptoNum = '')) THEN
    -- Get Customer's default shipto.
    SELECT
      shipto_id,
      shipto_name,
      shipto_shipzone_id,
      shipto_shipvia,
      shipto_num
    INTO _shipto
    FROM shiptoinfo
    WHERE 1=1
      AND shipto_cust_id = _cust.cust_id
      AND shipto_default;
  ELSIF (pShiptoId IS NULL AND pShiptoNum IS NOT NULL) THEN
    -- Get shipto info using pShiptoNum.
    SELECT
      shipto_id,
      shipto_name,
      shipto_shipzone_id,
      shipto_shipvia,
      shipto_num
    INTO _shipto
    FROM shiptoinfo
    WHERE 1=1
      AND shipto_cust_id = _cust.cust_id
      AND shipto_num = pShiptoNum;
  ELSE
    -- Get shipto info using pShiptoId.
    SELECT
      shipto_id,
      shipto_name,
      shipto_shipzone_id,
      shipto_shipvia,
      shipto_num
    INTO _shipto
    FROM shiptoinfo
    WHERE 1=1
      AND shipto_cust_id = _cust.cust_id
      AND shipto_id = pShiptoId;
  END IF;

  IF(NOT FOUND) THEN
    RAISE EXCEPTION 'Invalid Ship-to specified when trying to get a freight quote.';
  END IF;

  -- Get curr info.
  SELECT
    curr_id,
    curr_abbr
  INTO _curr
  FROM curr_symbol
  WHERE 1=1
    AND curr_id = _cust.cust_curr_id;

  IF(NOT FOUND) THEN
    RAISE EXCEPTION 'Could not find currency when trying to get a freight quote.';
  END IF;

  -- Check pOrderDate.
  IF (pOrderDate IS NULL) THEN
    _order_date := CURRENT_DATE;
  ELSE
    _order_date := pOrderDate;
  END IF;

  -- Check pShipVia.
  IF (pShipVia IS NULL OR pShipVia = '') THEN
    IF (_shipto.shipto_shipvia IS NULL OR _shipto.shipto_shipvia = '') THEN
      _ship_via := _cust.cust_shipvia;
    ELSE
      _ship_via := _shipto.shipto_shipvia;
    END IF;
  ELSE
    _ship_via := pShipVia;
  END IF;

  -- Determine if package weight should be included in freight calculation.
  SELECT fetchMetricBool('IncludePackageWeight') INTO _includepkgweight;

  -- Check pItemQty.
  IF (pItemQty IS NULL OR array_upper(pItemQty,1) IS NULL) THEN
    -- Item Array is NULL.
    RAISE EXCEPTION 'You must specify an Item ID, Item Number or Itemsite ID to get a freight quote.';
  ELSIF (pItemArrayType = 'item_number' AND (array_upper(pItemQty,1) > 0)) THEN
    -- Using item_number.
    FOR _weights IN
      -- Get a list of aggregated weights from sites and freight classes for items.
      SELECT
        CASE WHEN _includepkgweight THEN
          SUM(qty * (item_prodweight + item_packweight))
        ELSE
          SUM(qty * (item_prodweight))
        END AS weight,
        itemsite_warehous_id,
        COALESCE(item_freightclass_id, -1) AS item_freightclass_id
      FROM
        -- Create item_number -> qty record from array.
        (SELECT
          unnest((SELECT pItemQty[1:array_upper(pItemQty,1)][1])) AS item_number,
          unnest((SELECT pItemQty[1:array_upper(pItemQty,1)][2:array_ndims(pItemQty)]))::numeric AS qty
        ) AS itemnum_qty
        JOIN item USING (item_number)
        JOIN itemsite ON item_id=itemsite_item_id
      WHERE 1=1
        AND itemsite_warehous_id = fetchprefwarehousid()
      GROUP BY
        itemsite_warehous_id,
        item_freightclass_id
    LOOP
      -- Calculate the freight detail for these item weights.
      _row := calculateFreightDetail(
        _cust.cust_id, --pCustId
        _cust.custtype_id, --pCustTypeId
        _cust.custtype_code, --pCustTypeCode
        _shipto.shipto_id, --pShiptoId
        _shipto.shipto_shipzone_id, --pShipZoneId
        _shipto.shipto_num, --pShiptoNum
        _order_date, --pOrderDate
        _ship_via, --pShipVia
        _curr.curr_id, --pCurrId
        _curr.curr_abbr, --pCurrAbbr
        _weights.itemsite_warehous_id, --pItemSiteWhsId
        _weights.item_freightclass_id, --pItemFreightclassId
        _weights.weight --pWeight
        );

      RETURN NEXT _row;
    END LOOP;

  ELSIF (pItemArrayType = 'item_id' AND (array_upper(pItemQty,1) > 0)) THEN
    -- Using item_id.
    FOR _weights IN
      -- Get a list of aggregated weights from sites and freight classes for items.
      SELECT
        CASE WHEN _includepkgweight THEN
          SUM(qty * (item_prodweight + item_packweight))
        ELSE
          SUM(qty * (item_prodweight))
        END AS weight,
        itemsite_warehous_id,
        COALESCE(item_freightclass_id, -1) AS item_freightclass_id
      FROM
        -- Create item_id -> qty record from array.
        (SELECT
          unnest((SELECT pItemQty[1:array_upper(pItemQty,1)][1]))::integer AS item_id,
          unnest((SELECT pItemQty[1:array_upper(pItemQty,1)][2:array_ndims(pItemQty)]))::numeric AS qty
        ) AS itemid_qty
        JOIN item USING (item_id)
        JOIN itemsite ON item_id=itemsite_item_id
      WHERE 1=1
        AND itemsite_warehous_id = fetchprefwarehousid()
      GROUP BY
        itemsite_warehous_id,
        item_freightclass_id
    LOOP
      -- Calculate the freight detail for these item weights.
      _row := calculateFreightDetail(
        _cust.cust_id, --pCustId
        _cust.custtype_id, --pCustTypeId
        _cust.custtype_code, --pCustTypeCode
        _shipto.shipto_id, --pShiptoId
        _shipto.shipto_shipzone_id, --pShipZoneId
        _shipto.shipto_num, --pShiptoNum
        _order_date, --pOrderDate
        _ship_via, --pShipVia
        _curr.curr_id, --pCurrId
        _curr.curr_abbr, --pCurrAbbr
        _weights.itemsite_warehous_id, --pItemSiteWhsId
        _weights.item_freightclass_id, --pItemFreightclassId
        _weights.weight --pWeight
        );

      RETURN NEXT _row;
    END LOOP;
  ELSIF (pItemArrayType = 'itemsite_id' AND (array_upper(pItemQty,1) > 0)) THEN
    -- Using itemsite_id.
    FOR _weights IN
      -- Get a list of aggregated weights from sites and freight classes for items.
      SELECT
        CASE WHEN _includepkgweight THEN
          SUM(qty * (item_prodweight + item_packweight))
        ELSE
          SUM(qty * (item_prodweight))
        END AS weight,
        itemsite_warehous_id,
        COALESCE(item_freightclass_id, -1) AS item_freightclass_id
      FROM
        -- Create itemsite_id -> qty record from array.
        (SELECT
          unnest((SELECT pItemQty[1:array_upper(pItemQty,1)][1]))::integer AS itemsite_id,
          unnest((SELECT pItemQty[1:array_upper(pItemQty,1)][2:array_ndims(pItemQty)]))::numeric AS qty
        ) AS itemsiteid_qty
        JOIN itemsite USING (itemsite_id)
        JOIN item ON item_id=itemsite_item_id
      WHERE 1=1
      GROUP BY
        itemsite_warehous_id,
        item_freightclass_id
    LOOP
      -- Calculate the freight detail for these item weights.
      _row := calculateFreightDetail(
        _cust.cust_id, --pCustId
        _cust.custtype_id, --pCustTypeId
        _cust.custtype_code, --pCustTypeCode
        _shipto.shipto_id, --pShiptoId
        _shipto.shipto_shipzone_id, --pShipZoneId
        _shipto.shipto_num, --pShiptoNum
        _order_date, --pOrderDate
        _ship_via, --pShipVia
        _curr.curr_id, --pCurrId
        _curr.curr_abbr, --pCurrAbbr
        _weights.itemsite_warehous_id, --pItemSiteWhsId
        _weights.item_freightclass_id, --pItemFreightclassId
        _weights.weight --pWeight
        );

      RETURN NEXT _row;
    END LOOP;
  ELSE -- The item array provided is invalid.
    RAISE EXCEPTION 'The Item/Itemsite array provided when trying to get a freight quote is invalid.';
  END IF;

  IF(NOT FOUND) THEN
    RAISE EXCEPTION 'Error trying to aggregated weights when getting a freight quote.';
  END IF;

  -- Print debug.
  IF (_debug) THEN
    RAISE NOTICE 'pCustId = %', _cust.cust_id;
    RAISE NOTICE 'pCustTypeId = %', _cust.custtype_id;
    RAISE NOTICE 'pCustTypeCode = %', _cust.custtype_code;
    RAISE NOTICE 'pShiptoId = %', _shipto.shipto_id;
    RAISE NOTICE 'pShipZoneId = %', _shipto.shipto_shipzone_id;
    RAISE NOTICE 'pShiptoNum = %', _shipto.shipto_num;
    RAISE NOTICE 'pOrderDate = %', _order_date;
    RAISE NOTICE 'pShipVia = %', _ship_via;
    RAISE NOTICE 'pCurrId = %', _curr.curr_id;
    RAISE NOTICE 'pCurrAbbr = %', _curr.curr_abbr;
  END IF;

  RETURN;
END;
$_$;


ALTER FUNCTION public.freightdetailquote(integer, text, integer, text, date, text, text, text[]) OWNER TO admin;

--
-- TOC entry 1654 (class 1255 OID 146566233)
-- Dependencies: 4536 8
-- Name: freightforrecv(text, integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION freightforrecv(text, integer, boolean) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pordertype	ALIAS FOR $1;
  porderitemid	ALIAS FOR $2;
  pposted	ALIAS FOR $3;
  _freight	NUMERIC;

BEGIN
  IF (pordertype = 'TO' AND NOT fetchMetricBool('MultiWhs')) THEN
    RETURN 0;
  ELSIF (pordertype = 'RA' AND NOT fetchMetricBool('EnableReturnAuth')) THEN
    RETURN 0;
  END IF;

  SELECT SUM(COALESCE(recv_freight, 0)) INTO _freight
  FROM recv
  WHERE ((recv_orderitem_id=porderitemid)
    AND  (recv_posted = pposted)
    AND  (recv_order_type=pordertype));

  RETURN COALESCE(_freight, 0.0);

END;
$_$;


ALTER FUNCTION public.freightforrecv(text, integer, boolean) OWNER TO admin;

--
-- TOC entry 1655 (class 1255 OID 146566234)
-- Dependencies: 8
-- Name: gen_salt(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION gen_salt(text) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/pgcrypto', 'pg_gen_salt';


ALTER FUNCTION public.gen_salt(text) OWNER TO admin;

--
-- TOC entry 1656 (class 1255 OID 146566235)
-- Dependencies: 8
-- Name: gen_salt(text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION gen_salt(text, integer) RETURNS text
    LANGUAGE c STRICT
    AS '$libdir/pgcrypto', 'pg_gen_salt_rounds';


ALTER FUNCTION public.gen_salt(text, integer) OWNER TO admin;

--
-- TOC entry 1657 (class 1255 OID 146566236)
-- Dependencies: 4536 8
-- Name: getactiverevid(text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getactiverevid(text, integer) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTargetType ALIAS FOR $1;
  pTargetid ALIAS FOR $2;
  _revid INTEGER;

BEGIN
  --See if revcontrol turned on
  IF (fetchmetricbool('RevControl')) THEN

    IF (pTargetType='BOM') THEN
      SELECT rev_id INTO _revid
      FROM rev
      WHERE ((rev_target_type='BOM')
      AND (rev_target_id=pTargetid)
      AND (rev_status='A'));
      IF (NOT FOUND) THEN
        _revid:=-1;
      END IF;

      ELSE IF (pTargetType='BOO') THEN
      SELECT rev_id INTO _revid
      FROM rev
      WHERE ((rev_target_type='BOO')
      AND (rev_target_id=pTargetid)
      AND (rev_status='A'));
      IF (NOT FOUND) THEN
        _revid:=-1;
      END IF;

      ELSE
        RAISE EXCEPTION 'Invalid Revision Type';
      END IF;
    END IF;

  ELSE
    _revid:=-1;
  END IF;

  RETURN _revid;

END;
$_$;


ALTER FUNCTION public.getactiverevid(text, integer) OWNER TO admin;

--
-- TOC entry 1658 (class 1255 OID 146566237)
-- Dependencies: 4536 8
-- Name: getaddrid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getaddrid(paddressnumber text) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;
BEGIN
  IF (pAddressNumber IS NULL OR pAddressNumber = '') THEN
    RETURN NULL;
  END IF;

  SELECT addr_id INTO _returnVal
  FROM addr
  WHERE (addr_number=pAddressNumber);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Address Number % not found.', pAddressNumber;
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getaddrid(paddressnumber text) OWNER TO admin;

--
-- TOC entry 1659 (class 1255 OID 146566238)
-- Dependencies: 4536 8
-- Name: getadjustmenttaxtypeid(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getadjustmenttaxtypeid() RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _taxtypeid INTEGER;
BEGIN
  SELECT taxtype_id
    INTO _taxtypeid
  FROM taxtype
  WHERE (taxtype_name='Adjustment');

  RETURN _taxtypeid;
END;
$$;


ALTER FUNCTION public.getadjustmenttaxtypeid() OWNER TO admin;

--
-- TOC entry 1660 (class 1255 OID 146566239)
-- Dependencies: 4536 8
-- Name: getaropenid(text, character, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getaropenid(text, character, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCustNumber ALIAS FOR $1;
  pDocType ALIAS FOR $2;
  pDocNumber ALIAS FOR $3;
  _returnVal INTEGER;
BEGIN
  IF ((pCustNumber IS NULL) OR (pDocType IS NULL) OR (pDocNumber IS NULL)) THEN
	RETURN NULL;
  END IF;

  SELECT aropen_id INTO _returnVal
  FROM aropen
  WHERE ((aropen_cust_id=getCustId(pCustNumber,true))
    AND  (UPPER(aropen_doctype)=UPPER(pDocType))
    AND  (UPPER(aropen_docnumber)=UPPER(pDocNumber)));

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'AR Open Item % not found.', pDocNumber;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getaropenid(text, character, text) OWNER TO admin;

--
-- TOC entry 1661 (class 1255 OID 146566240)
-- Dependencies: 4536 8
-- Name: getbankaccntid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getbankaccntid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pBankAccntName ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pBankAccntName IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT bankaccnt_id INTO _returnVal
  FROM bankaccnt
  WHERE (UPPER(bankaccnt_name)=UPPER(pBankAccntName));

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Bank Account % not found.', pBankAccntName;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getbankaccntid(text) OWNER TO admin;

--
-- TOC entry 1662 (class 1255 OID 146566241)
-- Dependencies: 4536 8
-- Name: getbomitemid(text, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getbomitemid(text, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemNumber ALIAS FOR $1;
  pRevision ALIAS FOR $2;
  pSeqNumber ALIAS FOR $3;
  _returnVal INTEGER;

BEGIN
  IF ((pItemNumber IS NULL) OR (pSeqNumber IS NULL) OR (pItemNumber = '') OR (pSeqNumber = '') ) THEN
    RETURN NULL;
  END IF;

  SELECT bomitem_id INTO _returnVal
  FROM bomitem(getItemId(pItemNumber),COALESCE(getRevId('BOM',pItemNumber,pRevision)))
  WHERE (bomitem_seqnumber=pSeqNumber);

  IF (_returnVal IS NULL) THEN
    RAISE EXCEPTION 'Sequence % on Bill of Material % Revision % not found.', pSeqNumber, pItemNumber, pRevision;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getbomitemid(text, text, text) OWNER TO admin;

--
-- TOC entry 1650 (class 1255 OID 146566242)
-- Dependencies: 4536 8
-- Name: getbooitemseqid(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getbooitemseqid(text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemNumber ALIAS FOR $1;
  pSeqNumber ALIAS FOR $2;
  _revid INTEGER;
  _returnVal INTEGER;

BEGIN
  IF ((pItemNumber IS NULL) OR (pSeqNumber IS NULL)) THEN
    RETURN NULL;
  END IF;

  IF (NOT fetchMetricBool('Routings')) THEN
    RETURN -1;
  ELSE
    SELECT booitem_seq_id INTO _returnVal
    FROM booitem(getItemId(pItemNumber))
    WHERE (booitem_seqnumber=CAST(pSeqNumber AS integer));
  END IF;

  IF (_returnVal IS NULL) THEN
    RAISE EXCEPTION 'Boo Sequence % for Item % not found.', pSeqNumber, pItemNumber;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getbooitemseqid(text, text) OWNER TO admin;

--
-- TOC entry 1663 (class 1255 OID 146566243)
-- Dependencies: 4536 8
-- Name: getbudgheadid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getbudgheadid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pBudghead ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pBudghead IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT budghead_id INTO _returnVal
  FROM budghead
  WHERE (budghead_name=(pBudghead));

  IF (_returnVal IS NULL) THEN
    RAISE EXCEPTION 'Budget % not found.', pBudghead;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getbudgheadid(text) OWNER TO admin;

--
-- TOC entry 1664 (class 1255 OID 146566244)
-- Dependencies: 4536 8
-- Name: getcashrcptid(text, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getcashrcptid(text, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCustNumber ALIAS FOR $1;
  pFundsType ALIAS FOR $2;
  pDocNumber ALIAS FOR $3;
  _returnVal INTEGER;
BEGIN
  IF ((pCustNumber IS NULL) OR (pFundsType IS NULL) OR (pDocNumber IS NULL)) THEN
	RETURN NULL;
  END IF;

  SELECT cashrcpt_id INTO _returnVal
  FROM cashrcpt
  WHERE ((cashrcpt_cust_id=getCustId(pCustNumber,true))
    AND  (UPPER(cashrcpt_fundstype)=UPPER(pFundsType))
    AND  (UPPER(cashrcpt_docnumber)=UPPER(pDocNumber)));

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Cash Receipt % not found.', pDocNumber;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getcashrcptid(text, text, text) OWNER TO admin;

--
-- TOC entry 1665 (class 1255 OID 146566245)
-- Dependencies: 4536 8
-- Name: getcharid(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getcharid(pchar text, ptype text) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;
BEGIN
  IF (COALESCE(pChar, '') = '') THEN
    RETURN NULL;
  END IF;

  SELECT char_id INTO _returnVal
  FROM char
  WHERE ((char_name=pChar)
  AND ((pType IN ('C','CT') AND char_customers)
    OR (pType IN ('I','SI','QI','W','PI','TI') AND char_items)
    OR (pType='CRMACCT' AND char_crmaccounts)
    OR (pType='ADDR' AND char_addresses)
    OR (pType='CNTCT' AND char_contacts)
    OR (pType='LS' AND char_lotserial)
    OR (pType='EMP' AND char_employees)
    OR (pType='INCDT' AND char_incidents)
    )) LIMIT 1;

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Characteristic % not found.', pChar;
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getcharid(pchar text, ptype text) OWNER TO admin;

--
-- TOC entry 1666 (class 1255 OID 146566246)
-- Dependencies: 4536 8
-- Name: getclasscodeid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getclasscodeid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pClassCode ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pClassCode IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT classcode_id INTO _returnVal
  FROM classcode
  WHERE (classcode_code=pClassCode);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Class Code % not found.', pClassCode;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getclasscodeid(text) OWNER TO admin;

--
-- TOC entry 1667 (class 1255 OID 146566247)
-- Dependencies: 4536 8
-- Name: getcmheadid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getcmheadid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCreditMemoNumber ALIAS FOR $1;
BEGIN
  RETURN getCmheadId(pCreditMemoNumber, NULL);
END;
$_$;


ALTER FUNCTION public.getcmheadid(text) OWNER TO admin;

--
-- TOC entry 1668 (class 1255 OID 146566248)
-- Dependencies: 4536 8
-- Name: getcmheadid(text, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getcmheadid(text, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCreditMemoNumber ALIAS FOR $1;
  pPosted ALIAS FOR $2;
  _returnVal INTEGER;
BEGIN
  IF (pCreditMemoNumber IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT cmhead_id INTO _returnVal
  FROM cmhead
  WHERE (UPPER(cmhead_number)=UPPER(pCreditMemoNumber))
    AND ((pPosted IS NULL) OR (cmhead_posted=pPosted));

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Credit Memo % not found.', pCreditMemoNumber;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getcmheadid(text, boolean) OWNER TO admin;

--
-- TOC entry 1669 (class 1255 OID 146566249)
-- Dependencies: 4536 8
-- Name: getcmnttypeid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getcmnttypeid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCmntType ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (COALESCE(TRIM(pCmntType), '') = '') THEN
    RETURN NULL;
  END IF;

  SELECT cmnttype_id INTO _returnVal
  FROM cmnttype
  WHERE (cmnttype_name=pCmntType) LIMIT 1;

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Comment Type % not found.', pCmntType;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getcmnttypeid(text) OWNER TO admin;

--
-- TOC entry 1670 (class 1255 OID 146566250)
-- Dependencies: 4536 8
-- Name: getcntctid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getcntctid(pcontactnumber text) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;
BEGIN
  SELECT getCntctId(pContactNumber,true) INTO _returnVal;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getcntctid(pcontactnumber text) OWNER TO admin;

--
-- TOC entry 1671 (class 1255 OID 146566251)
-- Dependencies: 4536 8
-- Name: getcntctid(text, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getcntctid(pcontactnumber text, pnotfounderr boolean) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;
BEGIN
  IF (COALESCE(TRIM(pContactNumber), '') = '') THEN
    RETURN NULL;
  END IF;

  SELECT cntct_id INTO _returnVal
  FROM cntct
  WHERE (cntct_number=pContactNumber);

  IF (_returnVal IS NULL AND pNotFoundErr) THEN
    RAISE EXCEPTION 'Contact Number % not found.', pContactNumber;
  ELSIF (_returnVal IS NULL) THEN
    RETURN NULL;
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getcntctid(pcontactnumber text, pnotfounderr boolean) OWNER TO admin;

--
-- TOC entry 1672 (class 1255 OID 146566252)
-- Dependencies: 4536 8
-- Name: getcoheadid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getcoheadid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSalesOrderNumber ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pSalesOrderNumber IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT cohead_id INTO _returnVal
  FROM cohead
  WHERE (cohead_number=pSalesOrderNumber);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Sales Order % not found.', pSalesOrderNumber;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getcoheadid(text) OWNER TO admin;

--
-- TOC entry 1674 (class 1255 OID 146566253)
-- Dependencies: 4536 8
-- Name: getcoitemid(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getcoitemid(text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSalesOrderNumber	ALIAS FOR $1;
  pLineNumber 	    	ALIAS FOR $2;
  _linenumber		INTEGER;
  _subnumber		INTEGER;
  _returnVal 		INTEGER;
BEGIN
  IF (pSalesOrderNumber IS NULL OR pLineNumber IS NULL) THEN
    RETURN NULL;
  END IF;

  --Parse Line Number
  IF (position('.' in pLineNumber) > 0) THEN
    _linenumber	:= CAST(substring(pLineNumber from 1 for position('.' in pLineNumber)-1) AS INTEGER);
    _subnumber	:= CAST(substring(pLineNumber from position('.' in pLineNumber)+1 for length(pLineNumber)) AS INTEGER);
  ELSE
    _linenumber	:= CAST(pLineNumber AS INTEGER);
    _subnumber	:= 0;
  END IF;

  SELECT coitem_id INTO _returnVal
  FROM cohead, coitem
  WHERE ((cohead_number=pSalesOrderNumber)
  AND (coitem_cohead_id=cohead_id)
  AND (coitem_linenumber=_linenumber)
  AND (coitem_subnumber=_subnumber));

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Sales Order % not found.', pSalesOrderNumber;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getcoitemid(text, text) OWNER TO admin;

--
-- TOC entry 1675 (class 1255 OID 146566254)
-- Dependencies: 4536 8
-- Name: getcontrcteffective(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getcontrcteffective(pcontrctnumber text) RETURNS date
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal DATE;
BEGIN
  IF (pContrctNumber IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT contrct_effective INTO _returnVal
  FROM contrct
  WHERE (contrct_number=pContrctNumber);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Contract Number % not found.', pContrctNumber;
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getcontrcteffective(pcontrctnumber text) OWNER TO admin;

--
-- TOC entry 1676 (class 1255 OID 146566255)
-- Dependencies: 4536 8
-- Name: getcontrctexpires(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getcontrctexpires(pcontrctnumber text) RETURNS date
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal DATE;
BEGIN
  IF (pContrctNumber IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT contrct_expires INTO _returnVal
  FROM contrct
  WHERE (contrct_number=pContrctNumber);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Contract Number % not found.', pContrctNumber;
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getcontrctexpires(pcontrctnumber text) OWNER TO admin;

--
-- TOC entry 1677 (class 1255 OID 146566256)
-- Dependencies: 4536 8
-- Name: getcontrctid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getcontrctid(pcontrctnumber text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;
BEGIN
  IF (pContrctNumber IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT contrct_id INTO _returnVal
  FROM contrct
  WHERE (contrct_number=pContrctNumber);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Contract Number % not found.', pContrctNumber;
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getcontrctid(pcontrctnumber text) OWNER TO admin;

--
-- TOC entry 1678 (class 1255 OID 146566257)
-- Dependencies: 4536 8
-- Name: getcostcatid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getcostcatid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCostCat ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pCostCat IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT costcat_id INTO _returnVal
  FROM costcat
  WHERE (costcat_code=pCostCat);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Cost Category Code % not found.', pCostCat;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getcostcatid(text) OWNER TO admin;

--
-- TOC entry 1679 (class 1255 OID 146566258)
-- Dependencies: 4536 8
-- Name: getcostelemid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getcostelemid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCostElemType ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pCostElemType IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT costelem_id INTO _returnVal
  FROM costelem
  WHERE (costelem_type=pCostElemType);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Cost Element % not found.', pCostElemType;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getcostelemid(text) OWNER TO admin;

--
-- TOC entry 1680 (class 1255 OID 146566259)
-- Dependencies: 4536 8
-- Name: getcrmacctid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getcrmacctid(pacctnumber text) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;
BEGIN

  IF (pAcctNumber IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT crmacct_id INTO _returnVal
  FROM crmacct
  WHERE (UPPER(crmacct_number)=UPPER(pAcctNumber));

  IF (_returnVal IS NULL) THEN
      RAISE EXCEPTION 'CRM Account Number % not found.', pAcctNumber;
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getcrmacctid(pacctnumber text) OWNER TO admin;

--
-- TOC entry 1681 (class 1255 OID 146566260)
-- Dependencies: 4536 8
-- Name: getcurrid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getcurrid(pcurrname text) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;
BEGIN
  IF (pCurrName IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT curr_id INTO _returnVal
  FROM curr_symbol
  WHERE (curr_abbr=pCurrName);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Currency % not found.', pCurrName;
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getcurrid(pcurrname text) OWNER TO admin;

--
-- TOC entry 1682 (class 1255 OID 146566261)
-- Dependencies: 4536 8
-- Name: getcustid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getcustid(pcustnumber text) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;
BEGIN

  SELECT getCustId(pCustNumber,false) INTO _returnVal;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getcustid(pcustnumber text) OWNER TO admin;

--
-- TOC entry 1683 (class 1255 OID 146566262)
-- Dependencies: 4536 8
-- Name: getcustid(text, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getcustid(pcustnumber text, pinclprospects boolean) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;
BEGIN
  IF (pCustNumber IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT cust_id INTO _returnVal
  FROM custinfo
  WHERE (cust_number=UPPER(pCustNumber));

  IF (_returnVal IS NULL) THEN
    IF (pInclProspects) THEN
      SELECT prospect_id INTO _returnVal
      FROM prospect
      WHERE (UPPER(prospect_number)=UPPER(pCustNumber));
      IF (_returnVal IS NULL) THEN
        RAISE EXCEPTION 'Neither Customer nor Prospect Number % found.', pCustNumber;
      END IF;
    ELSE
      RAISE EXCEPTION 'Customer Number % not found.', pCustNumber;
    END IF;
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getcustid(pcustnumber text, pinclprospects boolean) OWNER TO admin;

--
-- TOC entry 1673 (class 1255 OID 146566263)
-- Dependencies: 4536 8
-- Name: getcustnamefrominfo(text, text, text, text, text, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getcustnamefrominfo(text, text, text, text, text, boolean) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _email	TEXT	:= COALESCE(UPPER($1), '');
  _company	TEXT	:= COALESCE(UPPER($2), '');
  _first	TEXT	:= COALESCE(UPPER($3), '');
  _last		TEXT	:= COALESCE(UPPER($4), '');
  _fullname	TEXT	:= COALESCE(UPPER($5), '');
  _generate	BOOLEAN	:= COALESCE($6, FALSE);
  _counter	INTEGER;
  _custcount	INTEGER	:= 0;
  _custname	TEXT;
  _candidate	RECORD;
  _r		RECORD;
BEGIN
  IF (_email != '') THEN
    SELECT count(*), cust_name INTO _custcount, _custname
    FROM custinfo LEFT OUTER JOIN cntct ON (cust_cntct_id=cntct_id)
    WHERE (UPPER(cntct_email)=_email)
    GROUP BY cust_name;
    IF (NOT FOUND) THEN
      _custcount := 0;
    ELSIF(_custcount = 1) THEN
      RETURN _custname;
    END IF;
  END IF;

  IF (_company != '') THEN
    SELECT count(*), cust_name INTO _custcount, _custname
    FROM custinfo
    WHERE (UPPER(cust_name)=_company)
    GROUP BY cust_name;
    IF (NOT FOUND) THEN
      _custcount := 0;
    ELSIF(_custcount = 1) THEN
      RETURN _custname;
    END IF;
  END IF;

  IF (_fullname = '' AND (_first != '' OR _last != '')) THEN
    _fullname := TRIM(_first || ' ' || _last);
  END IF;

  IF (_custcount <= 0 AND _fullname != '') THEN
    SELECT count(*), cust_name INTO _custcount, _custname
    FROM custinfo
    WHERE (UPPER(cust_name)=_fullname)
    GROUP BY cust_name;
    IF (NOT FOUND) THEN
      _custcount := 0;
    ELSIF(_custcount = 1) THEN
      RETURN _custname;
    END IF;
  END IF;

  IF (_custcount > 1) THEN
    RAISE EXCEPTION 'Found % possible Customers for % and % and %',
		    _custcount, _email, _company, _fullname;
  END IF;

  IF (_custcount <= 0 AND _generate) THEN
    IF (_company != '') THEN
      RETURN _company;
    ELSIF (_email != '') THEN
      RETURN _email;
    ELSIF (_fullname != '') THEN
      RETURN _fullname;
    ELSE
      RAISE EXCEPTION 'Could not generate a new Customer Name without an email address or the name of a company or person';
    END IF;
  END IF;

  IF (_custname IS NULL OR _custname = '') THEN
    RAISE EXCEPTION 'Could not find Customer Name for % and %',
		    _company, _fullname;
  END IF;

  RETURN _custname;
END;
$_$;


ALTER FUNCTION public.getcustnamefrominfo(text, text, text, text, text, boolean) OWNER TO admin;

--
-- TOC entry 1685 (class 1255 OID 146566264)
-- Dependencies: 4536 8
-- Name: getcustnumberfrominfo(text, text, text, text, text, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getcustnumberfrominfo(text, text, text, text, text, boolean) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2012 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _email	TEXT	:= COALESCE(UPPER($1), '');
  _company	TEXT	:= COALESCE(UPPER($2), '');
  _first	TEXT	:= COALESCE(UPPER($3), '');
  _last		TEXT	:= COALESCE(UPPER($4), '');
  _fullname	TEXT	:= COALESCE(UPPER($5), TRIM(_first || ' ' || _last));
  _generate	BOOLEAN	:= COALESCE($6, FALSE);
  _counter	INTEGER;
  _custcount	INTEGER	:= 0;
  _custnumber	TEXT;
  _candidate	TEXT	:= '';
  _loopmax	INTEGER := 0;
  _minlength	INTEGER := 5;
  _maxlength	INTEGER := 8;
  _numformat	TEXT	:= '';
  _testme	TEXT;
BEGIN
  IF (_email != '') THEN
    SELECT count(*), cust_number INTO _custcount, _custnumber
    FROM custinfo LEFT OUTER JOIN cntct ON (cust_cntct_id=cntct_id)
    WHERE (UPPER(cntct_email)=_email)
    GROUP BY cust_number;
    IF (NOT FOUND) THEN
      _custcount := 0;
    ELSIF(_custcount = 1) THEN
      RETURN _custnumber;
    END IF;
  END IF;

  IF (_company != '') THEN
    SELECT count(*), cust_number INTO _custcount, _custnumber
    FROM custinfo
    WHERE (UPPER(cust_name)=_company)
    GROUP BY cust_number;
    IF (NOT FOUND) THEN
      _custcount := 0;
    ELSIF(_custcount = 1) THEN
      RETURN _custnumber;
    END IF;
  END IF;

  IF (_fullname = '' AND (_first != '' OR _last != '')) THEN
    _fullname := TRIM(_first || ' ' || _last);
  END IF;

  IF (_custcount <= 0 AND _fullname != '') THEN
    SELECT count(*), cust_number INTO _custcount, _custnumber
    FROM custinfo
    WHERE (UPPER(cust_name)=_fullname)
    GROUP BY cust_number;
    IF (NOT FOUND) THEN
      _custcount := 0;
    ELSIF(_custcount = 1) THEN
      RETURN _custnumber;
    END IF;
  END IF;

  IF (_custcount > 1) THEN
    RAISE EXCEPTION 'Found % possible Customers for % and % and %',
		    _custcount, _email, _company, _fullname;
  END IF;

  IF (_custcount <= 0 AND _generate) THEN
    IF (_maxlength < _minlength) THEN
      RAISE EXCEPTION 'Fix getCustNumberFromInfo: max length < min length';
    END IF;

    IF (_company != '') THEN
      _candidate := _company;
    ELSIF (_email != '') THEN
      _candidate := SUBSTRING(_email FOR POSITION('@' IN _email) - 1);
    ELSIF (_last != '') THEN
      _candidate := _last;
      IF (_first != '') THEN
	_candidate := _candidate || _first;
      END IF;
    ELSIF (_fullname != '' AND (POSITION(' ' IN _fullname) > 0)) THEN
      _candidate := SUBSTRING(_fullname FROM POSITION(' ' IN _fullname) + 1) ||
		    SUBSTRING(_fullname FOR  POSITION(' ' IN _fullname) - 1);
    END IF;
    WHILE (POSITION(' ' IN _candidate) > 0) LOOP
      _candidate := SUBSTRING(_candidate FOR  POSITION(' ' IN _candidate) - 1) ||
		    SUBSTRING(_candidate FROM POSITION(' ' IN _candidate) + 1);
    END LOOP;
    FOR _counter IN _minlength.._maxlength LOOP
      _testme := SUBSTRING(_candidate FOR _counter);
      IF (NOT EXISTS(SELECT cust_number
		     FROM custinfo
		     WHERE (cust_number=_testme))) THEN
	_custnumber := _testme;
	EXIT;
      END IF;
    END LOOP;
    IF (_custnumber IS NULL OR _custnumber = '') THEN
      IF (LENGTH(_candidate) < _minlength) THEN
	_minlength := LENGTH(_candidate);
      END IF;
      FOR _counter IN _minlength.._maxlength LOOP
	_loopmax := _loopmax * 10 + 9;
	_numformat := _numformat || '0';
      END LOOP;
      FOR _counter IN 1.._loopmax LOOP
	_testme := SUBSTRING(_candidate FOR _minlength) ||
		   TRIM(TO_CHAR(_counter, _numformat));
	IF (NOT EXISTS(SELECT cust_number
		       FROM custinfo
		       WHERE (cust_number=_testme))) THEN
	  _custnumber := _testme;
	  EXIT;
	END IF;
      END LOOP;
    END IF;
    IF (_custnumber IS NULL OR _custnumber = '') THEN
      RAISE EXCEPTION 'Could not generate a new Customer Number';
    END IF;
  END IF;

  IF (_custnumber IS NULL OR _custnumber = '') THEN
    RAISE EXCEPTION 'Could not find Customer Number for % and % and %',
		    _email, _company, _fullname;
  END IF;

  RETURN _custnumber;
END;
$_$;


ALTER FUNCTION public.getcustnumberfrominfo(text, text, text, text, text, boolean) OWNER TO admin;

--
-- TOC entry 1686 (class 1255 OID 146566265)
-- Dependencies: 4536 8
-- Name: getcusttypeid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getcusttypeid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCustTypeCode ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pCustTypeCode IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT custtype_id INTO _returnVal
  FROM custtype
  WHERE (custtype_code=pCustTypeCode);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Customer Type % not found.', pCustTypeCode;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getcusttypeid(text) OWNER TO admin;

--
-- TOC entry 1687 (class 1255 OID 146566266)
-- Dependencies: 4536 8
-- Name: getdeptid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getdeptid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pDeptNumber ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (COALESCE(TRIM(pDeptNumber), '') = '') THEN
    RETURN NULL;
  END IF;

  SELECT dept_id INTO _returnVal
  FROM dept
  WHERE (UPPER(dept_number)=UPPER(pDeptNumber));

  IF (_returnVal IS NULL) THEN
    RAISE EXCEPTION 'Department % not found.', pDeptNumber;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getdeptid(text) OWNER TO admin;

--
-- TOC entry 1688 (class 1255 OID 146566267)
-- Dependencies: 4536 8
-- Name: getediprofileid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getediprofileid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pEdiProfileName ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pEdiProfileName IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT pkghead_id INTO _returnVal
    FROM pkghead
   WHERE(pkghead_name='xtbatch');
  IF(NOT FOUND) THEN
    RETURN NULL;
  END IF;

  SELECT ediprofile_id INTO _returnVal
  FROM xtbatch.ediprofile
  WHERE (ediprofile_name=pEdiProfileName);

  IF (_returnVal IS NULL) THEN
    RAISE EXCEPTION 'EDI Profile % not found.', pEdiProfileName;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getediprofileid(text) OWNER TO admin;

--
-- TOC entry 1689 (class 1255 OID 146566268)
-- Dependencies: 4536 8
-- Name: getediprofilename(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getediprofilename(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pEdiProfileId ALIAS FOR $1;
  _returnVal TEXT;
BEGIN
  IF (pEdiProfileId IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT pkghead_name INTO _returnVal
    FROM pkghead
   WHERE(pkghead_name='xtbatch');
  IF(NOT FOUND) THEN
    RETURN NULL;
  END IF;

  SELECT ediprofile_name INTO _returnVal
  FROM xtbatch.ediprofile
  WHERE (ediprofile_id=pEdiProfileId);

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getediprofilename(integer) OWNER TO admin;

--
-- TOC entry 1690 (class 1255 OID 146566269)
-- Dependencies: 4536 8
-- Name: getempid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getempid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pEmpCode ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (COALESCE(TRIM(pEmpCode), '') = '') THEN
    RETURN NULL;
  END IF;

  SELECT emp_id INTO _returnVal
  FROM emp
  WHERE (UPPER(emp_code)=UPPER(pEmpCode));

  IF (_returnVal IS NULL) THEN
    RAISE EXCEPTION 'Employee % not found.', pEmpCode;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getempid(text) OWNER TO admin;

--
-- TOC entry 1691 (class 1255 OID 146566270)
-- Dependencies: 4536 8
-- Name: getexpcatid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getexpcatid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pExpcatCode ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (COALESCE(TRIM(pExpcatCode), '') = '') THEN
    RETURN NULL;
  END IF;

  SELECT expcat_id INTO _returnVal
  FROM expcat
  WHERE (expcat_code=UPPER(pExpcatCode));

  IF (_returnVal IS NULL) THEN
    RAISE EXCEPTION 'Expense Category % not found.', pExpcatCode;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getexpcatid(text) OWNER TO admin;

--
-- TOC entry 1692 (class 1255 OID 146566271)
-- Dependencies: 2666 4536 8
-- Name: getflcoldata(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getflcoldata(integer, integer) RETURNS SETOF flcoldata
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pFlcolid ALIAS FOR $1;
  pPeriodid ALIAS FOR $2;
  _row flcoldata%ROWTYPE;
  _r RECORD;
  _start DATE;
  _end DATE;
  _col INTEGER := 1;
  _mult INTEGER;

BEGIN

--Get Layout Data
  SELECT * INTO _r
  FROM flcol
  WHERE (flcol_id=pFlcolid);

-- Handle Month...
  IF (_r.flcol_month) THEN
    SELECT period_start, period_end INTO _start, _end
    FROM period
    WHERE (period_id=pPeriodid);

    IF (_r.flcol_showdb) THEN
      -- Debits Column
      _row.flcoldata_column := _col;
      _row.flcoldata_start := _start;
      _row.flcoldata_end := _end;
      RETURN NEXT _row;
      _col := _col + 1;

      -- Credits Column
      _row.flcoldata_column := _col;
      _row.flcoldata_start := _start;
      _row.flcoldata_end := _end;
      RETURN NEXT _row;
      _col := _col + 1;
    END IF;

    -- Month Column
    _row.flcoldata_column := _col;
    _row.flcoldata_start := _start;
    _row.flcoldata_end := _end;
    RETURN NEXT _row;
    _col := _col + 1;

    -- These don't have drill down
    IF (_r.flcol_prcnt) THEN
      _col := _col + 1;
    END IF;
    IF (_r.flcol_budget) THEN
      _col := _col + 1;
      IF (_r.flcol_budgetprcnt) THEN
        _col := _col + 1;
      END IF;
      IF (_r.flcol_budgetdiff) THEN
        _col := _col + 1;
      END IF;
      IF (_r.flcol_budgetdiffprcnt) THEN
        _col := _col + 1;
      END IF;
    END IF;
  END IF;

-- Handle Quarter...
  IF (_r.flcol_quarter) THEN
    SELECT min(qtr.period_start), max(qtr.period_end) INTO _start, _end
    FROM period p
     JOIN period qtr ON (p.period_quarter=qtr.period_quarter)
                     AND (p.period_yearperiod_id=qtr.period_yearperiod_id)
    WHERE (p.period_id=pPeriodid);

    IF (_r.flcol_showdb) THEN
      -- Debits Column
      _row.flcoldata_column := _col;
      _row.flcoldata_start := _start;
      _row.flcoldata_end := _end;
      RETURN NEXT _row;
      _col := _col + 1;

      -- Credits Column
      _row.flcoldata_column := _col;
      _row.flcoldata_start := _start;
      _row.flcoldata_end := _end;
      RETURN NEXT _row;
      _col := _col + 1;
    END IF;

    -- Quarter Column
    _row.flcoldata_column := _col;
    _row.flcoldata_start := _start;
    _row.flcoldata_end := _end;
    RETURN NEXT _row;
    _col := _col + 1;

    -- These don't have drill down
    IF (_r.flcol_prcnt) THEN
      _col := _col + 1;
    END IF;
    IF (_r.flcol_budget) THEN
      _col := _col + 1;
      IF (_r.flcol_budgetprcnt) THEN
        _col := _col + 1;
      END IF;
      IF (_r.flcol_budgetdiff) THEN
        _col := _col + 1;
      END IF;
      IF (_r.flcol_budgetdiffprcnt) THEN
        _col := _col + 1;
      END IF;
    END IF;
  END IF;

-- Handle Year...
  IF (_r.flcol_year) THEN
    SELECT yearperiod_start, period_end INTO _start, _end
    FROM period p
     JOIN yearperiod ON (period_yearperiod_id=yearperiod_id)
    WHERE (p.period_id=pPeriodid);

    IF (_r.flcol_showdb) THEN
      -- Debits Column
      _row.flcoldata_column := _col;
      _row.flcoldata_start := _start;
      _row.flcoldata_end := _end;
      RETURN NEXT _row;
      _col := _col + 1;

      -- Credits Column
      _row.flcoldata_column := _col;
      _row.flcoldata_start := _start;
      _row.flcoldata_end := _end;
      RETURN NEXT _row;
      _col := _col + 1;
    END IF;

    -- Year Column
    _row.flcoldata_column := _col;
    _row.flcoldata_start := _start;
    _row.flcoldata_end := _end;
    RETURN NEXT _row;
    _col := _col + 1;

    -- These don't have drill down
    IF (_r.flcol_prcnt) THEN
      _col := _col + 1;
    END IF;
    IF (_r.flcol_budget) THEN
      _col := _col + 1;
      IF (_r.flcol_budgetprcnt) THEN
        _col := _col + 1;
      END IF;
      IF (_r.flcol_budgetdiff) THEN
        _col := _col + 1;
      END IF;
      IF (_r.flcol_budgetdiffprcnt) THEN
        _col := _col + 1;
      END IF;
    END IF;
  END IF;

  -- Handle Prior Month...
  IF (_r.flcol_priormonth) THEN
    SELECT prv.period_start, prv.period_end INTO _start, _end
    FROM period p
      JOIN period prv ON (prv.period_start < p.period_start)
    WHERE (p.period_id=pPeriodid)
    ORDER BY prv.period_start DESC
    LIMIT 1;

    -- Prior Month Column
    _row.flcoldata_column := _col;
    _row.flcoldata_start := _start;
    _row.flcoldata_end := _end;
    RETURN NEXT _row;
    _col := _col + 1;

    -- These don't have drill down
    IF (_r.flcol_priorprcnt) THEN
      _col := _col + 1;
    END IF;
    IF (_r.flcol_priordiff) THEN
      _col := _col + 1;
    END IF;
    IF (_r.flcol_priordiffprcnt) THEN
      _col := _col + 1;
    END IF;
  END IF;

-- Handle Prior Quarter...
  IF (_r.flcol_priorquarter) THEN
    IF (_r.flcol_priortype = 'P') THEN
      -- Prior Quarter
      SELECT min(period_start), max(period_end)
      INTO _start, _end
      FROM (
        SELECT prv.period_start, prv.period_end, prv.period_quarter, prv.period_yearperiod_id
        FROM period p
          JOIN period prv ON (prv.period_start < p.period_start)
                          AND (prv.period_quarter != p.period_quarter)
        WHERE (p.period_id=pPeriodid)) data
      GROUP BY period_quarter, period_yearperiod_id
      ORDER BY min(period_start) DESC
      LIMIT 1;
    ELSE
      -- Prior Year Quarter
      SELECT min(period_start), max(period_end)
      INTO _start, _end
      FROM (
        SELECT prv.period_start, prv.period_end, prv.period_quarter, prv.period_yearperiod_id
        FROM period p
          JOIN period prv ON (prv.period_start < p.period_start)
                          AND (prv.period_yearperiod_id != p.period_yearperiod_id)
                          AND (prv.period_quarter = p.period_quarter)
        WHERE (p.period_id=pPeriodid)) data
      GROUP BY period_quarter, period_yearperiod_id
      ORDER BY min(period_start) DESC
      LIMIT 1;
    END IF;

    -- Prior Quarter Column
    _row.flcoldata_column := _col;
    _row.flcoldata_start := _start;
    _row.flcoldata_end := _end;
    RETURN NEXT _row;
    _col := _col + 1;

    -- These don't have drill down
    IF (_r.flcol_priorprcnt) THEN
      _col := _col + 1;
    END IF;
    IF (_r.flcol_priordiff) THEN
      _col := _col + 1;
    END IF;
    IF (_r.flcol_priordiffprcnt) THEN
      _col := _col + 1;
    END IF;
  END IF;

  -- Handle Prior Year...
  IF (_r.flcol_prioryear IN ('D','F')) THEN
    IF (_r.flcol_prioryear = 'D') THEN
      -- Prior Year to Date
      SELECT yearperiod_start, prv.period_end INTO _start, _end
      FROM period p
        JOIN period prv ON (prv.period_number = p.period_number)
                        AND (prv.period_yearperiod_id != p.period_yearperiod_id)
                        AND (prv.period_start < p.period_start)
        JOIN yearperiod ON (prv.period_yearperiod_id=yearperiod_id)
      WHERE (p.period_id=pPeriodid)
      ORDER BY prv.period_start DESC
      LIMIT 1;
    ELSE
      -- Prior Full Year
      SELECT prv.yearperiod_start, prv.yearperiod_end INTO _start, _end
      FROM period p
        JOIN yearperiod cur ON (cur.yearperiod_id=p.period_yearperiod_id)
        JOIN yearperiod prv ON (prv.yearperiod_start < cur.yearperiod_start)
      WHERE (p.period_id=pPeriodid)
      ORDER BY prv.yearperiod_start DESC
      LIMIT 1;
    END IF;

    -- Prior Year Column
    _row.flcoldata_column := _col;
    _row.flcoldata_start := _start;
    _row.flcoldata_end := _end;
    RETURN NEXT _row;
    _col := _col + 1;

  END IF;

  RETURN;

END;
$_$;


ALTER FUNCTION public.getflcoldata(integer, integer) OWNER TO admin;

--
-- TOC entry 1694 (class 1255 OID 146566272)
-- Dependencies: 2666 4536 8
-- Name: getflcoldata(character, integer[], boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getflcoldata(character, integer[], boolean) RETURNS SETOF flcoldata
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pInterval ALIAS FOR $1;
  pPeriodids ALIAS FOR $2;
  pBudgets ALIAS FOR $3;
  _row flcoldata%ROWTYPE;
  _r RECORD;
  _start DATE;
  _end DATE;
  _col INTEGER := 1;
  _count INTEGER;
  _i INTEGER := 1;
  _incr INTEGER := 1;

BEGIN

  IF (pBudgets) THEN
    _col := 2;
    _incr := 2;
  END IF;

  _count := ARRAY_UPPER(pPeriodIds,1);

  IF (pInterval = 'M') THEN
    FOR _i IN 1.._count
    LOOP
      SELECT period_start, period_end INTO _start, _end
      FROM period
      WHERE (period_id=pPeriodids[_i]);

      _row.flcoldata_column := _col;
      _row.flcoldata_start := _start;
      _row.flcoldata_end := _end;
      RETURN NEXT _row;
      _col := _col + _incr;
    END LOOP;
  ELSIF (pInterval = 'Q') THEN
    FOR _i IN 1.._count
    LOOP
      SELECT min(qtr.period_start), max(qtr.period_end) INTO _start, _end
      FROM period cur
        JOIN period qtr ON (cur.period_yearperiod_id=qtr.period_yearperiod_id)
                        AND (cur.period_quarter=qtr.period_quarter)
      WHERE (cur.period_id=pPeriodids[_i]);

      _row.flcoldata_column := _col;
      _row.flcoldata_start := _start;
      _row.flcoldata_end := _end;
      RETURN NEXT _row;
      _col := _col + _incr;
    END LOOP;
  ELSE
    FOR _i IN 1.._count
    LOOP
      SELECT yearperiod_start, yearperiod_end INTO _start, _end
      FROM period
        JOIN yearperiod ON (period_yearperiod_id=yearperiod_id)
      WHERE (period_id=pPeriodids[_i]);

      _row.flcoldata_column := _col;
      _row.flcoldata_start := _start;
      _row.flcoldata_end := _end;
      RETURN NEXT _row;
      _col := _col + _incr;
    END LOOP;
  END IF;
  RETURN;

END;
$_$;


ALTER FUNCTION public.getflcoldata(character, integer[], boolean) OWNER TO admin;

--
-- TOC entry 1695 (class 1255 OID 146566273)
-- Dependencies: 2669 4536 8
-- Name: getflstmthead(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getflstmthead(integer, integer) RETURNS SETOF flstmthead
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pFlcolid ALIAS FOR $1;
  pPeriodid ALIAS FOR $2;
  _row flstmthead%ROWTYPE;
  _p RECORD;
  _month TEXT;
  _qtr TEXT;
  _year TEXT;
  _prmonth TEXT;
  _prqtr TEXT;
  _pryear TEXT;
  _err TEXT;

BEGIN

  SELECT 'No Data' INTO _err;

--Get Layout Data
  SELECT flcol_priortype, flcol_prioryear INTO _p
  FROM flcol
  WHERE (flcol_id=pFlcolid);

--get data...
--...for current Month
        SELECT
          (CASE
                      WHEN period_name='' THEN
                        formatdate(period_start) || '-' || formatdate(period_end)
                      ELSE period_name
          END) INTO _month
        FROM period
        WHERE (period_id=pPeriodId);

        IF _month IS NULL THEN
          _month := _err;
        END IF;

--...for Quarter
        SELECT
          ('Q' || period_quarter || '-' || EXTRACT(year from yearperiod_end)) INTO _qtr
        FROM period, yearperiod
        WHERE ((period_id=pPeriodId)
        AND (period_yearperiod_id=yearperiod_id));

        IF _qtr IS NULL THEN
          _qtr := _err;
        END IF;

--...for Year
        SELECT
          COALESCE((CASE WHEN period_name='' THEN
                (formatdate(period_start) || '-' || formatdate(period_end) || ' YTD')
          ELSE (period_name || ' YTD')
          END),'No Data') INTO _year
        FROM period
        WHERE (period_id=pPeriodId);

        IF _year IS NULL THEN
          _year := _err;
        END IF;

--...for prior month

        IF (_p.flcol_priortype = 'P') THEN

          SELECT
            (CASE WHEN pp.period_name='' THEN
              formatdate(pp.period_start) || '-' || formatdate(pp.period_end)
            ELSE pp.period_name END) INTO _prmonth
          FROM period cp, period pp
          WHERE ((cp.period_id=pPeriodId)
          AND (cp.period_start > pp.period_start))
          ORDER BY pp.period_start DESC LIMIT 1;

        ELSE

          SELECT
            (CASE WHEN pp.period_name='' THEN
              formatdate(pp.period_start) || '-' || formatdate(pp.period_end)
            ELSE pp.period_name END) INTO _prmonth
          FROM period cp, period pp
          WHERE ((cp.period_id=pPeriodId)
           AND (cp.period_id != pp.period_id)
           AND (cp.period_start > pp.period_start)
           AND (cp.period_number = pp.period_number))
          ORDER BY pp.period_start DESC LIMIT 1;

        END IF;

          IF _prmonth IS NULL THEN
            _prmonth := _err;
          END IF;


--...for prior quarter

        IF (_p.flcol_priortype='P') THEN

          SELECT ('Q' || pp.period_quarter || '-' || EXTRACT(year from yearperiod_end)) INTO _prqtr
          FROM period cp, period pp, yearperiod
          WHERE ((cp.period_id=pPeriodId)
          AND (cp.period_start > pp.period_start)
          AND (pp.period_quarter=
            CASE WHEN cp.period_quarter > 1 THEN
              cp.period_quarter - 1
          ELSE 4 END)
          AND (pp.period_start >= cp.period_start - interval '1 year')
          AND (pp.period_yearperiod_id=yearperiod_id))
          ORDER BY pp.period_start DESC LIMIT 1;

        ELSE

          SELECT
            ('Q' || pp.period_quarter || '-' || EXTRACT(year from pp.period_start)) INTO _prqtr
          FROM period cp, period pp, yearperiod cy, yearperiod py
          WHERE ((cp.period_id=pPeriodId)
          AND (cp.period_yearperiod_id=cy.yearperiod_id)
          AND (pp.period_yearperiod_id=py.yearperiod_id)
          AND (cp.period_quarter=pp.period_quarter)
          AND (cy.yearperiod_start > py.yearperiod_start))
          ORDER BY py.yearperiod_start DESC, pp.period_start DESC LIMIT 1;

        END IF;

        IF _prqtr IS NULL THEN
          _prqtr := _err;
        END IF;

--...for prior year

        IF (_p.flcol_prioryear='F') THEN

          SELECT (EXTRACT(year from py.yearperiod_end)||'') INTO _pryear
          FROM period cp, yearperiod cy, yearperiod py
          WHERE ((cp.period_id=pPeriodId)
           AND (cp.period_yearperiod_id = cy.yearperiod_id)
           AND (cy.yearperiod_start > py.yearperiod_start))
          ORDER BY py.yearperiod_start DESC LIMIT 1;

        ELSE

          SELECT
          (CASE
                      WHEN pp.period_name='' THEN
                        formatdate(pp.period_start) || '-' || formatdate(pp.period_end) || ' YTD'
                      ELSE pp.period_name || ' YTD'
          END) INTO _pryear
          FROM period cp, period pp
          WHERE ((cp.period_id=pPeriodId)
            AND (cp.period_number = pp.period_number)
            AND (cp.period_start > pp.period_start))
          ORDER BY pp.period_start DESC LIMIT 1;

        END IF;

        IF _pryear IS NULL THEN
          _pryear := _err;
        END IF;

-- RETURN RESULTS

        SELECT
                flhead_id AS flstmthead_flhead_id,
                flcol_id AS flstmthead_flcol_id,
                pPeriodid AS flstmthead_period,
                getEffectiveXtUser() AS flstmthead_username,
                CASE
                        WHEN flhead_type = 'I' THEN 'Income Statement'
                        WHEN flhead_type = 'B' THEN 'Balance Sheet'
                        WHEN flhead_type = 'C' THEN 'Cash Flow Statement'
                        ELSE 'N/A'
                END AS flstmthead_flhead_typedescrip1,
                CASE
                        WHEN flhead_type = 'I' THEN 'Income'
                        WHEN flhead_type = 'B' THEN 'Balance'
                        WHEN flhead_type = 'C' THEN 'Cash'
                        ELSE 'N/A'
                END AS flstmthead_flhead_typedescrip2,
                flhead_name AS flstmthead_flhead_name,
                flcol_name AS flstmthead_flcol_name,
                _month AS flstmthead_month,
                _qtr AS flstmthead_qtr,
                _year AS flstmthead_year,
                _prmonth AS flstmthead_prmonth,
                _prqtr AS flstmthead_prqtr,
                _pryear AS flstmthead_pryear INTO _p
        FROM flhead,flcol
        WHERE ((flcol_id=pFlcolid)
        AND (flhead_id=flcol_flhead_id));

                _row.flstmthead_flhead_id := _p.flstmthead_flhead_id;
                _row.flstmthead_flcol_id := _p.flstmthead_flcol_id;
                _row.flstmthead_period_id := _p.flstmthead_period;
                _row.flstmthead_username := _p.flstmthead_username;
                _row.flstmthead_typedescrip1 := _p.flstmthead_flhead_typedescrip1;
                _row.flstmthead_typedescrip2 := _p.flstmthead_flhead_typedescrip2;
                _row.flstmthead_flhead_name := _p.flstmthead_flhead_name;
                _row.flstmthead_flcol_name := _p.flstmthead_flcol_name;
                _row.flstmthead_month := _p.flstmthead_month;
                _row.flstmthead_qtr := _p.flstmthead_qtr;
                _row.flstmthead_year := _p.flstmthead_year;
                _row.flstmthead_prmonth := _p.flstmthead_prmonth;
                _row.flstmthead_prqtr := _p.flstmthead_prqtr;
                _row.flstmthead_pryear := _p.flstmthead_pryear;

        RETURN NEXT _row;

END;
$_$;


ALTER FUNCTION public.getflstmthead(integer, integer) OWNER TO admin;

--
-- TOC entry 1696 (class 1255 OID 146566274)
-- Dependencies: 2675 4536 8
-- Name: getfltrendhead(integer, integer[], character); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getfltrendhead(integer, integer[], character) RETURNS SETOF fltrendhead
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pFlheadid ALIAS FOR $1;
  pPeriodids ALIAS FOR $2;
  pInterval ALIAS FOR $3;
  _row fltrendhead%ROWTYPE;
  _p RECORD;
  _count INTEGER;
  _i INTEGER;
  _t TEXT;
  _fld TEXT[];
  _type CHAR;

BEGIN

-- Validate Interval
   IF pInterval <> 'M' AND pInterval <> 'Q' AND pInterval <> 'Y' THEN
     RAISE EXCEPTION 'Invalid Interval --> %', pInterval;
   END IF;

   IF ARRAY_UPPER(pPeriodIds,1) <= 12 THEN
        _count := ARRAY_UPPER(pPeriodIds,1);
   ELSE
        _count := 12;
   END IF;

   SELECT flhead_type INTO _type FROM flhead WHERE flhead_id = pFlheadId;

--get data...
--...for Month
        IF (pInterval = 'M') THEN
                FOR _i IN 1.._count
                LOOP
                        SELECT
                        (CASE
                                WHEN period_name='' THEN
                                        formatdate(period_start) || '-' || formatdate(period_end)
                                ELSE period_name
                        END) INTO _t
                        FROM period
                        WHERE (period_id=pPeriodIds[_i]);

                        _fld[_i] := _t;

                END LOOP;

--...for Quarter
                ELSE IF (pInterval = 'Q') THEN
                        FOR _i IN 1.._count
                        LOOP
                                SELECT
                                        ('Q' || period_quarter || '-' || EXTRACT(year from yearperiod_end)) INTO _t
                                FROM period, yearperiod
                                WHERE ((period_id=pPeriodIds[_i])
                                AND (period_yearperiod_id=yearperiod_id));

                                        _fld[_i] := _t;

                        END LOOP;
--...for Year
                ELSE
                        FOR _i IN 1.._count
                        LOOP
                                SELECT (EXTRACT(year from yearperiod_end)||'') INTO _t
                                FROM period, yearperiod
                                WHERE ((period_id=pPeriodIds[_i])
                                AND (period_yearperiod_id=yearperiod_id));

                                _fld[_i] := _t;

                        END LOOP;
                END IF;
        END IF;


-- RETURN RESULTS

        SELECT
                flhead_id AS fltrendhead_flhead_id,
                getEffectiveXtUser() AS fltrendhead_username,
                CASE
                        WHEN flhead_type = 'I' THEN 'Income Statement'
                        WHEN flhead_type = 'B' THEN 'Balance Sheet'
                        WHEN flhead_type = 'C' THEN 'Cash Flow Statement'
                        ELSE 'Ad Hoc'
                END AS fltrendhead_flhead_typedescrip,
                flhead_name AS fltrendhead_flhead_name INTO _p
        FROM flhead
        WHERE (flhead_id=pFlheadId);

                _row.fltrendhead_flhead_id := _p.fltrendhead_flhead_id;
                _row.fltrendhead_username := _p.fltrendhead_username;
               _row.fltrendhead_typedescrip := _p.fltrendhead_flhead_typedescrip;
                _row.fltrendhead_flhead_name := _p.fltrendhead_flhead_name;
                _row.fltrendhead_fld1 := _fld[1];
                _row.fltrendhead_fld2 := _fld[2];
                _row.fltrendhead_fld3 := _fld[3];
                _row.fltrendhead_fld4 := _fld[4];
                _row.fltrendhead_fld5 := _fld[5];
                _row.fltrendhead_fld6 := _fld[6];
                _row.fltrendhead_fld7 := _fld[7];
                _row.fltrendhead_fld8 := _fld[8];
                _row.fltrendhead_fld9 := _fld[9];
                _row.fltrendhead_fld10 := _fld[10];
                _row.fltrendhead_fld11 := _fld[11];
                _row.fltrendhead_fld12 := _fld[12];
                IF (_type IN ('I','C')) THEN
                        _row.fltrendhead_grndttl := 'Total';
                END IF;

        RETURN NEXT _row;

END;
$_$;


ALTER FUNCTION public.getfltrendhead(integer, integer[], character) OWNER TO admin;

--
-- TOC entry 1697 (class 1255 OID 146566275)
-- Dependencies: 4536 8
-- Name: getfreightclassid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getfreightclassid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pFreightClassCode ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pFreightClassCode IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT freightclass_id INTO _returnVal
  FROM freightclass
  WHERE (freightclass_code=pFreightClassCode);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Freight Class % not found.', pFreightClassCode;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getfreightclassid(text) OWNER TO admin;

--
-- TOC entry 1698 (class 1255 OID 146566276)
-- Dependencies: 4536 8
-- Name: getfreighttaxtypeid(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getfreighttaxtypeid() RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _taxtypeid INTEGER;
BEGIN
  SELECT taxtype_id
    INTO _taxtypeid
    FROM taxtype
   WHERE (taxtype_name='Freight');

  RETURN _taxtypeid;
END;
$$;


ALTER FUNCTION public.getfreighttaxtypeid() OWNER TO admin;

--
-- TOC entry 1699 (class 1255 OID 146566277)
-- Dependencies: 4536 8
-- Name: getgainlossaccntid(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getgainlossaccntid(integer) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pAccntId ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF ( (pAccntId = 0) OR (pAccntId IS NULL) ) THEN
	RETURN 0;
  END IF;

  IF (fetchMetricValue('GLCompanySize') = 0) THEN
    _returnVal := fetchMetricValue('CurrencyGainLossAccount')::integer;
  ELSE
    SELECT company_gainloss_accnt_id INTO _returnVal
    FROM company
      JOIN accnt ON (company_number=accnt_company)
    WHERE (accnt_id=pAccntId);
  END IF;

  IF (_returnVal IS NULL) THEN
    RAISE EXCEPTION 'Currency Gain/Loss Account not found for %', formatGlAccountLong(pAccntId);
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getgainlossaccntid(integer) OWNER TO admin;

--
-- TOC entry 1700 (class 1255 OID 146566278)
-- Dependencies: 4536 8
-- Name: getglaccntid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getglaccntid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pGlAccnt ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pGlAccnt IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT accnt_id INTO _returnVal
  FROM accnt
  WHERE (formatglaccount(accnt_id)=pGlAccnt);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Account Number % not found.', pGlAccnt;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getglaccntid(text) OWNER TO admin;

--
-- TOC entry 1701 (class 1255 OID 146566279)
-- Dependencies: 4536 8
-- Name: getglaccntid(text, text, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getglaccntid(text, text, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCompany ALIAS FOR $1;
  pProfit ALIAS FOR $2;
  pGlAccnt ALIAS FOR $3;
  pSub ALIAS FOR $4;
  _account TEXT;
  _returnVal INTEGER;
BEGIN
  IF (pGlAccnt IS NULL) THEN
	RETURN NULL;
  END IF;

  IF (pCompany is not null) THEN
    _account := pCompany || '-';
  END IF;

  IF (pProfit is not null) THEN
    _account := _account || pProfit || '-';
  END IF;
  IF (pGlAccnt is not null) THEN
    if (_account is null) then
	_account := pGlAccnt;
    else
	_account := _account || pGlAccnt;
    end if;
  END IF;

  IF (pSub is not null) THEN
    _account := _account || '-' || pSub;
  END IF;

  SELECT accnt_id INTO _returnVal
  FROM accnt
  WHERE (formatglaccount(accnt_id)=_account);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Account Number % not found.', _account;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getglaccntid(text, text, text, text) OWNER TO admin;

--
-- TOC entry 1702 (class 1255 OID 146566280)
-- Dependencies: 4536 8
-- Name: getimageid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getimageid(pimagename text) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;
BEGIN
  IF (COALESCE(TRIM(pImageName), '') = '') THEN
    RETURN NULL;
  END IF;

  SELECT image_id INTO _returnVal
  FROM image
  WHERE (image_name=pImageName);

  IF (_returnVal IS NULL) THEN
    RAISE EXCEPTION 'Image % not found.', pImageName;
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getimageid(pimagename text) OWNER TO admin;

--
-- TOC entry 1703 (class 1255 OID 146566281)
-- Dependencies: 4536 8
-- Name: getincdtcatid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getincdtcatid(pincdtcatname text) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;
BEGIN
  IF (pIncdtCatName IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT incdtcat_id INTO _returnVal
  FROM incdtcat
  WHERE (incdtcat_name=pIncdtCatName);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Incident Category Name % not found.', pIncdtCatName;
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getincdtcatid(pincdtcatname text) OWNER TO admin;

--
-- TOC entry 1704 (class 1255 OID 146566282)
-- Dependencies: 4536 8
-- Name: getincdtcrmacctid(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getincdtcrmacctid(pincidentnumber integer) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;
BEGIN
  IF (pIncidentNumber IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT incdt_crmacct_id INTO _returnVal
  FROM incdt
  WHERE (incdt_number=pIncidentNumber);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Incident Number % not found.', pIncidentNumber;
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getincdtcrmacctid(pincidentnumber integer) OWNER TO admin;

--
-- TOC entry 1705 (class 1255 OID 146566283)
-- Dependencies: 4536 8
-- Name: getincdtpriorityid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getincdtpriorityid(pincdtpriorityname text) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;
BEGIN
  IF (pIncdtPriorityName IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT incdtpriority_id INTO _returnVal
  FROM incdtpriority
  WHERE (incdtpriority_name=pIncdtPriorityName);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Incident Priority Name % not found.', pIncdtPriorityName;
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getincdtpriorityid(pincdtpriorityname text) OWNER TO admin;

--
-- TOC entry 1706 (class 1255 OID 146566284)
-- Dependencies: 4536 8
-- Name: getincdtresolutionid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getincdtresolutionid(pincdtresolutionname text) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;
BEGIN
  IF (pIncdtResolutionName IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT incdtresolution_id INTO _returnVal
  FROM incdtresolution
  WHERE (incdtresolution_name=pIncdtResolutionName);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Incident Resolution Name % not found.', pIncdtResolutionName;
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getincdtresolutionid(pincdtresolutionname text) OWNER TO admin;

--
-- TOC entry 1707 (class 1255 OID 146566285)
-- Dependencies: 4536 8
-- Name: getincdtseverityid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getincdtseverityid(pincdtseverityname text) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;
BEGIN
  IF (pIncdtSeverityName IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT incdtseverity_id INTO _returnVal
  FROM incdtseverity
  WHERE (incdtseverity_name=pIncdtSeverityName);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Incident Severity Name % not found.', pIncdtSeverityName;
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getincdtseverityid(pincdtseverityname text) OWNER TO admin;

--
-- TOC entry 1708 (class 1255 OID 146566286)
-- Dependencies: 4536 8
-- Name: getincidentid(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getincidentid(pincidentnumber integer) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;
BEGIN
  IF (pIncidentNumber IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT incdt_id INTO _returnVal
  FROM incdt
  WHERE (incdt_number=pIncidentNumber);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Incident Number % not found.', pIncidentNumber;
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getincidentid(pincidentnumber integer) OWNER TO admin;

--
-- TOC entry 1709 (class 1255 OID 146566287)
-- Dependencies: 4536 8
-- Name: getinvcheadid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getinvcheadid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pInvcNumber ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pInvcNumber IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT invchead_id INTO _returnVal
  FROM invchead
  WHERE (UPPER(invchead_invcnumber)=UPPER(pInvcNumber));

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Invoice % not found.', pInvcNumber;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getinvcheadid(text) OWNER TO admin;

--
-- TOC entry 1710 (class 1255 OID 146566288)
-- Dependencies: 4536 8
-- Name: getinvcitemlotserial(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getinvcitemlotserial(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pInvcitemid ALIAS FOR $1;
  _lotserial text;
  _r RECORD;
  _first BOOLEAN;
  _newMethod BOOLEAN;
BEGIN

  --Test to see if Lot/Serial Enabled
  SELECT metric_value INTO _lotserial
  FROM metric
  WHERE ((metric_name='LotSerialControl')
  AND (metric_value ='t'));

  IF (FOUND) THEN
    _lotserial := '';
    _first := true;

--  Two ways of doing this: old method and new method
--  First, find out if new method employed.
--  (new method is more accurate, but unfortunately no
--  way to migrate or correct old data.  Have to keep
--  old method in case someone reprints an old invoice.)

    SELECT (COUNT(*) > 0) INTO _newMethod
    FROM shipitem
    WHERE ((shipitem_invcitem_id=pInvcitemid)
    AND (shipitem_invhist_id IS NOT NULL));

    IF (_newMethod) THEN

      FOR _r IN SELECT DISTINCT ls_number
                FROM invdetail, invhist, shipitem, ls
               WHERE ((shipitem_invcitem_id=pInvcitemid)
                 AND  (shipitem_invhist_id=invhist_id)
                 AND  (invhist_id=invdetail_invhist_id)
                 AND  (invdetail_ls_id=ls_id)) LOOP
        IF (_first = false) THEN
          _lotserial := _lotserial || ', ';
        END IF;
        _lotserial := _lotserial || _r.ls_number;
        _first := false;
      END LOOP;

      RETURN _lotserial;
    ELSE
      -- Handle it old way
      FOR _r IN SELECT DISTINCT ls_number
                FROM ls, invdetail JOIN invhist ON (invdetail_invhist_id=invhist_id)
               WHERE ((invhist_transtype='SH')
                 AND  (invdetail_invcitem_id=pInvcitemid)
                 AND  (invdetail_ls_id=ls_id)) LOOP
        IF (_first = false) THEN
          _lotserial := _lotserial || ', ';
        END IF;
        _lotserial := _lotserial || _r.ls_number;
        _first := false;
      END LOOP;

      RETURN _lotserial;
    END IF;
  ELSE
    RETURN '';
  END IF;

END
$_$;


ALTER FUNCTION public.getinvcitemlotserial(integer) OWNER TO admin;

--
-- TOC entry 1684 (class 1255 OID 146566289)
-- Dependencies: 4536 8
-- Name: getipsheadid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getipsheadid(pipsname text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;
BEGIN
  IF (pIpsName IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT ipshead_id INTO _returnVal
  FROM ipshead
  WHERE (ipshead_name=pIpsName);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Pricing Schedule % not found.', pIpsName;
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getipsheadid(pipsname text) OWNER TO admin;

--
-- TOC entry 1712 (class 1255 OID 146566290)
-- Dependencies: 4536 8
-- Name: getipsitemid(text, text, numeric, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getipsitemid(pipsname text, pitemnumber text, pqtybreak numeric, pqtyuom text, ppriceuom text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;

BEGIN
  IF (pIpsName IS NULL AND pItemNumber IS NULL AND pQtyBreak IS NULL AND pQtyUom IS NULL AND pPriceUom IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT ipsitem_id INTO _returnVal
  FROM ipsiteminfo
  WHERE ((ipsitem_ipshead_id=getIpsheadId(pIpsName))
  AND (ipsitem_item_id=getItemId(pItemNumber))
  AND (ipsitem_qtybreak=pQtyBreak)
  AND (ipsitem_qty_uom_id=getUomId(pQtyUom))
  AND (ipsitem_price_uom_id=getUomId(pPriceUom)));

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Pricing Schedule Item for Schedule %, Item %,Qt Break %,Qty UOM %, Price UOM % not found.',
	pIpsName, pItemNumber, pQtyBreak, pQtyUom, pPriceUom;
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getipsitemid(pipsname text, pitemnumber text, pqtybreak numeric, pqtyuom text, ppriceuom text) OWNER TO admin;

--
-- TOC entry 1713 (class 1255 OID 146566291)
-- Dependencies: 4536 8
-- Name: getipsprodcatid(text, text, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getipsprodcatid(pipsname text, pprodcat text, pqtybreak numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;

BEGIN
  IF (pIpsName IS NULL AND pProdCat IS NULL AND pQtyBreak IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT ipsitem_id INTO _returnVal
  FROM ipsiteminfo
  WHERE ((ipsitem_ipshead_id=getIpsheadId(pIpsName))
  AND (ipsitem_prodcat_id=getProdcatId(pProdCat))
  AND (ipsitem_qtybreak=pQtyBreak));

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Pricing Schedule Product Category for Schedule %, Product Category %,Qt Break % not found.',
	pIpsName, pProdCat, pQtyBreak;
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getipsprodcatid(pipsname text, pprodcat text, pqtybreak numeric) OWNER TO admin;

--
-- TOC entry 1714 (class 1255 OID 146566292)
-- Dependencies: 4536 8
-- Name: getitemid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getitemid(text) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemNumber ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pItemNumber IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT item_id INTO _returnVal
  FROM item
  WHERE (item_number=UPPER(pItemNumber));

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Item % not found.', pItemNumber;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getitemid(text) OWNER TO admin;

--
-- TOC entry 1715 (class 1255 OID 146566293)
-- Dependencies: 4536 8
-- Name: getitemidfromupc(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getitemidfromupc(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemUPC ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pItemUPC IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT item_id INTO _returnVal
  FROM item
  WHERE (item_upccode=UPPER(pItemUPC));

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Item % not found.', pItemUPC;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getitemidfromupc(text) OWNER TO admin;

--
-- TOC entry 1716 (class 1255 OID 146566294)
-- Dependencies: 4536 8
-- Name: getitemsiteid(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getitemsiteid(text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWarehouseCode ALIAS FOR $1;
  pItemNumber ALIAS FOR $2;
  _returnVal INTEGER;
BEGIN
  SELECT getItemsiteId(pWarehouseCode,pItemNumber,'ALL') INTO _returnVal;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getitemsiteid(text, text) OWNER TO admin;

--
-- TOC entry 1717 (class 1255 OID 146566295)
-- Dependencies: 4536 8
-- Name: getitemsiteid(text, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getitemsiteid(text, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWarehouseCode ALIAS FOR $1;
  pItemNumber ALIAS FOR $2;
  pType ALIAS FOR $3;
  _type TEXT;
  _p RECORD;
BEGIN
  IF ((pWarehouseCode IS NULL) OR (pItemNumber IS NULL)) THEN
	RETURN NULL;
  END IF;

  IF UPPER(pType) NOT IN ('ALL','ACTIVE','SOLD') THEN
    RAISE EXCEPTION 'Invalid Type %. Valid Itemsite types are ALL and SOLD', pType;
  END IF;

  SELECT * INTO _p
  FROM itemsite, item
  WHERE ((itemsite_item_id=item_id)
  AND (itemsite_warehous_id=getWarehousId(pWarehouseCode,'ALL'))
  AND (item_number=UPPER(pItemNumber)));

  IF NOT (FOUND) THEN
    RAISE EXCEPTION 'Item % not found in Warehouse %', pItemNumber, pWarehouseCode;
  ELSIF ((UPPER(pType)='ACTIVE') OR (UPPER(pType)='SOLD')) THEN
    IF NOT (_p.item_active) THEN
      RAISE EXCEPTION 'Item % is inactive.', pItemNumber;
    ELSE
      IF NOT (_p.itemsite_active) THEN
        RAISE EXCEPTION 'Item % is inactive in Warehouse %', pItemNumber, pWarehouseCode;
      ELSE
        IF ((UPPER(pType)='SOLD') AND NOT _p.item_sold) THEN
          RAISE EXCEPTION 'Item % is not sold', pItemNumber;
        ELSE
          IF ((UPPER(pType)='SOLD') AND NOT _p.itemsite_sold) THEN
            RAISE EXCEPTION 'Item % is not sold from Warehouse %', pItemNumber, pWarehouseCode;
          END IF;
        END IF;
      END IF;
    END IF;
  END IF;

  RETURN _p.itemsite_id;
END;
$_$;


ALTER FUNCTION public.getitemsiteid(text, text, text) OWNER TO admin;

--
-- TOC entry 1718 (class 1255 OID 146566296)
-- Dependencies: 4536 8
-- Name: getitemsrcid(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getitemsrcid(text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemNumber ALIAS FOR $1;
  pVendNumber ALIAS FOR $2;
  _returnVal INTEGER;
BEGIN
  IF ((pItemNumber IS NULL) OR (pVendNumber IS NULL)) THEN
    RETURN NULL;
  END IF;

  SELECT itemsrc_id INTO _returnVal
  FROM itemsrc
  WHERE ((itemsrc_item_id=getItemId(pItemNumber))
  AND (itemsrc_vend_id=getVendId(pVendNumber)));

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Item Source Item % Vendor % not found.', pItemNumber,pVendNumber;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getitemsrcid(text, text) OWNER TO admin;

--
-- TOC entry 1719 (class 1255 OID 146566297)
-- Dependencies: 4536 8
-- Name: getlasttrialbalid(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getlasttrialbalid(integer, integer) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pAccntId ALIAS FOR $1;
  pPeriodId ALIAS FOR $2;
  _p RECORD;
  _accntType TEXT;
  _result NUMERIC;

BEGIN

  SELECT period_end,period_yearperiod_id INTO _p
  FROM period
  WHERE period_id=pPeriodId;

  SELECT accnt_type INTO _accntType
  FROM accnt
  WHERE accnt_id=pAccntId;

  IF (_accntType IN ('R','E')) THEN
        SELECT trialbal_id INTO _result
        FROM trialbal
        WHERE ((trialbal_accnt_id=pAccntId)
        AND (trialbal_period_id=pPeriodId));
  ELSE
        SELECT trialbal_id INTO _result
        FROM (SELECT trialbal_id
                FROM trialbal,period
                WHERE ((trialbal_accnt_id=pAccntId)
                AND (trialbal_period_id=period_id)
                AND (period_end <= _p.period_end)
                AND (period_yearperiod_id=_p.period_yearperiod_id))
                ORDER BY period_end DESC) AS data;
  END IF;

  RETURN _result;

END;
$_$;


ALTER FUNCTION public.getlasttrialbalid(integer, integer) OWNER TO admin;

--
-- TOC entry 1693 (class 1255 OID 146566298)
-- Dependencies: 4536 8
-- Name: getlocationid(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getlocationid(text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWarehouse ALIAS FOR $1;
  pLocation ALIAS FOR $2;
  _returnVal INTEGER;
BEGIN
  IF (pLocation IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT location_id INTO _returnVal
  FROM location
  WHERE ((location_warehous_id=getWarehousId(pWarehouse,'ACTIVE'))
  AND (formatLocationname(location_id)=pLocation))
  LIMIT 1;

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Location % not found in Warehouse %.', pLocation, pWarehouse;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getlocationid(text, text) OWNER TO admin;

--
-- TOC entry 1721 (class 1255 OID 146566299)
-- Dependencies: 4536 8
-- Name: getlotserialid(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getlotserialid(text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemNumber ALIAS FOR $1;
  pLotSerialNumber ALIAS FOR $2;
  _returnVal INTEGER;
BEGIN
  IF ((pItemNumber IS NULL) OR (pLotSerialNumber IS NULL) OR (pLotSerialNumber='')) THEN
	RETURN NULL;
  END IF;

  SELECT ls_id INTO _returnVal
  FROM ls
  WHERE ((ls_item_id=getItemId(pItemNumber))
  AND (UPPER(ls_number)=UPPER(pLotSerialNumber)));

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'LotSerial % not found.', pLotSerialNumber;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getlotserialid(text, text) OWNER TO admin;

--
-- TOC entry 1722 (class 1255 OID 146566300)
-- Dependencies: 4536 8
-- Name: getopenshipment(text, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getopenshipment(pordertype text, porderid integer, pwarehousid integer) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _result TEXT := '';

BEGIN

  IF (pOrderType = 'SO') THEN
    SELECT shiphead_number INTO _result
    FROM shiphead JOIN shipitem ON (shipitem_shiphead_id=shiphead_id)
                  JOIN coitem ON (coitem_id=shipitem_orderitem_id)
                  JOIN itemsite ON (itemsite_id=coitem_itemsite_id)
    WHERE (shiphead_order_id=pOrderId)
      AND (shiphead_order_type='SO')
      AND (NOT shiphead_shipped)
      AND (CASE WHEN (pWarehousId IS NULL) THEN TRUE
                ELSE itemsite_warehous_id=pWarehousId END)
    ORDER BY shiphead_number
    LIMIT 1;
  ELSEIF (pOrderType = 'TO') THEN
    SELECT shiphead_number INTO _result
    FROM shiphead JOIN tohead ON (tohead_id=shiphead_order_id)
    WHERE (shiphead_order_id=pOrderId)
      AND (shiphead_order_type='TO')
      AND (NOT shiphead_shipped)
      AND (CASE WHEN (pWarehousId IS NULL) THEN TRUE
                ELSE tohead_src_warehous_id=pWarehousId END)
    ORDER BY shiphead_number
    LIMIT 1;
  END IF;

  RETURN _result;

END;
$$;


ALTER FUNCTION public.getopenshipment(pordertype text, porderid integer, pwarehousid integer) OWNER TO admin;

--
-- TOC entry 1723 (class 1255 OID 146566301)
-- Dependencies: 4536 8
-- Name: getopenshipmentid(text, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getopenshipmentid(pordertype text, porderid integer, pwarehousid integer) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _result INTEGER := -1;

BEGIN

  IF (pOrderType = 'SO') THEN
    SELECT shiphead_id INTO _result
    FROM shiphead JOIN shipitem ON (shipitem_shiphead_id=shiphead_id)
                  JOIN coitem ON (coitem_id=shipitem_orderitem_id)
                  JOIN itemsite ON (itemsite_id=coitem_itemsite_id)
    WHERE (shiphead_order_id=pOrderId)
      AND (shiphead_order_type='SO')
      AND (NOT shiphead_shipped)
      AND (CASE WHEN (pWarehousId IS NULL) THEN TRUE
                ELSE itemsite_warehous_id=pWarehousId END)
    ORDER BY shiphead_number
    LIMIT 1;
  ELSEIF (pOrderType = 'TO') THEN
    SELECT shiphead_id INTO _result
    FROM shiphead JOIN tohead ON (tohead_id=shiphead_order_id)
    WHERE (shiphead_order_id=pOrderId)
      AND (shiphead_order_type='TO')
      AND (NOT shiphead_shipped)
      AND (CASE WHEN (pWarehousId IS NULL) THEN TRUE
                ELSE tohead_src_warehous_id=pWarehousId END)
    ORDER BY shiphead_number
    LIMIT 1;
  END IF;

  RETURN _result;

END;
$$;


ALTER FUNCTION public.getopenshipmentid(pordertype text, porderid integer, pwarehousid integer) OWNER TO admin;

--
-- TOC entry 1724 (class 1255 OID 146566302)
-- Dependencies: 4536 8
-- Name: getopheadid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getopheadid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pOpHeadName ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN

  IF (pOpHeadName IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT ophead_id INTO _returnVal
  FROM ophead
  WHERE (UPPER(ophead_name)=UPPER(pOpHeadName));

  IF (_returnVal IS NULL) THEN
      RAISE EXCEPTION 'Opportunity % not found.', pOpHeadName;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getopheadid(text) OWNER TO admin;

--
-- TOC entry 1725 (class 1255 OID 146566303)
-- Dependencies: 4536 8
-- Name: getpacklistcharname(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getpacklistcharname(integer, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pShipheadId ALIAS FOR $1;
  pOrderItemId ALIAS FOR $2;
  _charname text;
  _r RECORD;
  _first BOOLEAN;

BEGIN

-- If transfer order, get out
  SELECT shiphead_order_type INTO _r
  FROM shiphead
  WHERE ((shiphead_id=pShipheadId)
  AND (shiphead_order_type='TO'));

  IF (FOUND) THEN
    RETURN '';
  END IF;

  _charname := '';
  _first := true;

  FOR _r IN SELECT char_name
            FROM char, charass
            WHERE ((char_id=charass_char_id)
            AND (charass_target_type='SI')
            AND (charass_target_id=pOrderItemId))
  LOOP
        IF (_first = false) THEN
          _charname := _charname || '
';
        END IF;
        _charname := _charname || _r.char_name;
        _first := false;
  END LOOP;

  RETURN _charname;

END
$_$;


ALTER FUNCTION public.getpacklistcharname(integer, integer) OWNER TO admin;

--
-- TOC entry 1726 (class 1255 OID 146566304)
-- Dependencies: 4536 8
-- Name: getpacklistcharvalue(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getpacklistcharvalue(integer, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pShipheadId ALIAS FOR $1;
  pOrderItemId ALIAS FOR $2;
  _charval text;
  _r RECORD;
  _first BOOLEAN;

BEGIN

-- If transfer order, get out
  SELECT shiphead_order_type INTO _r
  FROM shiphead
  WHERE ((shiphead_id=pShipheadId)
  AND (shiphead_order_type='TO'));

  IF (FOUND) THEN
    RETURN '';
  END IF;

  _charval := '';
  _first := true;

  FOR _r IN SELECT charass_value
            FROM char, charass
            WHERE ((char_id=charass_char_id)
            AND (charass_target_type='SI')
            AND (charass_target_id=pOrderItemId))
  LOOP
        IF (_first = false) THEN
          _charval := _charval || '
';
        END IF;
        _charval := _charval || _r.charass_value;
        _first := false;
  END LOOP;

  RETURN _charval;

END
$_$;


ALTER FUNCTION public.getpacklistcharvalue(integer, integer) OWNER TO admin;

--
-- TOC entry 1727 (class 1255 OID 146566305)
-- Dependencies: 4536 8
-- Name: getpacklistitemlotserial(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getpacklistitemlotserial(integer, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pShipheadId ALIAS FOR $1;
  pOrderItemId ALIAS FOR $2;
  _lotserial text;
  _r RECORD;
  _first BOOLEAN;

BEGIN

  --Test to see if Lot/Serial Enabled
  SELECT metric_value INTO _lotserial
  FROM metric
  WHERE ((metric_name='LotSerialControl')
  AND (metric_value ='t'));

  IF (FOUND) THEN
    _lotserial := '';
    _first := true;

    FOR _r IN SELECT DISTINCT ls_number
              FROM invdetail, invhist, shipitem, ls
             WHERE ((shipitem_shiphead_id=pShipheadId)
               AND  (shipitem_orderitem_id=pOrderItemId)
               AND  (shipitem_invhist_id=invhist_id)
               AND  (invhist_id=invdetail_invhist_id)
               AND  (invdetail_ls_id=ls_id)) LOOP
      IF (_first = false) THEN
        _lotserial := _lotserial || ', ';
      END IF;
      _lotserial := _lotserial || _r.ls_number;
      _first := false;
    END LOOP;

    RETURN _lotserial;
  ELSE
    RETURN '';
  END IF;

END
$_$;


ALTER FUNCTION public.getpacklistitemlotserial(integer, integer) OWNER TO admin;

--
-- TOC entry 1730 (class 1255 OID 146566307)
-- Dependencies: 4536 8
-- Name: getperiodid(date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getperiodid(date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPeriodDate ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pPeriodDate IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT period_id INTO _returnVal
  FROM period
  WHERE ((pPeriodDate) between period_start AND period_end);

  IF (_returnVal IS NULL) THEN
    RAISE EXCEPTION 'Period for % not found.', pPeriodDate;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getperiodid(date) OWNER TO admin;

--
-- TOC entry 1729 (class 1255 OID 146566306)
-- Dependencies: 4536 8
-- Name: getperiodid(integer, character); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getperiodid(integer, character) RETURNS SETOF integer
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPeriodId ALIAS FOR $1;
  pInterval ALIAS FOR $2;
  _x RECORD;
BEGIN

-- Validate Interval
   IF pInterval <> 'M' AND pInterval <> 'Q' AND pInterval <> 'Y' THEN
     RAISE EXCEPTION 'Invalid Interval --> %', pInterval;
   END IF;

   IF pInterval='M' THEN
       RETURN NEXT pPeriodId;
     ELSE IF pInterval='Q' THEN
        FOR _x IN SELECT qp.period_id AS period_id
                FROM period cp, period qp
                WHERE ((cp.period_id=pPeriodId)
                AND (cp.period_yearperiod_id=qp.period_yearperiod_id)
                AND (cp.period_quarter=qp.period_quarter)
                AND (cp.period_start>=qp.period_start))
        ORDER BY qp.period_start
        LOOP
                RETURN NEXT _x.period_id;
        END LOOP;
     ELSE
        FOR _x IN SELECT yp.period_id AS period_id
                FROM period cp, period yp
                WHERE ((cp.period_id=pPeriodId)
                AND (cp.period_yearperiod_id=yp.period_yearperiod_id)
                AND (cp.period_start>=yp.period_start))
        ORDER BY yp.period_start
        LOOP
                RETURN NEXT _x.period_id;
        END LOOP;
     END IF;
   END IF;
  RETURN;
END;
$_$;


ALTER FUNCTION public.getperiodid(integer, character) OWNER TO admin;

--
-- TOC entry 1731 (class 1255 OID 146566308)
-- Dependencies: 4536 8
-- Name: getpkgheadid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getpkgheadid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  ppkgname ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (ppkgname IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT pkghead_id INTO _returnVal
  FROM pkghead
  WHERE (UPPER(pkghead_name)=UPPER(ppkgname));

  IF (_returnVal IS NULL) THEN
    RAISE EXCEPTION 'Package % not found.', ppkgname;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getpkgheadid(text) OWNER TO admin;

--
-- TOC entry 1732 (class 1255 OID 146566309)
-- Dependencies: 4536 8
-- Name: getplancodeid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getplancodeid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPlanCode ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pPlanCode IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT plancode_id INTO _returnVal
  FROM plancode
  WHERE (plancode_code=pPlanCode);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Plan Code % not found.', pPlanCode;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getplancodeid(text) OWNER TO admin;

--
-- TOC entry 1733 (class 1255 OID 146566310)
-- Dependencies: 4536 8
-- Name: getpoheadid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getpoheadid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPurchaseOrderNumber ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pPurchaseOrderNumber IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT pohead_id INTO _returnVal
  FROM pohead
  WHERE (pohead_number=pPurchaseOrderNumber);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Purchase Order % not found.', pPurchaseOrderNumber;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getpoheadid(text) OWNER TO admin;

--
-- TOC entry 1734 (class 1255 OID 146566311)
-- Dependencies: 4536 8
-- Name: getpoitemid(text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getpoitemid(text, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPurchaseOrderNumber	ALIAS FOR $1;
  pLineNumber 	    	ALIAS FOR $2;
  _returnVal 		INTEGER;
BEGIN
  IF (pPurchaseOrderNumber IS NULL OR pLineNumber IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT poitem_id INTO _returnVal
  FROM pohead, poitem
  WHERE ((pohead_number=pPurchaseOrderNumber)
  AND (poitem_pohead_id=pohead_id)
  AND (poitem_linenumber=pLineNumber));

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Purchase Order % not found.', pSalesOrderNumber;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getpoitemid(text, integer) OWNER TO admin;

--
-- TOC entry 1735 (class 1255 OID 146566312)
-- Dependencies: 4536 8
-- Name: getprjaccntid(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getprjaccntid(integer, integer) RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPrjid ALIAS FOR $1;
  pAccntid ALIAS FOR $2;

BEGIN
  -- Project Accounting is required to fully implement this functionality
  RETURN pAccntId;
END;
$_$;


ALTER FUNCTION public.getprjaccntid(integer, integer) OWNER TO admin;

--
-- TOC entry 1736 (class 1255 OID 146566313)
-- Dependencies: 4536 8
-- Name: getprjid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getprjid(pprjnumber text) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;
BEGIN
  IF (pPrjNumber IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT prj_id INTO _returnVal
  FROM prj
  WHERE (prj_number=pPrjNumber);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Project Number % not found.', pPrjNumber;
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getprjid(pprjnumber text) OWNER TO admin;

--
-- TOC entry 1737 (class 1255 OID 146566314)
-- Dependencies: 4536 8
-- Name: getprjtaskid(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getprjtaskid(pprjnumber text, ptasknumber text) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;
BEGIN
  IF (pPrjNumber IS NULL OR pTaskNumber IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT prjtask_id INTO _returnVal
  FROM prjtask
    JOIN prj ON (prj_id=prjtask_prj_id)
  WHERE ((prj_number=pPrjNumber)
  AND (prjtask_number=pTaskNumber));

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Project Task Number %-% not found.', pPrjNumber, pTaskNumber;
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getprjtaskid(pprjnumber text, ptasknumber text) OWNER TO admin;

--
-- TOC entry 1738 (class 1255 OID 146566315)
-- Dependencies: 4536 8
-- Name: getprodcatid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getprodcatid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pProdCat ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pProdCat IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT prodcat_id INTO _returnVal
  FROM prodcat
  WHERE (prodcat_code=pProdCat);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Product Category % not found.', pProdCat;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getprodcatid(text) OWNER TO admin;

--
-- TOC entry 1739 (class 1255 OID 146566316)
-- Dependencies: 4536 8
-- Name: getprospectid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getprospectid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pProspectNumber ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pProspectNumber IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT prospect_id INTO _returnVal
    FROM prospect
   WHERE(UPPER(prospect_number)=UPPER(pProspectNumber));
  IF (_returnVal IS NULL) THEN
    RAISE EXCEPTION 'Prospect Number % found.', pProspectNumber;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getprospectid(text) OWNER TO admin;

--
-- TOC entry 1720 (class 1255 OID 146566317)
-- Dependencies: 4536 8
-- Name: getquoteid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getquoteid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pQuoteNumber ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pQuoteNumber IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT quhead_id INTO _returnVal
  FROM quhead
  WHERE (quhead_number=pQuoteNumber);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Quote Number % not found.', pQuoteNumber;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getquoteid(text) OWNER TO admin;

--
-- TOC entry 1740 (class 1255 OID 146566318)
-- Dependencies: 4536 8
-- Name: getquotelineitemid(text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getquotelineitemid(text, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pQuoteNumber ALIAS FOR $1;
  pLineNumber ALIAS FOR $2;
  _returnVal INTEGER;
BEGIN
  IF ((pQuoteNumber IS NULL) OR (pLineNumber IS NULL)) THEN
    RETURN NULL;
  END IF;

  SELECT quitem_id INTO _returnVal
  FROM quhead, quitem
  WHERE ((quhead_number=pQuoteNumber)
  AND (quhead_id=quitem_quhead_id)
  AND (quitem_linenumber=pLineNumber));

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Quote Line Item %-%not found.', pQuoteNumber,pLineNumber;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getquotelineitemid(text, integer) OWNER TO admin;

--
-- TOC entry 1741 (class 1255 OID 146566319)
-- Dependencies: 4536 8
-- Name: getquotescheddate(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getquotescheddate(integer) RETURNS date
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pQuheadid ALIAS FOR $1;
  _minscheddate DATE;

BEGIN

  SELECT MIN(quitem_scheddate) INTO _minscheddate
  FROM quitem
  WHERE (quitem_quhead_id=pQuheadid);

  RETURN _minscheddate;

END;
$_$;


ALTER FUNCTION public.getquotescheddate(integer) OWNER TO admin;

--
-- TOC entry 1742 (class 1255 OID 146566320)
-- Dependencies: 4536 8
-- Name: getrevid(text, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getrevid(text, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pType ALIAS FOR $1;
  pItemNumber ALIAS FOR $2;
  pRevision ALIAS FOR $3;
  _returnVal INTEGER;
BEGIN
  IF (pItemNumber IS NULL) THEN
    RETURN NULL;
  END IF;

  IF (NOT fetchMetricBool('RevControl')) THEN
    RETURN -1;
  ELSIF ( (pRevision IS NULL) OR (LENGTH(pRevision)=0) ) THEN
    SELECT getActiveRevId(pType, getItemId(pItemNumber)) INTO _returnVal;
  ELSE
    IF (pType='BOM') THEN
      SELECT rev_id INTO _returnVal
      FROM item, bomhead, rev
      WHERE ((item_id=bomhead_item_id)
      AND (bomhead_rev_id=rev_id)
      AND (UPPER(item_number)=UPPER(pItemNumber))
      AND (rev_number=pRevision));
    ELSIF (pType='BOO') THEN
      SELECT rev_id INTO _returnVal
      FROM item, xtmfg.boohead, rev
      WHERE ((item_id=boohead_item_id)
      AND (boohead_rev_id=rev_id)
      AND (UPPER(item_number)=UPPER(pItemNumber))
      AND (rev_number=pRevision));
    ELSE
      RAISE EXCEPTION 'Invalid Revision Type.';
    END IF;
  END IF;

  IF (_returnVal IS NULL) THEN
    RAISE EXCEPTION '% revision % for % not found.', pType, pRevision, pItemNumber;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getrevid(text, text, text) OWNER TO admin;

--
-- TOC entry 1743 (class 1255 OID 146566321)
-- Dependencies: 4536 8
-- Name: getrsnid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getrsnid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pRsnCode ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pRsnCode IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT rsncode_id INTO _returnVal
  FROM rsncode
  WHERE (rsncode_code=pRsnCode);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Reason Code % not found.', pRsnCode;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getrsnid(text) OWNER TO admin;

--
-- TOC entry 1744 (class 1255 OID 146566322)
-- Dependencies: 4536 8
-- Name: getsalescatid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getsalescatid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSalesCatName ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pSalesCatName IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT salescat_id INTO _returnVal
  FROM salescat
  WHERE (salescat_name=pSalesCatName);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Sales Category % not found.', pSalesCatName;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getsalescatid(text) OWNER TO admin;

--
-- TOC entry 1746 (class 1255 OID 146566324)
-- Dependencies: 4536 8
-- Name: getsaleslineitemid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getsaleslineitemid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSalesOrderItem ALIAS FOR $1;
  _delpos INTEGER = 0;
  _order TEXT;
  _part TEXT;
  _ln INTEGER;
  _sn INTEGER;
BEGIN
  IF (pSalesOrderItem IS NULL) THEN
    RETURN NULL;
  END IF;
  _delpos := strpos(pSalesOrderItem, '-');
  IF (_delpos > 0) THEN
    _order := substr(pSalesOrderItem, 1, (_delpos - 1));
    _part := substr(pSalesOrderItem, (_delpos + 1));
    _delpos := strpos(_part, '.');
    IF (_delpos > 0) THEN
      _ln := CAST(substr(_part, 1, (_delpos - 1)) AS INTEGER);
      _sn := CAST(substr(_part, (_delpos + 1)) AS INTEGER);
    ELSE
      _ln := CAST(_part AS INTEGER);
      _sn := 0;
    END IF;
    RETURN getSalesLineItemId( _order, _ln, _sn );
  END IF;
  RETURN 0;
END;
$_$;


ALTER FUNCTION public.getsaleslineitemid(text) OWNER TO admin;

--
-- TOC entry 1745 (class 1255 OID 146566323)
-- Dependencies: 4536 8
-- Name: getsaleslineitemid(text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getsaleslineitemid(text, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN getSalesLineItemId($1, $2, 0);
END
$_$;


ALTER FUNCTION public.getsaleslineitemid(text, integer) OWNER TO admin;

--
-- TOC entry 1747 (class 1255 OID 146566325)
-- Dependencies: 4536 8
-- Name: getsaleslineitemid(text, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getsaleslineitemid(text, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSalesOrderNumber ALIAS FOR $1;
  pLineNumber ALIAS FOR $2;
  pSubNumber ALIAS FOR $3;
  _returnVal INTEGER;
BEGIN
  IF ((pSalesOrderNumber IS NULL) OR (pLineNumber IS NULL)) THEN
    RETURN NULL;
  END IF;

  SELECT coitem_id INTO _returnVal
  FROM cohead, coitem
  WHERE ((cohead_number=pSalesOrderNumber)
  AND (cohead_id=coitem_cohead_id)
  AND (coitem_linenumber=pLineNumber)
  AND (coitem_subnumber=pSubNumber));

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Sales Line Item %-%not found.', pSalesOrderNumber,pLineNumber;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getsaleslineitemid(text, integer, integer) OWNER TO admin;

--
-- TOC entry 1748 (class 1255 OID 146566326)
-- Dependencies: 4536 8
-- Name: getsalesorderid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getsalesorderid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSalesOrderNumber ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pSalesOrderNumber IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT cohead_id INTO _returnVal
  FROM cohead
  WHERE (cohead_number=pSalesOrderNumber);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Sales Order Number % not found.', pSalesOrderNumber;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getsalesorderid(text) OWNER TO admin;

--
-- TOC entry 1749 (class 1255 OID 146566327)
-- Dependencies: 4536 8
-- Name: getsalesrepid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getsalesrepid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSalesRepNumber ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pSalesRepNumber IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT salesrep_id INTO _returnVal
  FROM salesrep
  WHERE (salesrep_number=pSalesRepNumber);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Sales Rep Number % not found.', pSalesRepNumber;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getsalesrepid(text) OWNER TO admin;

--
-- TOC entry 1751 (class 1255 OID 146566328)
-- Dependencies: 4536 8
-- Name: getsaletypeid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getsaletypeid(psaletype text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;
BEGIN
  IF (pSaleType IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT saletype_id INTO _returnVal
  FROM saletype
  WHERE (saletype_code=UPPER(pSaleType));

  IF (_returnVal IS NULL) THEN
    RAISE EXCEPTION 'Sale Type % not found.', pSaleType;
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getsaletypeid(psaletype text) OWNER TO admin;

--
-- TOC entry 1752 (class 1255 OID 146566329)
-- Dependencies: 4536 8
-- Name: getshiftid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getshiftid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pShiftNumber ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (COALESCE(TRIM(pShiftNumber), '') = '') THEN
      RETURN NULL;
  END IF;

  SELECT shift_id INTO _returnVal
  FROM shift
  WHERE (UPPER(shift_number)=UPPER(pShiftNumber));

  IF (_returnVal IS NULL) THEN
    RAISE EXCEPTION 'Shift % not found.', pShiftNumber;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getshiftid(text) OWNER TO admin;

--
-- TOC entry 1753 (class 1255 OID 146566330)
-- Dependencies: 4536 8
-- Name: getshipchrgid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getshipchrgid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pShipChrgName ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pShipChrgName IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT shipchrg_id INTO _returnVal
  FROM shipchrg
  WHERE (shipchrg_name=pShipChrgName);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Ship Charge % not found.', pShipChrgName;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getshipchrgid(text) OWNER TO admin;

--
-- TOC entry 1754 (class 1255 OID 146566331)
-- Dependencies: 4536 8
-- Name: getshipformid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getshipformid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pShipFormName ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pShipFormName IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT shipform_id INTO _returnVal
  FROM shipform
  WHERE (shipform_name=pShipFormName) LIMIT 1;

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Ship Form % not found.', pShipFormName;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getshipformid(text) OWNER TO admin;

--
-- TOC entry 1755 (class 1255 OID 146566332)
-- Dependencies: 4536 8
-- Name: getshipheadid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getshipheadid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pShipmentNumber ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pShipmentNumber IS NULL OR pShipmentNumber = '') THEN
    RETURN NULL;
  END IF;

  SELECT shiphead_id INTO _returnVal
  FROM shiphead
  WHERE (shiphead_number=pShipmentNumber);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Shipment % not found.', pShipmentNumber;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getshipheadid(text) OWNER TO admin;

--
-- TOC entry 1756 (class 1255 OID 146566333)
-- Dependencies: 4536 8
-- Name: getshiptoid(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getshiptoid(text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCustNumber ALIAS FOR $1;
  pShiptoNumber ALIAS FOR $2;
  _returnVal INTEGER;
BEGIN
  IF ((pCustNumber IS NULL) OR (pShiptoNumber IS NULL)) THEN
	RETURN NULL;
  END IF;

  SELECT shipto_id INTO _returnVal
  FROM shiptoinfo
  WHERE ((shipto_cust_id=getCustId(pCustNumber,true))
  AND (UPPER(shipto_num)=UPPER(pShiptoNumber)));

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Shipto % not found.', pShiptoNumber;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getshiptoid(text, text) OWNER TO admin;

--
-- TOC entry 1757 (class 1255 OID 146566334)
-- Dependencies: 4536 8
-- Name: getshiptonumberfrominfo(text, text, text, text, text, text, text, text, text, text, text, text, text, boolean, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getshiptonumberfrominfo(text, text, text, text, text, text, text, text, text, text, text, text, text, boolean, boolean) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _custname TEXT := COALESCE(TRIM(UPPER( $1)), '');
  _email TEXT 	 := COALESCE(TRIM(UPPER( $2)), '');
  _company TEXT  := COALESCE(TRIM(UPPER( $3)), '');
  _first TEXT 	 := COALESCE(TRIM(UPPER( $4)), '');
  _last TEXT 	 := COALESCE(TRIM(UPPER( $5)), '');
  _fullname TEXT := COALESCE(TRIM(UPPER( $6)), '');
  _addr1 TEXT 	 := COALESCE(TRIM(UPPER( $7)), '');
  _addr2 TEXT 	 := COALESCE(TRIM(UPPER( $8)), '');
  _addr3 TEXT 	 := COALESCE(TRIM(UPPER( $9)), '');
  _city TEXT 	 := COALESCE(TRIM(UPPER($10)), '');
  _state TEXT 	 := COALESCE(TRIM(UPPER($11)), '');
  _postalcode TEXT := COALESCE(TRIM(UPPER($12)), '');
  _country TEXT  := COALESCE(TRIM(UPPER($13)), '');
  _generate BOOLEAN := COALESCE($14, FALSE);
  _create BOOLEAN := COALESCE($15, FALSE);

  _citytrunc TEXT;
  _counter INTEGER;
  _custid INTEGER;
  _custnumber TEXT;
  _candidate TEXT;
  _r RECORD;
  _statetrunc TEXT;
BEGIN
  IF (_custname = '') THEN
    _custname := getCustNameFromInfo(_email, _company, _first, _last,
                     _fullname, FALSE);
  END IF;


  SELECT COUNT(*) INTO _counter
  FROM custinfo, shiptoinfo, addr
  WHERE ((UPPER(cust_name)=UPPER(_custname))
    AND UPPER(shipto_name)=UPPER(_fullname)
    AND (cust_id=shipto_cust_id)
    AND (shipto_addr_id=addr_id));

  IF (_counter = 1) THEN
    SELECT shipto_num INTO _candidate
    FROM custinfo, shiptoinfo, addr
    WHERE ((UPPER(cust_name)=UPPER(_custname))
      AND UPPER(shipto_name)=UPPER(_fullname)
      AND (cust_id=shipto_cust_id)
      AND (shipto_addr_id=addr_id));

    RETURN _candidate;

  ELSE

    SELECT COUNT(*) INTO _counter
    FROM custinfo, shiptoinfo, addr
    WHERE ((UPPER(cust_name)=UPPER(_custname))
      AND (cust_id=shipto_cust_id)
      AND (shipto_addr_id=addr_id));

    IF (_counter = 1) THEN
      SELECT shipto_num INTO _candidate
      FROM custinfo, shiptoinfo, addr
      WHERE ((UPPER(cust_name)=UPPER(_custname))
        AND (cust_id=shipto_cust_id)
        AND (shipto_addr_id=addr_id));

      RETURN _candidate;

    ELSIF (_counter > 1) THEN
      SELECT shipto_num,
         CASE WHEN (UPPER(addr_country) = _country) THEN 1 ELSE 0 END +
         CASE WHEN (UPPER(addr_postalcode) = _postalcode) THEN 1 ELSE 0 END +
         CASE WHEN (UPPER(addr_state) = _state) THEN 1 ELSE 0 END +
         CASE WHEN (UPPER(addr_city) = _city) THEN 1 ELSE 0 END +
         CASE WHEN (UPPER(addr_line3) = _addr3) THEN 1 ELSE 0 END +
         CASE WHEN (UPPER(addr_line2) = _addr2) THEN 1 ELSE 0 END +
         CASE WHEN (UPPER(addr_line1) = _addr1) THEN 1 ELSE 0 END
         AS maxquotient INTO _candidate, _counter
      FROM custinfo, shiptoinfo, addr
      WHERE ((UPPER(cust_name)=_custname)
        AND (cust_id=shipto_cust_id)
        AND (shipto_addr_id=addr_id))
      ORDER BY maxquotient desc
      LIMIT 1;

      RETURN _candidate;
    END IF;
  END IF;

  IF (_generate) THEN
    SELECT cust_number, cust_id INTO _custnumber, _custid
    FROM custinfo
    WHERE (UPPER(cust_name)=_custname);

    -- keep the number short
    _citytrunc := SUBSTRING(_city FOR 5);
    _statetrunc := SUBSTRING(_state FOR 5);

    IF (LENGTH(_citytrunc) > 0 AND NOT EXISTS(SELECT UPPER(shipto_num)
              FROM shiptoinfo
              WHERE ((shipto_cust_id=_custid)
                AND (UPPER(shipto_num)=_citytrunc)) )) THEN
      _candidate := _citytrunc;
    ELSIF (LENGTH(_last || _citytrunc) > 0 AND NOT EXISTS(SELECT UPPER(shipto_num)
              FROM shiptoinfo
              WHERE ((shipto_cust_id=_custid)
                AND (UPPER(shipto_num)=_last || _citytrunc)) )) THEN
      _candidate := _last || _citytrunc;
    ELSIF (LENGTH(_statetrunc) > 0 AND NOT EXISTS(SELECT UPPER(shipto_num)
           FROM shiptoinfo
           WHERE ((shipto_cust_id=_custid)
             AND (UPPER(shipto_num)=_statetrunc)) )) THEN
      _candidate := _statetrunc;
    ELSIF (LENGTH(_last || _statetrunc) > 0 AND NOT EXISTS(SELECT UPPER(shipto_num)
           FROM shiptoinfo
           WHERE ((shipto_cust_id=_custid)
             AND (UPPER(shipto_num)=_last || _statetrunc)) )) THEN
      _candidate := _last || _statetrunc;

    ELSIF (LENGTH(_citytrunc || _statetrunc) > 0 AND NOT EXISTS(SELECT UPPER(shipto_num)
              FROM shiptoinfo
              WHERE ((shipto_cust_id=_custid)
                AND (UPPER(shipto_num)=_citytrunc || _statetrunc)) )) THEN
      _candidate := _citytrunc || _statetrunc;

    ELSE
      SELECT CAST(COALESCE(MAX(CAST(shipto_num AS INTEGER)), 0) + 1 AS TEXT)
      INTO _candidate
      FROM shiptoinfo
      WHERE ((shipto_cust_id=_custid)
       AND (shipto_num~'^[0-9]*$'));
    END IF;

    IF (_create) THEN
      INSERT INTO api.custshipto (
    customer_number, shipto_number, name,
    address1, address2, address3,
    city, state, postal_code, country, address_change,
    first, last, email,
    edi_profile
      ) VALUES (
    _custnumber, _candidate, _candidate,
    _addr1, _addr2, _addr3,
    _city, _state, _postalcode, _country, 'CHANGEONE',
    _first, _last, LOWER(_email),
    'No EDI'
      );
    END IF;

    RETURN _candidate;
  END IF;

  RETURN '';
END;
$_$;


ALTER FUNCTION public.getshiptonumberfrominfo(text, text, text, text, text, text, text, text, text, text, text, text, text, boolean, boolean) OWNER TO admin;

--
-- TOC entry 1758 (class 1255 OID 146566335)
-- Dependencies: 4536 8
-- Name: getshipviaid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getshipviaid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pShipViaCode ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pShipViaCode IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT shipvia_id INTO _returnVal
  FROM shipvia
  WHERE (shipvia_code=pShipViaCode);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'ShipVia Code % not found.', pShipViaCode;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getshipviaid(text) OWNER TO admin;

--
-- TOC entry 1759 (class 1255 OID 146566336)
-- Dependencies: 4536 8
-- Name: getshipzoneid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getshipzoneid(pshipzonename text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;
BEGIN
  IF (pShipZoneName IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT shipzone_id INTO _returnVal
  FROM shipzone
  WHERE (shipzone_name=pShipZoneName);

  IF (_returnVal IS NULL) THEN
    RAISE EXCEPTION 'Ship Zone % not found.', pShipZoneName;
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getshipzoneid(pshipzonename text) OWNER TO admin;

--
-- TOC entry 1760 (class 1255 OID 146566337)
-- Dependencies: 4536 8
-- Name: getsitetypeid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getsitetypeid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSiteType ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pSiteType IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT sitetype_id INTO _returnVal
  FROM sitetype
  WHERE (sitetype_name=pSiteType);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Site Type % not found.', pSiteType;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getsitetypeid(text) OWNER TO admin;

--
-- TOC entry 1761 (class 1255 OID 146566338)
-- Dependencies: 4536 8
-- Name: getsoitemstatus(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getsoitemstatus(pcoitemid integer) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _result TEXT;

BEGIN

  SELECT
      (CASE WHEN (coitem_status='O' AND (SELECT cust_creditstatus FROM custinfo WHERE cust_id=cohead_cust_id)='H') THEN 'H'
            WHEN (coitem_status='O' AND ((SELECT SUM(invcitem_billed)
                                            FROM invchead, invcitem
                                           WHERE ((CAST(invchead_ordernumber AS text)=cohead_number)
                                             AND  (invcitem_invchead_id=invchead_id)
                                             AND  (invcitem_item_id=itemsite_item_id)
                                             AND  (invcitem_warehous_id=itemsite_warehous_id)
                                             AND  (invcitem_linenumber=coitem_linenumber))) >= coitem_qtyord)) THEN 'I'
            WHEN (coitem_status='O' AND ((SELECT SUM(invcitem_billed)
                                            FROM invchead, invcitem
                                           WHERE ((CAST(invchead_ordernumber AS text)=cohead_number)
                                             AND  (invcitem_invchead_id=invchead_id)
                                             AND  (invcitem_item_id=itemsite_item_id)
                                             AND  (invcitem_warehous_id=itemsite_warehous_id)
                                             AND  (invcitem_linenumber=coitem_linenumber))) > 0)) THEN 'P'
            WHEN (coitem_status='O' AND (itemsite_qtyonhand - qtyAllocated(itemsite_id, CURRENT_DATE)
                                         + qtyOrdered(itemsite_id, CURRENT_DATE))
                                          >= ((coitem_qtyord - coitem_qtyshipped + coitem_qtyreturned) * coitem_qty_invuomratio)) THEN 'R'
            ELSE coitem_status END
       || CASE WHEN (coitem_firm) THEN 'F' ELSE '' END
       ) INTO _result
  FROM coitem JOIN cohead ON (cohead_id=coitem_cohead_id)
              JOIN custinfo ON (cust_id=cohead_cust_id)
              JOIN itemsite ON (itemsite_id=coitem_itemsite_id)
  WHERE (coitem_id=pCoitemid);

  RETURN _result;

END;
$$;


ALTER FUNCTION public.getsoitemstatus(pcoitemid integer) OWNER TO admin;

--
-- TOC entry 1762 (class 1255 OID 146566339)
-- Dependencies: 4536 8
-- Name: getsoscheddate(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getsoscheddate(integer) RETURNS date
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCoheadid ALIAS FOR $1;
  _minscheddate DATE;

BEGIN

  SELECT MIN(coitem_scheddate) INTO _minscheddate
  FROM coitem
  WHERE ( (coitem_cohead_id=pCoheadid)
    AND   (coitem_status NOT IN ('C', 'X')) );

  RETURN _minscheddate;

END;
$_$;


ALTER FUNCTION public.getsoscheddate(integer) OWNER TO admin;

--
-- TOC entry 1763 (class 1255 OID 146566340)
-- Dependencies: 4536 8
-- Name: getsostatus(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getsostatus(integer) RETURNS character
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCoheadid ALIAS FOR $1;
  _result char(1);

BEGIN

  SELECT cohead_status INTO _result
  FROM cohead
  WHERE (cohead_id=pCoheadid);

  RETURN _result;

END;
$_$;


ALTER FUNCTION public.getsostatus(integer) OWNER TO admin;

--
-- TOC entry 1764 (class 1255 OID 146566341)
-- Dependencies: 2702 4536 8
-- Name: getsubtax(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getsubtax(integer, integer) RETURNS SETOF subtax
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTaxCodeId ALIAS FOR $1;
  pLevel ALIAS FOR $2;
  _row subtax%ROWTYPE;
  _x RECORD;
  _y RECORD;

BEGIN

  FOR _x IN --Select all tax codes whose calculation basis is pTaxCodeId
    SELECT tax_id, tax_code, tax_descrip
    FROM tax
    WHERE tax_basis_tax_id = pTaxCodeId


    LOOP
    _row.subtax_taxcode_id := _x.tax_id;
    _row.subtax_taxcode_code := _x.tax_code;
    _row.subtax_taxcode_descrip := _x.tax_descrip;
    _row.subtax_taxcode_level := pLevel + 1;

   RETURN NEXT _row;

    FOR _y IN SELECT * from getSubTax(_x.tax_id, pLevel + 1) --This is the recursive part.
    LOOP

      _row.subtax_taxcode_id := _y.subtax_taxcode_id;
      _row.subtax_taxcode_code := _y.subtax_taxcode_code ;
      _row.subtax_taxcode_descrip := _y.subtax_taxcode_descrip;
      _row.subtax_taxcode_level := pLevel + 2;

      RETURN NEXT _row;

    END LOOP;

  END LOOP;

END;
$_$;


ALTER FUNCTION public.getsubtax(integer, integer) OWNER TO admin;

--
-- TOC entry 1765 (class 1255 OID 146566342)
-- Dependencies: 4536 8
-- Name: gettaxauthid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION gettaxauthid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTaxAuthCode ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pTaxAuthCode IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT taxauth_id INTO _returnVal
  FROM taxauth
  WHERE (taxauth_code=pTaxAuthCode);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Tax Authority % not found.', pTaxAuthCode;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.gettaxauthid(text) OWNER TO admin;

--
-- TOC entry 1766 (class 1255 OID 146566343)
-- Dependencies: 4536 8
-- Name: gettaxid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION gettaxid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTaxCode ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pTaxCode IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT tax_id INTO _returnVal
  FROM tax
  WHERE (tax_code=pTaxCode);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Tax Code % not found.', pTaxCode;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.gettaxid(text) OWNER TO admin;

--
-- TOC entry 1767 (class 1255 OID 146566344)
-- Dependencies: 4536 8
-- Name: gettaxtypeid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION gettaxtypeid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTaxType ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pTaxType IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT taxtype_id INTO _returnVal
  FROM taxtype
  WHERE (taxtype_name=pTaxType);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Tax Type % not found.', pTaxType;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.gettaxtypeid(text) OWNER TO admin;

--
-- TOC entry 1768 (class 1255 OID 146566345)
-- Dependencies: 4536 8
-- Name: gettaxzoneid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION gettaxzoneid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTaxZone ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pTaxZone IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT taxzone_id INTO _returnVal
  FROM taxzone
  WHERE (taxzone_code=pTaxZone);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Tax Zone % not found.', pTaxZone;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.gettaxzoneid(text) OWNER TO admin;

--
-- TOC entry 1769 (class 1255 OID 146566346)
-- Dependencies: 4536 8
-- Name: gettermsid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION gettermsid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTermsCode ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pTermsCode IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT terms_id INTO _returnVal
  FROM terms
  WHERE (terms_code=pTermsCode);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Terms Code % not found.', pTermsCode;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.gettermsid(text) OWNER TO admin;

--
-- TOC entry 1770 (class 1255 OID 146566347)
-- Dependencies: 4536 8
-- Name: getunassignedaccntid(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getunassignedaccntid() RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _test INTEGER;
  _returnVal INTEGER;
BEGIN
  SELECT fetchMetricValue('UnassignedAccount') INTO _test;

  IF (_test IS NULL) THEN
    RAISE EXCEPTION 'Metric not found for UnassignedAccount';
  END IF;

  SELECT accnt_id INTO _returnVal
  FROM accnt
  WHERE (accnt_id=_test);

  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Metric UnassignedAccount is an invalid G/L Account';
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getunassignedaccntid() OWNER TO admin;

--
-- TOC entry 1771 (class 1255 OID 146566348)
-- Dependencies: 4536 8
-- Name: getuomid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getuomid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pUom ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pUom IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT uom_id INTO _returnVal
  FROM uom
  WHERE (uom_name=pUom);

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Unit of Measure % not found.', pUom;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getuomid(text) OWNER TO admin;

--
-- TOC entry 1773 (class 1255 OID 146566349)
-- Dependencies: 4536 8
-- Name: getuomtypeid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getuomtypeid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pUomType ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pUomType IS NULL) THEN
	RETURN NULL;
  END IF;

  SELECT uomtype_id INTO _returnVal
  FROM uomtype
  WHERE (UPPER(uomtype_name)=UPPER(pUomType));

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Unit of Measuer Type % not found.', pUomType;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getuomtypeid(text) OWNER TO admin;

--
-- TOC entry 1774 (class 1255 OID 146566350)
-- Dependencies: 4536 8
-- Name: getuomtypeid(text[]); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getuomtypeid(text[]) RETURNS integer[]
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pUomTypes ALIAS FOR $1;
  _returnVal INTEGER[];
  _val INTEGER;
  _i INTEGER;
BEGIN
  IF (pUomTypes IS NULL) OR (ARRAY_UPPER(pUomTypes,1) = 0) THEN
	RETURN NULL;
  END IF;

  FOR _i IN 1..ARRAY_UPPER(pUomTypes,1)
  LOOP
    SELECT uomtype_id INTO _val
    FROM uomtype
    WHERE (UPPER(uomtype_name)=UPPER(pUomTypes[_i]));

    IF (_val IS NULL) THEN
	RAISE EXCEPTION 'Unit of Measure Type % not found.', pUomTypes[_i];
    ELSE
      _returnVal[_i] := _val;
    END IF;
  END LOOP;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getuomtypeid(text[]) OWNER TO admin;

--
-- TOC entry 1775 (class 1255 OID 146566351)
-- Dependencies: 4536 8
-- Name: getusrid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getusrid(pusr text) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;
BEGIN
  SELECT usr_id INTO _returnVal
  FROM usr
  WHERE (usr_username=COALESCE(pUsr, getEffectiveXtUser()));

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'User % not found.', pUsr;
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getusrid(pusr text) OWNER TO admin;

--
-- TOC entry 1776 (class 1255 OID 146566352)
-- Dependencies: 4536 8
-- Name: getusrlocaleid(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getusrlocaleid() RETURNS integer
    LANGUAGE plpgsql IMMUTABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;
BEGIN
  SELECT CAST(usrpref_value AS INTEGER)
  FROM usrpref
  WHERE (usrpref_username=getEffectiveXTUser())
    AND (usrpref_name='locale_id') INTO _returnVal;

  IF (_returnVal IS NULL) THEN
    SELECT locale_id
    FROM locale
    WHERE (LOWER(locale_code) = 'default')
    LIMIT 1 INTO _returnVal;
  END IF;

  IF (_returnVal IS NULL) THEN
    SELECT locale_id
    FROM locale
    ORDER BY locale_id
    LIMIT 1 INTO _returnVal;
  END IF;

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'User Locale not found.';
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getusrlocaleid() OWNER TO admin;

--
-- TOC entry 1777 (class 1255 OID 146566353)
-- Dependencies: 4536 8
-- Name: getvendaddrid(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getvendaddrid(text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVendNumber   ALIAS FOR $1;
  pVendAddrCode ALIAS FOR $2;
  _returnVal INTEGER;
BEGIN
  IF ( (pVendNumber IS NULL) OR (pVendAddrCode IS NULL) ) THEN
    RETURN NULL;
  END IF;

  SELECT vendaddr_id INTO _returnVal
    FROM vendaddrinfo
    JOIN vendinfo ON (vend_id=vendaddr_vend_id)
  WHERE ( (vendaddr_code=pVendAddrCode)
    AND   (vend_number=pVendNumber) );

  IF (_returnVal IS NULL) THEN
    RAISE EXCEPTION 'Vendor Number % Address % not found.',
    pVendNumber, pVendAddrCode;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getvendaddrid(text, text) OWNER TO admin;

--
-- TOC entry 1778 (class 1255 OID 146566354)
-- Dependencies: 4536 8
-- Name: getvendid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getvendid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVendNumber ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pVendNumber IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT vend_id INTO _returnVal
    FROM vendinfo
   WHERE (vend_number=pVendNumber);

  IF (_returnVal IS NULL) THEN
    RAISE EXCEPTION 'Vendor Number % not found.', pVendNumber;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getvendid(text) OWNER TO admin;

--
-- TOC entry 1779 (class 1255 OID 146566355)
-- Dependencies: 4536 8
-- Name: getvendtypeid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getvendtypeid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVendTypeCode ALIAS FOR $1;
  _returnVal INTEGER;
BEGIN
  IF (pVendTypeCode IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT vendtype_id INTO _returnVal
  FROM vendtype
  WHERE (UPPER(vendtype_code)=UPPER(pVendTypeCode));

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Vendor Type % not found.', pVendTypeCode;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getvendtypeid(text) OWNER TO admin;

--
-- TOC entry 1780 (class 1255 OID 146566356)
-- Dependencies: 4536 8
-- Name: getwarehousid(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getwarehousid(pwarehouscode text, ptype text) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _active BOOL;
  _shipping BOOL;
  _returnVal INTEGER;
BEGIN
  IF (pWarehousCode IS NULL) THEN
	RETURN NULL;
  END IF;

  IF (UPPER(pType) NOT IN ('ALL','ACTIVE','SHIPPING')) THEN
    	RAISE EXCEPTION 'Warehouse lookip type % not valid. Valid types are ALL, ACTIVE and SHIPPING', pType;
  END IF;

  SELECT warehous_id, warehous_active, warehous_shipping INTO _returnVal, _active, _shipping
  FROM site()
  WHERE (warehous_code=UPPER(pWarehousCode));

  IF (_returnVal IS NULL) THEN
    RAISE EXCEPTION 'Warehouse Code % not found.', pWarehousCode;
    ELSE IF ((pType='SHIPPING') AND (_shipping=false)) THEN
      RAISE EXCEPTION 'Warehouse Code % is not a vaild shipping warehouse.', pWarehousCode;
      ELSE IF ((pType IN ('SHIPPING','ACTIVE')) AND (_active=false)) THEN
        RAISE EXCEPTION 'Warehouse Code % is inactive.', pWarehousCode;
      END IF;
    END IF;
  END IF;

  RETURN _returnVal;
END;
$$;


ALTER FUNCTION public.getwarehousid(pwarehouscode text, ptype text) OWNER TO admin;

--
-- TOC entry 1781 (class 1255 OID 146566357)
-- Dependencies: 4536 8
-- Name: getwhsezoneid(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION getwhsezoneid(text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWhseCode ALIAS FOR $1;
  pWhseZoneName ALIAS FOR $2;
  _returnVal INTEGER;
BEGIN
  IF ((pWhseCode IS NULL) OR (pWhseZoneName IS NULL)) THEN
	RETURN NULL;
  END IF;

  SELECT whsezone_id INTO _returnVal
  FROM whsezone
  WHERE ( (whsezone_warehous_id=getWarehousId(pWhseCode, 'ACTIVE'))
      AND (UPPER(whsezone_name)=UPPER(pWhseZoneName)) );

  IF (_returnVal IS NULL) THEN
	RAISE EXCEPTION 'Whsezone % not found.', pWhseZoneName;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.getwhsezoneid(text, text) OWNER TO admin;

--
-- TOC entry 1782 (class 1255 OID 146566358)
-- Dependencies: 4536 8
-- Name: grantallmodulecmnttypesource(integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION grantallmodulecmnttypesource(integer, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCmnttypeid ALIAS FOR $1;
  pModuleName ALIAS FOR $2;
  _source RECORD;
  _sourceCounter INTEGER;

BEGIN

  _sourceCounter := 0;

  FOR _source IN SELECT source_id
                 FROM source
                 WHERE (source_module=pModuleName) LOOP

    IF (SELECT grantCmnttypeSource(pCmnttypeid, _source.source_id)) THEN
      _sourceCounter := _sourceCounter + 1;
    END IF;

  END LOOP;

  RETURN _sourceCounter;

END;
$_$;


ALTER FUNCTION public.grantallmodulecmnttypesource(integer, text) OWNER TO admin;

--
-- TOC entry 1783 (class 1255 OID 146566359)
-- Dependencies: 4536 8
-- Name: grantallmodulepriv(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION grantallmodulepriv(text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pUsername ALIAS FOR $1;
  pModuleName ALIAS FOR $2;
  _priv RECORD;
  _privCounter INTEGER;

BEGIN

  _privCounter := 0;

  FOR _priv IN SELECT priv_id
               FROM priv
               WHERE (priv_module=pModuleName) LOOP

    IF (SELECT grantPriv(pUsername, _priv.priv_id)) THEN
      _privCounter := _privCounter + 1;
    END IF;

  END LOOP;

  RETURN _privCounter;

END;
$_$;


ALTER FUNCTION public.grantallmodulepriv(text, text) OWNER TO admin;

--
-- TOC entry 1784 (class 1255 OID 146566360)
-- Dependencies: 4536 8
-- Name: grantallmoduleprivgroup(integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION grantallmoduleprivgroup(integer, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pGrpid ALIAS FOR $1;
  pModuleName ALIAS FOR $2;
  _priv RECORD;
  _privCounter INTEGER;

BEGIN

  _privCounter := 0;

  FOR _priv IN SELECT priv_id
               FROM priv
               WHERE (priv_module=pModuleName) LOOP

    IF (SELECT grantPrivGroup(pGrpid, _priv.priv_id)) THEN
      _privCounter := _privCounter + 1;
    END IF;

  END LOOP;

  RETURN _privCounter;

END;
$_$;


ALTER FUNCTION public.grantallmoduleprivgroup(integer, text) OWNER TO admin;

--
-- TOC entry 1785 (class 1255 OID 146566361)
-- Dependencies: 4536 8
-- Name: grantcmnttypesource(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION grantcmnttypesource(integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCmnttypeid ALIAS FOR $1;
  pSourceid ALIAS FOR $2;
  _test INTEGER;

BEGIN

  SELECT cmnttypesource_id INTO _test
  FROM cmnttypesource
  WHERE ( (cmnttypesource_cmnttype_id=pCmnttypeid)
    AND (cmnttypesource_source_id=pSourceid) );

  IF (FOUND) THEN
    RETURN FALSE;
  END IF;

  INSERT INTO cmnttypesource
  ( cmnttypesource_cmnttype_id, cmnttypesource_source_id )
  VALUES
  ( pCmnttypeid, pSourceid );

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.grantcmnttypesource(integer, integer) OWNER TO admin;

--
-- TOC entry 1786 (class 1255 OID 146566362)
-- Dependencies: 4536 8
-- Name: grantgroup(text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION grantgroup(text, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pUsername ALIAS FOR $1;
  pGrpid ALIAS FOR $2;
  _test INTEGER;

BEGIN

  SELECT usrgrp_id INTO _test
  FROM usrgrp
  WHERE ( (usrgrp_username=pUsername)
   AND (usrgrp_grp_id=pGrpid) );

  IF (FOUND) THEN
    RETURN FALSE;
  END IF;

  INSERT INTO usrgrp
  ( usrgrp_username, usrgrp_grp_id )
  VALUES
  ( pUsername, pGrpid );

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.grantgroup(text, integer) OWNER TO admin;

--
-- TOC entry 1787 (class 1255 OID 146566363)
-- Dependencies: 4536 8
-- Name: grantpriv(text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION grantpriv(text, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pUsername ALIAS FOR $1;
  pPrivid ALIAS FOR $2;
  _test INTEGER;

BEGIN

  SELECT usrpriv_id INTO _test
  FROM usrpriv
  WHERE ( (usrpriv_username=pUsername)
   AND (usrpriv_priv_id=pPrivid) );

  IF (FOUND) THEN
    RETURN FALSE;
  END IF;

  INSERT INTO usrpriv
  ( usrpriv_username, usrpriv_priv_id )
  VALUES
  ( pUsername, pPrivid );

  NOTIFY "usrprivUpdated";

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.grantpriv(text, integer) OWNER TO admin;

--
-- TOC entry 1788 (class 1255 OID 146566364)
-- Dependencies: 4536 8
-- Name: grantpriv(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION grantpriv(text, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pUsername ALIAS FOR $1;
  pPrivname ALIAS FOR $2;
  _test INTEGER;

BEGIN

  SELECT usrpriv_id INTO _test
    FROM usrpriv
    JOIN priv ON (usrpriv_priv_id=priv_id)
  WHERE ((usrpriv_username=pUsername)
     AND (priv_name=pPrivname) );

  IF (FOUND) THEN
    RETURN FALSE;
  END IF;

  INSERT INTO usrpriv
  ( usrpriv_username, usrpriv_priv_id )
  SELECT pUsername, priv_id
    FROM priv
   WHERE (priv_name=pPrivname);

  NOTIFY "usrprivUpdated";

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.grantpriv(text, text) OWNER TO admin;

--
-- TOC entry 1789 (class 1255 OID 146566365)
-- Dependencies: 4536 8
-- Name: grantprivgroup(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION grantprivgroup(integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pGrpid ALIAS FOR $1;
  pPrivid ALIAS FOR $2;
  _test INTEGER;

BEGIN

  SELECT grppriv_id INTO _test
  FROM grppriv
  WHERE ( (grppriv_grp_id=pGrpid)
   AND (grppriv_priv_id=pPrivid) );

  IF (FOUND) THEN
    RETURN FALSE;
  END IF;

  INSERT INTO grppriv
  ( grppriv_grp_id, grppriv_priv_id )
  VALUES
  ( pGrpid, pPrivid );

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.grantprivgroup(integer, integer) OWNER TO admin;

--
-- TOC entry 1790 (class 1255 OID 146566366)
-- Dependencies: 4536 8
-- Name: hasalarms(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION hasalarms() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _alarm          RECORD;
  _batchId        INTEGER;
  _evntlogordtype TEXT;
  _evnttypeid     INTEGER;
  _evnttypename   TEXT;
  _fromEmail      TEXT;
  _itemid         INTEGER;
  _longsource     TEXT;
  _msgId          INTEGER;
  _recipient      TEXT;
  _recipientPart  INTEGER;
  _returnVal      BOOLEAN := FALSE;
  _summary        TEXT;
  _whsId          INTEGER := -1;

BEGIN
  FOR _alarm IN SELECT *
                FROM alarm
                WHERE ((alarm_creator=getEffectiveXtUser())
                   AND (CURRENT_TIMESTAMP > alarm_trigger)) LOOP
    _returnVal := TRUE;

    IF (_alarm.alarm_source = 'TODO') THEN
      SELECT (todoitem_name || '-' || todoitem_description),
             'T', 'TodoAlarm', 'To-Do Item'
      INTO _summary, _evntlogordtype, _evnttypename, _longsource
      FROM todoitem
      WHERE (todoitem_id = _alarm.alarm_source_id);

    ELSIF (_alarm.alarm_source = 'INCDT') THEN
      SELECT (incdt_number || '-' || incdt_summary),
             'I', 'IncidentAlarm', 'Incident'
      INTO _summary, _evntlogordtype, _evnttypename, _longsource
      FROM incdt
      WHERE (incdt_id = _alarm.alarm_source_id);

    ELSIF (_alarm.alarm_source = 'J') THEN
      SELECT (prj_number || ' ' || prj_name || '-' || prjtask_name),
              'J', 'TaskAlarm', 'Project Task'
      INTO _summary, _evntlogordtype, _evnttypename, _longsource
      FROM prjtask JOIN prj ON (prj_id=prjtask_prj_id)
      WHERE (prjtask_id = _alarm.alarm_source_id);

    ELSE
      CONTINUE; -- there's nothing to do for this iteration of the loop
    END IF;

    -- if event alarm
    IF (_alarm.alarm_event) THEN
      SELECT evnttype_id INTO _evnttypeid
      FROM evnttype
      WHERE (evnttype_name=_evnttypename);

      _recipientPart := 1;
      LOOP
        _recipient := SPLIT_PART(_alarm.alarm_event_recipient, ',', _recipientPart);
        EXIT WHEN (LENGTH(_recipient) = 0);

        SELECT usrpref_value INTO _whsId
        FROM usrpref
        WHERE ( (usrpref_username = _recipient)
          AND   (usrpref_name = 'PreferredWarehouse') );

        INSERT INTO evntlog (evntlog_evnttime, evntlog_username,
                             evntlog_evnttype_id, evntlog_ordtype,
                             evntlog_ord_id, evntlog_warehous_id, evntlog_number
                   ) VALUES (CURRENT_TIMESTAMP, _recipient,
                             _evnttypeid, _evntlogordtype,
                             _alarm.alarm_source_id, _whsId, _summary);

        _recipientPart := _recipientPart + 1;
      END LOOP;
    END IF;

    IF (_alarm.alarm_email) THEN
      SELECT usr_email INTO _fromEmail
      FROM usr
      WHERE (usr_username = _alarm.alarm_creator);

      _recipientPart := 1;
      LOOP
        _recipient := SPLIT_PART(_alarm.alarm_email_recipient, ',', _recipientPart);
        EXIT WHEN (LENGTH(_recipient) <= 0);
        _batchId := xtbatch.submitEmailToBatch(_fromEmail, _recipient, '',
                                               _summary,
                                               'Alarm reminder for '
                                               || _longsource || '.',
                                               NULL, CURRENT_TIMESTAMP,
                                               FALSE, NULL, NULL);
        _recipientPart := _recipientPart + 1;
      END LOOP;
    END IF;

    IF (_alarm.alarm_sysmsg) THEN
      _recipientPart := 1;
      LOOP
        _recipient := SPLIT_PART(_alarm.alarm_sysmsg_recipient, ',', _recipientPart);
        EXIT WHEN (LENGTH(_recipient) <= 0);
        _msgId := postMessage(_recipient, (_longsource || ' - ' || _summary));
        _recipientPart := _recipientPart + 1;
      END LOOP;
    END IF;

    DELETE FROM alarm WHERE alarm_id=_alarm.alarm_id;
  END LOOP;
  RETURN _returnVal;

END;
$$;


ALTER FUNCTION public.hasalarms() OWNER TO admin;

--
-- TOC entry 1791 (class 1255 OID 146566367)
-- Dependencies: 4536 8
-- Name: hasevents(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION hasevents() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  PERFORM evntlog_id
  FROM evntlog
  WHERE ( (evntlog_dispatched IS NULL)
   AND (evntlog_username=getEffectiveXtUser()) )
  LIMIT 1;
  RETURN FOUND;

END;
$$;


ALTER FUNCTION public.hasevents() OWNER TO admin;

--
-- TOC entry 1792 (class 1255 OID 146566368)
-- Dependencies: 4536 8
-- Name: hasmessages(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION hasmessages() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  PERFORM msguser_id
  FROM msg, msguser
  WHERE ( (msguser_username=getEffectiveXtUser())
   AND (msguser_msg_id=msg_id)
   AND (CURRENT_TIMESTAMP BETWEEN msg_scheduled AND msg_expires)
   AND (msguser_viewed IS NULL) )
  LIMIT 1;
  RETURN FOUND;

END;
$$;


ALTER FUNCTION public.hasmessages() OWNER TO admin;

--
-- TOC entry 1794 (class 1255 OID 146566369)
-- Dependencies: 4536 8
-- Name: haspriv(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION haspriv(text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPrivName	ALIAS FOR $1;
  _result       INTEGER;
  _returnVal	BOOLEAN;

BEGIN
  RAISE NOTICE 'hasPriv(TEXT) is deprecated. Use checkPrivilege(TEXT) instead.';
  SELECT priv_id INTO _result
    FROM priv, grppriv, usrgrp
   WHERE((usrgrp_grp_id=grppriv_grp_id)
     AND (grppriv_priv_id=priv_id)
     AND (priv_name=pPrivName)
     AND (usrgrp_username=getEffectiveXtUser()));
  IF (FOUND) THEN
    RETURN true;
  END IF;

  SELECT COALESCE(usrpriv_id, 0) != 0 INTO _returnVal
  FROM priv LEFT OUTER JOIN
       usrpriv ON (priv_id=usrpriv_priv_id AND usrpriv_username = getEffectiveXtUser())
  WHERE (priv_name=pPrivName);
  IF (_returnVal IS NULL) THEN
    _returnVal := FALSE;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.haspriv(text) OWNER TO admin;

--
-- TOC entry 1795 (class 1255 OID 146566370)
-- Dependencies: 4536 8
-- Name: hasprivonobject(text, text, integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION hasprivonobject(pprivtype text, pobjecttype text, pobjectid integer DEFAULT NULL::integer, puser text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _haspriv   BOOLEAN := FALSE;
  _privfound BOOLEAN := FALSE;
  _pkey      TEXT[];
  _privdesc  RECORD;
  _qstr      TEXT;

BEGIN
  IF UPPER(pPrivType) NOT IN ('CREATE', 'EDIT', 'VIEW', 'DELETE') THEN
    RAISE EXCEPTION 'Cannot check if user has % on % [xtuple: hasPrivOnObject, -1, %, %]',
                     pPrivType, pObjectType, pPrivType, pObjectType;
  END IF;

  /* TODO: create privdesc table? can't do it yet because this is a fix for a minor release
     NOTE: only include tables that have a single integer column as pkey
     NOTE: some of these are part of proprietary extensions. how do we make them part of the extension?
  */
  FOR _privdesc IN
  WITH privdesc AS (
    SELECT 'ADDR' AS otype,    'public' AS masterschema,
                                         'addr' AS mastertable,
                                                     'MaintainAddressMasters' AS editall,
                                                                                     'ViewAddressMasters' AS viewall,
                                                                                                               NULL AS ownerfield,        NULL AS editmine,                NULL AS viewmine
     UNION ALL SELECT 'BBH',   'xtmfg',  'bbom',     'MaintainBBOMs',                'ViewBBOMs',              NULL,                      NULL,                            NULL
     UNION ALL SELECT 'BBI',   'xtmfg',  'bbom',     'MaintainBBOMs',                'ViewBBOMs',              NULL,                      NULL,                            NULL
     UNION ALL SELECT 'BMH',   'public', 'bom',      'MaintainBOMs',                 'ViewBOMs',               NULL,                      NULL,                            NULL
     UNION ALL SELECT 'BMI',   'public', 'bom',      'MaintainBOMs',                 'ViewBOMs',               NULL,                      NULL,                            NULL
     UNION ALL SELECT 'BOH',   'xtmfg',  'boo',      'MaintainBOOs',                 'ViewBOOs',               NULL,                      NULL,                            NULL
     UNION ALL SELECT 'BOI',   'xtmfg',  'boo',      'MaintainBOOs',                 'ViewBOOs',               NULL,                      NULL,                            NULL
     UNION ALL SELECT 'C',     'public', 'custinfo', 'MaintainCustomerMasters',      'ViewCustomerMasters',    NULL,                      NULL,                            NULL
     UNION ALL SELECT 'CRMA',  'public', 'crmacct',  'MaintainAllCRMAccounts',       'ViewAllCRMAccounts',     'crmacct_owner_username',  'MaintainPersonalCRMAccounts',   'ViewPersonalCRMAccounts'
     UNION ALL SELECT 'EMP',   'public', 'emp',      'MaintainEmployees',            'ViewEmployees',          NULL,                      NULL,                            NULL
     UNION ALL SELECT 'I',     'public', 'item',     'MaintainItemMasters',          'ViewItemMasters',        NULL,                      NULL,                            NULL
     UNION ALL SELECT 'INCDT', 'public', 'incdt',    'MaintainAllIncidents',         'ViewAllIncidents',       'incdt_owner_username',    'MaintainPersonalIncidents',     'ViewPersonalIncidents'
     UNION ALL SELECT 'IR',    'public', 'itemsrc',  'MaintainItemSources',          'ViewItemSources',        NULL,                      NULL,                            NULL
     UNION ALL SELECT 'IS',    'public', 'itemsite', 'MaintainItemSites',            'ViewItemSites',          NULL,                      NULL,                            NULL
     UNION ALL SELECT 'J',     'public', 'prj',      'MaintainAllProjects',          'ViewAllProjects',        'prj_owner_username',      'MaintainPersonalProjects',      'ViewPersonalProjects'
     UNION ALL SELECT 'J',     'public', 'prj',      'MaintainAllProjects',          'ViewAllProjects',        'prj_username',            'MaintainPersonalProjects',      'ViewPersonalProjects'
     UNION ALL SELECT 'L',     'public', 'location', 'MaintainLocations',            'ViewLocations',          NULL,                      NULL,                            NULL
     UNION ALL SELECT 'OPP',   'public', 'ophead',   'MaintainAllOpportunities',     'ViewAllOpportunities',   'ophead_owner_username',   'MaintainPersonalOpportunities', 'ViewPersonalOpportunities'
     UNION ALL SELECT 'P',     'public', 'pohead',   'MaintainPurchaseOrders',       'ViewPurchaseOrders',     NULL,                      NULL,                            NULL
     UNION ALL SELECT 'PI',    'public', 'pohead',   'MaintainPurchaseOrders',       'ViewPurchaseOrders',     NULL,                      NULL,                            NULL
     UNION ALL SELECT 'Q',     'public', 'quhead',   'MaintainQuotes',               'ViewQuotes',             NULL,                      NULL,                            NULL
     UNION ALL SELECT 'QI',    'public', 'quhead',   'MaintainQuotes',               'ViewQuotes',             NULL,                      NULL,                            NULL
     UNION ALL SELECT 'RA',    'public', 'rahead',   'MaintainReturns',              'ViewReturns',            NULL,                      NULL,                            NULL
     UNION ALL SELECT 'RI',    'public', 'rahead',   'MaintainReturns',              'ViewReturns',            NULL,                      NULL,                            NULL
     UNION ALL SELECT 'S',     'public', 'cohead',   'MaintainSalesOrders',          'ViewSalesOrders',        NULL,                      NULL,                            NULL
     UNION ALL SELECT 'SI',    'public', 'cohead',   'MaintainSalesOrders',          'ViewSalesOrders',        NULL,                      NULL,                            NULL
     UNION ALL SELECT 'T',     'public', 'cntct',    'MaintainAllContacts',          'ViewAllContacts',        'cntct_owner_username',    'MaintainPersonalContacts',      'ViewPersonalContacts'
     UNION ALL SELECT 'TE',    'te',     'tehead',   'MaintainTimeExpense',          'ViewTimeExpenseHistory', 'tehead_username',         'MaintainTimeExpenseSelf',       NULL
     UNION ALL SELECT 'TE',    'te',     'tehead',   'MaintainTimeExpenseOthers',    'ViewTimeExpenseHistory', 'tehead_username',         'MaintainTimeExpenseSelf',       NULL
     UNION ALL SELECT 'TI',    'public', 'tohead',   'MaintainTransferOrders',       'ViewTransferOrders',     NULL,                      NULL,                            NULL
     UNION ALL SELECT 'TO',    'public', 'tohead',   'MaintainTransferOrders',       'ViewTransferOrders',     NULL,                      NULL,                            NULL
     UNION ALL SELECT 'TODO',  'public', 'todoitem', 'MaintainAllToDoItems',         'ViewAllToDoItems',       'todoitem_owner_username', 'MaintainPersonalToDoItems',     'ViewPersonalToDoItems'
     UNION ALL SELECT 'V',     'public', 'vendinfo', 'MaintainVendors',              'ViewVendors',            NULL,                      NULL,                            NULL
     UNION ALL SELECT 'W',     'public', 'wo',       'MaintainWorkOrders',           'ViewWorkOrders',         NULL,                      NULL,                            NULL
     UNION ALL SELECT 'WH',    'public', 'whsinfo',  'MaintainWarehouses',           'ViewWarehouses',         NULL,                      NULL,                            NULL)
  -- UNION ALL SELECT 'LS',    'public', 'ls',       NULL,                           NULL,                     NULL,                      NULL,                            NULL
  -- UNION ALL SELECT 'P',     'public', 'pohead',   'MaintainPostedPurchaseOrders', 'ViewPurchaseOrders',     NULL,                      NULL,                            NULL -- additional criteria?
  -- UNION ALL SELECT 'PI',    'public', 'pohead',   'MaintainPostedPurchaseOrders', 'ViewPurchaseOrders',     NULL,                      NULL,                            NULL -- additional criteria?
     SELECT *
       FROM privdesc
      WHERE otype = pObjectType
  LOOP
    _privfound := TRUE;
    RAISE DEBUG '% % % % % % %',
                _privdesc.otype, _privdesc.masterschema, _privdesc.mastertable,
                _privdesc.editall, _privdesc.viewall, _privdesc.editmine, _privdesc.viewmine;

    IF checkPrivilege(CASE UPPER(pPrivType) WHEN 'CREATE' THEN _privdesc.editall
                                            WHEN 'EDIT'   THEN _privdesc.editall
                                            WHEN 'DELETE' THEN _privdesc.editall
                                            WHEN 'VIEW'   THEN _privdesc.viewall
                      END) THEN
      _haspriv = TRUE;

    ELSIF checkPrivilege(CASE UPPER(pPrivType) WHEN 'CREATE' THEN _privdesc.editmine
                                               WHEN 'EDIT'   THEN _privdesc.editmine
                                               WHEN 'DELETE' THEN _privdesc.editmine
                                               WHEN 'VIEW'   THEN _privdesc.viewmine
                         END) THEN
      IF pObjectId IS NULL THEN
      _haspriv = TRUE;

      ELSE
        _pkey := primaryKeyFields(_privdesc.masterschema, _privdesc.mastertable);

        -- SELECT ... FROM schema.table WHERE pkeyfield = pObjectId AND ownerfield = pUser
        _qstr := 'SELECT EXISTS(SELECT 1
                                  FROM ' || quote_ident(_privdesc.masterschema)
                                   || '.' || quote_ident(_privdesc.mastertable)
                                   || ' WHERE ' || quote_ident(_pkey[1]) || ' = ' || pObjectId
                                   || '   AND ' || quote_ident(_privdesc.ownerfield)
                                   || '= ' || quote_literal(COALESCE(pUser, getEffectiveXtUser())) || ');';
        RAISE DEBUG '%', _qstr;

        EXECUTE _qstr INTO _haspriv;
      END IF;
    END IF;

    EXIT WHEN _haspriv;
  END LOOP;

  RETURN _haspriv OR NOT _privfound;

END;
$$;


ALTER FUNCTION public.hasprivonobject(pprivtype text, pobjecttype text, pobjectid integer, puser text) OWNER TO admin;

--
-- TOC entry 8975 (class 0 OID 0)
-- Dependencies: 1795
-- Name: FUNCTION hasprivonobject(pprivtype text, pobjecttype text, pobjectid integer, puser text); Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON FUNCTION hasprivonobject(pprivtype text, pobjecttype text, pobjectid integer, puser text) IS 'Return if a user has permission to view or edit a specific database object.
pPrivType is either CREATE, EDIT, DELETE, or VIEW, and controls which privilege is checked.
pObjectType is one of the string constants used by the Documents widget, such as ADDR for Addresses.
pObjectId is the internal id of the record in the table associated with pObjectType (defaults to NULL).
pUser is the username to be checked for those pObjectTypes that restrict access to individual users (NULL == current user and is the default).';


--
-- TOC entry 1796 (class 1255 OID 146566372)
-- Dependencies: 8
-- Name: hmac(text, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION hmac(text, text, text) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgcrypto', 'pg_hmac';


ALTER FUNCTION public.hmac(text, text, text) OWNER TO admin;

--
-- TOC entry 1797 (class 1255 OID 146566373)
-- Dependencies: 8
-- Name: hmac(bytea, bytea, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION hmac(bytea, bytea, text) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgcrypto', 'pg_hmac';


ALTER FUNCTION public.hmac(bytea, bytea, text) OWNER TO admin;

--
-- TOC entry 1798 (class 1255 OID 146566374)
-- Dependencies: 4536 8
-- Name: implodewo(integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION implodewo(integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoid ALIAS FOR $1;
  implodeChildren ALIAS FOR $2;
  resultCode INTEGER;
  _wotcCnt   INTEGER;
  _routings  BOOLEAN;

BEGIN
  SELECT metric_value='t' INTO _routings
         FROM metric
         WHERE (metric_name='Routings');

  IF ((SELECT wo_id
       FROM wo
       WHERE ((wo_status='E')
        AND (wo_id=pWoid))) IS NULL) THEN
    RETURN 0;
  END IF;

  IF (_routings) THEN
    SELECT count(*) INTO _wotcCnt
    FROM xtmfg.wotc
    WHERE (wotc_wo_id=pWoid);
    IF (_wotcCnt > 0) THEN
      RETURN -1;
    END IF;
  END IF;

--  Delete any created P/R's for this W/O
  PERFORM deletePr('W', womatl_id)
  FROM womatl
  WHERE (womatl_wo_id=pWoid);

  DELETE FROM womatl
  WHERE (womatl_id IN ( SELECT womatl_id
                        FROM womatl, wo
                        WHERE ((womatl_wo_id=wo_id)
                         AND (wo_status='E')
                         AND (wo_id=pWoid)) ));

  IF _routings THEN

    DELETE FROM xtmfg.wooper
    WHERE (wooper_id IN ( SELECT wooper_id
                          FROM xtmfg.wooper, wo
                          WHERE ((wooper_wo_id=wo_id)
                           AND (wo_status='E')
                           AND (wo_id=pWoid)) ));
  END IF;

  UPDATE wo
  SET wo_status='O'
  WHERE (wo_id=pWoid);

  IF (implodeChildren) THEN
    resultCode := (SELECT MAX(implodeWo(wo_id, TRUE))
                   FROM wo
                   WHERE ((wo_ordtype='W')
                    AND (wo_ordid=pWoid)));

    resultCode := (SELECT MAX(deleteWo(wo_id, TRUE))
                   FROM wo
                   WHERE ((wo_ordtype='W')
                    AND (wo_ordid=pWoid)));
  END IF;

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.implodewo(integer, boolean) OWNER TO admin;

--
-- TOC entry 206 (class 1259 OID 146566375)
-- Dependencies: 5952 5953 5954 8
-- Name: incdt; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE incdt (
    incdt_id integer NOT NULL,
    incdt_number integer NOT NULL,
    incdt_crmacct_id integer,
    incdt_cntct_id integer,
    incdt_summary text,
    incdt_descrip text,
    incdt_item_id integer,
    incdt_timestamp timestamp without time zone DEFAULT now() NOT NULL,
    incdt_status character(1) DEFAULT 'N'::bpchar NOT NULL,
    incdt_assigned_username text,
    incdt_incdtcat_id integer,
    incdt_incdtseverity_id integer,
    incdt_incdtpriority_id integer,
    incdt_incdtresolution_id integer,
    incdt_lotserial text,
    incdt_ls_id integer,
    incdt_aropen_id integer,
    incdt_owner_username text,
    incdt_recurring_incdt_id integer,
    incdt_updated timestamp without time zone DEFAULT now() NOT NULL,
    incdt_prj_id integer,
    incdt_public boolean
);


ALTER TABLE public.incdt OWNER TO admin;


--
-- TOC entry 1799 (class 1255 OID 146566384)
-- Dependencies: 2785 4536 8
-- Name: incdt(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION incdt() RETURNS SETOF incdt
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _row incdt%ROWTYPE;
  _priv TEXT;
  _grant BOOLEAN;

BEGIN
  -- This query will give us the most permissive privilege the user has been granted
  SELECT privilege, granted INTO _priv, _grant
  FROM privgranted
  WHERE privilege IN ('MaintainAllIncidents','ViewAllIncidents','MaintainPersonalIncidents','ViewPersonalIncidents')
  ORDER BY granted DESC, sequence
  LIMIT 1;

  -- If have an 'All' privilege return all results
  IF (_priv ~ 'All' AND _grant) THEN
    FOR _row IN
      SELECT * FROM incdt
    LOOP
      RETURN NEXT _row;
    END LOOP;
  -- Otherwise if have any other grant, must be personal privilege.
  ELSIF (_grant) THEN
    FOR _row IN
      SELECT * FROM incdt
      WHERE  getEffectiveXtUser() IN (incdt_owner_username, incdt_assigned_username)
    LOOP
      RETURN NEXT _row;
    END LOOP;
  END IF;

  RETURN;

END;
$$;


ALTER FUNCTION public.incdt() OWNER TO admin;

--
-- TOC entry 8980 (class 0 OID 0)
-- Dependencies: 1799
-- Name: FUNCTION incdt(); Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON FUNCTION incdt() IS 'A table function that returns Incident results according to privilege settings.';


--
-- TOC entry 1800 (class 1255 OID 146566385)
-- Dependencies: 4536 8
-- Name: indentedbom(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION indentedbom(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  _revid INTEGER;

BEGIN

  SELECT getActiveRevId('BOM',pItemid) INTO _revid;

  RETURN indentedBOM(pItemid, _revid);

END;
$_$;


ALTER FUNCTION public.indentedbom(integer) OWNER TO admin;

--
-- TOC entry 1801 (class 1255 OID 146566386)
-- Dependencies: 4536 8
-- Name: indentedbom(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION indentedbom(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pRevisionid ALIAS FOR $2;
  _bomworkid INTEGER;
  _indexid INTEGER;
  _r RECORD;
  _batchsize NUMERIC;

BEGIN

  -- Get the batch quantity
  SELECT COALESCE( (
    SELECT bomhead_batchsize
    FROM bomhead
    WHERE ((bomhead_item_id=pItemId)
    AND (bomhead_rev_id=pRevisionid)) LIMIT 1),1) INTO _batchsize;

--  Check on the temporary workspace
--  PERFORM maintainBOMWorkspace();

--  Grab a new index for this bomwork set
  SELECT NEXTVAL('misc_index_seq') INTO _indexid;

--  Step through all of the components of the passed pItemid
  FOR _r IN SELECT bomitem.*,
                   item_id,
                   itemuomtouom(item_id, item_inv_uom_id, NULL, (bomitem_qtyfxd/_batchsize + bomitem_qtyper) * (1 + bomitem_scrap), 'qtyper') AS qtyreq,
                   (itemuomtouomratio(bomitem_item_id, bomitem_uom_id, NULL)
                               * bomitem_qtyfxd) AS qtyfxd,
                   (itemuomtouomratio(bomitem_item_id, bomitem_uom_id, NULL)
                               * bomitem_qtyper) AS qtyper,
                   stdcost(item_id, bomitem_id) AS standardcost,
                   actcost(item_id, bomitem_id) AS actualcost
  FROM bomitem(pItemId, pRevisionid), item
  WHERE ( (bomitem_item_id=item_id) ) LOOP

--  Insert the component and bomitem parameters
    SELECT NEXTVAL('bomwork_bomwork_id_seq') INTO _bomworkid;
    INSERT INTO bomwork
    ( bomwork_id, bomwork_set_id, bomwork_parent_id, bomwork_level,
      bomwork_parent_seqnumber, bomwork_seqnumber,
      bomwork_item_id, bomwork_createwo, bomwork_qtyreq,
      bomwork_qtyfxd, bomwork_qtyper, bomwork_scrap, bomwork_issuemethod,
      bomwork_effective, bomwork_expires,
      bomwork_stdunitcost, bomwork_actunitcost,
      bomwork_char_id, bomwork_value, bomwork_notes, bomwork_ref,
      bomwork_bomitem_id, bomwork_ecn )
    VALUES
    ( _bomworkid, _indexid, -1, 1,
      0, _r.bomitem_seqnumber,
      _r.item_id, _r.bomitem_createwo, _r.qtyreq,
      _r.qtyfxd, _r.qtyper, _r.bomitem_scrap, _r.bomitem_issuemethod,
      _r.bomitem_effective, _r.bomitem_expires,
      _r.standardcost, _r.actualcost,
      _r.bomitem_char_id, _r.bomitem_value, _r.bomitem_notes, _r.bomitem_ref,
      _r.bomitem_id, _r.bomitem_ecn );

--  Explode the components of the current component
    PERFORM explodeBOM(_r.item_id, _bomworkid, 1);

  END LOOP;

--  Return a key to the result
  RETURN _indexid;

END;
$_$;


ALTER FUNCTION public.indentedbom(integer, integer) OWNER TO admin;

--
-- TOC entry 1802 (class 1255 OID 146566387)
-- Dependencies: 2657 4536 8
-- Name: indentedbom(integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION indentedbom(integer, integer, integer, integer) RETURNS SETOF bomdata
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pRevisionid ALIAS FOR $2;
  pExpiredDays ALIAS FOR $3;
  pFutureDays ALIAS FOR $4;
  _row bomdata%ROWTYPE;
  _bomworksetid INTEGER;
  _x RECORD;
  _check CHAR(1);
  _inactive BOOLEAN := FALSE;
  _batchsize NUMERIC;
BEGIN

  IF (pRevisionid != -1) THEN
    --Is this a deactivated revision?
    SELECT rev_status INTO _check
    FROM rev
    WHERE ((rev_id=pRevisionid)
    AND (rev_status='I'));
    IF (FOUND) THEN
      _inactive := TRUE;
    END IF;
  END IF;

  -- Get the batch quantity
  SELECT COALESCE( (
    SELECT bomhead_batchsize
    FROM bomhead
    WHERE ((bomhead_item_id=pItemId)
    AND (bomhead_rev_id=pRevisionid)) LIMIT 1),1) INTO _batchsize;

  IF NOT (_inactive) THEN

    --We can explode this out based on current data
    SELECT indentedBOM(pItemid, pRevisionid) INTO _bomworksetid;

    FOR _x IN
        SELECT bomwork_id, bomwork_parent_id, bomwork_level,
               bomworkSequence(bomwork_id) AS seq_ord,
               bomwork_seqnumber, item_id, item_number, uom_name,
               item_descrip1, item_descrip2,
               (item_descrip1 || ' ' || item_descrip2) AS itemdescription,
               bomwork_qtyreq, bomwork_qtyfxd, bomwork_qtyper, bomwork_scrap, bomwork_createwo,
       CASE WHEN (bomwork_issuemethod='S') THEN 'Push'
            WHEN (bomwork_issuemethod='L') THEN 'Pull'
            WHEN (bomwork_issuemethod='M') THEN 'Mixed'
            ELSE 'Special'
       END AS issuemethod,
       bomwork_effective, bomwork_expires,
       (bomwork_expires <= CURRENT_DATE) AS expired,
       (bomwork_effective > CURRENT_DATE) AS future,
       bomwork_actunitcost AS actunitcost,
       bomwork_stdunitcost AS stdunitcost,
       CASE WHEN item_type NOT IN ('R','T') THEN
         itemuomtouom(item_id, item_inv_uom_id, NULL, (bomwork_qtyfxd/_batchsize + bomwork_qtyper) * (1 + bomwork_scrap), 'qtyper') * bomwork_actunitcost
       ELSE 0.0 END AS actextendedcost,
       CASE WHEN item_type NOT IN ('R','T') THEN
         itemuomtouom(item_id, item_inv_uom_id, NULL, (bomwork_qtyfxd/_batchsize + bomwork_qtyper) * (1 + bomwork_scrap), 'qtyper') * bomwork_stdunitcost
       ELSE 0.0 END AS stdextendedcost,
       bomwork_char_id,
       bomwork_value, bomwork_notes, bomwork_ref,
       bomwork_bomitem_id, bomwork_ecn
       FROM bomwork, item, uom
       WHERE ( (bomwork_item_id=item_id)
       AND (item_inv_uom_id=uom_id)
       AND (bomwork_set_id=_bomworksetid) )
       AND (bomwork_expires > (CURRENT_DATE - pExpiredDays))
       AND (bomwork_effective <= (CURRENT_DATE + pFutureDays))
       UNION
       SELECT -1, -1, 1,
              '0',
              NULL,-1, costelem_type AS bomdata_item_number, '',
              '', '',
              '',
              NULL, NULL, NULL, NULL, NULL,
              '',
              NULL, NULL,
              false,
              false,
              currToBase(itemcost_curr_id, itemcost_actcost, CURRENT_DATE) AS actunitcost,
              itemcost_stdcost AS stdunitcost,
              currToBase(itemcost_curr_id, itemcost_actcost, CURRENT_DATE) AS actextendedcost,
              itemcost_stdcost AS stdextendedcost,
              NULL,
              NULL,NULL,NULL,
              NULL,NULL
       FROM itemcost, costelem
       WHERE ( (itemcost_costelem_id=costelem_id)
       AND (NOT itemcost_lowlevel)
       AND (itemcost_item_id=pItemid) )
       ORDER BY seq_ord
    LOOP
        _row.bomdata_bomwork_id := _x.bomwork_id;
        _row.bomdata_bomwork_parent_id := _x.bomwork_parent_id;
        _row.bomdata_bomwork_level := _x.bomwork_level;
        _row.bomdata_bomwork_seqnumber := _x.bomwork_seqnumber;
        _row.bomdata_bomitem_id := _x.bomwork_bomitem_id;
        _row.bomdata_item_id := _x.item_id;
        _row.bomdata_item_number := _x.item_number;
        _row.bomdata_uom_name := _x.uom_name;
        _row.bomdata_item_descrip1 := _x.item_descrip1;
        _row.bomdata_item_descrip2 := _x.item_descrip2;
        _row.bomdata_itemdescription := _x.itemdescription;
        _row.bomdata_batchsize := _batchsize;
        _row.bomdata_qtyreq := _x.bomwork_qtyreq;
        _row.bomdata_qtyfxd := _x.bomwork_qtyfxd;
        _row.bomdata_qtyper := _x.bomwork_qtyper;
        _row.bomdata_scrap := _x.bomwork_scrap;
        _row.bomdata_createchild := _x.bomwork_createwo;
        _row.bomdata_issuemethod := _x.issuemethod;
        _row.bomdata_effective := _x.bomwork_effective;
        _row.bomdata_expires := _x.bomwork_expires;
        _row.bomdata_expired := _x.expired;
        _row.bomdata_future := _x.future;
        _row.bomdata_actunitcost := _x.actunitcost;
        _row.bomdata_stdunitcost := _x.stdunitcost;
        _row.bomdata_actextendedcost := _x.actextendedcost;
        _row.bomdata_stdextendedcost := _x.stdextendedcost;
        _row.bomdata_ecn := _x.bomwork_ecn;
        _row.bomdata_char_id := _x.bomwork_char_id;
        _row.bomdata_value := _x.bomwork_value;
        _row.bomdata_notes := _x.bomwork_notes;
        _row.bomdata_ref := _x.bomwork_ref;
        RETURN NEXT _row;
    END LOOP;

    PERFORM deleteBOMWorkset(_bomworksetid);

  ELSE

-- Use historical snapshot for inactive revisions
    FOR _x IN
        SELECT bomhist_id, bomhist_parent_id, bomhist_level,
               bomhistSequence(bomhist_seq_id) AS seq_ord,
               bomhist_seqnumber, item_id, item_number, uom_name,
               item_descrip1, item_descrip2,
               (item_descrip1 || ' ' || item_descrip2) AS itemdescription,
               bomhist_qtyreq, bomhist_qtyfxd, bomhist_qtyper, bomhist_scrap,
               bomhist_createwo,
       CASE WHEN (bomhist_issuemethod='S') THEN 'Push'
            WHEN (bomhist_issuemethod='L') THEN 'Pull'
            WHEN (bomhist_issuemethod='M') THEN 'Mixed'
            ELSE 'Special'
       END AS issuemethod,
       bomhist_effective, bomhist_expires,
       (bomhist_expires <= CURRENT_DATE) AS expired,
       (bomhist_effective > CURRENT_DATE) AS future,
       bomhist_actunitcost AS actunitcost,
       bomhist_stdunitcost AS stdunitcost,
       CASE WHEN item_type NOT IN ('R','T') THEN
         (bomist_qtyfxd/_batchsize + bomhist_qtyper) * (1 + bomhist_scrap) * bomhist_actunitcost
       ELSE 0 END AS actextendedcost,
       CASE WHEN item_type NOT IN ('R','T') THEN
         (bomist_qtyfxd/_batchsize + bomhist_qtyper) * (1 + bomhist_scrap) * bomhist_stdunitcost
       ELSE 0 END AS stdextendedcost,
       bomhist_char_id, bomhist_value, bomhist_notes, bomhist_ref
       FROM bomhist, item, uom
       WHERE ( (bomhist_item_id=item_id)
       AND (item_inv_uom_id=uom_id)
       AND (bomhist_rev_id=pRevisionid) )
       AND (bomhist_expires > (CURRENT_DATE - pExpiredDays))
       AND (bomhist_effective <= (CURRENT_DATE + pFutureDays))
       UNION
       SELECT -1, -1, 1,
              '0',
              NULL,-1, costelem_type AS bomdata_item_number, '',
              '', '',
              '',
              NULL, NULL, NULL, NULL,
              false,
              '', NULL, NULL,
              false,
              false,
              bomhist_actunitcost AS actunitcost,
              bomhist_stdunitcost AS stdunitcost,
              bomhist_actunitcost AS actextendedcost,
              bomhist_stdunitcost AS stdextendedcost,
              NULL,NULL,NULL,NULL
       FROM bomhist, costelem
       WHERE ((bomhist_rev_id=pRevisionid)
       AND (costelem_id=bomhist_item_id))
       ORDER BY seq_ord
    LOOP
        _row.bomdata_bomwork_id := _x.bomhist_id;
        _row.bomdata_bomwork_parent_id := _x.bomhist_parent_id;
        _row.bomdata_bomwork_level := _x.bomhist_level;
        _row.bomdata_bomwork_seqnumber := _x.bomhist_seqnumber;
        _row.bomdata_bomitem_id := -1;
        _row.bomdata_item_id := _x.item_id;
        _row.bomdata_item_number := _x.item_number;
        _row.bomdata_uom_name := _x.uom_name;
        _row.bomdata_item_descrip1 := _x.item_descrip1;
        _row.bomdata_item_descrip2 := _x.item_descrip2;
        _row.bomdata_itemdescription := _x.itemdescription;
        _row.bomdata_batchsize := _batchsize;
        _row.bomdata_qtyreq := _x.bomhist_qtyreq;
        _row.bomdata_qtyfxd := _x.bomist_qtyfxd;
        _row.bomdata_qtyper := _x.bomhist_qtyper;
        _row.bomdata_scrap := _x.bomhist_scrap;
        _row.bomdata_createchild := _x.bomhist_createwo;
        _row.bomdata_issuemethod := _x.issuemethod;
        _row.bomdata_effective := _x.bomhist_effective;
        _row.bomdata_expires := _x.bomhist_expires;
        _row.bomdata_expired := _x.expired;
        _row.bomdata_future := _x.future;
        _row.bomdata_actunitcost := _x.actunitcost;
        _row.bomdata_stdunitcost := _x.stdunitcost;
        _row.bomdata_actextendedcost := _x.actextendedcost;
        _row.bomdata_stdextendedcost := _x.stdextendedcost;
        _row.bomdata_ecn := '';
        _row.bomdata_char_id := _x.bomhist_char_id;
        _row.bomdata_value := _x.bomhist_value;
        _row.bomdata_notes := _x.bomhist_notes;
        _row.bomdata_ref := _x.bomhist_ref;
        RETURN NEXT _row;
    END LOOP;
  END IF;

  RETURN;
END;
$_$;


ALTER FUNCTION public.indentedbom(integer, integer, integer, integer) OWNER TO admin;

--
-- TOC entry 1805 (class 1255 OID 146566389)
-- Dependencies: 4536 8
-- Name: indentedwhereused(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION indentedwhereused(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  _indexid INTEGER;
  _level INTEGER;

BEGIN

--  Check on the temporary workspace
--  PERFORM maintainBOMWorkspace();

  _indexid := (SELECT NEXTVAL('misc_index_seq'));
  _level := 1;

  INSERT INTO bomwork
  ( bomwork_set_id, bomwork_parent_id,
    bomwork_level, bomwork_seqnumber,
    bomwork_item_id, bomwork_item_type, bomwork_createwo,
    bomwork_qtyfxd, bomwork_qtyper,
    bomwork_scrap, bomwork_issuemethod,
    bomwork_effective, bomwork_expires, bomwork_status,
    bomwork_stdunitcost, bomwork_actunitcost )
  SELECT _indexid, -1,
         1, bomitem_seqnumber,
         item_id, item_type, bomitem_createwo,
         (itemuomtouomratio(bomitem_item_id, bomitem_uom_id, NULL) * bomitem_qtyfxd),
         (itemuomtouomratio(bomitem_item_id, bomitem_uom_id, NULL) * bomitem_qtyper),
         bomitem_scrap, bomitem_issuemethod,
         bomitem_effective, bomitem_expires, 'U',
         stdcost(item_id), actcost(item_id)
  FROM bomitem, item
  WHERE ((bomitem_item_id=pItemid)
    AND (bomitem_parent_item_id=item_id)
    AND (CURRENT_DATE BETWEEN bomitem_effective AND (bomitem_expires - 1))
    AND (bomitem_rev_id=getActiveRevId('BOM',bomitem_parent_item_id)));

  WHILE ( ( SELECT count(*)
            FROM bomwork
            WHERE ((bomwork_status='U')
              AND (bomwork_set_id=_indexid)) ) > 0) LOOP

    _level := _level + 1;

    INSERT INTO bomwork
    ( bomwork_set_id, bomwork_parent_id,
      bomwork_level, bomwork_seqnumber,
      bomwork_item_id, bomwork_item_type, bomwork_createwo,
      bomwork_qtyfxd, bomwork_qtyper,
      bomwork_scrap, bomwork_issuemethod,
      bomwork_effective, bomwork_expires, bomwork_status,
      bomwork_stdunitcost, bomwork_actunitcost )
    SELECT _indexid, bomwork_id,
           _level, bomitem_seqnumber,
           item_id, item_type, bomitem_createwo,
           (bomwork_qtyper * (itemuomtouomratio(bomitem_item_id, bomitem_uom_id, NULL) * bomitem_qtyfxd)),
           (bomwork_qtyper * (itemuomtouomratio(bomitem_item_id, bomitem_uom_id, NULL) * bomitem_qtyper)),
           bomitem_scrap, bomitem_issuemethod,
           CASE WHEN bomitem_effective < bomwork_effective THEN
             bomwork_effective
           ELSE bomitem_effective END,
           CASE WHEN bomitem_expires > bomwork_expires THEN
             bomwork_expires
           ELSE bomitem_expires END,
           'N',
           stdcost(item_id), actcost(item_id)
    FROM bomwork JOIN bomitem ON ( (bomitem_item_id=bomwork_item_id)
                               AND (CURRENT_DATE BETWEEN bomitem_effective AND (bomitem_expires - 1))
                               AND (bomitem_rev_id=getActiveRevId('BOM',bomitem_parent_item_id)) )
                 JOIN item ON (item_id=bomitem_parent_item_id)
    WHERE (bomwork_status='U');

    UPDATE bomwork
    SET bomwork_status='C'
    WHERE ((bomwork_status='U')
      AND (bomwork_set_id=_indexid));

    UPDATE bomwork
    SET bomwork_status='U'
    WHERE ((bomwork_status='N')
      AND (bomwork_set_id=_indexid));

  END LOOP;

  RETURN _indexid;
END;
$_$;


ALTER FUNCTION public.indentedwhereused(integer) OWNER TO admin;

--
-- TOC entry 1806 (class 1255 OID 146566390)
-- Dependencies: 2711 4536 8
-- Name: indentedwo(integer, boolean, boolean, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION indentedwo(integer, boolean, boolean, boolean) RETURNS SETOF wodata
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
   pwoid ALIAS FOR $1;
   pshowops ALIAS FOR $2;
   pshowmatl ALIAS FOR $3;
   pshowindent ALIAS FOR $4;
  _row wodata%ROWTYPE;
  _subrow wodata%ROWTYPE;
  _opx wodata%ROWTYPE;
  _x RECORD;
  _level INTEGER;

BEGIN
    --The wodata_id_type column is used to indicate the source of the wodata_id
    --there are three different tables used wo, womatl and womatlvar
    --wodata_id_type = 1 = wo_id
    --wodata_id_type = 2 = womatl_id
    --wodata_id_type = 3 = wooper_id
    --initialise values
    _level := 0;
    --get top level works orders
    FOR _x IN
       SELECT wo_id,wo_number,wo_subnumber,wo_status,wo_startdate,
         wo_duedate,wo_adhoc,wo_itemsite_id,itemsite_qtyonhand,
         wo_qtyord,wo_qtyrcv,wo_prodnotes, item_number,
         item_descrip1, item_descrip2, item_listprice, uom_name
       FROM wo, itemsite, item, uom
       WHERE ((wo_id = pwoid)
         AND (itemsite_id = wo_itemsite_id)
         AND (itemsite_item_id=item_id)
         AND (item_inv_uom_id=uom_id))
       ORDER BY wo_number, wo_subnumber
    LOOP
        _row.wodata_id := _x.wo_id;
        _row.wodata_id_type := 1;
        _row.wodata_number := _x.wo_number;
        _row.wodata_subnumber := _x.wo_subnumber;
        _row.wodata_itemnumber := _x.item_number;
        _row.wodata_descrip := _x.item_descrip1 || '-' || _x.item_descrip2;
        _row.wodata_status := _x.wo_status;
        _row.wodata_startdate := _x.wo_startdate;
        _row.wodata_duedate := _x.wo_duedate;
        _row.wodata_adhoc := _x.wo_adhoc;
        _row.wodata_itemsite_id := _x.wo_itemsite_id;
        _row.wodata_custprice := _x.item_listprice;
        _row.wodata_listprice := _x.item_listprice;
        _row.wodata_qoh := _x.itemsite_qtyonhand;
        _row.wodata_short := noneg(_x.wo_qtyord - _x.wo_qtyrcv);
        _row.wodata_qtyrcv := _x.wo_qtyrcv;
        _row.wodata_qtyordreq := _x.wo_qtyord;
        _row.wodata_qtyuom := _x.uom_name;
        _row.wodata_scrap := 0;
        _row.wodata_notes := _x.wo_prodnotes;
        _row.wodata_level := _level;
        RETURN NEXT _row;
        IF (pshowmatl AND NOT pshowops) THEN
          --expand materials
          FOR _subrow IN
             SELECT * FROM indentedwomatl(pwoid, _level)
          LOOP
            RETURN NEXT _subrow;
          END LOOP;
        END IF;

        IF ((pshowmatl OR pshowindent) AND NOT pshowops) THEN
          --expand next level down
          FOR _subrow IN
           SELECT * FROM indentedwo(_x.wo_id, NULL, _level + 1, pshowmatl, pshowindent)
          LOOP
            RETURN NEXT _subrow;
          END LOOP;
        END IF;

        IF (pshowops) THEN
         --expand materials not on operations
         IF (pshowmatl) THEN
           FOR _subrow IN
             SELECT * FROM indentedwomatl(pwoid, -1, _level)
           LOOP
             RETURN NEXT _subrow;
           END LOOP;
         END IF;

         IF (pshowmatl OR pshowindent) THEN
           --expand next level down
           FOR _subrow IN
             SELECT * FROM indentedwo(_x.wo_id, -1, _level + 1,  pshowmatl, pshowindent)
           LOOP
             RETURN NEXT _subrow;
           END LOOP;
         END IF;

         --expand opeartions
         FOR _opx IN
           SELECT * FROM xtmfg.indentedwoops(pwoid,_level)
         LOOP
           RETURN NEXT _opx;

           IF (pshowmatl) THEN
              --expand materials on operations
              FOR _subrow IN
                 SELECT * FROM indentedwomatl(pwoid, _opx.wodata_id, _level + 1)
              LOOP
                RETURN NEXT _subrow;
              END LOOP;
           END IF;

           IF (pshowmatl OR pshowindent) THEN
              --expand next level down
              FOR _subrow IN
                SELECT * FROM indentedwo(_x.wo_id, _opx.wodata_id, _level + 2,  pshowmatl, pshowindent)
              LOOP
                RETURN NEXT _subrow;
              END LOOP;
           END IF;
         END LOOP;
       END IF;
  END LOOP;
  RETURN;
END;
$_$;


ALTER FUNCTION public.indentedwo(integer, boolean, boolean, boolean) OWNER TO admin;

--
-- TOC entry 1807 (class 1255 OID 146566391)
-- Dependencies: 2711 4536 8
-- Name: indentedwo(integer, integer, integer, boolean, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION indentedwo(integer, integer, integer, boolean, boolean) RETURNS SETOF wodata
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
   pwoid ALIAS FOR $1;
   pwooperid ALIAS FOR $2;
   plevel ALIAS FOR $3;
   pshowmatl ALIAS FOR $4;
   pshowindent ALIAS FOR $5;
  _row wodata%ROWTYPE;
  _opx wodata%ROWTYPE;
  _x RECORD;
  _subx RECORD;
  _index INTEGER;
  _level INTEGER;
  _qry TEXT;

BEGIN
    --The wodata id column is used to indicate the source of the id
    --there are three different tables used wo, womatl and womatlvar
    --wodata_id_type = 1 = wo_id
    --wodata_id_type = 2 = womatl_id
    --wodata_id_type = 3 = wooper_id
    _level := (plevel + 1);
    --find all WO with the ordid of the next level up
    _qry := 'SELECT wo_id,wo_number,wo_subnumber,wo_status,wo_startdate,wo_duedate,
         wo_adhoc,wo_itemsite_id,itemsite_qtyonhand,wo_qtyord,wo_qtyrcv, wo_prodnotes,
         item_number,item_descrip1, item_descrip2, item_listprice, uom_name,
         womatl_qtyiss, womatl_scrap, womatl_wooper_id
       FROM itemsite,  wo, item, uom, womatl
       WHERE ((wo_ordid = ' || pwoid || ')
         AND (wo_ordtype = ''W'')
         AND (itemsite_item_id=item_id)
         AND (item_inv_uom_id=uom_id)
         AND (wo_womatl_id=womatl_id)
         AND (wo_itemsite_id = itemsite_id) ';

    IF (pwooperid IS NOT NULL) THEN
      _qry := _qry || ' AND (womatl_wooper_id=' || pwooperid || ') ';
    END IF;

    _qry := _qry || ') ORDER BY wo_number, wo_subnumber';
 /* if (pwooperid IS NOT NULL) THEN
    raise exception 'stop %',_qry;
  END IF;*/
    FOR _x IN
      EXECUTE _qry
    LOOP
        _row.wodata_id := _x.wo_id;
        _row.wodata_id_type := 1;
        _row.wodata_number := _x.wo_number;
        _row.wodata_subnumber := _x.wo_subnumber;
        _row.wodata_itemnumber := _x.item_number;
        _row.wodata_descrip := _x.item_descrip1 || '-' || _x.item_descrip2;
        _row.wodata_status := _x.wo_status;
        _row.wodata_startdate := _x.wo_startdate;
        _row.wodata_duedate := _x.wo_duedate;
        _row.wodata_adhoc := _x.wo_adhoc;
        _row.wodata_itemsite_id := _x.wo_itemsite_id;
        _row.wodata_custprice := _x.item_listprice;
        _row.wodata_listprice := _x.item_listprice;
        _row.wodata_qoh := _x.itemsite_qtyonhand;
        _row.wodata_short := noneg(_x.wo_qtyord - _x.wo_qtyrcv);
        _row.wodata_qtyiss := _x.womatl_qtyiss;
        _row.wodata_qtyrcv := _x.wo_qtyrcv;
        _row.wodata_qtyordreq := _x.wo_qtyord;
	_row.wodata_scrap := _x.womatl_scrap;
        _row.wodata_notes := _x.wo_prodnotes;
        _row.wodata_level := plevel;
        RETURN NEXT _row;
        --if indentation require expand next level
        IF (pshowindent AND pwooperid IS NULL) THEN
          IF (pshowmatl AND pshowindent) THEN
      	    --get materials for this level
            FOR _subx IN
              SELECT * FROM indentedwomatl(_x.wo_id, plevel)
	    LOOP
	      RETURN NEXT _subx;
  	    END LOOP;
          END IF;

          IF (pshowindent) THEN
            --expand lower levels
            FOR _subx IN
              SELECT * FROM indentedwo(_x.wo_id, NULL, _level, pshowmatl, pshowindent )
            LOOP
	      RETURN NEXT _subx;
            END LOOP;
          END IF;

        ELSIF (pshowindent) THEN --Handle operations
          --expand materials not on operations
          IF (pshowmatl) THEN
            FOR _subx IN
              SELECT * FROM indentedwomatl(_x.wo_id, -1, plevel)
            LOOP
              RETURN NEXT _subx;
            END LOOP;
          END IF;

          --expand next level down not on operations
          FOR _subx IN
            SELECT * FROM indentedwo(_x.wo_id, -1, _level,  pshowmatl, pshowindent)
          LOOP
            RETURN NEXT _subx;
          END LOOP;

          --expand operations
          FOR _opx IN
            SELECT * FROM xtmfg.indentedwoops(_x.wo_id,plevel)
          LOOP
            RETURN NEXT _opx;

            IF (pshowmatl) THEN
              --expand materials on operations
              FOR _subx IN
                 SELECT * FROM indentedwomatl(_x.wo_id, _opx.wodata_id, _level)
              LOOP
                RETURN NEXT _subx;
                --	raise exception 'stop %',_opx.wodata_id;
              END LOOP;
            END IF;

            --expand next level down
            FOR _subx IN
              SELECT * FROM indentedwo(_x.wo_id, _opx.wodata_id, _level + 2,  pshowmatl, pshowindent)
            LOOP
              RETURN NEXT _subx;
            END LOOP;

          END LOOP;
        END IF;
      END LOOP;
  RETURN;
END;
$_$;


ALTER FUNCTION public.indentedwo(integer, integer, integer, boolean, boolean) OWNER TO admin;

--
-- TOC entry 1808 (class 1255 OID 146566392)
-- Dependencies: 2711 4536 8
-- Name: indentedwomatl(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION indentedwomatl(integer, integer) RETURNS SETOF wodata
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
   pwoid ALIAS FOR $1;
   plevel ALIAS FOR $2;
  _subx RECORD;

BEGIN
  FOR _subx IN
    SELECT * FROM indentedwomatl(pwoid, NULL::integer, plevel)
  LOOP
    RETURN NEXT _subx;
  END LOOP;
  RETURN;
END;
$_$;


ALTER FUNCTION public.indentedwomatl(integer, integer) OWNER TO admin;

--
-- TOC entry 1809 (class 1255 OID 146566393)
-- Dependencies: 2711 4536 8
-- Name: indentedwomatl(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION indentedwomatl(integer, integer, integer) RETURNS SETOF wodata
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
   pwoid ALIAS FOR $1;
   pwooperid ALIAS FOR $2;
   plevel ALIAS FOR $3;
  _status TEXT;
  _subrow wodata%ROWTYPE;
  _subx RECORD;
  _level INTEGER;
  _qry TEXT;

BEGIN
  --The wodata id column is used to indicate the source of the id
  --there are three different tables used wo, womatl and womatlvar
  --wodata_id_type = 1 = wo_id
  --wodata_id_type = 2 = womatl_id
  --wodata_id_type = 3 = wooper_id

  _qry := 'SELECT womatl_id, wo_number, wo_subnumber,
      wo_startdate, womatl_duedate, womatl_itemsite_id,
      itemsite_qtyonhand, womatl_qtyreq, womatl_qtyiss,
      womatl_qtyper, womatl_qtyreq, womatl_scrap,
      womatl_ref, womatl_notes, womatl_price, item_listprice,
      item_number, item_descrip1, item_descrip2,
      uom_name
    FROM womatl, wo, itemsite, item, uom
    WHERE ((wo_id = womatl_wo_id)
     AND (wo_id = ' || pwoid || ')
     AND (womatl_itemsite_id = itemsite_id)
     AND (itemsite_item_id=item_id)
     AND (womatl_uom_id=uom_id) ';
-- Need to display in case child w/o is deleted
--     AND (NOT womatl_createwo OR womatl_createwo IS NULL) ';

  IF (pwooperid IS NOT NULL) THEN
    _qry := _qry || 'AND (womatl_wooper_id=' || pwooperid  || ')';
  END IF;

  _qry := _qry || ') ORDER BY item_number;';

  _level := plevel + 1;
  SELECT wo_status FROM wo WHERE wo_id = pwoid  LIMIT 1 INTO _status;

  FOR _subx IN
    EXECUTE _qry
  LOOP
    _subrow.wodata_id := _subx.womatl_id;
    _subrow.wodata_id_type  := 2;
    _subrow.wodata_number := _subx.wo_number;
    _subrow.wodata_subnumber := _subx.wo_subnumber;
    _subrow.wodata_itemnumber := _subx.item_number;
    _subrow.wodata_descrip := _subx.item_descrip1 || '-' || _subx.item_descrip2;
    _subrow.wodata_status := _status;
    _subrow.wodata_startdate := _subx.wo_startdate;
    _subrow.wodata_duedate := _subx.womatl_duedate;
    _subrow.wodata_itemsite_id := _subx.womatl_itemsite_id;
    _subrow.wodata_custprice := _subx.womatl_price;
    _subrow.wodata_listprice := _subx.item_listprice;
    _subrow.wodata_qoh := _subx.itemsite_qtyonhand;
    IF((_subx.itemsite_qtyonhand > (_subx.womatl_qtyreq - _subx.womatl_qtyiss))) THEN
      _subrow.wodata_short := 0;
    ELSE
      _subrow.wodata_short := (_subx.womatl_qtyreq - _subx.womatl_qtyiss) -  _subx.itemsite_qtyonhand;
    END IF;
    _subrow.wodata_qtyper := _subx.womatl_qtyper;
    _subrow.wodata_qtyiss := _subx.womatl_qtyiss;
    _subrow.wodata_qtyordreq := _subx.womatl_qtyreq;
    _subrow.wodata_qtyuom := _subx.uom_name;
    _subrow.wodata_scrap := _subx.womatl_scrap;
    _subrow.wodata_notes := _subx.womatl_notes;
    _subrow.wodata_ref := _subx.womatl_ref;
    _subrow.wodata_level := _level;
    RETURN NEXT _subrow;
  END LOOP;

  RETURN;
END;
$_$;


ALTER FUNCTION public.indentedwomatl(integer, integer, integer) OWNER TO admin;

--
-- TOC entry 1810 (class 1255 OID 146566394)
-- Dependencies: 4536 8
-- Name: initeffectivextuser(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION initeffectivextuser() RETURNS void
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  -- Effective users use a temporary table to store the user information
  -- and this function, called by the other functions, makes sure the temp
  -- tables exist first.
  PERFORM *
     FROM pg_catalog.pg_class
    WHERE relname = 'effective_user'
      AND relnamespace = pg_catalog.pg_my_temp_schema();

  IF NOT FOUND THEN
    CREATE TEMPORARY TABLE effective_user (
      effective_key TEXT,
      effective_value TEXT
    );
    CREATE UNIQUE INDEX effective_user_pkey ON effective_user (effective_key);
  END IF;
END;
$$;


ALTER FUNCTION public.initeffectivextuser() OWNER TO admin;

--
-- TOC entry 1812 (class 1255 OID 146566395)
-- Dependencies: 4536 8
-- Name: initialdistribution(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION initialdistribution(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pLocationid ALIAS FOR $2;
  _itemlocid INTEGER;
  _invhistid INTEGER;
  _itemlocSeries INTEGER;
  _r RECORD;

BEGIN

--  Make sure the passed itemsite points to a real item
  IF ( (SELECT (item_type IN ('R', 'F') OR itemsite_costmethod = 'J')
         FROM itemsite, item
         WHERE ( (itemsite_item_id=item_id)
          AND (itemsite_id=pItemsiteid) ) ) ) THEN
    RETURN 0;
  END IF;

  _itemlocSeries := NEXTVAL('itemloc_series_seq');

--  Reassign the location_id for all existing itemlocs if
--  the passed itemsite is already lot/serial controlled
  IF ( ( SELECT (itemsite_controlmethod IN ('L', 'S'))
         FROM itemsite
         WHERE (itemsite_id=pItemsiteid) ) ) THEN

    FOR _r IN SELECT itemloc_id, itemloc_ls_id, itemloc_qty
              FROM itemloc
              WHERE (itemloc_itemsite_id=pItemsiteid) LOOP

--  Create the RL transaction
      SELECT NEXTVAL('invhist_invhist_id_seq') INTO _invhistid;
      INSERT INTO invhist
      ( invhist_id, invhist_itemsite_id, invhist_series,
        invhist_transtype, invhist_invqty,
        invhist_qoh_before, invhist_qoh_after,
        invhist_comments,
        invhist_invuom, invhist_unitcost, invhist_hasdetail,
        invhist_costmethod, invhist_value_before, invhist_value_after )
      SELECT _invhistid, itemsite_id, _itemlocSeries,
             'RL', 0,
             _r.itemloc_qty, _r.itemloc_qty,
             'Initial Distribution',
             uom_name, stdCost(item_id), TRUE,
             itemsite_costmethod, itemsite_value, itemsite_value
      FROM item, itemsite, uom
      WHERE ( (itemsite_item_id=item_id)
       AND (item_inv_uom_id=uom_id)
       AND (itemsite_controlmethod <> 'N')
       AND (itemsite_id=pItemsiteid) );

--  Update the itemloc
      UPDATE itemloc
      SET itemloc_location_id=pLocationid
      WHERE (itemloc_id=_r.itemloc_id);

--  Record the detail transaction
      INSERT INTO invdetail
      ( invdetail_invhist_id, invdetail_location_id, invdetail_ls_id,
        invdetail_qty, invdetail_qty_before, invdetail_qty_after )
      VALUES
      ( _invhistid, pLocationid, _r.itemloc_ls_id,
        _r.itemloc_qty, 0, _r.itemloc_qty );

--  Adjust QOH if this itemlocdist is to/from a non-netable location
      IF ( SELECT (NOT location_netable)
           FROM location
           WHERE (location_id=pLocationid) ) THEN

        INSERT INTO invhist
        ( invhist_itemsite_id, invhist_series,
          invhist_transtype, invhist_invqty,
          invhist_qoh_before, invhist_qoh_after,
          invhist_comments,
          invhist_invuom, invhist_unitcost,
          invhist_costmethod, invhist_value_before, invhist_value_after  )
        SELECT itemsite_id, _itemlocSeries,
               'NN', (_r.itemloc_qty * -1),
               _r.itemloc_qty, 0,
               'Initial Distribution',
               uom_name, stdCost(item_id),
               itemsite_costmethod, itemsite_value, itemsite_value
        FROM itemsite, item, uom
        WHERE ( (itemsite_item_id=item_id)
         AND (item_inv_uom_id=uom_id)
         AND (itemsite_controlmethod <> 'N')
         AND (itemsite_id=pItemsiteid) );

        UPDATE itemsite
        SET itemsite_nnqoh = (itemsite_nnqoh + _r.itemloc_qty),
            itemsite_qtyonhand = (itemsite_qtyonhand - _r.itemloc_qty)
        WHERE (itemsite_id=pItemsiteid);

      END IF;

    END LOOP;

  ELSE
--  The passed itemsite is not lot/serial controlled
--  Make sure that there are not any stagnent itemlocs
    DELETE FROM itemloc
    WHERE (itemloc_itemsite_id=pItemsiteid);

--  Create the RL transaction
    SELECT NEXTVAL('invhist_invhist_id_seq') INTO _invhistid;
    INSERT INTO invhist
    ( invhist_id, invhist_itemsite_id, invhist_series,
      invhist_transtype, invhist_invqty,
      invhist_qoh_before, invhist_qoh_after,
      invhist_comments,
      invhist_invuom, invhist_unitcost, invhist_hasdetail,
      invhist_costmethod, invhist_value_before, invhist_value_after  )
    SELECT _invhistid, itemsite_id, _itemlocSeries,
           'RL', 0,
           itemsite_qtyonhand, itemsite_qtyonhand,
           'Initial Distribution',
           uom_name, stdCost(item_id), TRUE,
           itemsite_costmethod, itemsite_value, itemsite_value
    FROM item, itemsite, uom
    WHERE ( (itemsite_item_id=item_id)
     AND (item_inv_uom_id=uom_id)
     AND (itemsite_controlmethod <> 'N')
     AND (itemsite_id=pItemsiteid) );

--  Create the itemloc
    SELECT NEXTVAL('itemloc_itemloc_id_seq') INTO _itemlocid;
    INSERT INTO itemloc
    ( itemloc_id, itemloc_itemsite_id, itemloc_location_id,
      itemloc_expiration, itemloc_qty )
    SELECT _itemlocid, itemsite_id, pLocationid,
           endOfTime(), itemsite_qtyonhand
    FROM itemsite
    WHERE (itemsite_id=pItemsiteid);

--  Record the detail transaction
    INSERT INTO invdetail
    ( invdetail_invhist_id, invdetail_location_id,
      invdetail_qty, invdetail_qty_before, invdetail_qty_after )
    SELECT _invhistid, pLocationid,
           itemsite_qtyonhand, 0, itemsite_qtyonhand
    FROM itemsite
    WHERE (itemsite_id=pItemsiteid);

--  Adjust QOH if this itemlocdist is to/from a non-netable location
    IF ( SELECT (NOT location_netable)
         FROM location
         WHERE (location_id=pLocationid) ) THEN

      INSERT INTO invhist
      ( invhist_itemsite_id, invhist_series,
        invhist_transtype, invhist_invqty,
        invhist_qoh_before, invhist_qoh_after,
        invhist_comments,
        invhist_invuom, invhist_unitcost,
        invhist_costmethod, invhist_value_before, invhist_value_after  )
      SELECT itemsite_id, _itemlocSeries,
             'NN', (itemloc_qty * -1),
             itemloc_qty, 0,
             'Initial Distribution',
             uom_name, stdCost(item_id),
             itemsite_costmethod, itemsite_value, itemsite_value
      FROM itemloc, itemsite, item, uom
      WHERE ( (itemsite_item_id=item_id)
       AND (item_inv_uom_id=uom_id)
       AND (itemsite_controlmethod <> 'N')
       AND (itemloc_itemsite_id=itemsite_id)
       AND (itemloc_id=_itemlocid) );

      UPDATE itemsite
      SET itemsite_nnqoh = itemsite_qtyonhand,
          itemsite_qtyonhand = 0
      FROM itemloc
      WHERE ( (itemloc_itemsite_id=itemsite_id)
       AND (itemloc_id=_itemlocid) );

    END IF;

  END IF;

  RETURN _itemlocid;

END;
$_$;


ALTER FUNCTION public.initialdistribution(integer, integer) OWNER TO admin;

--
-- TOC entry 207 (class 1259 OID 146566396)
-- Dependencies: 5956 5957 5958 5959 5960 5961 5962 5963 5964 8
-- Name: apopen; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE apopen (
    apopen_id integer DEFAULT nextval(('"apopen_apopen_id_seq"'::text)::regclass) NOT NULL,
    apopen_docdate date,
    apopen_duedate date,
    apopen_terms_id integer,
    apopen_vend_id integer,
    apopen_doctype character(1),
    apopen_docnumber text,
    apopen_amount numeric(20,2),
    apopen_notes text,
    apopen_posted boolean,
    apopen_reference text,
    apopen_invcnumber text,
    apopen_ponumber text,
    apopen_journalnumber integer,
    apopen_paid numeric(20,2) DEFAULT 0,
    apopen_open boolean,
    apopen_username text,
    apopen_discount boolean DEFAULT false NOT NULL,
    apopen_accnt_id integer DEFAULT (-1),
    apopen_curr_id integer DEFAULT basecurrid(),
    apopen_closedate date,
    apopen_distdate date,
    apopen_void boolean DEFAULT false NOT NULL,
    apopen_curr_rate numeric NOT NULL,
    apopen_discountable_amount numeric(20,2) DEFAULT 0,
    apopen_status text,
    CONSTRAINT apopen_apopen_status_check CHECK ((((apopen_status = 'O'::text) OR (apopen_status = 'H'::text)) OR (apopen_status = 'C'::text))),
    CONSTRAINT apopen_apopen_status_notnull CHECK ((apopen_status IS NOT NULL))
);


ALTER TABLE public.apopen OWNER TO admin;


--
-- TOC entry 208 (class 1259 OID 146566411)
-- Dependencies: 5966 8
-- Name: curr_symbol; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE curr_symbol (
    curr_id integer NOT NULL,
    curr_base boolean DEFAULT false NOT NULL,
    curr_name character varying(50) NOT NULL,
    curr_symbol character varying(9) NOT NULL,
    curr_abbr character varying(3) NOT NULL
);


ALTER TABLE public.curr_symbol OWNER TO admin;

--
-- TOC entry 8983 (class 0 OID 0)
-- Dependencies: 208
-- Name: TABLE curr_symbol; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE curr_symbol IS 'Currency Names, Symbols, and Abbreviations';


--
-- TOC entry 209 (class 1259 OID 146566415)
-- Dependencies: 5967 5968 5969 8
-- Name: terms; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE terms (
    terms_id integer DEFAULT nextval(('terms_terms_id_seq'::text)::regclass) NOT NULL,
    terms_code text NOT NULL,
    terms_descrip text,
    terms_type character(1),
    terms_duedays integer,
    terms_discdays integer,
    terms_discprcnt numeric(10,6),
    terms_cutoffday integer,
    terms_ap boolean,
    terms_ar boolean,
    terms_fincharg boolean DEFAULT true NOT NULL,
    CONSTRAINT terms_terms_code_check CHECK ((terms_code <> ''::text))
);


ALTER TABLE public.terms OWNER TO admin;

--
-- TOC entry 8985 (class 0 OID 0)
-- Dependencies: 209
-- Name: TABLE terms; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE terms IS 'Billing Terms information';


--
-- TOC entry 210 (class 1259 OID 146566424)
-- Dependencies: 5970 5971 5972 5973 5974 5975 5976 5977 5978 5979 5980 5981 5982 5983 8
-- Name: vendinfo; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE vendinfo (
    vend_id integer DEFAULT nextval(('vend_vend_id_seq'::text)::regclass) NOT NULL,
    vend_name text,
    vend_lastpurchdate date,
    vend_active boolean,
    vend_po boolean,
    vend_comments text,
    vend_pocomments text,
    vend_number text NOT NULL,
    vend_1099 boolean,
    vend_exported boolean,
    vend_fobsource character(1),
    vend_fob text,
    vend_terms_id integer,
    vend_shipvia text,
    vend_vendtype_id integer,
    vend_qualified boolean,
    vend_ediemail text,
    vend_ediemailbody text,
    vend_edisubject text,
    vend_edifilename text,
    vend_accntnum text,
    vend_emailpodelivery boolean,
    vend_restrictpurch boolean,
    vend_edicc text,
    vend_curr_id integer DEFAULT basecurrid(),
    vend_cntct1_id integer,
    vend_cntct2_id integer,
    vend_addr_id integer,
    vend_match boolean DEFAULT false NOT NULL,
    vend_ach_enabled boolean DEFAULT false NOT NULL,
    vend_ach_accnttype text,
    vend_ach_use_vendinfo boolean DEFAULT true NOT NULL,
    vend_ach_indiv_number text DEFAULT ''::text NOT NULL,
    vend_ach_indiv_name text DEFAULT ''::text NOT NULL,
    vend_ediemailhtml boolean DEFAULT false NOT NULL,
    vend_ach_routingnumber bytea DEFAULT '\x00'::bytea NOT NULL,
    vend_ach_accntnumber bytea DEFAULT '\x00'::bytea NOT NULL,
    vend_taxzone_id integer,
    vend_accnt_id integer,
    vend_expcat_id integer DEFAULT (-1),
    vend_tax_id integer DEFAULT (-1),
    CONSTRAINT vendinfo_vend_ach_accnttype_check CHECK (((vend_ach_accnttype = 'K'::text) OR (vend_ach_accnttype = 'C'::text))),
    CONSTRAINT vendinfo_vend_number_check CHECK ((vend_number <> ''::text))
);


ALTER TABLE public.vendinfo OWNER TO admin;


SET search_path = api, pg_catalog;

--
-- TOC entry 211 (class 1259 OID 146566444)
-- Dependencies: 8471 6
-- Name: apmemo; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW apmemo AS
    SELECT vendinfo.vend_number AS vendor_number, apopen.apopen_docdate AS document_date, apopen.apopen_duedate AS due_date, CASE WHEN (apopen.apopen_doctype = 'C'::bpchar) THEN 'Credit Memo'::text ELSE 'Debit Memo'::text END AS document_type, apopen.apopen_docnumber AS document_number, apopen.apopen_ponumber AS po_number, apopen.apopen_journalnumber AS journal_number, terms.terms_code AS terms, curr.curr_abbr AS currency, apopen.apopen_amount AS amount, apopen.apopen_paid AS paid, (apopen.apopen_amount - apopen.apopen_paid) AS balance, apopen.apopen_notes AS notes, CASE WHEN (apopen.apopen_accnt_id = (-1)) THEN NULL::text ELSE public.formatglaccount(apopen.apopen_accnt_id) END AS alternate_prepaid_account FROM (((public.apopen LEFT JOIN public.vendinfo ON ((vendinfo.vend_id = apopen.apopen_vend_id))) LEFT JOIN public.curr_symbol curr ON ((curr.curr_id = apopen.apopen_curr_id))) LEFT JOIN public.terms ON ((terms.terms_id = apopen.apopen_terms_id))) WHERE (apopen.apopen_doctype = ANY (ARRAY['C'::bpchar, 'D'::bpchar]));


ALTER TABLE api.apmemo OWNER TO admin;

--
-- TOC entry 8990 (class 0 OID 0)
-- Dependencies: 211
-- Name: VIEW apmemo; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW apmemo IS 'A/P Credit and Debit Memo';


SET search_path = public, pg_catalog;

--
-- TOC entry 1813 (class 1255 OID 146566449)
-- Dependencies: 2804 4536 8
-- Name: insertapmemo(api.apmemo); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION insertapmemo(api.apmemo) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pNew ALIAS FOR $1;
  _result INTEGER;

BEGIN
  IF (pNew.document_type = 'Credit Memo') THEN
    SELECT createAPCreditMemo( getVendId(pNew.vendor_number),
                               pNew.document_number,
                               pNew.po_number,
                               pNew.document_date,
                               pNew.amount,
                               pNew.notes,
                               getGLAccntId(pNew.alternate_prepaid_account),
                               pNew.due_date,
                               getTermsId(pNew.terms) ) INTO _result;
    IF (_result <= 0) THEN
      RAISE EXCEPTION 'Function createAPCreditMemo failed with result = %', _result;
    END IF;
  ELSE
    IF (pNew.document_type = 'Debit Memo') THEN
      SELECT createAPDebitMemo( null, getVendId(pNew.vendor_number),
                                pNew.journal_number,
                                pNew.document_number,
                                pNew.po_number,
                                pNew.document_date,
                                pNew.amount,
                                pNew.notes,
                                getGLAccntId(pNew.alternate_prepaid_account),
                                pNew.due_date,
                                getTermsId(pNew.terms),
                                COALESCE(getCurrId(pNew.currency), baseCurrId()) ) INTO _result;
      IF (_result <= 0) THEN
        RAISE EXCEPTION 'Function createAPDebitMemo failed with result = %', _result;
      END IF;
    ELSE
      RAISE EXCEPTION 'Function insertAPMemo failed, invalid Document Type';
    END IF;
  END IF;

  RETURN TRUE;
END;
$_$;


ALTER FUNCTION public.insertapmemo(api.apmemo) OWNER TO admin;


--
-- TOC entry 212 (class 1259 OID 146566450)
-- Dependencies: 5984 5985 5986 5987 5988 5989 5990 5991 5992 8
-- Name: aropen; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE aropen (
    aropen_id integer DEFAULT nextval(('"aropen_aropen_id_seq"'::text)::regclass) NOT NULL,
    aropen_docdate date NOT NULL,
    aropen_duedate date NOT NULL,
    aropen_terms_id integer,
    aropen_cust_id integer,
    aropen_doctype character(1),
    aropen_docnumber text,
    aropen_applyto text,
    aropen_ponumber text,
    aropen_amount numeric(20,2) NOT NULL,
    aropen_notes text,
    aropen_posted boolean DEFAULT false NOT NULL,
    aropen_salesrep_id integer,
    aropen_commission_due numeric(20,2),
    aropen_commission_paid boolean DEFAULT false,
    aropen_ordernumber text,
    aropen_cobmisc_id integer DEFAULT (-1),
    aropen_journalnumber integer,
    aropen_paid numeric(20,2) DEFAULT 0,
    aropen_open boolean,
    aropen_username text,
    aropen_rsncode_id integer,
    aropen_salescat_id integer DEFAULT (-1),
    aropen_accnt_id integer DEFAULT (-1),
    aropen_curr_id integer DEFAULT basecurrid(),
    aropen_closedate date,
    aropen_distdate date,
    aropen_curr_rate numeric NOT NULL,
    aropen_discount boolean DEFAULT false NOT NULL,
    aropen_fincharg_date date,
    aropen_fincharg_amount numeric(20,2)
);


ALTER TABLE public.aropen OWNER TO admin;


-- TOC entry 213 (class 1259 OID 146566465)
-- Dependencies: 5993 5994 5995 5996 5997 5998 5999 6000 6001 6002 6003 6004 6005 8
-- Name: custinfo; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE custinfo (
    cust_id integer DEFAULT nextval(('cust_cust_id_seq'::text)::regclass) NOT NULL,
    cust_active boolean NOT NULL,
    cust_custtype_id integer,
    cust_salesrep_id integer,
    cust_commprcnt numeric(10,6),
    cust_name text,
    cust_creditlmt integer,
    cust_creditrating text,
    cust_financecharge boolean,
    cust_backorder boolean NOT NULL,
    cust_partialship boolean NOT NULL,
    cust_terms_id integer,
    cust_discntprcnt numeric(10,6) NOT NULL,
    cust_balmethod character(1) NOT NULL,
    cust_ffshipto boolean NOT NULL,
    cust_shipform_id integer,
    cust_shipvia text,
    cust_blanketpos boolean NOT NULL,
    cust_shipchrg_id integer NOT NULL,
    cust_creditstatus character(1) NOT NULL,
    cust_comments text,
    cust_ffbillto boolean NOT NULL,
    cust_usespos boolean NOT NULL,
    cust_number text NOT NULL,
    cust_dateadded date DEFAULT ('now'::text)::date,
    cust_exported boolean DEFAULT false,
    cust_emaildelivery boolean DEFAULT false,
    cust_ediemail text,
    cust_edisubject text,
    cust_edifilename text,
    cust_ediemailbody text,
    cust_autoupdatestatus boolean NOT NULL,
    cust_autoholdorders boolean NOT NULL,
    cust_edicc text,
    cust_ediprofile_id integer,
    cust_preferred_warehous_id integer DEFAULT (-1) NOT NULL,
    cust_curr_id integer DEFAULT basecurrid(),
    cust_creditlmt_curr_id integer DEFAULT basecurrid(),
    cust_cntct_id integer,
    cust_corrcntct_id integer,
    cust_soemaildelivery boolean DEFAULT false,
    cust_soediemail text,
    cust_soedisubject text,
    cust_soedifilename text,
    cust_soediemailbody text,
    cust_soedicc text,
    cust_soediprofile_id integer,
    cust_gracedays integer,
    cust_ediemailhtml boolean DEFAULT false NOT NULL,
    cust_soediemailhtml boolean DEFAULT false NOT NULL,
    cust_taxzone_id integer,
    cust_statementcycle text,
    CONSTRAINT custinfo_balmethod_check CHECK (((cust_balmethod = 'B'::bpchar) OR (cust_balmethod = 'O'::bpchar))),
    CONSTRAINT custinfo_creditstatus_check CHECK ((((cust_creditstatus = 'G'::bpchar) OR (cust_creditstatus = 'W'::bpchar)) OR (cust_creditstatus = 'H'::bpchar))),
    CONSTRAINT custinfo_cust_number_check CHECK ((cust_number <> ''::text))
);


ALTER TABLE public.custinfo OWNER TO admin;


--
-- TOC entry 214 (class 1259 OID 146566484)
-- Dependencies: 6007 8
-- Name: rsncode; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE rsncode (
    rsncode_id integer NOT NULL,
    rsncode_code text NOT NULL,
    rsncode_descrip text,
    rsncode_doctype text,
    CONSTRAINT rsncode_rsncode_code_check CHECK ((rsncode_code <> ''::text))
);


ALTER TABLE public.rsncode OWNER TO admin;

--
-- TOC entry 9010 (class 0 OID 0)
-- Dependencies: 214
-- Name: TABLE rsncode; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE rsncode IS 'Debit/Credit Memo Reason Code information';


--
-- TOC entry 215 (class 1259 OID 146566491)
-- Dependencies: 6009 8
-- Name: salescat; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE salescat (
    salescat_id integer NOT NULL,
    salescat_active boolean,
    salescat_name text NOT NULL,
    salescat_descrip text,
    salescat_sales_accnt_id integer,
    salescat_prepaid_accnt_id integer,
    salescat_ar_accnt_id integer,
    CONSTRAINT salescat_salescat_name_check CHECK ((salescat_name <> ''::text))
);


ALTER TABLE public.salescat OWNER TO admin;

--
-- TOC entry 9012 (class 0 OID 0)
-- Dependencies: 215
-- Name: TABLE salescat; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE salescat IS 'Sales Category information';


--
-- TOC entry 216 (class 1259 OID 146566498)
-- Dependencies: 6010 6011 8
-- Name: salesrep; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE salesrep (
    salesrep_id integer DEFAULT nextval(('salesrep_salesrep_id_seq'::text)::regclass) NOT NULL,
    salesrep_active boolean,
    salesrep_number text NOT NULL,
    salesrep_name text,
    salesrep_commission numeric(8,4),
    salesrep_method character(1),
    salesrep_emp_id integer,
    CONSTRAINT salesrep_salesrep_number_check CHECK ((salesrep_number <> ''::text))
);


ALTER TABLE public.salesrep OWNER TO admin;


SET search_path = api, pg_catalog;

--
-- TOC entry 217 (class 1259 OID 146566506)
-- Dependencies: 8472 6
-- Name: armemo; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW armemo AS
    SELECT custinfo.cust_number AS customer_number, aropen.aropen_docdate AS document_date, aropen.aropen_duedate AS due_date, CASE WHEN (aropen.aropen_doctype = 'C'::bpchar) THEN 'Credit Memo'::text ELSE 'Debit Memo'::text END AS document_type, aropen.aropen_docnumber AS document_number, aropen.aropen_applyto AS order_number, aropen.aropen_journalnumber AS journal_number, rsncode.rsncode_code AS reason_code, terms.terms_code AS terms, salesrep.salesrep_number AS sales_rep, curr.curr_abbr AS currency, aropen.aropen_amount AS amount, aropen.aropen_paid AS paid, (aropen.aropen_amount - aropen.aropen_paid) AS balance, aropen.aropen_commission_due AS commission_due, aropen.aropen_commission_paid AS commission_paid, aropen.aropen_notes AS notes, salescat.salescat_name AS alternate_prepaid_sales_category, CASE WHEN (aropen.aropen_accnt_id = (-1)) THEN NULL::text ELSE public.formatglaccount(aropen.aropen_accnt_id) END AS alternate_prepaid_account FROM ((((((public.aropen LEFT JOIN public.custinfo ON ((custinfo.cust_id = aropen.aropen_cust_id))) LEFT JOIN public.curr_symbol curr ON ((curr.curr_id = aropen.aropen_curr_id))) LEFT JOIN public.salesrep ON ((salesrep.salesrep_id = aropen.aropen_salesrep_id))) LEFT JOIN public.terms ON ((terms.terms_id = aropen.aropen_terms_id))) LEFT JOIN public.salescat ON ((salescat.salescat_id = aropen.aropen_salescat_id))) LEFT JOIN public.rsncode ON ((rsncode.rsncode_id = aropen.aropen_rsncode_id))) WHERE (aropen.aropen_doctype = ANY (ARRAY['C'::bpchar, 'D'::bpchar]));


ALTER TABLE api.armemo OWNER TO admin;

--
-- TOC entry 9017 (class 0 OID 0)
-- Dependencies: 217
-- Name: VIEW armemo; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW armemo IS 'A/R Credit and Debit Memo';


SET search_path = public, pg_catalog;

--
-- TOC entry 1814 (class 1255 OID 146566511)
-- Dependencies: 2827 4536 8
-- Name: insertarmemo(api.armemo); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION insertarmemo(api.armemo) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pNew ALIAS FOR $1;
  _result INTEGER;

BEGIN
  IF (pNew.document_type = 'Credit Memo') THEN
    SELECT createARCreditMemo( NULL,
                               getCustId(pNew.customer_number),
                               pNew.document_number,
                               pNew.order_number,
                               pNew.document_date,
                               pNew.amount,
                               pNew.notes,
                               getRsnId(pNew.reason_code),
                               getSalescatId(pNew.alternate_prepaid_sales_category),
                               getGLAccntId(pNew.alternate_prepaid_account),
                               pNew.due_date,
                               getTermsId(pNew.terms),
                               getSalesrepId(pNew.sales_rep),
                               pNew.commission_due,
                               pNew.journal_number,
                               COALESCE(getCurrId(pNew.currency), baseCurrId()) ) INTO _result;
    IF (_result <= 0) THEN
      RAISE EXCEPTION 'Function createARCreditMemo failed with result = %', _result;
    END IF;
  ELSE
    IF (pNew.document_type = 'Debit Memo') THEN
      SELECT createARDebitMemo( null, getCustId(pNew.customer_number),
                                pNew.journal_number,
                                pNew.document_number,
                                pNew.order_number,
                                pNew.document_date,
                                pNew.amount,
                                pNew.notes,
                                getRsnId(pNew.reason_code),
                                getSalescatId(pNew.alternate_prepaid_sales_category),
                                getGLAccntId(pNew.alternate_prepaid_account),
                                pNew.due_date,
                                getTermsId(pNew.terms),
                                getSalesrepId(pNew.sales_rep),
                                pNew.commission_due,
                                COALESCE(getCurrId(pNew.currency), baseCurrId()) ) INTO _result;
      IF (_result <= 0) THEN
        RAISE EXCEPTION 'Function createARDebitMemo failed with result = %', _result;
      END IF;
    ELSE
      RAISE EXCEPTION 'Function insertARMemo failed, invalid Document Type';
    END IF;
  END IF;

  RETURN TRUE;
END;
$_$;


ALTER FUNCTION public.insertarmemo(api.armemo) OWNER TO admin;

--
-- TOC entry 1815 (class 1255 OID 146566512)
-- Dependencies: 4536 8
-- Name: insertccard(text, boolean, text, bytea, bytea, bytea, bytea, bytea, bytea, bytea, bytea, bytea, bytea, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION insertccard(text, boolean, text, bytea, bytea, bytea, bytea, bytea, bytea, bytea, bytea, bytea, bytea, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCustomer ALIAS FOR $1;
  pActive ALIAS FOR $2;
  pType ALIAS FOR $3;
  pNumber ALIAS FOR $4;
  pName ALIAS FOR $5;
  pAddr1 ALIAS FOR $6;
  pAddr2 ALIAS FOR $7;
  pCity ALIAS FOR $8;
  pState ALIAS FOR $9;
  pPostal ALIAS FOR $10;
  pCountry ALIAS FOR $11;
  pMonth ALIAS FOR $12;
  pYear ALIAS FOR $13;
  pKey ALIAS FOR $14;
  _type CHAR;
  _number TEXT;
  _month INTEGER;
  _year INTEGER;
  _result INTEGER;

BEGIN
  --Initialize
  _number = CAST(encode(pNumber, 'escape') AS text);
  _month = CAST(encode(pMonth, 'escape') AS integer);
  _year = CAST(encode(pYear, 'escape') AS integer);

  -- Check Card holder info
  IF (pName IS NULL) THEN
      RAISE EXCEPTION 'The name of the card holder must be entered';
  END IF;
  IF (pAddr1 IS NULL OR pAddr1 = '') THEN
      RAISE EXCEPTION 'The first address line must be entered';
  END IF;
  IF (pCity IS NULL OR pCity = '') THEN
      RAISE EXCEPTION 'The city must be entered';
  END IF;
  IF (pState IS NULL OR pState = '') THEN
      RAISE EXCEPTION 'The state must be entered';
  END IF;
  IF (pPostal IS NULL OR pPostal = '') THEN
      RAISE EXCEPTION 'The zip code must be entered';
  END IF;
  IF (pCountry IS NULL OR pCountry = '') THEN
      RAISE EXCEPTION 'The country must be entered';
  END IF;
  IF (pMonth IS NULL OR pMonth = '') THEN
      RAISE EXCEPTION 'The Expiration Month must be entered';
  END IF;
  IF (_month < 1 OR _month > 12) THEN
      RAISE EXCEPTION 'Valid Expiration Months are 01 through 12';
  END IF;
  IF (LENGTH(_year::text) <> 4) THEN
      RAISE EXCEPTION 'Valid Expiration Years are CCYY in format';
  END IF;
  IF (_year < 1970 OR _year > 2100) THEN
      RAISE EXCEPTION 'Valid Expiration Years are 1970 through 2100';
  END IF;

  -- Check Number Length
  IF ((NOT _number ~  '[0-9]{13,16}') OR (LENGTH(_number) = 14) OR (LENGTH(_number) > 16)) THEN
    RAISE EXCEPTION 'The credit card number must be all numeric (no spaces or hyphens) and must be 13, 15 or 16 characters in length';
  END IF;

  -- Convert Type
  IF (pType = 'Visa') THEN
    _type  = 'V';
  ELSE
    IF (pType = 'Master Card') THEN
      _type  = 'M';
    ELSE
      IF (pType = 'American Express') THEN
        _type  = 'A';
      ELSE
        IF (pType = 'Discover') THEN
          _type  = 'D';
        ELSE
          RAISE EXCEPTION 'You must select Master Card, Visa, American
                            Express or Discover as the credit card type.';
        END IF;
      END IF;
    END IF;
  END IF;

  -- Check Card Specific Data
  SELECT editccnumber(_number, _type) INTO _result;

  IF (_result = -1) THEN
    RAISE EXCEPTION 'You must select Master Card, Visa, American
                      Express or Discover as the credit card type.';
  END IF;
  IF (_result = -2) THEN
    RAISE EXCEPTION 'The length of a Master Card credit card number
                      has to be 16 digits.';
  END IF;
  IF (_result = -3) THEN
    RAISE EXCEPTION 'The length of a Visa credit card number
                      has to be either 13 or 16 digits.';
  END IF;
  IF (_result = -4) THEN
    RAISE EXCEPTION 'The length of an American Express credit card
                      number has to be 15 digits.';
  END IF;
  IF (_result = -5) THEN
    RAISE EXCEPTION 'The length of a Discover credit card number
                      has to be 16 digits.';
  END IF;
   IF (_result = -6) THEN
    RAISE EXCEPTION 'The first two digits for a valid Master Card
                      number must be between 51 and 55';
  END IF;
  IF (_result = -7) THEN
    RAISE EXCEPTION 'The first digit for a valid Visa number must
                      be 4';
  END IF;
   IF (_result = -8) THEN
    RAISE EXCEPTION 'The first two digits for a valid American
                      Express number must be 34 or 37.';
  END IF;
  IF (_result = -9) THEN
    RAISE EXCEPTION 'The first four digits for a valid Discover
                      Express number must be 6011.';
  END IF;
  IF ((_result = -10) AND NOT fetchmetricbool('CCTest')) THEN
    RAISE EXCEPTION 'The credit card number that you have provided
                      is not valid.';
  END IF;
  IF (_result < -10) THEN
    RAISE EXCEPTION 'Invalid Credit Card Information';
  END IF;

  -- Insert Record

  INSERT INTO ccard (
    ccard_seq,
    ccard_cust_id,
    ccard_active,
    ccard_name,
    ccard_address1,
    ccard_address2,
    ccard_city,
    ccard_state,
    ccard_zip,
    ccard_country,
    ccard_number,
    ccard_month_expired,
    ccard_year_expired,
    ccard_type)
    VALUES
    ((SELECT COALESCE(MAX(ccard_seq), 0) + 10
      FROM ccard
      WHERE (ccard_cust_id =getCustId(pCustomer))),
     getCustId(pCustomer),
     COALESCE(pActive),
     encrypt(setbytea(pName), setbytea(pKey), 'bf'),
     encrypt(setbytea(pAddr1), setbytea(pKey), 'bf'),
     encrypt(setbytea(pAddr2), setbytea(pKey), 'bf'),
     encrypt(setbytea(pCity), setbytea(pKey), 'bf'),
     encrypt(setbytea(pState), setbytea(pKey), 'bf'),
     encrypt(setbytea(pPostal), setbytea(pKey), 'bf'),
     encrypt(setbytea(pCountry), setbytea(pKey), 'bf'),
     encrypt(setbytea(pNumber), setbytea(pKey), 'bf'),
     encrypt(setbytea(pMonth), setbytea(pKey), 'bf'),
     encrypt(setbytea(pYear), setbytea(pKey), 'bf'),
     _type );

  RETURN true;
END;
$_$;


ALTER FUNCTION public.insertccard(text, boolean, text, bytea, bytea, bytea, bytea, bytea, bytea, bytea, bytea, bytea, bytea, text) OWNER TO admin;

--
-- TOC entry 9019 (class 0 OID 0)
-- Dependencies: 1815
-- Name: FUNCTION insertccard(text, boolean, text, bytea, bytea, bytea, bytea, bytea, bytea, bytea, bytea, bytea, bytea, text); Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON FUNCTION insertccard(text, boolean, text, bytea, bytea, bytea, bytea, bytea, bytea, bytea, bytea, bytea, bytea, text) IS 'This function is generally used to support the _custcreditcard API view';


--
-- TOC entry 218 (class 1259 OID 146566514)
-- Dependencies: 6012 6013 6014 6015 8
-- Name: cmhead; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE cmhead (
    cmhead_id integer DEFAULT nextval(('cmhead_cmhead_id_seq'::text)::regclass) NOT NULL,
    cmhead_number text NOT NULL,
    cmhead_posted boolean,
    cmhead_invcnumber text,
    cmhead_custponumber text,
    cmhead_cust_id integer,
    cmhead_docdate date,
    cmhead_shipto_id integer,
    cmhead_shipto_name text,
    cmhead_shipto_address1 text,
    cmhead_shipto_address2 text,
    cmhead_shipto_address3 text,
    cmhead_shipto_city text,
    cmhead_shipto_state text,
    cmhead_shipto_zipcode text,
    cmhead_salesrep_id integer,
    cmhead_freight numeric(16,4),
    cmhead_misc numeric(16,4),
    cmhead_comments text,
    cmhead_printed boolean,
    cmhead_billtoname text,
    cmhead_billtoaddress1 text,
    cmhead_billtoaddress2 text,
    cmhead_billtoaddress3 text,
    cmhead_billtocity text,
    cmhead_billtostate text,
    cmhead_billtozip text,
    cmhead_hold boolean,
    cmhead_commission numeric(8,4),
    cmhead_misc_accnt_id integer,
    cmhead_misc_descrip text,
    cmhead_rsncode_id integer,
    cmhead_curr_id integer DEFAULT basecurrid(),
    cmhead_freighttaxtype_id integer,
    cmhead_gldistdate date,
    cmhead_billtocountry text,
    cmhead_shipto_country text,
    cmhead_rahead_id integer,
    cmhead_taxzone_id integer,
    cmhead_prj_id integer,
    cmhead_void boolean DEFAULT false,
    cmhead_saletype_id integer,
    cmhead_shipzone_id integer,
    CONSTRAINT cmhead_cmhead_number_check CHECK ((cmhead_number <> ''::text))
);


ALTER TABLE public.cmhead OWNER TO admin;

--
-- TOC entry 9020 (class 0 OID 0)
-- Dependencies: 218
-- Name: TABLE cmhead; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE cmhead IS 'S/O Credit Memo header information';


--
-- TOC entry 9021 (class 0 OID 0)
-- Dependencies: 218
-- Name: COLUMN cmhead.cmhead_freighttaxtype_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN cmhead.cmhead_freighttaxtype_id IS 'Deprecated column - DO NOT USE';


--
-- TOC entry 9022 (class 0 OID 0)
-- Dependencies: 218
-- Name: COLUMN cmhead.cmhead_saletype_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN cmhead.cmhead_saletype_id IS 'Associated sale type for credit memo.';


--
-- TOC entry 9023 (class 0 OID 0)
-- Dependencies: 218
-- Name: COLUMN cmhead.cmhead_shipzone_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN cmhead.cmhead_shipzone_id IS 'Associated shipping zone for credit memo.';


--
-- TOC entry 219 (class 1259 OID 146566524)
-- Dependencies: 6016 6017 8
-- Name: shiptoinfo; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE shiptoinfo (
    shipto_id integer DEFAULT nextval(('shipto_shipto_id_seq'::text)::regclass) NOT NULL,
    shipto_cust_id integer NOT NULL,
    shipto_name text,
    shipto_salesrep_id integer,
    shipto_comments text,
    shipto_shipcomments text,
    shipto_shipzone_id integer,
    shipto_shipvia text,
    shipto_commission numeric(10,4) NOT NULL,
    shipto_shipform_id integer,
    shipto_shipchrg_id integer,
    shipto_active boolean NOT NULL,
    shipto_default boolean,
    shipto_num text,
    shipto_ediprofile_id integer,
    shipto_cntct_id integer,
    shipto_addr_id integer,
    shipto_taxzone_id integer,
    shipto_preferred_warehous_id integer DEFAULT (-1) NOT NULL
);


ALTER TABLE public.shiptoinfo OWNER TO admin;


--
-- TOC entry 220 (class 1259 OID 146566532)
-- Dependencies: 6019 8
-- Name: taxzone; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE taxzone (
    taxzone_id integer NOT NULL,
    taxzone_code text NOT NULL,
    taxzone_descrip text,
    CONSTRAINT taxzone_taxzone_code_check CHECK ((taxzone_code <> ''::text))
);


ALTER TABLE public.taxzone OWNER TO admin;

--
-- TOC entry 9028 (class 0 OID 0)
-- Dependencies: 220
-- Name: TABLE taxzone; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE taxzone IS 'Tax zone information';


--
-- TOC entry 9029 (class 0 OID 0)
-- Dependencies: 220
-- Name: COLUMN taxzone.taxzone_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN taxzone.taxzone_id IS 'Primary key';


--
-- TOC entry 9030 (class 0 OID 0)
-- Dependencies: 220
-- Name: COLUMN taxzone.taxzone_code; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN taxzone.taxzone_code IS 'Code';


--
-- TOC entry 9031 (class 0 OID 0)
-- Dependencies: 220
-- Name: COLUMN taxzone.taxzone_descrip; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN taxzone.taxzone_descrip IS 'Description';


SET search_path = api, pg_catalog;

--
-- TOC entry 221 (class 1259 OID 146566539)
-- Dependencies: 8473 6
-- Name: creditmemo; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW creditmemo AS
    SELECT cmhead.cmhead_number AS memo_number, CASE WHEN (cmhead.cmhead_invcnumber = '-1'::text) THEN ''::text ELSE cmhead.cmhead_invcnumber END AS apply_to, cmhead.cmhead_docdate AS memo_date, CASE WHEN cmhead.cmhead_posted THEN 'Posted'::text ELSE 'Unposted'::text END AS status, salesrep.salesrep_number AS sales_rep, cmhead.cmhead_commission AS commission, COALESCE(taxzone.taxzone_code, 'None'::text) AS tax_zone, COALESCE(rsncode.rsncode_code, 'None'::text) AS reason_code, cmhead.cmhead_hold AS on_hold, custinfo.cust_number AS customer_number, cmhead.cmhead_billtoname AS billto_name, cmhead.cmhead_billtoaddress1 AS billto_address1, cmhead.cmhead_billtoaddress2 AS billto_address2, cmhead.cmhead_billtoaddress3 AS billto_address3, cmhead.cmhead_billtocity AS billto_city, cmhead.cmhead_billtostate AS billto_state, cmhead.cmhead_billtozip AS billto_postal_code, cmhead.cmhead_billtocountry AS billto_country, shiptoinfo.shipto_num AS shipto_number, cmhead.cmhead_shipto_name AS shipto_name, cmhead.cmhead_shipto_address1 AS shipto_address1, cmhead.cmhead_shipto_address2 AS shipto_address2, cmhead.cmhead_shipto_address3 AS shipto_address3, cmhead.cmhead_shipto_city AS shipto_city, cmhead.cmhead_shipto_state AS shipto_state, cmhead.cmhead_shipto_zipcode AS shipto_postal_code, cmhead.cmhead_shipto_country AS shipto_country, cmhead.cmhead_custponumber AS customer_po_number, cmhead.cmhead_comments AS notes, curr.curr_abbr AS currency, cmhead.cmhead_misc_descrip AS misc_charge_description, cmhead.cmhead_misc AS misc_charge_amount, CASE WHEN (cmhead.cmhead_misc_accnt_id = (-1)) THEN ''::text ELSE public.formatglaccount(cmhead.cmhead_misc_accnt_id) END AS misc_charge_credit_account, cmhead.cmhead_freight AS freight FROM ((((((public.cmhead LEFT JOIN public.custinfo ON ((custinfo.cust_id = cmhead.cmhead_cust_id))) LEFT JOIN public.shiptoinfo ON ((shiptoinfo.shipto_id = cmhead.cmhead_shipto_id))) LEFT JOIN public.curr_symbol curr ON ((curr.curr_id = cmhead.cmhead_curr_id))) LEFT JOIN public.salesrep ON ((salesrep.salesrep_id = cmhead.cmhead_salesrep_id))) LEFT JOIN public.taxzone ON ((taxzone.taxzone_id = cmhead.cmhead_taxzone_id))) LEFT JOIN public.rsncode ON ((rsncode.rsncode_id = cmhead.cmhead_rsncode_id)));


ALTER TABLE api.creditmemo OWNER TO admin;

--
-- TOC entry 9033 (class 0 OID 0)
-- Dependencies: 221
-- Name: VIEW creditmemo; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW creditmemo IS 'Credit Memo Header';


SET search_path = public, pg_catalog;

--
-- TOC entry 1816 (class 1255 OID 146566544)
-- Dependencies: 2842 4536 8
-- Name: insertcreditmemo(api.creditmemo); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION insertcreditmemo(api.creditmemo) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
	pNew ALIAS FOR $1;
BEGIN
	-- NOTE: (SELECT getCustId(...)) seems redundant, but it actually produces
	-- a HUGE performance increase because it makes the Postgres query planner
	-- use an index scan rather than an sequential table scan on cust_id
  INSERT INTO cmhead (
		cmhead_number,
		cmhead_posted,
		cmhead_invcnumber,
                cmhead_custponumber,
		cmhead_cust_id,
		cmhead_docdate,
		cmhead_shipto_id,
		cmhead_shipto_name,
		cmhead_shipto_address1,
		cmhead_shipto_address2,
		cmhead_shipto_address3,
		cmhead_shipto_city,
		cmhead_shipto_state,
		cmhead_shipto_zipcode,
		cmhead_shipto_country,
		cmhead_salesrep_id,
		cmhead_freight,
		cmhead_misc,
		cmhead_comments,
		cmhead_printed,
		cmhead_billtoname,
		cmhead_billtoaddress1,
		cmhead_billtoaddress2,
		cmhead_billtoaddress3,
		cmhead_billtocity,
		cmhead_billtostate,
		cmhead_billtozip,
		cmhead_billtocountry,
		cmhead_hold,
		cmhead_commission,
		cmhead_misc_accnt_id,
		cmhead_misc_descrip,
		cmhead_rsncode_id,
		cmhead_curr_id,
		cmhead_taxzone_id,
                cmhead_gldistdate,
                cmhead_rahead_id
		)
	 SELECT
		(CASE -- use a case here so we don't unnecessarily fetch a new CM number
			WHEN pNew.memo_number IS NULL THEN fetchCMNumber()
			ELSE pNew.memo_number
		END),
		FALSE, -- posted
		pNew.apply_to,
		pNew.customer_po_number,
		cust_id,
		COALESCE(pNew.memo_date, CURRENT_DATE),
		COALESCE(shipto_id,-1),
		pNew.shipto_name,
		pNew.shipto_address1,
		pNew.shipto_address2,
		pNew.shipto_address3,
		pNew.shipto_city,
		pNew.shipto_state,
		pNew.shipto_postal_code,
		pNew.shipto_country,
		COALESCE(getSalesRepId(pNew.sales_rep),shipto_salesrep_id,cust_salesrep_id),
		COALESCE(pNew.freight, 0),
		COALESCE(pNew.misc_charge_amount, 0),
		pNew.notes,
		FALSE, -- printed
		COALESCE(pNew.billto_name, invchead_billto_name, cust_name),
		COALESCE(pNew.billto_address1, invchead_billto_address1, addr_line1),
		COALESCE(pNew.billto_address2, invchead_billto_address2, addr_line2),
		COALESCE(pNew.billto_address3, invchead_billto_address3, addr_line3),
		COALESCE(pNew.billto_city, invchead_billto_city, addr_city),
		COALESCE(pNew.billto_state, invchead_billto_state, addr_state),
		COALESCE(pNew.billto_postal_code, invchead_billto_zipcode, addr_postalcode),
		COALESCE(pNew.billto_country, invchead_billto_country, addr_country),
		COALESCE(pNew.on_hold, FALSE),
		COALESCE(pNew.commission, 0),
		COALESCE(getGlAccntId(pNew.misc_charge_credit_account),-1),
		pNew.misc_charge_description,
		(SELECT rsncode_id FROM rsncode WHERE rsncode_code = pNew.reason_code),
		COALESCE(getCurrId(pNew.currency),cust_curr_id,basecurrid()),
                CASE WHEN pNew.tax_zone = 'None' THEN NULL
                     ELSE COALESCE(getTaxZoneID(pNew.tax_zone),cust_taxzone_id)
                END,
                NULL,
                NULL
	FROM custinfo
		LEFT OUTER JOIN shiptoinfo ON (shipto_id=(SELECT CASE
			WHEN getShiptoId(pNew.customer_number,pNew.shipto_number) IS NOT NULL
				THEN getShiptoId(pNew.customer_number,pNew.shipto_number)
			ELSE (SELECT shipto_id FROM shiptoinfo WHERE shipto_cust_id=cust_id AND shipto_default)
		END))
                LEFT OUTER JOIN invchead ON (invchead_id=getInvcheadId(pNEW.apply_to))
                LEFT OUTER JOIN cntct ON (cntct_id=cust_cntct_id)
                LEFT OUTER JOIN addr ON (addr_id=cntct_addr_id)
	WHERE cust_id = (CASE
		WHEN pNew.customer_number IS NOT NULL THEN (SELECT getCustId(pNew.customer_number))
		ELSE (SELECT invchead_cust_id FROM invchead WHERE invchead_invcnumber = pNew.apply_to)
	END);
	RETURN TRUE;
END;
$_$;


ALTER FUNCTION public.insertcreditmemo(api.creditmemo) OWNER TO admin;

--
-- TOC entry 222 (class 1259 OID 146566545)
-- Dependencies: 6020 6021 8
-- Name: cmitem; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE cmitem (
    cmitem_id integer DEFAULT nextval(('cmitem_cmitem_id_seq'::text)::regclass) NOT NULL,
    cmitem_cmhead_id integer NOT NULL,
    cmitem_linenumber integer NOT NULL,
    cmitem_itemsite_id integer NOT NULL,
    cmitem_qtycredit numeric(18,6) NOT NULL,
    cmitem_qtyreturned numeric(18,6) NOT NULL,
    cmitem_unitprice numeric(16,4) NOT NULL,
    cmitem_comments text,
    cmitem_rsncode_id integer,
    cmitem_taxtype_id integer,
    cmitem_qty_uom_id integer NOT NULL,
    cmitem_qty_invuomratio numeric(20,10) NOT NULL,
    cmitem_price_uom_id integer NOT NULL,
    cmitem_price_invuomratio numeric(20,10) NOT NULL,
    cmitem_raitem_id integer,
    cmitem_updateinv boolean DEFAULT true NOT NULL
);


ALTER TABLE public.cmitem OWNER TO admin;


SET search_path = api, pg_catalog;

--
-- TOC entry 223 (class 1259 OID 146566553)
-- Dependencies: 8474 6
-- Name: creditmemoline; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW creditmemoline AS
    SELECT cmhead.cmhead_number AS memo_number, cmitem.cmitem_linenumber AS line_number, item.item_number, whsinfo.warehous_code AS recv_site, rsncode.rsncode_code AS reason_code, cmitem.cmitem_qtyreturned AS qty_returned, cmitem.cmitem_qtycredit AS qty_to_credit, COALESCE(qty_uom.uom_name, 'None'::text) AS qty_uom, cmitem.cmitem_unitprice AS net_unit_price, COALESCE(price_uom.uom_name, 'None'::text) AS price_uom, COALESCE(taxtype.taxtype_name, 'None'::text) AS tax_type, cmitem.cmitem_comments AS notes FROM ((((((((public.cmitem LEFT JOIN public.cmhead ON ((cmitem.cmitem_cmhead_id = cmhead.cmhead_id))) LEFT JOIN public.itemsite ON ((itemsite.itemsite_id = cmitem.cmitem_itemsite_id))) LEFT JOIN public.item ON ((item.item_id = itemsite.itemsite_item_id))) LEFT JOIN public.whsinfo ON ((whsinfo.warehous_id = itemsite.itemsite_warehous_id))) LEFT JOIN public.rsncode ON ((rsncode.rsncode_id = cmitem.cmitem_rsncode_id))) LEFT JOIN public.taxtype ON ((taxtype.taxtype_id = cmitem.cmitem_taxtype_id))) LEFT JOIN public.uom qty_uom ON ((qty_uom.uom_id = cmitem.cmitem_qty_uom_id))) LEFT JOIN public.uom price_uom ON ((price_uom.uom_id = cmitem.cmitem_price_uom_id)));


ALTER TABLE api.creditmemoline OWNER TO admin;

--
-- TOC entry 9037 (class 0 OID 0)
-- Dependencies: 223
-- Name: VIEW creditmemoline; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW creditmemoline IS 'Credit Memo Line';


SET search_path = public, pg_catalog;

--
-- TOC entry 1817 (class 1255 OID 146566558)
-- Dependencies: 2849 4536 8
-- Name: insertcreditmemoline(api.creditmemoline); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION insertcreditmemoline(api.creditmemoline) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pNew ALIAS FOR $1;
  _check INTEGER;
  _r RECORD;

BEGIN
  SELECT cmhead_id INTO _check
  FROM cmhead
  WHERE (cmhead_id=getCmheadId(pNew.memo_number, FALSE));
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Credit Memo # % not found', pNew.memo_number;
  END IF;

  INSERT INTO cmitem ( cmitem_cmhead_id,
                       cmitem_linenumber,
                       cmitem_itemsite_id,
                       cmitem_qtycredit,
                       cmitem_qtyreturned,
                       cmitem_unitprice,
                       cmitem_comments,
                       cmitem_rsncode_id,
                       cmitem_taxtype_id,
                       cmitem_qty_uom_id,
                       cmitem_qty_invuomratio,
                       cmitem_price_uom_id,
                       cmitem_price_invuomratio	)
  SELECT cmhead_id,
         COALESCE(pNew.line_number,
                  (SELECT (COALESCE(MAX(cmitem_linenumber), 0) + 1)
                   FROM cmitem WHERE (cmitem_cmhead_id=cmhead_id))),
         COALESCE(itemsite_id, -1),
         COALESCE(pNew.qty_to_credit, 0),
         COALESCE(pNew.qty_returned, 0),
         COALESCE(pNew.net_unit_price, 0),
         pNew.notes,
         getRsnId(pNew.reason_code),
         taxtype_id,
         COALESCE(getUomId(pNew.qty_uom), item_inv_uom_id),
         CASE
           WHEN item_id IS NOT NULL THEN itemuomtouomratio(item_id, COALESCE(getUomId(pNew.qty_uom),item_inv_uom_id),item_inv_uom_id)
           ELSE 1
         END,
         COALESCE(getUomId(pNew.price_uom),item_price_uom_id),
         CASE
           WHEN item_id IS NOT NULL THEN itemuomtouomratio(item_id, COALESCE(getUomId(pNew.price_uom),item_price_uom_id),item_price_uom_id)
           ELSE 1
        END
  FROM cmhead LEFT OUTER JOIN item ON (item_id=getItemId(pNew.item_number))
              LEFT OUTER JOIN itemsite ON (itemsite_item_id=item_id AND itemsite_warehous_id=getWarehousId(pNew.recv_site, 'ALL'))
              LEFT OUTER JOIN taxtype ON (taxtype_id=CASE WHEN pNew.tax_type IS NULL THEN getItemTaxType(item_id,cmhead_taxzone_id)
                                                          WHEN pNew.tax_type = 'None' THEN NULL
                                                          ELSE getTaxTypeId(pNew.tax_type)
                                                     END)
  WHERE (cmhead_id=getCmheadId(pNew.memo_number, FALSE));

  RETURN TRUE;
END;
$_$;


ALTER FUNCTION public.insertcreditmemoline(api.creditmemoline) OWNER TO admin;

--
-- TOC entry 1803 (class 1255 OID 146566559)
-- Dependencies: 4536 8
-- Name: insertflgroup(integer, integer, integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION insertflgroup(integer, integer, integer, integer, boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pFlheadid  ALIAS FOR $1;
  pPeriodid  ALIAS FOR $2;
  pFlgrpid   ALIAS FOR $3;
  pLevel     ALIAS FOR $4;
  pSummarize ALIAS FOR $5;

BEGIN
  RETURN insertFlGroup(pFlheadid, pPeriodid, pFlgrpid, pLevel, pSummarize, NULL);
END;
$_$;


ALTER FUNCTION public.insertflgroup(integer, integer, integer, integer, boolean) OWNER TO admin;

--
-- TOC entry 1818 (class 1255 OID 146566560)
-- Dependencies: 4536 8
-- Name: insertflgroup(integer, integer, integer, integer, boolean, character); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION insertflgroup(integer, integer, integer, integer, boolean, character) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pFlheadid  ALIAS FOR $1;
  pPeriodid  ALIAS FOR $2;
  pFlgrpid   ALIAS FOR $3;
  pLevel     ALIAS FOR $4;
  pSummarize ALIAS FOR $5;
  pInterval  ALIAS FOR $6;

BEGIN
  RETURN insertFlGroup(pFlheadid, pPeriodid, pFlgrpid, pLevel, pSummarize, pInterval, NULL);
END;
$_$;


ALTER FUNCTION public.insertflgroup(integer, integer, integer, integer, boolean, character) OWNER TO admin;

--
-- TOC entry 1819 (class 1255 OID 146566561)
-- Dependencies: 4536 8
-- Name: insertflgroup(integer, integer, integer, integer, boolean, character, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION insertflgroup(integer, integer, integer, integer, boolean, character, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pFlheadid  ALIAS FOR $1;
  pPeriodid  ALIAS FOR $2;
  pFlgrpid   ALIAS FOR $3;
  pLevel     ALIAS FOR $4;
  pSummarize ALIAS FOR $5;
  pInterval  ALIAS FOR $6;
  pPrjid     ALIAS FOR $7;

  _subtotal BOOLEAN;
  _r RECORD;
  _g RECORD;
  _all BOOLEAN;

BEGIN

  _all = COALESCE(pPrjid,-1) = -1;

-- Check to see if this group wants a subtotal
  _subtotal := FALSE;
  IF (pFlgrpid != -1) THEN
    SELECT COALESCE(flgrp_subtotal, FALSE) INTO _subtotal
      FROM flgrp
     WHERE ((flgrp_flhead_id=pFlheadid)
       AND  (flgrp_id=pFlgrpid));
  END IF;

  FOR _r IN SELECT 'G' AS type, flgrp_id AS type_id,
                   flgrp_order AS orderby,
                   flgrp_summarize AS summarize,
                   flgrp_subtract AS subtract,
                   CASE WHEN(flgrp_summarize AND (NOT flgrp_showstart)) THEN NULL
                        ELSE 0.00
                   END AS beginning,
                   CASE WHEN(flgrp_summarize AND (NOT flgrp_showend)) THEN NULL
                        ELSE 0.00
                   END AS ending,
                   CASE WHEN(flgrp_summarize AND (NOT flgrp_showdelta)) THEN NULL
                        ELSE 0.00
                   END AS debits,
                   CASE WHEN(flgrp_summarize AND (NOT flgrp_showdelta)) THEN NULL
                        ELSE 0.00
                   END AS credits,
                   CASE WHEN(flgrp_summarize AND (NOT flgrp_showbudget)) THEN NULL
                        ELSE 0.00
                   END AS budget,
                   CASE WHEN(flgrp_summarize AND (NOT flgrp_showdiff)) THEN NULL
                        ELSE 0.00
                   END AS diff,
                   CASE WHEN(flgrp_summarize AND (NOT flgrp_showcustom)) THEN NULL
                        ELSE 0.00
                   END AS custom,
                   CASE WHEN(flgrp_showstartprcnt) THEN 0.00
                        ELSE NULL
                   END AS beginningprcnt,
                   CASE WHEN(flgrp_showendprcnt) THEN 0.00
                        ELSE NULL
                   END AS endingprcnt,
                   CASE WHEN(flgrp_showdeltaprcnt) THEN 0.00
                        ELSE NULL
                   END AS debitsprcnt,
                   CASE WHEN(flgrp_showdeltaprcnt) THEN 0.00
                        ELSE NULL
                   END AS creditsprcnt,
                   CASE WHEN(flgrp_showbudgetprcnt) THEN 0.00
                        ELSE NULL
                   END AS budgetprcnt,
                   CASE WHEN(flgrp_showdiffprcnt) THEN 0.00
                        ELSE NULL
                   END AS diffprcnt,
                   CASE WHEN(flgrp_showcustomprcnt) THEN 0.00
                        ELSE NULL
                   END AS customprcnt,
                   -1 AS accnt_id,
                   '' AS accnt_number
              FROM flgrp
             WHERE ((flgrp_flgrp_id=pFlgrpid)
               AND  (flgrp_flhead_id=pFlheadid))
             UNION ALL
            SELECT 'I' AS type, flitem_id AS type_id,
                   flitem_order AS orderby,
                   FALSE AS summarize,
                   flitem_subtract AS subtract,
                   CASE WHEN (flitem_showstart AND (first_trialbal_id IS NULL)) THEN 0.00
                        WHEN (flitem_showstart) THEN normalizeTrialBal(first_trialbal_id, 'B')
                        ELSE NULL
                   END AS beginning,
                   CASE WHEN (flitem_showend AND (last_trialbal_id IS NULL)) THEN 0.00
                        WHEN (flitem_showend) THEN normalizeTrialBal(last_trialbal_id, 'E')
                        ELSE NULL
                   END AS ending,
                   CASE WHEN (flitem_showdelta) THEN sum_trialbal_debits
                        ELSE NULL
                   END AS debits,
                   CASE WHEN (flitem_showdelta) THEN sum_trialbal_credits
                        ELSE NULL
                   END AS credits,
                   CASE WHEN ((flitem_showbudget) AND (accnt_type IN ('R','E')) AND flhead_type IN ('I','C','A')) THEN COALESCE(sum_budget_amount,0)
                        WHEN ((flitem_showbudget) AND (accnt_type IN ('R','E')) AND flhead_type = 'B' ) THEN
                                (SELECT COALESCE(SUM(b.budget_amount),0)
                                FROM budget b,
                                        (SELECT ytd.period_id AS ytd_period_id
                                        FROM period cp, period ytd
                                        WHERE ((cp.period_id = last_flitem_period_id)
                                        AND (ytd.period_start <= cp.period_start)
                                AND (ytd.period_yearperiod_id = cp.period_yearperiod_id))) AS periods
                                WHERE ((b.budget_accnt_id=accnt_id)
                                AND (b.budget_period_id=ytd_period_id)))
                        WHEN ((flitem_showbudget) AND (accnt_type IN ('A','L','Q')) AND flhead_type = 'C') THEN calccashbudget(accnt_id,last_flitem_period_id,pInterval)
                        ELSE COALESCE(last_budget_amount,0)
                   END AS budget,
                   CASE WHEN (flitem_showdiff AND (first_trialbal_id IS NULL)) THEN 0.00
                        WHEN (flitem_showdiff) THEN COALESCE(normalizeTrialBal(last_trialbal_id, 'E') - normalizeTrialBal(first_trialbal_id, 'B'), 0.00)
                        ELSE NULL
                   END AS diff,
                   CASE WHEN (NOT flitem_showcustom) THEN NULL
                        WHEN (flitem_custom_source='S' AND (first_trialbal_id IS NOT NULL)) THEN normalizeTrialBal(first_trialbal_id, 'B')
                        WHEN (flitem_custom_source='E' AND (first_trialbal_id IS NOT NULL)) THEN normalizeTrialBal(last_trialbal_id, 'E')
                        WHEN (flitem_custom_source='D') THEN sum_trialbal_debits
                        WHEN (flitem_custom_source='C') THEN sum_trialbal_credits
                        WHEN (flitem_custom_source='B') THEN (
                                CASE
                                  WHEN (accnt_type IN ('R','E')) THEN sum_budget_amount
                                  ELSE last_budget_amount
                                END)
                        WHEN (flitem_custom_source='F' AND  (first_trialbal_id IS NOT NULL)) THEN COALESCE(normalizeTrialBal(last_trialbal_id, 'E') - normalizeTrialBal(first_trialbal_id, 'B'), 0.00)
                        ELSE 0.00
                   END AS custom,
                   CASE WHEN(flitem_showstartprcnt) THEN 0.00
                        ELSE NULL
                   END AS beginningprcnt,
                   CASE WHEN(flitem_showendprcnt) THEN 0.00
                        ELSE NULL
                   END AS endingprcnt,
                   CASE WHEN(flitem_showdeltaprcnt) THEN 0.00
                        ELSE NULL
                   END AS debitsprcnt,
                   CASE WHEN(flitem_showdeltaprcnt) THEN 0.00
                        ELSE NULL
                   END AS creditsprcnt,
                   CASE WHEN(flitem_showbudgetprcnt) THEN 0.00
                        ELSE NULL
                   END AS budgetprcnt,
                   CASE WHEN(flitem_showdiffprcnt) THEN 0.00
                        ELSE NULL
                   END AS diffprcnt,
                   CASE WHEN(flitem_showcustomprcnt) THEN 0.00
                        ELSE NULL
                   END AS customprcnt,
                   accnt_id,
                   public.formatglaccount(accnt_id) AS accnt_number
              FROM
                (SELECT
                  flhead_type,flitem_id,flitem_order,flitem_subtract,flitem_showstart,flitem_showend,
                  flitem_showdelta,flitem_showbudget,flitem_showdiff,flitem_showcustom,
                  flitem_custom_source,flitem_showstartprcnt,flitem_showendprcnt,flitem_showdeltaprcnt,
                  flitem_showbudgetprcnt,flitem_showdiffprcnt,flitem_showcustomprcnt,
                  accnt_id,accnt_type,
                  FIRST(trialbal_id) AS first_trialbal_id, LAST(trialbal_id) AS last_trialbal_id,
                  SUM(trialbal_debits) AS sum_trialbal_debits, SUM(trialbal_credits) AS sum_trialbal_credits,
                  LAST(flitem_period_id) AS last_flitem_period_id,
                  SUM(budget_amount) AS sum_budget_amount, LAST(budget_amount) AS last_budget_amount
                  FROM
                (SELECT period_id AS flitem_period_id, period_start,flhead_type,flitem_id,flitem_order,flitem_subtract,flitem_showstart,flitem_showend,
                        flitem_showdelta,flitem_showbudget,flitem_showdiff,flitem_showcustom,
                        flitem_custom_source,flitem_showstartprcnt,flitem_showendprcnt,flitem_showdeltaprcnt,
                        flitem_showbudgetprcnt,flitem_showdiffprcnt,flitem_showcustomprcnt,
                        accnt_id,accnt_type,COALESCE(trialbal_id,getlasttrialbalid(accnt_id,period_id)) as trialbal_id,COALESCE(trialbal_debits,0) as trialbal_debits,
                        COALESCE(trialbal_credits,0) AS trialbal_credits,COALESCE(budget_amount,0) AS budget_amount
                   FROM (SELECT period_id, period_start, flhead_type, flitem_id,flitem_order,flitem_subtract,flitem_showstart,flitem_showend,
                                flitem_showdelta,flitem_showbudget,flitem_showdiff,flitem_showcustom,flitem_custom_source,flitem_showstartprcnt,
                                flitem_showendprcnt,flitem_showdeltaprcnt,flitem_showbudgetprcnt,flitem_showdiffprcnt,flitem_showcustomprcnt,
                                accnt_id, accnt_type
                        FROM  period,flaccnt
                        WHERE ((flitem_flhead_id=pFlheadid)
                        AND (flitem_flgrp_id=pFlgrpid)
                        AND (_all OR prj_id=pPrjId)
                        AND (period_id IN  (SELECT * FROM getperiodid(pPeriodId,pInterval))))
                        ORDER BY flitem_id
                        ) AS flitem
                   LEFT OUTER JOIN trialbal
                     ON ((trialbal_accnt_id=accnt_id)
                     AND (trialbal_period_id=period_id))
                   LEFT OUTER JOIN budget
                     ON ((budget_accnt_id=accnt_id)
                     AND (budget_period_id=period_id))
             ORDER BY accnt_id, period_start) AS data
             GROUP BY flhead_type,flitem_id,flitem_order,flitem_subtract,flitem_showstart,flitem_showend,
                flitem_showdelta,flitem_showbudget,flitem_showdiff,flitem_showcustom,
                flitem_custom_source,flitem_showstartprcnt,flitem_showendprcnt,flitem_showdeltaprcnt,
                flitem_showbudgetprcnt,flitem_showdiffprcnt,flitem_showcustomprcnt,accnt_id,accnt_type) AS agg
             UNION ALL
            SELECT 'S' AS type, flspec_id AS type_id,
                   flspec_order AS orderby,
                   FALSE AS summarize,
                   flspec_subtract AS subtract,
                   CASE WHEN (flspec_showstart) THEN findSpecialFinancial('S', flspec_type, pPeriodid)
                        ELSE NULL
                   END AS beginning,
                   CASE WHEN (flspec_showend) THEN findSpecialFinancial('E', flspec_type, pPeriodid)
                        ELSE NULL
                   END AS ending,
                   CASE WHEN (flspec_showdelta) THEN findSpecialFinancial('D', flspec_type, pPeriodid)
                        ELSE NULL
                   END AS debits,
                   CASE WHEN (flspec_showdelta) THEN findSpecialFinancial('C', flspec_type, pPeriodid)
                        ELSE NULL
                   END AS credits,
                   CASE WHEN (flspec_showbudget) THEN findSpecialFinancial('B', flspec_type, pPeriodid)
                        ELSE NULL
                   END AS budget,
                   CASE WHEN (flspec_showdiff) THEN findSpecialFinancial('E', flspec_type, pPeriodid) - findSpecialFinancial('S', flspec_type, pPeriodid)
                        ELSE NULL
                   END AS diff,
                   CASE WHEN (NOT flspec_showcustom) THEN NULL
                        WHEN (flspec_custom_source='F') THEN findSpecialFinancial('E', flspec_type, pPeriodid) - findSpecialFinancial('S', flspec_type, pPeriodid)
                        WHEN (flspec_custom_source IN ('S', 'E', 'D', 'C', 'B')) THEN findSpecialFinancial(flspec_custom_source, flspec_type, pPeriodid)
                        ELSE 0.00
                   END AS custom,
                   CASE WHEN(flspec_showstartprcnt) THEN 0.00
                        ELSE NULL
                   END AS beginningprcnt,
                   CASE WHEN(flspec_showendprcnt) THEN 0.00
                        ELSE NULL
                   END AS endingprcnt,
                   CASE WHEN(flspec_showdeltaprcnt) THEN 0.00
                        ELSE NULL
                   END AS debitsprcnt,
                   CASE WHEN(flspec_showdeltaprcnt) THEN 0.00
                        ELSE NULL
                   END AS creditsprcnt,
                   CASE WHEN(flspec_showbudgetprcnt) THEN 0.00
                        ELSE NULL
                   END AS budgetprcnt,
                   CASE WHEN(flspec_showdiffprcnt) THEN 0.00
                        ELSE NULL
                   END AS diffprcnt,
                   CASE WHEN(flspec_showcustomprcnt) THEN 0.00
                        ELSE NULL
                   END AS customprcnt,
                   -1 AS accnt_id,
                   '' AS accnt_number
              FROM flspec
             WHERE ((flspec_flgrp_id=pFlgrpid)
               AND  (flspec_flhead_id=pFlheadid))
          ORDER BY orderby, accnt_number LOOP

    IF (_r.type = 'G') THEN

-- Create a record for the items sub items to be attached to and be able to update the total
      INSERT INTO flrpt
             (flrpt_flhead_id, flrpt_period_id, flrpt_username,
              flrpt_order,
              flrpt_level, flrpt_type, flrpt_type_id,
              flrpt_beginning, flrpt_ending,
              flrpt_debits, flrpt_credits, flrpt_budget, flrpt_diff, flrpt_custom,
              flrpt_beginningprcnt, flrpt_endingprcnt,
              flrpt_debitsprcnt, flrpt_creditsprcnt, flrpt_budgetprcnt, flrpt_diffprcnt, flrpt_customprcnt,
              flrpt_parent_id, flrpt_interval)
      VALUES (pFlheadid, pPeriodid, getEffectiveXtUser(),
              (COALESCE(( SELECT MAX(flrpt_order)
                            FROM flrpt
                           WHERE ((flrpt_flhead_id=pFlheadid)
                             AND  (flrpt_period_id=pPeriodid)
                             AND (flrpt_interval=pInterval)
                             AND  (flrpt_username=getEffectiveXtUser()))
                        ), 1) + 1),
              pLevel, _r.type, _r.type_id,
              _r.beginning, _r.ending,
              _r.debits, _r.credits, _r.budget, _r.diff, _r.custom,
              _r.beginningprcnt, _r.endingprcnt,
              _r.debitsprcnt, _r.creditsprcnt, _r.budgetprcnt, _r.diffprcnt, _r.customprcnt,
              pFlgrpid, pInterval);

      PERFORM insertFlGroup(pFlheadid, pPeriodid, _r.type_id, (pLevel + 1), (pSummarize OR _r.summarize), pInterval, pPrjid);

-- Update the parent item
      SELECT COALESCE(flrpt_beginning, 0.00) AS beginning,
             COALESCE(flrpt_ending, 0.00) AS ending,
             COALESCE(flrpt_debits, 0.00) AS debits,
             COALESCE(flrpt_credits, 0.00) AS credits,
             COALESCE(flrpt_budget, 0.00) AS budget,
             COALESCE(flrpt_diff, 0.00) AS diff,
             COALESCE(flrpt_custom, 0.00) AS custom INTO _g
        FROM flrpt
       WHERE ((flrpt_flhead_id=pFlheadid)
         AND  (flrpt_period_id=pPeriodid)
          AND (flrpt_interval=pInterval)
         AND  (flrpt_username=getEffectiveXtUser())
         AND  (flrpt_type=_r.type)
         AND  (flrpt_type_id=_r.type_id));
      IF (_r.subtract) THEN
        UPDATE flrpt
           SET flrpt_beginning = flrpt_beginning - _g.beginning,
               flrpt_ending    = flrpt_ending    - _g.ending,
               flrpt_debits    = flrpt_debits    - _g.debits,
               flrpt_credits   = flrpt_credits   - _g.credits,
               flrpt_budget    = flrpt_budget    - _g.budget,
               flrpt_diff      = flrpt_diff      - _g.diff,
               flrpt_custom    = flrpt_custom    - _g.custom
         WHERE ((flrpt_flhead_id=pFlheadid)
           AND  (flrpt_period_id=pPeriodid)
           AND  (flrpt_interval=pInterval)
           AND  (flrpt_username=getEffectiveXtUser())
           AND  (flrpt_type='G')
           AND  (flrpt_type_id=pFlgrpid));
      ELSE
        UPDATE flrpt
           SET flrpt_beginning = flrpt_beginning + _g.beginning,
               flrpt_ending    = flrpt_ending    + _g.ending,
               flrpt_debits    = flrpt_debits    + _g.debits,
               flrpt_credits   = flrpt_credits   + _g.credits,
               flrpt_budget    = flrpt_budget    + _g.budget,
               flrpt_diff      = flrpt_diff      + _g.diff,
               flrpt_custom    = flrpt_custom    + _g.custom
         WHERE ((flrpt_flhead_id=pFlheadid)
           AND  (flrpt_period_id=pPeriodid)
           AND  (flrpt_interval=pInterval)
           AND  (flrpt_username=getEffectiveXtUser())
           AND  (flrpt_type='G')
           AND  (flrpt_type_id=pFlgrpid));
      END IF;

-- If we are summarizing then we need to remove the record we created now that we have updated the total
      IF (pSummarize) THEN
        DELETE FROM flrpt
         WHERE ((flrpt_flhead_id=pFlheadid)
          AND  (flrpt_period_id=pPeriodid)
          AND  (flrpt_interval=pInterval)
          AND  (flrpt_username=getEffectiveXtUser())
          AND  (flrpt_type=_r.type)
          AND  (flrpt_type_id=_r.type_id));
      END IF;

    ELSE
      IF (_r.type = 'I' OR _r.type = 'S' ) THEN

-- If we are not summarizing then create a new entry for this record
        IF (NOT pSummarize) THEN
          INSERT INTO flrpt
                 (flrpt_flhead_id, flrpt_period_id, flrpt_username,
                  flrpt_order,
                  flrpt_level, flrpt_type, flrpt_type_id,
                  flrpt_beginning, flrpt_ending,
                  flrpt_debits, flrpt_credits, flrpt_budget, flrpt_diff, flrpt_custom,
                  flrpt_beginningprcnt, flrpt_endingprcnt,
                  flrpt_debitsprcnt, flrpt_creditsprcnt, flrpt_budgetprcnt, flrpt_diffprcnt, flrpt_customprcnt,
                  flrpt_parent_id,flrpt_accnt_id,flrpt_interval)
          VALUES (pFlheadid, pPeriodid, getEffectiveXtUser(),
                  (COALESCE(( SELECT MAX(flrpt_order)
                               FROM flrpt
                              WHERE ((flrpt_flhead_id=pFlheadid)
                                AND  (flrpt_period_id=pPeriodid)
                                AND  (flrpt_interval=pInterval)
                                AND  (flrpt_username=getEffectiveXtUser()))
                            ), 1) + 1),
                  pLevel, _r.type, _r.type_id,
                  _r.beginning, _r.ending,
                  _r.debits, _r.credits, _r.budget, _r.diff, _r.custom,
                  _r.beginningprcnt, _r.endingprcnt,
                  _r.debitsprcnt, _r.creditsprcnt, _r.budgetprcnt, _r.diffprcnt, _r.customprcnt,
                  pFlgrpid,_r.accnt_id,pInterval);
        END IF;

-- Update the parent item
        IF (_r.subtract) THEN
          UPDATE flrpt
             SET flrpt_beginning = flrpt_beginning - COALESCE(_r.beginning, 0.00),
                 flrpt_ending    = flrpt_ending    - COALESCE(_r.ending, 0.00),
                 flrpt_debits    = flrpt_debits    - COALESCE(_r.debits, 0.00),
                 flrpt_credits   = flrpt_credits   - COALESCE(_r.credits, 0.00),
                 flrpt_budget    = flrpt_budget    - COALESCE(_r.budget, 0.00),
                 flrpt_diff      = flrpt_diff      - COALESCE(_r.diff, 0.00),
                 flrpt_custom    = flrpt_custom    - COALESCE(_r.custom, 0.00)
           WHERE ((flrpt_flhead_id=pFlheadid)
             AND  (flrpt_period_id=pPeriodid)
             AND  (flrpt_interval=pInterval)
             AND  (flrpt_username=getEffectiveXtUser())
             AND  (flrpt_type='G')
             AND  (flrpt_type_id=pFlgrpid));
        ELSE
          UPDATE flrpt
             SET flrpt_beginning = flrpt_beginning + COALESCE(_r.beginning, 0.00),
                 flrpt_ending    = flrpt_ending    + COALESCE(_r.ending, 0.00),
                 flrpt_debits    = flrpt_debits    + COALESCE(_r.debits, 0.00),
                 flrpt_credits   = flrpt_credits   + COALESCE(_r.credits, 0.00),
                 flrpt_budget    = flrpt_budget    + COALESCE(_r.budget, 0.00),
                 flrpt_diff      = flrpt_diff      + COALESCE(_r.diff, 0.00),
                 flrpt_custom    = flrpt_custom    + COALESCE(_r.custom, 0.00)
           WHERE ((flrpt_flhead_id=pFlheadid)
             AND  (flrpt_interval=pInterval)
             AND  (flrpt_period_id=pPeriodid)
             AND  (flrpt_username=getEffectiveXtUser())
             AND  (flrpt_type='G')
             AND  (flrpt_type_id=pFlgrpid));
        END IF;

      END IF;
    END IF;

  END LOOP;

  IF (NOT pSummarize) THEN
-- If this group wants a summarized line create it here.
    IF (_subtotal) THEN
      INSERT INTO flrpt
             (flrpt_flhead_id, flrpt_period_id, flrpt_username,
              flrpt_order,
              flrpt_level, flrpt_type, flrpt_type_id,
              flrpt_beginning, flrpt_ending,
              flrpt_debits, flrpt_credits, flrpt_budget, flrpt_diff, flrpt_custom,
              flrpt_beginningprcnt, flrpt_endingprcnt,
              flrpt_debitsprcnt, flrpt_creditsprcnt, flrpt_budgetprcnt, flrpt_diffprcnt, flrpt_customprcnt,
              flrpt_parent_id, flrpt_altname,flrpt_interval )
      SELECT pFlheadid, pPeriodid, getEffectiveXtUser(),
             (COALESCE(( SELECT MAX(flrpt_order)
                           FROM flrpt
                          WHERE ((flrpt_flhead_id=pFlheadid)
                            AND  (flrpt_period_id=pPeriodid)
                            AND  (flrpt_interval=pInterval)
                            AND  (flrpt_username=getEffectiveXtUser()))
                       ), 1) + 1),
             pLevel, 'T', -1,
             CASE WHEN (flgrp_showstart) THEN flrpt_beginning
                  ELSE NULL
             END,
             CASE WHEN (flgrp_showend) THEN flrpt_ending
                  ELSE NULL
             END,
             CASE WHEN (flgrp_showdelta) THEN flrpt_debits
                  ELSE NULL
             END,
             CASE WHEN (flgrp_showdelta) THEN flrpt_credits
                  ELSE NULL
             END,
             CASE WHEN (flgrp_showbudget) THEN flrpt_budget
                  ELSE NULL
             END,
             CASE WHEN (flgrp_showdiff) THEN flrpt_diff
                  ELSE NULL
             END,
             CASE WHEN (flgrp_showcustom) THEN flrpt_custom
                  ELSE NULL
             END,
             CASE WHEN (flgrp_showstartprcnt) THEN flrpt_beginningprcnt
                  ELSE NULL
             END,
             CASE WHEN (flgrp_showendprcnt) THEN flrpt_endingprcnt
                  ELSE NULL
             END,
             CASE WHEN (flgrp_showdeltaprcnt) THEN flrpt_debitsprcnt
                  ELSE NULL
             END,
             CASE WHEN (flgrp_showdeltaprcnt) THEN flrpt_creditsprcnt
                  ELSE NULL
             END,
             CASE WHEN (flgrp_showbudgetprcnt) THEN flrpt_budgetprcnt
                  ELSE NULL
             END,
             CASE WHEN (flgrp_showdiffprcnt) THEN flrpt_diffprcnt
                  ELSE NULL
             END,
             CASE WHEN (flgrp_showcustomprcnt) THEN flrpt_customprcnt
                  ELSE NULL
             END,
             pFlgrpid,
             CASE WHEN (flgrp_usealtsubtotal) THEN flgrp_altsubtotal
                  ELSE NULL
             END, pInterval
        FROM flrpt, flgrp
       WHERE ((flrpt_flhead_id=flgrp_flhead_id)
         AND  (flrpt_type_id=flgrp_id)
         AND  (flrpt_flhead_id=pFlheadid)
         AND  (flrpt_period_id=pPeriodid)
         AND  (flrpt_interval=pInterval)
         AND  (flrpt_username=getEffectiveXtUser())
         AND  (flrpt_type='G')
         AND  (flrpt_type_id=pFlgrpid));
    END IF;
  END IF;

  return TRUE;
END;
$_$;


ALTER FUNCTION public.insertflgroup(integer, integer, integer, integer, boolean, character, integer) OWNER TO admin;

--
-- TOC entry 1820 (class 1255 OID 146566563)
-- Dependencies: 4536 8
-- Name: insertgltransaction(text, text, text, text, integer, integer, integer, numeric, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION insertgltransaction(text, text, text, text, integer, integer, integer, numeric, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSource ALIAS FOR $1;
  pDocType ALIAS FOR $2;
  pDocNumber ALIAS FOR $3;
  pNotes ALIAS FOR $4;
  pCreditid ALIAS FOR $5;
  pDebitid ALIAS FOR $6;
  pMiscid ALIAS FOR $7;
  pAmount ALIAS FOR $8;
  pDistDate ALIAS FOR $9;
  _return INTEGER;

BEGIN

  SELECT insertGLTransaction( fetchJournalNumber('GL-MISC'),
                              pSource, pDocType, pDocNumber, pNotes,
                              pCreditid, pDebitid, pMiscid, pAmount, pDistDate) INTO _return;

  RETURN _return;

END;
$_$;


ALTER FUNCTION public.insertgltransaction(text, text, text, text, integer, integer, integer, numeric, date) OWNER TO admin;

--
-- TOC entry 1821 (class 1255 OID 146566564)
-- Dependencies: 4536 8
-- Name: insertgltransaction(integer, text, text, text, text, integer, integer, integer, numeric, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION insertgltransaction(integer, text, text, text, text, integer, integer, integer, numeric, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pJournalNumber ALIAS FOR $1;
  pSource ALIAS FOR $2;
  pDocType ALIAS FOR $3;
  pDocNumber ALIAS FOR $4;
  pNotes ALIAS FOR $5;
  pCreditid ALIAS FOR $6;
  pDebitid ALIAS FOR $7;
  pMiscid ALIAS FOR $8;
  pAmount ALIAS FOR $9;
  pDistDate ALIAS FOR $10;
  _return INTEGER;

BEGIN

  SELECT insertGLTransaction( pJournalNumber, pSource, pDocType, pDocNumber, pNotes,
                              pCreditid, pDebitid, pMiscid, pAmount, pDistDate, TRUE) INTO _return;

  RETURN _return;

END;
$_$;


ALTER FUNCTION public.insertgltransaction(integer, text, text, text, text, integer, integer, integer, numeric, date) OWNER TO admin;

--
-- TOC entry 1822 (class 1255 OID 146566565)
-- Dependencies: 4536 8
-- Name: insertgltransaction(text, text, text, text, integer, integer, integer, numeric, date, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION insertgltransaction(text, text, text, text, integer, integer, integer, numeric, date, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSource ALIAS FOR $1;
  pDocType ALIAS FOR $2;
  pDocNumber ALIAS FOR $3;
  pNotes ALIAS FOR $4;
  pCreditid ALIAS FOR $5;
  pDebitid ALIAS FOR $6;
  pMiscid ALIAS FOR $7;
  pAmount ALIAS FOR $8;
  pDistDate ALIAS FOR $9;
  pPostTrialBal ALIAS FOR $10;
  _return INTEGER;

BEGIN

  SELECT insertGLTransaction( fetchJournalNumber('GL-MISC'),
                              pSource, pDocType, pDocNumber, pNotes,
                              pCreditid, pDebitid, pMiscid, pAmount, pDistDate, pPostTrialBal) INTO _return;

  RETURN _return;

END;
$_$;


ALTER FUNCTION public.insertgltransaction(text, text, text, text, integer, integer, integer, numeric, date, boolean) OWNER TO admin;

--
-- TOC entry 1823 (class 1255 OID 146566566)
-- Dependencies: 4536 8
-- Name: insertgltransaction(integer, text, text, text, text, integer, integer, integer, numeric, date, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION insertgltransaction(integer, text, text, text, text, integer, integer, integer, numeric, date, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pJournalNumber ALIAS FOR $1;
  pSource ALIAS FOR $2;
  pDocType ALIAS FOR $3;
  pDocNumber ALIAS FOR $4;
  pNotes ALIAS FOR $5;
  pCreditid ALIAS FOR $6;
  pDebitid ALIAS FOR $7;
  pMiscid ALIAS FOR $8;
  pAmount ALIAS FOR $9;
  pDistDate ALIAS FOR $10;
  pPostTrialBal ALIAS FOR $11;

  _return INTEGER;

BEGIN

  SELECT insertGLTransaction( pJournalNumber, pSource, pDocType, pDocNumber, pNotes,
                              pCreditid, pDebitid, pMiscid, pAmount, pDistDate, pPostTrialBal, false) INTO _return;

  RETURN _return;

END;
$_$;


ALTER FUNCTION public.insertgltransaction(integer, text, text, text, text, integer, integer, integer, numeric, date, boolean) OWNER TO admin;

--
-- TOC entry 1824 (class 1255 OID 146566567)
-- Dependencies: 4536 8
-- Name: insertgltransaction(integer, text, text, text, text, integer, integer, integer, numeric, date, boolean, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION insertgltransaction(integer, text, text, text, text, integer, integer, integer, numeric, date, boolean, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pJournalNumber ALIAS FOR $1;
  pSource ALIAS FOR $2;
  pDocType ALIAS FOR $3;
  pDocNumber ALIAS FOR $4;
  pNotes ALIAS FOR $5;
  pCreditid ALIAS FOR $6;
  pDebitid ALIAS FOR $7;
  pMiscid ALIAS FOR $8;
  pAmount ALIAS FOR $9;
  pDistDate ALIAS FOR $10;
  pPostTrialBal ALIAS FOR $11;
  pOnlyGL ALIAS FOR $12;
  _debitid INTEGER;
  _creditid INTEGER;
  _sequence INTEGER;
  _check INTEGER;

BEGIN

--  Check GL Interface metric
  IF (fetchMetricBool('InterfaceToGL') = false AND pSource IN ('I/M', 'P/D', 'S/R', 'W/O')) THEN
    RETURN 0;
  END IF;
  IF (fetchMetricBool('InterfaceAPToGL') = false AND pSource = 'A/P') THEN
    RETURN 0;
  END IF;
  IF (fetchMetricBool('InterfaceARToGL') = false AND pSource IN ('A/R', 'S/O', 'S/R')) THEN
    RETURN 0;
  END IF;

--  Is there anything to post?
--  ToDo - 2 should really be the scale of the base currency
  IF (round(pAmount, 2) = 0) THEN
    RETURN -3;
  END IF;

/*  Make sure we don't create an imbalance across companies.
    The 'IgnoreCompanyBalance' metric is a back door mechanism to
    allow legacy users to create transactions accross companies if
    they have been using the company segment for something else
    and they MUST continue to be able to do so.  It can only be
    implemented by direct sql update to the metric table and should
    otherwise be discouraged.
*/
  IF (COALESCE(fetchMetricValue('GLCompanySize'),0) > 0
    AND fetchMetricBool('IgnoreCompany') = false)  THEN

    IF (SELECT (COALESCE(d.accnt_company,'') != COALESCE(c.accnt_company,''))
       FROM accnt d, accnt c
       WHERE ((d.accnt_id=pDebitid)
        AND (c.accnt_id=pCreditid))) THEN
      RAISE EXCEPTION 'G/L Transaction can not be posted because accounts % and % reference two differnt companies.',
        formatGlaccount(pDebitid), formatGlaccount(pCreditid);
    END IF;
  END IF;

--  Validate pDebitid
  IF (pDebitid IN (SELECT accnt_id FROM accnt)) THEN
    _debitid := pDebitid;
  ELSE
    SELECT getUnassignedAccntId() INTO _debitid;
  END IF;

--  Validate pCreditid
  IF (pCreditid IN (SELECT accnt_id FROM accnt)) THEN
    _creditid := pCreditid;
  ELSE
    SELECT getUnassignedAccntId() INTO _creditid;
  END IF;

-- refuse to accept postings into closed periods
  IF (SELECT BOOL_AND(COALESCE(period_closed, FALSE))
      FROM accnt LEFT OUTER JOIN
           period ON (pDistDate BETWEEN period_start AND period_end)
      WHERE (accnt_id IN (_creditid, _debitid))) THEN
    RAISE EXCEPTION 'Cannot post to closed period (%).', pDistDate;
    RETURN -4;  -- remove raise exception when all callers check return code
  END IF;

-- refuse to accept postings into frozen periods without proper priv
  IF (SELECT NOT BOOL_AND(checkPrivilege('PostFrozenPeriod')) AND
             BOOL_AND(COALESCE(period_freeze, FALSE))
      FROM accnt LEFT OUTER JOIN
           period ON (pDistDate BETWEEN period_start AND period_end)
      WHERE (accnt_id IN (_creditid, _debitid))) THEN
    RAISE EXCEPTION 'Cannot post to frozen period (%).', pDistDate;
    RETURN -4;  -- remove raise exception when all callers check return code
  END IF;

-- refuse to accept postings into nonexistent periods
  IF NOT EXISTS(SELECT period_id
                FROM period
                WHERE (pDistDate BETWEEN period_start AND period_end)) THEN
    RAISE EXCEPTION 'Cannot post to nonexistent period (%).', pDistDate;
  END IF;

--  Grab a sequence for the pair
  SELECT fetchGLSequence() INTO _sequence;

  IF (NOT pOnlyGL AND fetchMetricBool('UseJournals')) THEN
  --  First the credit
    INSERT INTO sltrans
    ( sltrans_journalnumber, sltrans_posted, sltrans_created, sltrans_date,
      sltrans_sequence, sltrans_accnt_id, sltrans_source,
      sltrans_doctype, sltrans_docnumber, sltrans_notes,
      sltrans_misc_id, sltrans_amount )
    VALUES
    ( pJournalNumber, FALSE, CURRENT_TIMESTAMP, pDistDate,
      _sequence, _creditid, pSource,
      pDocType, pDocNumber, pNotes,
      pMiscid, pAmount );

  --  Now the debit
    INSERT INTO sltrans
    ( sltrans_journalnumber, sltrans_posted, sltrans_created, sltrans_date,
      sltrans_sequence, sltrans_accnt_id, sltrans_source,
      sltrans_doctype, sltrans_docnumber, sltrans_notes,
      sltrans_misc_id, sltrans_amount )
    VALUES
    ( pJournalNumber, FALSE, CURRENT_TIMESTAMP, pDistDate,
      _sequence, _debitid, pSource,
      pDocType, pDocNumber, pNotes,
      pMiscid, (pAmount * -1) );
  ELSE
  --  First the credit
    INSERT INTO gltrans
    ( gltrans_journalnumber, gltrans_posted, gltrans_exported, gltrans_created, gltrans_date,
      gltrans_sequence, gltrans_accnt_id, gltrans_source,
      gltrans_doctype, gltrans_docnumber, gltrans_notes,
      gltrans_misc_id, gltrans_amount )
    VALUES
    ( pJournalNumber, FALSE, FALSE, CURRENT_TIMESTAMP, pDistDate,
      _sequence, _creditid, pSource,
      pDocType, pDocNumber, pNotes,
      pMiscid, pAmount );

  --  Now the debit
    INSERT INTO gltrans
    ( gltrans_journalnumber, gltrans_posted, gltrans_exported, gltrans_created, gltrans_date,
      gltrans_sequence, gltrans_accnt_id, gltrans_source,
      gltrans_doctype, gltrans_docnumber, gltrans_notes,
      gltrans_misc_id, gltrans_amount )
    VALUES
    ( pJournalNumber, FALSE, FALSE, CURRENT_TIMESTAMP, pDistDate,
      _sequence, _debitid, pSource,
      pDocType, pDocNumber, pNotes,
      pMiscid, (pAmount * -1) );

    IF (pPostTrialBal) THEN
      PERFORM postIntoTrialBalance(_sequence);
    END IF;
  END IF;

  RETURN _sequence;

END;
$_$;


ALTER FUNCTION public.insertgltransaction(integer, text, text, text, text, integer, integer, integer, numeric, date, boolean, boolean) OWNER TO admin;

--
-- TOC entry 1825 (class 1255 OID 146566569)
-- Dependencies: 4536 8
-- Name: insertintoglseries(integer, text, text, text, integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION insertintoglseries(integer, text, text, text, integer, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSequence ALIAS FOR $1;
  pSource ALIAS FOR $2;
  pDocType ALIAS FOR $3;
  pDocNumber ALIAS FOR $4;
  pAccntid ALIAS FOR $5;
  pAmount ALIAS FOR $6;
  _returnValue INTEGER;

BEGIN

  SELECT insertIntoGLSeries( pSequence, pSource, pDocType, pDocNumber,
                             pAccntid, pAmount, CURRENT_DATE, '' ) INTO _returnValue;

  RETURN _returnValue;

END;
$_$;


ALTER FUNCTION public.insertintoglseries(integer, text, text, text, integer, numeric) OWNER TO admin;

--
-- TOC entry 1826 (class 1255 OID 146566570)
-- Dependencies: 4536 8
-- Name: insertintoglseries(integer, text, text, text, integer, numeric, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION insertintoglseries(integer, text, text, text, integer, numeric, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSequence ALIAS FOR $1;
  pSource ALIAS FOR $2;
  pDocType ALIAS FOR $3;
  pDocNumber ALIAS FOR $4;
  pAccntid ALIAS FOR $5;
  pAmount ALIAS FOR $6;
  pDistDate ALIAS FOR $7;
  _returnValue INTEGER;

BEGIN

  SELECT insertIntoGLSeries( pSequence, pSource, pDocType, pDocNumber,
                             pAccntid, pAmount, pDistDate, '' ) INTO _returnValue;

  RETURN _returnValue;

END;
$_$;


ALTER FUNCTION public.insertintoglseries(integer, text, text, text, integer, numeric, date) OWNER TO admin;

--
-- TOC entry 1827 (class 1255 OID 146566571)
-- Dependencies: 4536 8
-- Name: insertintoglseries(integer, text, text, text, integer, numeric, date, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION insertintoglseries(integer, text, text, text, integer, numeric, date, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSequence ALIAS FOR $1;
  pSource ALIAS FOR $2;
  pDocType ALIAS FOR $3;
  pDocNumber ALIAS FOR $4;
  pAccntid ALIAS FOR $5;
  pAmount ALIAS FOR $6;
  pDistDate ALIAS FOR $7;
  pNotes ALIAS FOR $8;
  _returnValue INTEGER;

BEGIN

  SELECT insertIntoGLSeries( pSequence, pSource, pDocType, pDocNumber,
                             pAccntid, pAmount, pDistDate, pNotes, NULL ) INTO _returnValue;

  RETURN _returnValue;

END;
$_$;


ALTER FUNCTION public.insertintoglseries(integer, text, text, text, integer, numeric, date, text) OWNER TO admin;

--
-- TOC entry 1828 (class 1255 OID 146566572)
-- Dependencies: 4536 8
-- Name: insertintoglseries(integer, text, text, text, integer, numeric, date, text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION insertintoglseries(integer, text, text, text, integer, numeric, date, text, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSequence ALIAS FOR $1;
  pSource ALIAS FOR $2;
  pDocType ALIAS FOR $3;
  pDocNumber ALIAS FOR $4;
  pAccntid ALIAS FOR $5;
  pAmount ALIAS FOR $6;
  pDistDate ALIAS FOR $7;
  pNotes ALIAS FOR $8;
  pMiscid ALIAS FOR $9;
  _glseriesid INTEGER;

BEGIN

--  Check GL Interface metric
  IF (fetchMetricBool('InterfaceToGL') = false AND pSource IN ('I/M', 'P/D', 'S/R', 'W/O')) THEN
    RETURN 0;
  END IF;
  IF (fetchMetricBool('InterfaceAPToGL') = false AND pSource = 'A/P') THEN
    RETURN 0;
  END IF;
  IF (fetchMetricBool('InterfaceARToGL') = false AND pSource IN ('A/R', 'S/O', 'S/R')) THEN
    RETURN 0;
  END IF;

--  Verify the target accnt
  IF ( (pAccntid IS NULL) OR (pAccntid = -1) ) THEN
    RETURN -1;
  END IF;

-- refuse to accept postings into closed periods
  IF (SELECT BOOL_AND(COALESCE(period_closed, FALSE))
      FROM accnt LEFT OUTER JOIN
           period ON (pDistDate BETWEEN period_start AND period_end)
      WHERE (accnt_id = pAccntid)) THEN
    RAISE EXCEPTION 'Cannot post to closed period (%).', pDistDate;
    RETURN -4;  -- remove raise exception when all callers check return code
  END IF;

-- refuse to accept postings into frozen periods without proper priv
  IF (SELECT NOT BOOL_AND(checkPrivilege('PostFrozenPeriod')) AND
             BOOL_AND(COALESCE(period_freeze, FALSE))
      FROM accnt LEFT OUTER JOIN
           period ON (pDistDate BETWEEN period_start AND period_end)
      WHERE (accnt_id = pAccntid)) THEN
    RAISE EXCEPTION 'Cannot post to frozen period (%).', pDistDate;
    RETURN -4;  -- remove raise exception when all callers check return code
  END IF;

-- refuse to accept postings into nonexistent periods
  IF NOT EXISTS(SELECT period_id
                FROM period
                WHERE (pDistDate BETWEEN period_start AND period_end)) THEN
    RAISE EXCEPTION 'Cannot post to nonexistent period (%).', pDistDate;
  END IF;

-- Insert into the glseries
  SELECT NEXTVAL('glseries_glseries_id_seq') INTO _glseriesid;
  INSERT INTO glseries
  ( glseries_id, glseries_sequence, glseries_source, glseries_doctype, glseries_docnumber,
    glseries_accnt_id, glseries_amount, glseries_distdate, glseries_notes, glseries_misc_id )
  VALUES
  ( _glseriesid, pSequence, pSource, pDocType, pDocNumber,
    pAccntid, pAmount, pDistDate, pNotes, pMiscid );

  RETURN _glseriesid;

END;
$_$;


ALTER FUNCTION public.insertintoglseries(integer, text, text, text, integer, numeric, date, text, integer) OWNER TO admin;

--
-- TOC entry 224 (class 1259 OID 146566573)
-- Dependencies: 6022 6023 6024 6026 8
-- Name: invchead; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE invchead (
    invchead_id integer NOT NULL,
    invchead_cust_id integer NOT NULL,
    invchead_shipto_id integer,
    invchead_ordernumber text,
    invchead_orderdate date,
    invchead_posted boolean NOT NULL,
    invchead_printed boolean NOT NULL,
    invchead_invcnumber text NOT NULL,
    invchead_invcdate date NOT NULL,
    invchead_shipdate date,
    invchead_ponumber text,
    invchead_shipvia text,
    invchead_fob text,
    invchead_billto_name text,
    invchead_billto_address1 text,
    invchead_billto_address2 text,
    invchead_billto_address3 text,
    invchead_billto_city text,
    invchead_billto_state text,
    invchead_billto_zipcode text,
    invchead_billto_phone text,
    invchead_shipto_name text,
    invchead_shipto_address1 text,
    invchead_shipto_address2 text,
    invchead_shipto_address3 text,
    invchead_shipto_city text,
    invchead_shipto_state text,
    invchead_shipto_zipcode text,
    invchead_shipto_phone text,
    invchead_salesrep_id integer,
    invchead_commission numeric(20,10) NOT NULL,
    invchead_terms_id integer,
    invchead_freight numeric(16,2) NOT NULL,
    invchead_misc_amount numeric(16,2) NOT NULL,
    invchead_misc_descrip text,
    invchead_misc_accnt_id integer,
    invchead_payment numeric(16,2),
    invchead_paymentref text,
    invchead_notes text,
    invchead_billto_country text,
    invchead_shipto_country text,
    invchead_prj_id integer,
    invchead_curr_id integer DEFAULT basecurrid(),
    invchead_gldistdate date,
    invchead_recurring boolean DEFAULT false NOT NULL,
    invchead_recurring_interval integer,
    invchead_recurring_type text,
    invchead_recurring_until date,
    invchead_recurring_invchead_id integer,
    invchead_shipchrg_id integer,
    invchead_taxzone_id integer,
    invchead_void boolean DEFAULT false,
    invchead_saletype_id integer,
    invchead_shipzone_id integer,
    CONSTRAINT invchead_invchead_invcnumber_check CHECK ((invchead_invcnumber <> ''::text))
);


ALTER TABLE public.invchead OWNER TO admin;


--
-- TOC entry 225 (class 1259 OID 146566583)
-- Dependencies: 6028 6029 8
-- Name: prj; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE prj (
    prj_id integer NOT NULL,
    prj_number text NOT NULL,
    prj_name text NOT NULL,
    prj_descrip text,
    prj_status character(1) NOT NULL,
    prj_so boolean,
    prj_wo boolean,
    prj_po boolean,
    prj_owner_username text,
    prj_start_date date,
    prj_due_date date,
    prj_assigned_date date,
    prj_completed_date date,
    prj_username text,
    prj_recurring_prj_id integer,
    prj_crmacct_id integer,
    prj_cntct_id integer,
    prj_prjtype_id integer,
    CONSTRAINT prj_prj_number_check CHECK ((prj_number <> ''::text)),
    CONSTRAINT prj_prj_status_check CHECK ((prj_status = ANY (ARRAY['P'::bpchar, 'O'::bpchar, 'C'::bpchar])))
);


ALTER TABLE public.prj OWNER TO admin;


--
-- TOC entry 226 (class 1259 OID 146566591)
-- Dependencies: 6031 8
-- Name: saletype; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE saletype (
    saletype_id integer NOT NULL,
    saletype_code text NOT NULL,
    saletype_descr text,
    saletype_active boolean DEFAULT true NOT NULL
);


ALTER TABLE public.saletype OWNER TO admin;


--
-- TOC entry 227 (class 1259 OID 146566598)
-- Dependencies: 6032 6033 8
-- Name: shipzone; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE shipzone (
    shipzone_id integer DEFAULT nextval(('shipzone_shipzone_id_seq'::text)::regclass) NOT NULL,
    shipzone_name text NOT NULL,
    shipzone_descrip text,
    CONSTRAINT shipzone_shipzone_name_check CHECK ((shipzone_name <> ''::text))
);


ALTER TABLE public.shipzone OWNER TO admin;

--
-- TOC entry 9056 (class 0 OID 0)
-- Dependencies: 227
-- Name: TABLE shipzone; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE shipzone IS 'Shipping Zone information';


SET search_path = api, pg_catalog;

--
-- TOC entry 228 (class 1259 OID 146566606)
-- Dependencies: 8475 6
-- Name: invoice; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW invoice AS
    SELECT invchead.invchead_invcnumber AS invoice_number, invchead.invchead_ordernumber AS order_number, invchead.invchead_invcdate AS invoice_date, invchead.invchead_shipdate AS ship_date, invchead.invchead_orderdate AS order_date, saletype.saletype_code AS sale_type, salesrep.salesrep_number AS sales_rep, invchead.invchead_commission AS commission, COALESCE(taxzone.taxzone_code, 'None'::text) AS tax_zone, terms.terms_code AS terms, custinfo.cust_number AS customer_number, invchead.invchead_billto_name AS billto_name, invchead.invchead_billto_address1 AS billto_address1, invchead.invchead_billto_address2 AS billto_address2, invchead.invchead_billto_address3 AS billto_address3, invchead.invchead_billto_city AS billto_city, invchead.invchead_billto_state AS billto_state, invchead.invchead_billto_zipcode AS billto_postal_code, invchead.invchead_billto_country AS billto_country, invchead.invchead_billto_phone AS billto_phone, shiptoinfo.shipto_num AS shipto_number, invchead.invchead_shipto_name AS shipto_name, invchead.invchead_shipto_address1 AS shipto_address1, invchead.invchead_shipto_address2 AS shipto_address2, invchead.invchead_shipto_address3 AS shipto_address3, invchead.invchead_shipto_city AS shipto_city, invchead.invchead_shipto_state AS shipto_state, invchead.invchead_shipto_zipcode AS shipto_postal_code, invchead.invchead_shipto_country AS shipto_country, shipzone.shipzone_name AS shipto_shipzone, invchead.invchead_shipto_phone AS shipto_phone, invchead.invchead_ponumber AS po_number, invchead.invchead_shipvia AS ship_via, prj.prj_number AS project_number, invchead.invchead_fob AS fob, invchead.invchead_misc_descrip AS misc_charge_description, invchead.invchead_misc_amount AS misc_charge, CASE WHEN (invchead.invchead_misc_accnt_id = (-1)) THEN NULL::text ELSE public.formatglaccount(invchead.invchead_misc_accnt_id) END AS misc_charge_account_number, invchead.invchead_freight AS freight, curr.curr_abbr AS currency, invchead.invchead_payment AS payment, invchead.invchead_notes AS notes FROM (((((((((public.invchead LEFT JOIN public.custinfo ON ((custinfo.cust_id = invchead.invchead_cust_id))) LEFT JOIN public.shiptoinfo ON ((shiptoinfo.shipto_id = invchead.invchead_shipto_id))) LEFT JOIN public.prj ON ((prj.prj_id = invchead.invchead_prj_id))) LEFT JOIN public.curr_symbol curr ON ((curr.curr_id = invchead.invchead_curr_id))) LEFT JOIN public.salesrep ON ((salesrep.salesrep_id = invchead.invchead_salesrep_id))) LEFT JOIN public.terms ON ((terms.terms_id = invchead.invchead_terms_id))) LEFT JOIN public.taxzone ON ((taxzone.taxzone_id = invchead.invchead_taxzone_id))) LEFT JOIN public.saletype ON ((invchead.invchead_saletype_id = saletype.saletype_id))) LEFT JOIN public.shipzone ON ((invchead.invchead_shipzone_id = shipzone.shipzone_id)));


ALTER TABLE api.invoice OWNER TO admin;

--
-- TOC entry 9058 (class 0 OID 0)
-- Dependencies: 228
-- Name: VIEW invoice; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW invoice IS '
This view can be used as an interface to import Invioce Header data directly
into the system.  Required fields will be checked and default values will be
populated';


SET search_path = public, pg_catalog;

--
-- TOC entry 1829 (class 1255 OID 146566611)
-- Dependencies: 2868 4536 8
-- Name: insertinvoice(api.invoice); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION insertinvoice(api.invoice) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
	pNew ALIAS FOR $1;
BEGIN
	-- NOTE: (SELECT getCustId(...)) seems redundant, but it actually produces
	-- a HUGE performance increase because it makes the Postgres query planner
	-- use an index scan rather than an sequential table scan on cust_id
	INSERT INTO invchead (
		invchead_invcnumber,
		invchead_ordernumber,
		invchead_invcdate,
		invchead_shipdate,
		invchead_orderdate,
		invchead_printed,
		invchead_posted,
		invchead_salesrep_id,
		invchead_commission,
		invchead_taxzone_id,
		invchead_terms_id,
		invchead_cust_id,
		invchead_billto_name,
		invchead_billto_address1,
		invchead_billto_address2,
		invchead_billto_address3,
		invchead_billto_city,
		invchead_billto_state,
		invchead_billto_zipcode,
		invchead_billto_country,
		invchead_billto_phone,
		invchead_shipto_id,
		invchead_shipto_name,
		invchead_shipto_address1,
		invchead_shipto_address2,
		invchead_shipto_address3,
		invchead_shipto_city,
		invchead_shipto_state,
		invchead_shipto_zipcode,
		invchead_shipto_country,
		invchead_shipto_phone,
		invchead_ponumber,
		invchead_shipvia,
		invchead_prj_id,
		invchead_fob,
		invchead_misc_descrip,
		invchead_misc_amount,
		invchead_misc_accnt_id,
		invchead_freight,
		invchead_curr_id,
		invchead_payment,
		invchead_notes,
                invchead_saletype_id,
                invchead_shipzone_id
	) SELECT
		(CASE -- use a case here so we don't unnecessarily fetch a new invoice number
			WHEN pNew.invoice_number IS NULL THEN CAST(fetchInvcNumber() AS TEXT)
			WHEN pNew.invoice_number = '' THEN CAST(fetchInvcNumber() AS TEXT)
			ELSE pNew.invoice_number
		END),
		pNew.order_number,
		COALESCE(pNew.invoice_date, CURRENT_DATE),
		pNew.ship_date,
		pNew.order_date,
		FALSE,
		FALSE,
		COALESCE(getSalesRepId(pNew.sales_rep),shipto_salesrep_id,cust_salesrep_id),
		COALESCE(pNew.commission, 0),
		CASE
			WHEN pNew.tax_zone = 'None' THEN NULL
			ELSE COALESCE(getTaxZoneId(pNew.tax_zone),shipto_taxzone_id,cust_taxzone_id)
		END,
		COALESCE(getTermsId(pNew.terms),cust_terms_id),
		(SELECT getCustId(pNew.customer_number)),
		COALESCE(pNew.billto_name, cohead_billtoname, cust_name),
		COALESCE(pNew.billto_address1, cohead_billtoaddress1, addr_line1),
		COALESCE(pNew.billto_address2, cohead_billtoaddress2, addr_line2),
		COALESCE(pNew.billto_address3, cohead_billtoaddress3, addr_line3),
		COALESCE(pNew.billto_city, cohead_billtocity, addr_city),
		COALESCE(pNew.billto_state, cohead_billtostate, addr_state),
		COALESCE(pNew.billto_postal_code, cohead_billtozipcode, addr_postalcode),
		COALESCE(pNew.billto_country, cohead_billtocountry, addr_country),
		COALESCE(pNew.billto_phone, ''),
		COALESCE(shipto_id,-1),
		pNew.shipto_name,
		pNew.shipto_address1,
		pNew.shipto_address2,
		pNew.shipto_address3,
		pNew.shipto_city,
		pNew.shipto_state,
		pNew.shipto_postal_code,
		pNew.shipto_country,
		pNew.shipto_phone,
		COALESCE(pNew.po_number, ''),
		COALESCE(pNew.ship_via,shipto_shipvia,cust_shipvia),
		COALESCE(getPrjId(pNew.project_number),-1),
		COALESCE(pNew.fob,fetchDefaultFob((
			SELECT CAST(usrpref_value AS INTEGER)
			FROM usrpref, whsinfo
			WHERE ((warehous_id=CAST(usrpref_value AS INTEGER))
				AND (warehous_shipping)
				AND (warehous_active)
				AND (usrpref_username=getEffectiveXtUser())
				AND (usrpref_name='PreferredWarehouse')
			)
		))),
		pNew.misc_charge_description,
		COALESCE(pNew.misc_charge, 0),
		COALESCE(getGlAccntId(pNew.misc_charge_account_number),-1),
		COALESCE(pNew.freight, 0),
		COALESCE(getCurrId(pNew.currency),(
			SELECT cust_curr_id
			FROM custinfo
			WHERE (cust_id=(SELECT getCustId(pNew.customer_number)))
		),basecurrid()),
		COALESCE(pNew.payment,0),
		COALESCE(pNew.notes,''),
                getSaleTypeId(pNew.sale_type),
                getShipZoneId(pNew.shipto_shipzone)
	FROM custinfo
		LEFT OUTER JOIN shiptoinfo ON (shipto_id=(SELECT CASE
			WHEN getShiptoId(pNew.customer_number,pNew.shipto_number) IS NOT NULL
				THEN getShiptoId(pNew.customer_number,pNew.shipto_number)
			ELSE (SELECT shipto_id FROM shiptoinfo WHERE shipto_cust_id=cust_id AND shipto_default)
		END))
               LEFT OUTER JOIN cohead ON (cohead_number=pNEW.order_number)
               LEFT OUTER JOIN cntct ON (cntct_id=cust_cntct_id)
               LEFT OUTER JOIN addr ON (addr_id=cntct_addr_id)
	WHERE cust_id = (SELECT getCustId(pNew.customer_number));
	RETURN TRUE;
END;
$_$;


ALTER FUNCTION public.insertinvoice(api.invoice) OWNER TO admin;

--
-- TOC entry 229 (class 1259 OID 146566612)
-- Dependencies: 6035 6036 8
-- Name: invcitem; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE invcitem (
    invcitem_id integer NOT NULL,
    invcitem_invchead_id integer NOT NULL,
    invcitem_linenumber integer,
    invcitem_item_id integer,
    invcitem_warehous_id integer DEFAULT (-1),
    invcitem_custpn text,
    invcitem_number text,
    invcitem_descrip text,
    invcitem_ordered numeric(20,6) NOT NULL,
    invcitem_billed numeric(20,6) NOT NULL,
    invcitem_custprice numeric(20,4),
    invcitem_price numeric(20,4) NOT NULL,
    invcitem_notes text,
    invcitem_salescat_id integer,
    invcitem_taxtype_id integer,
    invcitem_qty_uom_id integer,
    invcitem_qty_invuomratio numeric(20,10) NOT NULL,
    invcitem_price_uom_id integer,
    invcitem_price_invuomratio numeric(20,10) NOT NULL,
    invcitem_coitem_id integer,
    invcitem_updateinv boolean DEFAULT false,
    invcitem_rev_accnt_id integer
);


ALTER TABLE public.invcitem OWNER TO admin;


SET search_path = api, pg_catalog;

--
-- TOC entry 230 (class 1259 OID 146566620)
-- Dependencies: 8476 6
-- Name: invoiceline; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW invoiceline AS
    SELECT invchead.invchead_invcnumber AS invoice_number, invcitem.invcitem_linenumber AS line_number, item.item_number, invcitem.invcitem_number AS misc_item_number, whsinfo.warehous_code AS site, invcitem.invcitem_descrip AS misc_item_description, salescat.salescat_name AS sales_category, invcitem.invcitem_custpn AS customer_part_number, invcitem.invcitem_ordered AS qty_ordered, invcitem.invcitem_billed AS qty_billed, invcitem.invcitem_updateinv AS update_inventory, invcitem.invcitem_price AS net_unit_price, COALESCE(taxtype.taxtype_name, 'None'::text) AS tax_type, COALESCE(qty_uom.uom_name, 'None'::text) AS qty_uom, COALESCE(price_uom.uom_name, 'None'::text) AS price_uom, invcitem.invcitem_notes AS notes, CASE WHEN (invcitem.invcitem_rev_accnt_id IS NOT NULL) THEN public.formatglaccount(invcitem.invcitem_rev_accnt_id) ELSE NULL::text END AS alternate_rev_account FROM (((((((public.invcitem LEFT JOIN public.invchead ON ((invcitem.invcitem_invchead_id = invchead.invchead_id))) LEFT JOIN public.item ON ((item.item_id = invcitem.invcitem_item_id))) LEFT JOIN public.whsinfo ON ((invcitem.invcitem_warehous_id = whsinfo.warehous_id))) LEFT JOIN public.salescat ON ((salescat.salescat_id = invcitem.invcitem_salescat_id))) LEFT JOIN public.taxtype ON ((taxtype.taxtype_id = invcitem.invcitem_taxtype_id))) LEFT JOIN public.uom qty_uom ON ((qty_uom.uom_id = invcitem.invcitem_qty_uom_id))) LEFT JOIN public.uom price_uom ON ((price_uom.uom_id = invcitem.invcitem_price_uom_id)));


ALTER TABLE api.invoiceline OWNER TO admin;

--
-- TOC entry 9062 (class 0 OID 0)
-- Dependencies: 230
-- Name: VIEW invoiceline; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW invoiceline IS '
This view can be used as an interface to import Invoice Line Items data directly
into the system.  Required fields will be checked and default values will be
populated';


SET search_path = public, pg_catalog;

--
-- TOC entry 1830 (class 1255 OID 146566625)
-- Dependencies: 2875 4536 8
-- Name: insertinvoicelineitem(api.invoiceline); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION insertinvoicelineitem(api.invoiceline) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
	pNew ALIAS FOR $1;
	_r RECORD;
BEGIN
	INSERT INTO invcitem (
		invcitem_invchead_id,
		invcitem_linenumber,
		invcitem_item_id,
		invcitem_warehous_id,
		invcitem_custpn,
		invcitem_number,
		invcitem_descrip,
		invcitem_ordered,
		invcitem_billed,
                invcitem_updateinv,
		invcitem_custprice,
		invcitem_price,
		invcitem_notes,
		invcitem_salescat_id,
		invcitem_taxtype_id,
		invcitem_qty_uom_id,
		invcitem_qty_invuomratio,
		invcitem_price_uom_id,
		invcitem_price_invuomratio,
                invcitem_rev_accnt_id
	) SELECT
		invchead_id,
		COALESCE(pNew.line_number,(
			SELECT (COALESCE(MAX(invcitem_linenumber), 0) + 1)
			FROM invcitem WHERE (invcitem_invchead_id=invchead_id)
		)),
		COALESCE(item_id, -1),
		COALESCE(getwarehousid(pNew.site,'ALL'),-1),
		pNew.customer_part_number,
		(CASE WHEN item_id IS NULL THEN pNew.misc_item_number ELSE NULL END),
		(CASE WHEN item_id IS NULL THEN pNew.misc_item_description ELSE NULL END),
		pNew.qty_ordered,
		COALESCE(pNew.qty_billed, 0),
                COALESCE(pNew.update_inventory,FALSE),
		0, -- invcitem_custprice
		COALESCE(pNew.net_unit_price,itemPrice(item_id,invchead_cust_id,
			invchead_shipto_id,pNew.qty_ordered,invchead_curr_id,invchead_orderdate)),
		COALESCE(pNew.notes,''),
		CASE
			WHEN item_id IS NULL THEN
				(SELECT salescat_id FROM salescat WHERE salescat_name = pNew.sales_category)
			ELSE NULL
		END,
		taxtype_id,
		CASE
			WHEN item_id IS NOT NULL THEN
				COALESCE((SELECT uom_id FROM uom WHERE (uom_name=pNew.qty_uom)), item_price_uom_id)
			ELSE NULL
		END,
		CASE
			WHEN item_id IS NOT NULL THEN
				itemuomtouomratio(item_id,
					COALESCE((SELECT uom_id FROM uom WHERE uom_name=pNew.qty_uom),item_price_uom_id),
					item_price_uom_id
				)
			ELSE 1
		END,
		CASE
			WHEN item_id IS NOT NULL THEN
				COALESCE((SELECT uom_id FROM uom WHERE uom_name=pNew.price_uom),item_price_uom_id)
			ELSE NULL
		END,
		CASE
			WHEN item_id IS NOT NULL THEN
				itemuomtouomratio(item_id,
					COALESCE((SELECT uom_id FROM uom WHERE uom_name=pNew.price_uom),item_price_uom_id),
					item_price_uom_id
				)
			ELSE 1
		END,
                getGlAccntId(pNew.alternate_rev_account)
	FROM invchead
		LEFT OUTER JOIN item ON (item_id=getItemId(pNew.item_number))
		LEFT OUTER JOIN taxtype ON (taxtype_id=CASE
			WHEN pNew.tax_type IS NULL THEN getItemTaxType(item_id,invchead_taxzone_id)
			WHEN pNew.tax_type = 'None' THEN NULL
			ELSE (SELECT taxtype_id FROM taxtype WHERE taxtype_name=pNew.tax_type)
		END)
	WHERE (invchead_invcnumber=pNew.invoice_number) AND (invchead_posted=FALSE);
	RETURN TRUE;
END;
$_$;


ALTER FUNCTION public.insertinvoicelineitem(api.invoiceline) OWNER TO admin;

--
-- TOC entry 1831 (class 1255 OID 146566626)
-- Dependencies: 4536 8
-- Name: insertitemcost(integer, integer, integer, numeric, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION insertitemcost(integer, integer, integer, numeric, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
pItemId ALIAS FOR $1;
pCostElemId ALIAS FOR $2;
pCurrId ALIAS FOR $3;
pCost ALIAS FOR $4;
pPostToStandard ALIAS FOR $5;
_itemcost_id INTEGER;
_update_return INTEGER;
_postcost_return BOOLEAN;

--This function is used with the api.itemcost View for updating and inserting
--into the itemcosts table

BEGIN
  IF (pCost IS NULL OR pCost < 0) THEN
    RAISE EXCEPTION 'itemcost Actual Cost Invalid ', pCost;
  END IF;

-- Check for uniqueness
  SELECT itemcost_id INTO _itemcost_id
  FROM itemcost
  WHERE ( (itemcost_item_id = pItemId)
    AND   (itemcost_costelem_id = pCostElemId)
    AND   (NOT itemcost_lowlevel) );
  IF (FOUND) THEN
    RAISE EXCEPTION 'itemcost already exists for this Item and Cost Element';
  END IF;

-- Check for valid combination of item_type and costelem_type
  IF (SELECT (COUNT(*) > 0)
      FROM item, costelem
      WHERE (item_id=pItemId)
        AND (costelem_id=pCostElemId)
        AND (item_type IN ('M', 'F', 'B', 'C', 'T'))
        AND (costelem_type IN ('Material'))) THEN
    RAISE EXCEPTION 'itemcost of this type is invalid for Manufactured Item';
  END IF;

  IF (SELECT (COUNT(*) > 0)
      FROM item, costelem
      WHERE (item_id=pItemId)
        AND (costelem_id=pCostElemId)
        AND (item_type IN ('O', 'P'))
        AND (costelem_type IN ('Direct Labor', 'Overhead', 'Machine Overhead'))) THEN
    RAISE EXCEPTION 'itemcost of this type is invalid for Purchased Item';
  END IF;

  IF (pCost > 0) THEN
    SELECT NEXTVAL('itemcost_itemcost_id_seq') INTO _itemcost_id;
    INSERT INTO itemcost
      ( itemcost_id, itemcost_item_id, itemcost_costelem_id, itemcost_lowlevel,
        itemcost_stdcost, itemcost_posted, itemcost_actcost, itemcost_updated, itemcost_curr_id )
    VALUES
      ( _itemcost_id, pItemId, pCostElemId, FALSE,
        0, startOfTime(), pCost, CURRENT_DATE, pCurrId );

    --Only Post Cost to standard if the parameter is set to true
    IF (pPostToStandard) THEN
      IF (NOT checkPrivilege('PostStandardCosts')) THEN
        RAISE EXCEPTION 'You do not have privileges to poststandard itemcosts. Set api.itemcost post_to_standard to false';
      END IF;
      SELECT postcost(_itemcost_id) INTO _postcost_return;
      IF (NOT _postcost_return) THEN
        RETURN -2;
      END IF;
    END IF;
  ELSE
    RETURN -1;
  END IF;

  RETURN _itemcost_id;

END;
$_$;


ALTER FUNCTION public.insertitemcost(integer, integer, integer, numeric, boolean) OWNER TO admin;

--
-- TOC entry 1832 (class 1255 OID 146566627)
-- Dependencies: 2767 4536 8
-- Name: insertsalesline(api.salesline); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION insertsalesline(api.salesline) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2012 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pNEW ALIAS FOR $1;
  _r RECORD;

BEGIN

  IF (NOT EXISTS (SELECT cohead_id FROM cohead WHERE cohead_number=pNEW.order_number)) THEN
    RAISE EXCEPTION 'Function insertSalesLine failed because Sales Order % not found', pNEW.order_number;
  END IF;

  IF (NOT EXISTS (SELECT item_id FROM item WHERE item_number=pNEW.item_number)) THEN
    RAISE EXCEPTION 'Function insertSalesLine failed because Item Number % not found', pNEW.item_number;
  END IF;

  SELECT * INTO _r
  FROM cohead, itemsite, item, whsinfo
  WHERE ((cohead_number=pNEW.order_number)
  AND (itemsite_warehous_id=warehous_id
  AND (itemsite_item_id=item_id)
  AND (itemsite_active)
  AND (item_number=pNEW.item_number)
  AND (warehous_active)
  AND (warehous_id=COALESCE(getWarehousId(pNEW.sold_from_site,'ALL'),cohead_warehous_id,fetchprefwarehousid()))));

  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Function insertSalesLine failed with unknown failure to retrieve Sales Order';
  END IF;

  INSERT INTO coitem (
    coitem_cohead_id,
    coitem_linenumber,
    coitem_itemsite_id,
    coitem_status,
    coitem_scheddate,
    coitem_promdate,
    coitem_qtyord,
    coitem_qty_uom_id,
    coitem_qty_invuomratio,
    coitem_qtyshipped,
    coitem_unitcost,
    coitem_price,
    coitem_price_uom_id,
    coitem_price_invuomratio,
    coitem_custprice,
    coitem_order_id,
    coitem_memo,
    coitem_imported,
    coitem_qtyreturned,
    coitem_custpn,
    coitem_order_type,
    coitem_substitute_item_id,
    coitem_prcost,
    coitem_taxtype_id,
    coitem_warranty,
    coitem_cos_accnt_id,
    coitem_rev_accnt_id)
  VALUES (
    _r.cohead_id,
    pNEW.line_number::INTEGER,
    _r.itemsite_id,
    pNEW.status,
    pNEW.scheduled_date,
    pNEW.promise_date,
    pNEW.qty_ordered,
    COALESCE(getUomId(pNEW.qty_uom),_r.item_inv_uom_id),
    itemuomtouomratio(_r.item_id,COALESCE(getUomId(pNEW.qty_uom),_r.item_inv_uom_id),_r.item_inv_uom_id),
    0,
    stdCost(_r.item_id),
    COALESCE(pNEW.net_unit_price,itemPrice(_r.item_id,_r.cohead_cust_id,
             _r.cohead_shipto_id,pNEW.qty_ordered,_r.cohead_curr_id,_r.cohead_orderdate)),
    COALESCE(getUomId(pNEW.price_uom),_r.item_price_uom_id),
    itemuomtouomratio(_r.item_id,COALESCE(getUomId(pNEW.price_uom),_r.item_price_uom_id),_r.item_price_uom_id),
    itemPrice(_r.item_id,_r.cohead_cust_id,_r.cohead_shipto_id,pNEW.qty_ordered,_r.cohead_curr_id,_r.cohead_orderdate),
    -1,
    pNEW.notes,
    true,
    0,
    pNEW.customer_pn,
    CASE
      WHEN ((pNEW.create_order  AND (_r.item_type = 'M')) OR
           ((pNEW.create_order IS NULL) AND _r.itemsite_createwo)) THEN
        'W'
      WHEN ((pNEW.create_order AND (_r.item_type = 'P')) OR
           ((pNEW.create_order IS NULL) AND _r.itemsite_createsopr)) THEN
        'R'
      WHEN ((pNEW.create_order AND (_r.item_type = 'P') AND (_r.itemsite_createsopo)) OR
           ((pNEW.create_order IS NULL) AND _r.itemsite_createsopo)) THEN
        'P'
    END,
    getitemid(pNEW.substitute_for),
    pNEW.overwrite_po_price,
    COALESCE(getTaxTypeId(pNEW.tax_type), getItemTaxType(_r.itemsite_item_id, _r.cohead_taxzone_id)),
    pNEW.warranty,
    getGlAccntId(pNEW.alternate_cos_account),
    getGlAccntId(pNEW.alternate_rev_account)
    );

  RETURN TRUE;
END;
$_$;


ALTER FUNCTION public.insertsalesline(api.salesline) OWNER TO admin;

--
-- TOC entry 1833 (class 1255 OID 146566628)
-- Dependencies: 8
-- Name: intervaltominutes(interval); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION intervaltominutes(interval) RETURNS numeric
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT (EXTRACT(DAY FROM $1) * 24 * 60 +
          EXTRACT(HOUR FROM $1) * 60 +
          EXTRACT(MINUTE FROM $1) +
          ROUND((EXTRACT(SECOND FROM $1) / 60)::NUMERIC, 4))::NUMERIC AS result
$_$;


ALTER FUNCTION public.intervaltominutes(interval) OWNER TO admin;

--
-- TOC entry 1834 (class 1255 OID 146566629)
-- Dependencies: 4536 8
-- Name: invadjustment(integer, numeric, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION invadjustment(integer, numeric, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN invAdjustment($1, $2, $3, $4, CURRENT_TIMESTAMP, NULL);
END;
$_$;


ALTER FUNCTION public.invadjustment(integer, numeric, text, text) OWNER TO admin;

--
-- TOC entry 1835 (class 1255 OID 146566630)
-- Dependencies: 4536 8
-- Name: invadjustment(integer, numeric, text, text, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION invadjustment(integer, numeric, text, text, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN invAdjustment($1, $2, $3, $4, $5, NULL);
END;
$_$;


ALTER FUNCTION public.invadjustment(integer, numeric, text, text, timestamp with time zone) OWNER TO admin;

--
-- TOC entry 1837 (class 1255 OID 146566631)
-- Dependencies: 4536 8
-- Name: invadjustment(integer, numeric, text, text, timestamp with time zone, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION invadjustment(integer, numeric, text, text, timestamp with time zone, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid     ALIAS FOR $1;
  pQty            ALIAS FOR $2;
  pDocumentNumber ALIAS FOR $3;
  pComments       ALIAS FOR $4;
  pGlDistTS       ALIAS FOR $5;
  pCostValue      ALIAS FOR $6;
  _invhistid      INTEGER;
  _itemlocSeries  INTEGER;

BEGIN

--  Make sure the passed itemsite points to a real item
  IF ( ( SELECT (item_type IN ('R', 'F') OR itemsite_costmethod = 'J')
         FROM itemsite, item
         WHERE ( (itemsite_item_id=item_id)
          AND (itemsite_id=pItemsiteid) ) ) ) THEN
    RETURN 0;
  END IF;

  SELECT NEXTVAL('itemloc_series_seq') INTO _itemlocSeries;
  SELECT postInvTrans( itemsite_id, 'AD', pQty,
                       'I/M', 'AD', pDocumentNumber, '',
                       ('Miscellaneous Adjustment for item ' || item_number || E'\n' ||  pComments),
                       costcat_asset_accnt_id, costcat_adjustment_accnt_id,
                       _itemlocSeries, pGlDistTS, pCostValue) INTO _invhistid
  FROM itemsite, item, costcat
  WHERE ( (itemsite_item_id=item_id)
   AND (itemsite_costcat_id=costcat_id)
   AND (itemsite_id=pItemsiteid) );

  RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.invadjustment(integer, numeric, text, text, timestamp with time zone, numeric) OWNER TO admin;

--
-- TOC entry 1838 (class 1255 OID 146566632)
-- Dependencies: 4536 8
-- Name: invexpense(integer, numeric, integer, text, text, timestamp with time zone, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION invexpense(pitemsiteid integer, pqty numeric, pexpcatid integer, pdocumentnumber text, pcomments text, pgldistts timestamp with time zone DEFAULT now(), pprjid integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _invhistid INTEGER;
  _itemlocSeries INTEGER;

BEGIN

  --  Make sure the passed itemsite points to a real item
  IF ( ( SELECT (item_type IN ('R', 'F') OR itemsite_costmethod = 'J')
         FROM itemsite, item
         WHERE ( (itemsite_item_id=item_id)
          AND (itemsite_id=pItemsiteid) ) ) ) THEN
    RETURN 0;
  END IF;

  SELECT NEXTVAL('itemloc_series_seq') INTO _itemlocSeries;
  SELECT postInvTrans( itemsite_id, 'EX', pQty,
                       'I/M', 'EX', pDocumentNumber, '',
                       CASE WHEN (pQty < 0) THEN ('Reverse Material Expense for item ' || item_number || E'\n' ||  pComments)
                            ELSE  ('Material Expense for item ' || item_number || E'\n' ||  pComments)
                       END,
                       getPrjAccntId(pPrjid, expcat_exp_accnt_id), costcat_asset_accnt_id,
                       _itemlocSeries, pGlDistTS) INTO _invhistid
  FROM itemsite, item, costcat, expcat
  WHERE ( (itemsite_item_id=item_id)
   AND (itemsite_costcat_id=costcat_id)
   AND (itemsite_id=pItemsiteid)
   AND (expcat_id=pExpcatid) );

  INSERT INTO invhistexpcat (invhistexpcat_invhist_id, invhistexpcat_expcat_id)
                     VALUES (_invhistid,               pExpcatid);

  RETURN _itemlocSeries;

END;
$$;


ALTER FUNCTION public.invexpense(pitemsiteid integer, pqty numeric, pexpcatid integer, pdocumentnumber text, pcomments text, pgldistts timestamp with time zone, pprjid integer) OWNER TO admin;

--
-- TOC entry 1839 (class 1255 OID 146566633)
-- Dependencies: 4536 8
-- Name: invhistsense(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION invhistsense(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pInvhistId ALIAS FOR $1;
  _count INTEGER;
  _row RECORD;
  _sense INTEGER;
BEGIN

  SELECT invhist_transtype, invhist_ordnumber, itemsite_warehous_id
  INTO _row
  FROM invhist
    JOIN itemsite ON (itemsite_id=invhist_itemsite_id)
  WHERE (invhist_id=pInvhistId);

  GET DIAGNOSTICS _count = ROW_COUNT;
  IF (_count = 0) THEN
    RAISE EXCEPTION 'Record not found for invhist_id=%',pInvhistId;
  END IF;

  -- increase inventory: AD RM RT RP RR RS RX RB TR
  -- decrease inventory: IM IB IT SH SI EX RI
  -- TS and TR are special: shipShipment and recallShipment should not change
  -- QOH at the Transfer Order src whs (as this was done by issueToShipping)
  -- but postReceipt should change QOH at the transit whs
  IF (_row.invhist_transtype='TS') THEN
       _sense := CASE WHEN (SELECT tohead_trns_warehous_id=_row.itemsite_warehous_id
                                  FROM tohead
                                  WHERE (tohead_number=_row.invhist_ordnumber)) THEN -1
                ELSE 0
                END;
  ELSIF (_row.invhist_transtype='TR') THEN
      _sense := CASE WHEN (SELECT tohead_src_warehous_id=_row.itemsite_warehous_id
                                  FROM tohead
                                  WHERE (tohead_number=_row.invhist_ordnumber)) THEN 0
                ELSE 1
                END;
  ELSIF (_row.invhist_transtype IN ('IM', 'IB', 'IT', 'SH', 'SI', 'EX', 'RI')) THEN
      _sense := -1;
    ELSE
      _sense := 1;
    END IF;

  RETURN _sense;
END;
$_$;


ALTER FUNCTION public.invhistsense(integer) OWNER TO admin;

--
-- TOC entry 1840 (class 1255 OID 146566634)
-- Dependencies: 4536 8
-- Name: invhisttrig(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION invhisttrig() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

--  Need to allow 'temporary' negative for average costed item that has been frozen.
--  Check at itemsite after all of the transactions have been thawed will ensure
--  that final Qty On Hand is positive.
--  IF (NEW.invhist_qoh_after < 0 AND NEW.invhist_costmethod = 'A') THEN
--    RAISE EXCEPTION 'Invhist (%) is recording with average costing and is not allowed to have a negative quantity on hand.', NEW.invhist_id;
--  END IF;

  IF ( ( SELECT itemsite_freeze
         FROM itemsite
         WHERE (itemsite_id=NEW.invhist_itemsite_id) ) ) THEN
    NEW.invhist_posted = FALSE;
  END IF;

  -- never change the created timestamp, which defaults to CURRENT_TIMESTAMP
  IF (TG_OP != 'INSERT') THEN
    NEW.invhist_created = OLD.invhist_created;
  ELSE
    -- Always need a series id for distribution posting
    IF (NEW.invhist_series IS NULL) THEN
      RAISE EXCEPTION 'Column invhist_series may not be null.';
    END IF;
  END IF;

  RETURN NEW;

END;
$$;


ALTER FUNCTION public.invhisttrig() OWNER TO admin;

--
-- TOC entry 1841 (class 1255 OID 146566635)
-- Dependencies: 4536 8
-- Name: invoicetotal(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION invoicetotal(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pInvoiceId ALIAS FOR $1;
  _linesum   NUMERIC;
  _linetax   NUMERIC;
  _result    NUMERIC;
  _allocated NUMERIC;
  _posted    BOOLEAN;

BEGIN

  SELECT SUM(ROUND(COALESCE((invcitem_billed * invcitem_qty_invuomratio) *
                             (invcitem_price / COALESCE(invcitem_price_invuomratio,1)), 0),2))
                          INTO _linesum
  FROM invcitem
  WHERE (invcitem_invchead_id=pInvoiceId);

  -- TODO: why sum on the result of select round(sum(), 2)?
  SELECT SUM(tax) INTO _linetax
    FROM (SELECT ROUND(SUM(COALESCE(taxdetail_tax, 0)),2) AS tax
            FROM tax
            JOIN calculateTaxDetailSummary('I', pInvoiceId, 'T') ON (taxdetail_tax_id=tax_id)
	  GROUP BY tax_id) AS data;

  SELECT noNeg(invchead_freight + invchead_misc_amount + COALESCE(_linetax, 0) + COALESCE(_linesum, 0)),
         invchead_posted INTO _result, _posted
  FROM invchead
  WHERE (invchead_id=pInvoiceId);

  IF NOT FOUND THEN
    RETURN 0;
  END IF;

  IF (_posted) THEN
    SELECT COALESCE(SUM(currToCurr(arapply_curr_id, aropen_curr_id,
                                   arapply_applied, aropen_docdate)),0) INTO _allocated
     FROM arapply, aropen, invchead
    WHERE ( (invchead_posted)
      AND   (invchead_id=pInvoiceId)
      AND   (aropen_docnumber=invchead_invcnumber)
      AND   (aropen_doctype='I')
      AND   (arapply_target_aropen_id=aropen_id)
      AND   (arapply_reftype='S')
      AND   (invchead_posted) ) ;
  ELSE
    SELECT COALESCE(SUM(CASE WHEN((aropen_amount - aropen_paid) >=
                       currToCurr(aropenalloc_curr_id, aropen_curr_id,
                          aropenalloc_amount, aropen_docdate))
           THEN currToCurr(aropenalloc_curr_id, invchead_curr_id,
                   aropenalloc_amount, aropen_docdate)
           ELSE currToCurr(aropen_curr_id, invchead_curr_id,
                   aropen_amount - aropen_paid, aropen_docdate)
           END),0) INTO _allocated
     FROM invchead LEFT OUTER JOIN cohead ON (cohead_number=invchead_ordernumber)
                   JOIN aropenalloc ON ((aropenalloc_doctype='I' AND aropenalloc_doc_id=invchead_id) OR
                                        (aropenalloc_doctype='S' AND aropenalloc_doc_id=cohead_id))
                   JOIN aropen ON (aropen_id=aropenalloc_aropen_id AND (aropen_amount - aropen_paid) > 0.0)
    WHERE ( (NOT invchead_posted)
      AND   (invchead_id=pInvoiceId) );
  END IF;

  RETURN _result - COALESCE(_allocated, 0);

END;
$_$;


ALTER FUNCTION public.invoicetotal(integer) OWNER TO admin;

--
-- TOC entry 1811 (class 1255 OID 146566636)
-- Dependencies: 4536 8
-- Name: invreceipt(integer, numeric, text, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION invreceipt(integer, numeric, text, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN invReceipt($1, $2, $3, $4, $5, CURRENT_TIMESTAMP, NULL);
END;
$_$;


ALTER FUNCTION public.invreceipt(integer, numeric, text, text, text) OWNER TO admin;

--
-- TOC entry 1836 (class 1255 OID 146566637)
-- Dependencies: 4536 8
-- Name: invreceipt(integer, numeric, text, text, text, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION invreceipt(integer, numeric, text, text, text, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN invReceipt($1, $2, $3, $4, $5, $6, NULL);
END;
$_$;


ALTER FUNCTION public.invreceipt(integer, numeric, text, text, text, timestamp with time zone) OWNER TO admin;

--
-- TOC entry 1842 (class 1255 OID 146566638)
-- Dependencies: 4536 8
-- Name: invreceipt(integer, numeric, text, text, text, timestamp with time zone, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION invreceipt(integer, numeric, text, text, text, timestamp with time zone, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pQty ALIAS FOR $2;
  pOrdernumber ALIAS FOR $3;
  pDocumentNumber ALIAS FOR $4;
  pComments ALIAS FOR $5;
  pGlDistTS     ALIAS FOR $6;
  pCostValue ALIAS FOR $7;
  _invhistid INTEGER;
  _itemlocSeries INTEGER;

BEGIN

--  Make sure the passed itemsite points to a real item
  IF ( ( SELECT (item_type IN ('R', 'F') OR itemsite_costmethod = 'J')
         FROM itemsite, item
         WHERE ( (itemsite_item_id=item_id)
          AND (itemsite_id=pItemsiteid) ) ) ) THEN
    RETURN 0;
  END IF;

  SELECT NEXTVAL('itemloc_series_seq') INTO _itemlocSeries;
  SELECT postInvTrans( itemsite_id, 'RX', pQty,
                       'I/M', 'RX', pDocumentNumber, '',
                       ('Miscellaneous Receipt for item ' || item_number || E'\n' ||  pComments),
                       costcat_asset_accnt_id, costcat_liability_accnt_id,
                       _itemlocSeries, pGlDistTS, pCostValue) INTO _invhistid
  FROM itemsite, item, costcat
  WHERE ( (itemsite_item_id=item_id)
   AND (itemsite_costcat_id=costcat_id)
   AND (itemsite_id=pItemsiteid) );

  RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.invreceipt(integer, numeric, text, text, text, timestamp with time zone, numeric) OWNER TO admin;

--
-- TOC entry 1843 (class 1255 OID 146566639)
-- Dependencies: 4536 8
-- Name: invscrap(integer, numeric, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION invscrap(integer, numeric, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN invScrap($1, $2, $3, $4, CURRENT_TIMESTAMP);
END;
$_$;


ALTER FUNCTION public.invscrap(integer, numeric, text, text) OWNER TO admin;

--
-- TOC entry 1844 (class 1255 OID 146566640)
-- Dependencies: 4536 8
-- Name: invscrap(integer, numeric, text, text, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION invscrap(integer, numeric, text, text, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN invScrap($1, $2, $3, $4, $5, NULL);
END;
$_$;


ALTER FUNCTION public.invscrap(integer, numeric, text, text, timestamp with time zone) OWNER TO admin;

--
-- TOC entry 1845 (class 1255 OID 146566641)
-- Dependencies: 4536 8
-- Name: invscrap(integer, numeric, text, text, timestamp with time zone, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION invscrap(integer, numeric, text, text, timestamp with time zone, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN invScrap($1, $2, $3, $4, $5, $6, NULL);
END;
$_$;


ALTER FUNCTION public.invscrap(integer, numeric, text, text, timestamp with time zone, integer) OWNER TO admin;

--
-- TOC entry 1846 (class 1255 OID 146566642)
-- Dependencies: 4536 8
-- Name: invscrap(integer, numeric, text, text, timestamp with time zone, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION invscrap(integer, numeric, text, text, timestamp with time zone, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pQty ALIAS FOR $2;
  pDocumentNumber ALIAS FOR $3;
  pComments ALIAS FOR $4;
  pGlDistTS ALIAS FOR $5;
  pInvHistId ALIAS FOR $6;
  pPrjid ALIAS FOR $7;
  _invhistid INTEGER;
  _itemlocSeries INTEGER;

BEGIN

--  Make sure the passed itemsite points to a real item
  IF ( ( SELECT (item_type IN ('R', 'F') OR itemsite_costmethod = 'J')
         FROM itemsite, item
         WHERE ( (itemsite_item_id=item_id)
          AND (itemsite_id=pItemsiteid) ) ) ) THEN
    RETURN 0;
  END IF;

  IF (pInvHistId IS NOT NULL) THEN
    SELECT invhist_series INTO _itemlocSeries
    FROM invhist
    WHERE invhist_id=pInvHistId;
  ELSE
    SELECT NEXTVAL('itemloc_series_seq') INTO _itemlocSeries;
  END IF;

  SELECT postInvTrans( itemsite_id, 'SI', pQty,
                       'I/M', 'SI', pDocumentNumber, '',
                       CASE WHEN (pQty < 0) THEN ('Reverse Material Scrap for item ' || item_number || E'\n' ||  pComments)
                            ELSE ('Material Scrap for item ' || item_number || E'\n' ||  pComments)
                       END,
                       getPrjAccntId(pPrjid, costcat_scrap_accnt_id), costcat_asset_accnt_id,
                       _itemlocSeries, pGlDistTS, NULL, pInvHistId) INTO _invhistid
  FROM itemsite, item, costcat
  WHERE ( (itemsite_item_id=item_id)
   AND (itemsite_costcat_id=costcat_id)
   AND (itemsite_id=pItemsiteid) );

  RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.invscrap(integer, numeric, text, text, timestamp with time zone, integer, integer) OWNER TO admin;

--
-- TOC entry 1847 (class 1255 OID 146566643)
-- Dependencies: 8
-- Name: isdba(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION isdba(text DEFAULT NULL::text) RETURNS boolean
    LANGUAGE sql
    AS $_$
  SELECT (datdba=pg_roles.oid OR rolsuper) AS issuper
    FROM pg_database, pg_roles
  WHERE ((datname=current_database())
     AND (rolname=COALESCE($1, getEffectiveXtUser())));
$_$;


ALTER FUNCTION public.isdba(text) OWNER TO admin;

--
-- TOC entry 1848 (class 1255 OID 146566644)
-- Dependencies: 4536 8
-- Name: ismulticurr(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION ismulticurr() RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN (SELECT (count(*) > 1)
          FROM curr_symbol);
END;
$$;


ALTER FUNCTION public.ismulticurr() OWNER TO admin;

--
-- TOC entry 1849 (class 1255 OID 146566645)
-- Dependencies: 4536 8
-- Name: isnumeric(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION isnumeric(text) RETURNS boolean
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pText ALIAS FOR $1;
  _cursor INTEGER;

BEGIN

  IF ( (LENGTH(pText) = 0) OR (pText IS NULL) ) THEN
    RETURN FALSE;
  END IF;

  FOR _cursor IN 1..LENGTH(pText) LOOP
    IF (SUBSTRING(pText FROM _cursor FOR 1) NOT IN ( '0', '1', '2', '3', '4',
                                                     '5' ,'6' ,'7' ,'8' ,'9' )) THEN
      RETURN FALSE;
    END IF;
  END LOOP;

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.isnumeric(text) OWNER TO admin;

--
-- TOC entry 1850 (class 1255 OID 146566646)
-- Dependencies: 4536 8
-- Name: issueallbalancetoshipping(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION issueallbalancetoshipping(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN issueAllBalanceToShipping('SO', $1, 0, NULL);
END;
$_$;


ALTER FUNCTION public.issueallbalancetoshipping(integer) OWNER TO admin;

--
-- TOC entry 1855 (class 1255 OID 146566647)
-- Dependencies: 4536 8
-- Name: issueallbalancetoshipping(text, integer, integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION issueallbalancetoshipping(text, integer, integer, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pordertype		ALIAS FOR $1;
  pheadid		ALIAS FOR $2;
  _itemlocSeries	INTEGER 		 := $3;
  _timestamp		TIMESTAMP WITH TIME ZONE := $4;
  _s			RECORD;

BEGIN
  IF (pordertype = 'SO') THEN
    FOR _s IN SELECT coitem_id,
                     CASE WHEN (fetchMetricBool('RequireSOReservations'))
                          THEN coitem_qtyreserved
                          ELSE noNeg( coitem_qtyord - coitem_qtyshipped + coitem_qtyreturned - qtyAtShipping('SO', coitem_id) )
                     END AS _balance
	      FROM coitem LEFT OUTER JOIN (itemsite JOIN item ON (itemsite_item_id=item_id)) ON (coitem_itemsite_id=itemsite_id)
	      WHERE ( (coitem_status NOT IN ('C','X'))
                AND (item_type != 'K')
	       AND (coitem_cohead_id=pheadid) ) LOOP

      IF (_s.balance <> 0) THEN
	_itemlocSeries := issueToShipping(pordertype, _s.coitem_id, _s.balance, _itemlocSeries, _timestamp);
	IF (_itemlocSeries < 0) THEN
	  EXIT;
	END IF;
      END IF;
    END LOOP;

  ELSEIF (pordertype = 'TO') THEN
    FOR _s IN SELECT toitem_id,
                     noNeg( toitem_qty_ordered - toitem_qty_shipped - qtyAtShipping('TO', toitem_id) )
                      AS balance
	      FROM toitem
	      WHERE ( (toitem_status NOT IN ('C','X'))
	       AND (toitem_tohead_id=pheadid) ) LOOP

      IF (_s.balance <> 0) THEN
	_itemlocSeries := issueToShipping(pordertype, _s.toitem_id, _s.balance, _itemlocSeries, _timestamp);
	IF (_itemlocSeries < 0) THEN
	  EXIT;
	END IF;
      END IF;
    END LOOP;

  ELSE
    RETURN -1;
  END IF;

  RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.issueallbalancetoshipping(text, integer, integer, timestamp with time zone) OWNER TO admin;

--
-- TOC entry 1856 (class 1255 OID 146566648)
-- Dependencies: 4536 8
-- Name: issuelinebalancetoshipping(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION issuelinebalancetoshipping(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN issueLineBalanceToShipping('SO', $1, NULL);
END;
$_$;


ALTER FUNCTION public.issuelinebalancetoshipping(integer) OWNER TO admin;

--
-- TOC entry 1857 (class 1255 OID 146566649)
-- Dependencies: 4536 8
-- Name: issuelinebalancetoshipping(text, integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION issuelinebalancetoshipping(text, integer, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN issueLineBalanceToShipping($1, $2, $3, 0, NULL);
END;
$_$;


ALTER FUNCTION public.issuelinebalancetoshipping(text, integer, timestamp with time zone) OWNER TO admin;

--
-- TOC entry 1858 (class 1255 OID 146566650)
-- Dependencies: 4536 8
-- Name: issuelinebalancetoshipping(text, integer, timestamp with time zone, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION issuelinebalancetoshipping(text, integer, timestamp with time zone, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pordertype		ALIAS FOR $1;
  pitemid		ALIAS FOR $2;
  ptimestamp		ALIAS FOR $3;
  pitemlocseries       	ALIAS FOR $4;
  pinvhistid		ALIAS FOR $5;
  _itemlocSeries	INTEGER := 0;
  _qty			NUMERIC;

BEGIN
  _itemlocSeries := COALESCE(pitemlocseries,0);

  IF (pordertype = 'SO') THEN
    SELECT CASE WHEN (fetchMetricBool('RequireSOReservations'))
                THEN coitem_qtyreserved
                ELSE noNeg( coitem_qtyord - coitem_qtyshipped + coitem_qtyreturned - qtyAtShipping('SO', coitem_id) )
           END INTO _qty
    FROM coitem
    WHERE (coitem_id=pitemid);
  ELSEIF (pordertype = 'TO') THEN
    SELECT noNeg( toitem_qty_ordered - toitem_qty_shipped - qtyAtShipping('TO', toitem_id) )
               INTO _qty
    FROM toitem
    WHERE (toitem_id=pitemid);
  ELSE
    RETURN -1;
  END IF;

  IF (_qty > 0) THEN
    _itemlocSeries := issueToShipping(pordertype, pitemid, _qty, _itemlocSeries, ptimestamp, pinvhistid);
  END IF;

  RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.issuelinebalancetoshipping(text, integer, timestamp with time zone, integer, integer) OWNER TO admin;

--
-- TOC entry 1859 (class 1255 OID 146566651)
-- Dependencies: 4536 8
-- Name: issues(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION issues(text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTransType ALIAS FOR $1;

BEGIN
  IF (pTransType IN ('IM', 'IB', 'IT')) THEN
    RETURN TRUE;
  ELSE
    RETURN FALSE;
  END IF;

END;
$_$;


ALTER FUNCTION public.issues(text) OWNER TO admin;

--
-- TOC entry 1860 (class 1255 OID 146566652)
-- Dependencies: 4536 8
-- Name: issuetoshipping(integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION issuetoshipping(integer, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN issueToShipping('SO', $1, $2, 0, CURRENT_TIMESTAMP);
END;
$_$;


ALTER FUNCTION public.issuetoshipping(integer, numeric) OWNER TO admin;

--
-- TOC entry 1861 (class 1255 OID 146566653)
-- Dependencies: 4536 8
-- Name: issuetoshipping(integer, numeric, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION issuetoshipping(integer, numeric, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN issueToShipping('SO', $1, $2, $3, CURRENT_TIMESTAMP);
END;
$_$;


ALTER FUNCTION public.issuetoshipping(integer, numeric, integer) OWNER TO admin;

--
-- TOC entry 1862 (class 1255 OID 146566654)
-- Dependencies: 4536 8
-- Name: issuetoshipping(text, integer, numeric, integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION issuetoshipping(text, integer, numeric, integer, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN issueToShipping($1, $2, $3, $4, $5, NULL);
END;
$_$;


ALTER FUNCTION public.issuetoshipping(text, integer, numeric, integer, timestamp with time zone) OWNER TO admin;

--
-- TOC entry 1863 (class 1255 OID 146566655)
-- Dependencies: 4536 8
-- Name: issuetoshipping(text, integer, numeric, integer, timestamp with time zone, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION issuetoshipping(text, integer, numeric, integer, timestamp with time zone, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pordertype		ALIAS FOR $1;
  pitemid		ALIAS FOR $2;
  pQty			ALIAS FOR $3;
  _itemlocSeries	INTEGER	:= $4;
  _timestamp		TIMESTAMP WITH TIME ZONE := $5;
  pinvhistid		ALIAS FOR $6;
  _coholdtype		TEXT;
  _invhistid		INTEGER;
  _shipheadid		INTEGER;
  _shipnumber		INTEGER;
  _cntctid              INTEGER;
  _p                    RECORD;
  _m                    RECORD;
  _value                NUMERIC;
  _warehouseid		INTEGER;
  _shipitemid     	INTEGER;
  _freight              NUMERIC;

BEGIN

  IF (_timestamp IS NULL) THEN
    _timestamp := CURRENT_TIMESTAMP;
  END IF;

  IF (_itemlocSeries = 0) THEN
    _itemlocSeries := NEXTVAL('itemloc_series_seq');
  END IF;

  IF (pordertype = 'SO') THEN

    -- Check site security
    SELECT warehous_id INTO _warehouseid
    FROM coitem,itemsite,site()
    WHERE ((coitem_id=pitemid)
    AND (itemsite_id=coitem_itemsite_id)
    AND (warehous_id=itemsite_warehous_id));

    IF (NOT FOUND) THEN
      RETURN 0;
    END IF;

    -- Check for average cost items going negative
    IF ( SELECT ( (itemsite_costmethod='A') AND
                  ((itemsite_qtyonhand - round(pQty * coitem_qty_invuomratio, 6)) < 0.0) )
         FROM coitem JOIN itemsite ON (itemsite_id=coitem_itemsite_id)
         WHERE (coitem_id=pitemid) ) THEN
      RETURN -20;
    END IF;

    -- Check auto registration
    IF ( SELECT COALESCE(itemsite_autoreg, FALSE)
         FROM coitem JOIN itemsite ON (itemsite_id=coitem_itemsite_id)
         WHERE (coitem_id=pitemid) ) THEN
      SELECT COALESCE(crmacct_cntct_id_1, -1) INTO _cntctid
      FROM coitem JOIN cohead ON (cohead_id=coitem_cohead_id)
                  JOIN crmacct ON (crmacct_cust_id=cohead_cust_id)
      WHERE (coitem_id=pitemid);
      IF (_cntctid = -1) THEN
        RETURN -15;
      END IF;
    END IF;

    SELECT shiphead_id INTO _shipheadid
    FROM shiphead, coitem JOIN itemsite ON (itemsite_id=coitem_itemsite_id)
    WHERE ( (coitem_id=pitemid)
      AND   (shiphead_number=getOpenShipment(pordertype, coitem_cohead_id, itemsite_warehous_id)) );
    IF (NOT FOUND) THEN
      SELECT NEXTVAL('shiphead_shiphead_id_seq') INTO _shipheadid;

      _shipnumber := fetchShipmentNumber();
      IF (_shipnumber < 0) THEN
	RETURN -10;
      END IF;

      SELECT cohead_holdtype INTO _coholdtype
      FROM cohead, coitem
      WHERE ((cohead_id=coitem_cohead_id)
        AND  (coitem_id=pitemid));

      IF (_coholdtype = 'C') THEN
	RETURN -12;
      ELSIF (_coholdtype = 'P') THEN
	RETURN -13;
      ELSIF (_coholdtype = 'R') THEN
	RETURN -14;
      END IF;

      INSERT INTO shiphead
      ( shiphead_id, shiphead_number, shiphead_order_id, shiphead_order_type,
	shiphead_shipped,
	shiphead_sfstatus, shiphead_shipvia, shiphead_shipchrg_id,
	shiphead_freight, shiphead_freight_curr_id,
	shiphead_shipdate, shiphead_notes, shiphead_shipform_id )
      SELECT _shipheadid, _shipnumber, coitem_cohead_id, pordertype,
	     FALSE,
	     'N', cohead_shipvia,
	     CASE WHEN (cohead_shipchrg_id <= 0) THEN NULL
	          ELSE cohead_shipchrg_id
	     END,
	     cohead_freight, cohead_curr_id,
	     _timestamp::DATE, cohead_shipcomments,
	     CASE WHEN cohead_shipform_id = -1 THEN NULL
	          ELSE cohead_shipform_id
	     END
      FROM cohead, coitem
      WHERE ((coitem_cohead_id=cohead_id)
         AND (coitem_id=pitemid) );

      UPDATE pack
      SET pack_shiphead_id = _shipheadid,
	  pack_printed = FALSE
      FROM coitem
      WHERE ((pack_head_id=coitem_cohead_id)
	AND  (pack_shiphead_id IS NULL)
	AND  (pack_head_type='SO')
	AND  (coitem_id=pitemid));

    ELSE
      UPDATE pack
      SET pack_printed = FALSE
      FROM coitem
      WHERE ((pack_head_id=coitem_cohead_id)
	AND  (pack_shiphead_id=_shipheadid)
	AND  (pack_head_type='SO')
	AND  (coitem_id=pitemid));
    END IF;

    -- Handle g/l transaction
    SELECT postInvTrans( itemsite_id, 'SH', (pQty * coitem_qty_invuomratio),
			   'S/R', porderType,
			   formatSoNumber(coitem_id), shiphead_number,
                           ('Issue ' || item_number || ' to Shipping for customer ' || cohead_billtoname),
			   getPrjAccntId(cohead_prj_id, costcat_shipasset_accnt_id), costcat_asset_accnt_id,
			   _itemlocSeries, _timestamp, NULL, pinvhistid ) INTO _invhistid
    FROM coitem, cohead, itemsite, item, costcat, shiphead
    WHERE ( (coitem_cohead_id=cohead_id)
     AND (coitem_itemsite_id=itemsite_id)
     AND (itemsite_item_id=item_id)
     AND (itemsite_costcat_id=costcat_id)
     AND (coitem_id=pitemid)
     AND (shiphead_id=_shipheadid) );

    SELECT (invhist_unitcost * invhist_invqty) INTO _value
    FROM invhist
    WHERE (invhist_id=_invhistid);

    _shipitemid := nextval('shipitem_shipitem_id_seq');
    INSERT INTO shipitem
    ( shipitem_id, shipitem_shiphead_id, shipitem_orderitem_id, shipitem_qty,
      shipitem_transdate, shipitem_trans_username, shipitem_invoiced,
      shipitem_value, shipitem_invhist_id )
    VALUES
    ( _shipitemid, _shipheadid, pitemid, pQty,
      _timestamp, getEffectiveXtUser(), FALSE,
      _value,
      CASE WHEN _invhistid = -1 THEN
        NULL
      ELSE
        _invhistid
      END );

    -- Handle reservation
    IF (fetchmetricbool('EnableSOReservations')) THEN
      -- Remember what was reserved so we can re-reserve if this issue is returned
      INSERT INTO shipitemrsrv
        (shipitemrsrv_shipitem_id, shipitemrsrv_qty)
      SELECT _shipitemid, least(pQty,coitem_qtyreserved)
      FROM coitem
      WHERE ((coitem_id=pitemid)
      AND (coitem_qtyreserved > 0));

      -- Update sales order
      UPDATE coitem
        SET coitem_qtyreserved = noNeg(coitem_qtyreserved - pQty)
      WHERE(coitem_id=pitemid);
    END IF;

    -- Calculate shipment freight
    SELECT calcShipFreight(_shipheadid) INTO _freight;
    UPDATE shiphead SET shiphead_freight=_freight
    WHERE (shiphead_id=_shipheadid);

  ELSEIF (pordertype = 'TO') THEN

    -- Check site security
    IF (fetchMetricBool('MultiWhs')) THEN
      SELECT warehous_id INTO _warehouseid
      FROM toitem, tohead, site()
      WHERE ( (toitem_id=pitemid)
        AND   (tohead_id=toitem_tohead_id)
        AND   (warehous_id=tohead_src_warehous_id) );

      IF (NOT FOUND) THEN
        RETURN 0;
      END IF;
    END IF;

    SELECT postInvTrans( itemsite_id, 'SH', pQty, 'S/R',
			 pordertype, formatToNumber(toitem_id), '', 'Issue to Shipping',
			 costcat_shipasset_accnt_id, costcat_asset_accnt_id,
			 _itemlocSeries, _timestamp) INTO _invhistid
    FROM tohead, toitem, itemsite, costcat
    WHERE ((tohead_id=toitem_tohead_id)
      AND  (itemsite_item_id=toitem_item_id)
      AND  (itemsite_warehous_id=tohead_src_warehous_id)
      AND  (itemsite_costcat_id=costcat_id)
      AND  (toitem_id=pitemid) );

    SELECT (invhist_unitcost * invhist_invqty) INTO _value
    FROM invhist
    WHERE (invhist_id=_invhistid);

    SELECT shiphead_id INTO _shipheadid
    FROM shiphead, toitem JOIN tohead ON (tohead_id=toitem_tohead_id)
    WHERE ( (toitem_id=pitemid)
      AND   (shiphead_number=getOpenShipment(pordertype, tohead_id, tohead_src_warehous_id)) );

    IF (NOT FOUND) THEN
      _shipheadid := NEXTVAL('shiphead_shiphead_id_seq');

      _shipnumber := fetchShipmentNumber();
      IF (_shipnumber < 0) THEN
	RETURN -10;
      END IF;

      INSERT INTO shiphead
      ( shiphead_id, shiphead_number, shiphead_order_id, shiphead_order_type,
	shiphead_shipped,
	shiphead_sfstatus, shiphead_shipvia, shiphead_shipchrg_id,
	shiphead_freight, shiphead_freight_curr_id,
	shiphead_shipdate, shiphead_notes, shiphead_shipform_id )
      SELECT _shipheadid, _shipnumber, tohead_id, pordertype,
	     FALSE,
	     'N', tohead_shipvia, tohead_shipchrg_id,
	     tohead_freight + SUM(toitem_freight), tohead_freight_curr_id,
	     _timestamp::DATE, tohead_shipcomments, tohead_shipform_id
      FROM tohead, toitem
      WHERE ((toitem_tohead_id=tohead_id)
         AND (tohead_id IN (SELECT toitem_tohead_id
			    FROM toitem
			    WHERE (toitem_id=pitemid))) )
      GROUP BY tohead_id, tohead_shipvia, tohead_shipchrg_id, tohead_freight,
	       tohead_freight_curr_id, tohead_shipcomments, tohead_shipform_id;
    END IF;

    INSERT INTO shipitem
    ( shipitem_shiphead_id, shipitem_orderitem_id, shipitem_qty,
      shipitem_transdate, shipitem_trans_username, shipitem_invoiced,
      shipitem_value, shipitem_invhist_id )
    VALUES
    ( _shipheadid, pitemid, pQty,
      _timestamp, getEffectiveXtUser(), FALSE,
      _value,
      CASE WHEN _invhistid = -1 THEN NULL
           ELSE _invhistid
      END
    );

  ELSE
    RETURN -11;
  END IF;

  RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.issuetoshipping(text, integer, numeric, integer, timestamp with time zone, integer) OWNER TO admin;

--
-- TOC entry 1867 (class 1255 OID 146566660)
-- Dependencies: 4536 8
-- Name: issuewomaterial(integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION issuewomaterial(integer, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWomatlid ALIAS FOR $1;
  pQty ALIAS FOR $2;
  _itemlocSeries INTEGER;

BEGIN

  SELECT NEXTVAL('itemloc_series_seq') INTO _itemlocSeries;
  RETURN issueWoMaterial(pWomatlid, pQty, _itemlocSeries);

END;
$_$;


ALTER FUNCTION public.issuewomaterial(integer, numeric) OWNER TO admin;

--
-- TOC entry 1865 (class 1255 OID 146566658)
-- Dependencies: 4536 8
-- Name: issuewomaterial(integer, numeric, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION issuewomaterial(integer, numeric, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWomatlid ALIAS FOR $1;
  pQty ALIAS FOR $2;
  pItemlocSeries ALIAS FOR $3;
  _p RECORD;
  _invhistid INTEGER;
  _itemlocSeries INTEGER;

BEGIN
  RETURN issueWoMaterial(pWomatlid, pQty, pItemlocSeries, now());
END;
$_$;


ALTER FUNCTION public.issuewomaterial(integer, numeric, integer) OWNER TO admin;

--
-- TOC entry 1866 (class 1255 OID 146566659)
-- Dependencies: 4536 8
-- Name: issuewomaterial(integer, numeric, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION issuewomaterial(integer, numeric, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWomatlid ALIAS FOR $1;
  pQty ALIAS FOR $2;
  pMarkPush ALIAS FOR $3;
  _itemlocSeries INTEGER;

BEGIN
  RETURN issueWoMaterial(pWomatlid, pQty, pMarkPush, now());
END;
$_$;


ALTER FUNCTION public.issuewomaterial(integer, numeric, boolean) OWNER TO admin;

--
-- TOC entry 1864 (class 1255 OID 146566657)
-- Dependencies: 4536 8
-- Name: issuewomaterial(integer, numeric, integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION issuewomaterial(integer, numeric, integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWomatlid ALIAS FOR $1;
  pQty ALIAS FOR $2;
  pItemlocSeries ALIAS FOR $3;
  pMarkPush ALIAS FOR $4;
  _itemlocSeries INTEGER;

BEGIN
  RETURN issueWoMaterial(pWomatlid, pQty, pItemlocSeries,now());
END;
$_$;


ALTER FUNCTION public.issuewomaterial(integer, numeric, integer, boolean) OWNER TO admin;

--
-- TOC entry 1852 (class 1255 OID 146566662)
-- Dependencies: 4536 8
-- Name: issuewomaterial(integer, numeric, integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION issuewomaterial(integer, numeric, integer, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN issueWoMaterial($1, $2, $3, $4, NULL);
END;
$_$;


ALTER FUNCTION public.issuewomaterial(integer, numeric, integer, timestamp with time zone) OWNER TO admin;

--
-- TOC entry 1869 (class 1255 OID 146566663)
-- Dependencies: 4536 8
-- Name: issuewomaterial(integer, numeric, boolean, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION issuewomaterial(integer, numeric, boolean, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWomatlid ALIAS FOR $1;
  pQty ALIAS FOR $2;
  pMarkPush ALIAS FOR $3;
  pGlDistTS ALIAS FOR $4;
  _itemlocSeries INTEGER;

BEGIN

  SELECT issueWoMaterial(pWomatlid, pQty, 0, pGlDistTS) INTO _itemlocSeries;
  IF (_itemlocSeries < 0) THEN
    RETURN _itemlocSeries;
  END IF;

  IF (pMarkPush) THEN
    UPDATE womatl
    SET womatl_issuemethod='S'
    WHERE ((womatl_issuemethod='M')
     AND (womatl_id=pWomatlid));
  END IF;

  RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.issuewomaterial(integer, numeric, boolean, timestamp with time zone) OWNER TO admin;

--
-- TOC entry 1851 (class 1255 OID 146566661)
-- Dependencies: 4536 8
-- Name: issuewomaterial(integer, numeric, integer, boolean, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION issuewomaterial(integer, numeric, integer, boolean, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWomatlid ALIAS FOR $1;
  pQty ALIAS FOR $2;
  pItemlocSeries ALIAS FOR $3;
  pMarkPush ALIAS FOR $4;
  pGlDistTS ALIAS FOR $5;
  _itemlocSeries INTEGER;

BEGIN

  SELECT issueWoMaterial(pWomatlid, pQty, pItemlocSeries, pGlDistTS) INTO _itemlocSeries;

  IF (pMarkPush) THEN
    UPDATE womatl
    SET womatl_issuemethod='S'
    WHERE ((womatl_issuemethod='M')
     AND (womatl_id=pWomatlid));
  END IF;

  RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.issuewomaterial(integer, numeric, integer, boolean, timestamp with time zone) OWNER TO admin;

--
-- TOC entry 1870 (class 1255 OID 146566664)
-- Dependencies: 4536 8
-- Name: issuewomaterial(integer, numeric, integer, timestamp with time zone, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION issuewomaterial(integer, numeric, integer, timestamp with time zone, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWomatlid ALIAS FOR $1;
  pQty ALIAS FOR $2;
  pItemlocSeries ALIAS FOR $3;
  pGlDistTS ALIAS FOR $4;
  pInvhistid ALIAS FOR $5;
  _p RECORD;
  _invhistid INTEGER;
  _itemlocSeries INTEGER;

BEGIN

  SELECT item_id,
         itemsite_id AS c_itemsite_id,
         wo_itemsite_id AS p_itemsite_id,
         itemsite_loccntrl, itemsite_controlmethod,
         womatl_wo_id, womatl_qtyreq, itemsite_item_id, womatl_uom_id, wo_prj_id,
         roundQty(item_fractional, itemuomtouom(itemsite_item_id, womatl_uom_id, NULL, pQty)) AS qty,
         formatWoNumber(wo_id) AS woNumber,
         CASE WHEN(itemsite_costmethod='J' AND item_type='P' AND poitem_id IS NOT NULL) THEN poitem_unitprice
              WHEN(itemsite_costmethod IN ('A','J')) THEN avgcost(itemsite_id)
              WHEN(itemsite_costmethod='S') THEN stdcost(itemsite_item_id)
              ELSE 0.0
         END AS cost,
         womatl_issuemethod AS issueMethod INTO _p
  FROM womatl JOIN wo ON (wo_id=womatl_wo_id)
              JOIN itemsite ON (itemsite_id=womatl_itemsite_id)
              JOIN item ON (item_id=itemsite_item_id)
              LEFT OUTER JOIN poitem ON (poitem_order_id=womatl_id AND poitem_order_type='W')
  WHERE (womatl_id=pWomatlid);

  IF (pQty < 0) THEN
    RETURN pItemlocSeries;
  END IF;

  IF (pItemlocSeries <> 0) THEN
    _itemlocSeries := pItemlocSeries;
  ELSE
    SELECT NEXTVAL('itemloc_series_seq') INTO _itemlocSeries;
  END IF;
  SELECT postInvTrans( ci.itemsite_id, 'IM', _p.qty,
                      'W/O', 'WO', _p.woNumber, '',
                      ('Material ' || item_number || ' Issue to Work Order'),
                      getPrjAccntId(_p.wo_prj_id, pc.costcat_wip_accnt_id),
                      cc.costcat_asset_accnt_id, _itemlocSeries, pGlDistTS,
                      NULL, pInvhistid ) INTO _invhistid
  FROM itemsite AS ci, itemsite AS pi,
       costcat AS cc, costcat AS pc,
       item
  WHERE ( (ci.itemsite_costcat_id=cc.costcat_id)
   AND (pi.itemsite_costcat_id=pc.costcat_id)
   AND (ci.itemsite_id=_p.c_itemsite_id)
   AND (pi.itemsite_id=_p.p_itemsite_id)
   AND (ci.itemsite_item_id=item_id) );

--  Create linkage to the transaction created
  IF (_invhistid != -1) THEN
    INSERT INTO womatlpost (womatlpost_womatl_id,womatlpost_invhist_id)
                VALUES (pWomatlid,_invhistid);
  END IF;

--  Increase the parent W/O's WIP value by the value of the issued components
  UPDATE wo
  SET wo_wipvalue = (wo_wipvalue + (_p.cost * _p.qty)),
      wo_postedvalue = (wo_postedvalue + (_p.cost * _p.qty))
  WHERE (wo_id=_p.womatl_wo_id);

  UPDATE womatl
  SET womatl_qtyiss = (womatl_qtyiss + itemuomtouom(_p.itemsite_item_id, NULL, _p.womatl_uom_id, _p.qty)),
      womatl_lastissue = pGlDistTS::DATE
  WHERE (womatl_id=pWomatlid);

  UPDATE wo
  SET wo_status='I'
  WHERE ( (wo_status <> 'I')
   AND (wo_id=_p.womatl_wo_id) );

  RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.issuewomaterial(integer, numeric, integer, timestamp with time zone, integer) OWNER TO admin;

--
-- TOC entry 1871 (class 1255 OID 146566665)
-- Dependencies: 4536 8
-- Name: issuewomaterialbatch(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION issuewomaterialbatch(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoid ALIAS FOR $1;
  _itemlocSeries INTEGER;
  _r RECORD;
  _woNumber TEXT;

BEGIN

  SELECT NEXTVAL('itemloc_series_seq') INTO _itemlocSeries;

  FOR _r IN SELECT womatl_id,
              CASE WHEN (womatl_qtyreq >= 0) THEN
                roundQty(itemuomfractionalbyuom(item_id, womatl_uom_id), noNeg(womatl_qtyreq - womatl_qtyiss))
              ELSE
                roundQty(itemuomfractionalbyuom(item_id, womatl_uom_id), noNeg(womatl_qtyiss * -1))
              END AS qty
            FROM womatl, itemsite, item
            WHERE ( (womatl_itemsite_id=itemsite_id)
             AND (itemsite_item_id=item_id)
             AND (womatl_issuemethod IN ('S', 'M'))
             AND (womatl_wo_id=pWoid) ) LOOP

    IF (_r.qty > 0) THEN
      SELECT issueWoMaterial(_r.womatl_id, _r.qty, _itemlocSeries, TRUE) INTO _itemlocSeries;
    END IF;

  END LOOP;

  RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.issuewomaterialbatch(integer) OWNER TO admin;

--
-- TOC entry 1872 (class 1255 OID 146566666)
-- Dependencies: 4536 8
-- Name: itemaltcapinvrat(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemaltcapinvrat(integer) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;

BEGIN
  RETURN itemUOMRatioByType(pItemid, 'AltCapacity');
END;
$_$;


ALTER FUNCTION public.itemaltcapinvrat(integer) OWNER TO admin;

--
-- TOC entry 1873 (class 1255 OID 146566667)
-- Dependencies: 4536 8
-- Name: itemaltcapuom(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemaltcapuom(integer) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;

BEGIN
  RETURN itemUOMByType(pItemid, 'AltCapacity');
END;
$_$;


ALTER FUNCTION public.itemaltcapuom(integer) OWNER TO admin;

--
-- TOC entry 1874 (class 1255 OID 146566668)
-- Dependencies: 4536 8
-- Name: itemcapinvrat(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemcapinvrat(integer) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;

BEGIN
  RETURN itemUOMRatioByType(pItemid, 'Capacity');
END;
$_$;


ALTER FUNCTION public.itemcapinvrat(integer) OWNER TO admin;

--
-- TOC entry 1875 (class 1255 OID 146566669)
-- Dependencies: 4536 8
-- Name: itemcapuom(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemcapuom(integer) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;

BEGIN
  RETURN itemUOMByType(pItemid, 'Capacity');
END;
$_$;


ALTER FUNCTION public.itemcapuom(integer) OWNER TO admin;

--
-- TOC entry 1877 (class 1255 OID 146566671)
-- Dependencies: 4536 8
-- Name: itemcharprice(integer, integer, text, integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemcharprice(integer, integer, text, integer, numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pCharid ALIAS FOR $2;
  pCharValue ALIAS FOR $3;
  pCustid ALIAS FOR $4;
  pQty ALIAS FOR $5;

BEGIN
  RETURN itemCharPrice(pItemid, pCharid, pCharValue, pCustid, -1, pQty, baseCurrId(), CURRENT_DATE);
END;
$_$;


ALTER FUNCTION public.itemcharprice(integer, integer, text, integer, numeric) OWNER TO admin;

--
-- TOC entry 1878 (class 1255 OID 146566672)
-- Dependencies: 4536 8
-- Name: itemcharprice(integer, integer, text, integer, integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemcharprice(integer, integer, text, integer, integer, numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pCharid ALIAS FOR $2;
  pCharValue ALIAS FOR $3;
  pCustid ALIAS FOR $4;
  pShiptoid ALIAS FOR $5;
  pQty ALIAS FOR $6;

BEGIN
  RETURN itemCharPrice(pItemid, pCharid, pCharValue, pCustid, pShiptoid, pQty, baseCurrId(), CURRENT_DATE);
END;
$_$;


ALTER FUNCTION public.itemcharprice(integer, integer, text, integer, integer, numeric) OWNER TO admin;

--
-- TOC entry 1879 (class 1255 OID 146566673)
-- Dependencies: 4536 8
-- Name: itemcharprice(integer, integer, text, integer, integer, numeric, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemcharprice(integer, integer, text, integer, integer, numeric, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pCharid ALIAS FOR $2;
  pCharValue ALIAS FOR $3;
  pCustid ALIAS FOR $4;
  pShiptoid ALIAS FOR $5;
  pQty ALIAS FOR $6;
  pCurrid ALIAS FOR $7;

BEGIN
  RETURN itemCharPrice(pItemid, pCharid, pCharValue, pCustid, pShiptoid, pQty, pCurrid, CURRENT_DATE);
END;
$_$;


ALTER FUNCTION public.itemcharprice(integer, integer, text, integer, integer, numeric, integer) OWNER TO admin;

--
-- TOC entry 1876 (class 1255 OID 146566670)
-- Dependencies: 4536 8
-- Name: itemcharprice(integer, integer, text, integer, integer, numeric, integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemcharprice(integer, integer, text, integer, integer, numeric, integer, date) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pCharid ALIAS FOR $2;
  pCharValue ALIAS FOR $3;
  pCustid ALIAS FOR $4;
  pShiptoid ALIAS FOR $5;
  pQty ALIAS FOR $6;
  pCurrid ALIAS FOR $7;
  pEffective ALIAS FOR $8;

BEGIN
  RETURN itemCharPrice(pItemid, pCharid, pCharValue, pCustid, pShiptoid, pQty, pCurrid, CURRENT_DATE, CURRENT_DATE);
END;
$_$;


ALTER FUNCTION public.itemcharprice(integer, integer, text, integer, integer, numeric, integer, date) OWNER TO admin;

--
-- TOC entry 1880 (class 1255 OID 146566674)
-- Dependencies: 4536 8
-- Name: itemcharprice(integer, integer, text, integer, integer, numeric, integer, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemcharprice(integer, integer, text, integer, integer, numeric, integer, date, date) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pCharid ALIAS FOR $2;
  pCharValue ALIAS FOR $3;
  pCustid ALIAS FOR $4;
  pShiptoid ALIAS FOR $5;
  pQty ALIAS FOR $6;
  pCurrid ALIAS FOR $7;
  pEffective ALIAS FOR $8;
  pAsOf ALIAS FOR $9;
  _price NUMERIC;
  _sales NUMERIC;
  _item RECORD;
  _iteminvpricerat NUMERIC;

BEGIN
-- If the charass_value passed in is NULL, we can skip this function
  IF (pCharValue IS NULL) THEN
    RETURN 0;
  END IF;

-- Return the itemCharPrice in the currency passed in as pCurrid

-- Get a value here so we do not have to call the function several times
  SELECT iteminvpricerat(pItemid)
    INTO _iteminvpricerat;

-- First get a sales price if any so we when we find other prices
-- we can determine if we want that price or this price.
--  Check for a Sale Price
  SELECT currToCurr(ipshead_curr_id, pCurrid,
                      ipsprice_price - (ipsprice_price * cust_discntprcnt),
                      pEffective) INTO _sales
  FROM (
  SELECT ipsitem_ipshead_id AS ipsprice_ipshead_id,
         itemuomtouom(ipsitem_item_id, ipsitem_qty_uom_id, NULL, ipsitem_qtybreak) AS ipsprice_qtybreak,
         (ipsitemchar_price * itemuomtouomratio(ipsitem_item_id, NULL, ipsitem_price_uom_id)) * _iteminvpricerat AS ipsprice_price
    FROM ipsiteminfo,ipsitemchar
   WHERE((ipsitem_item_id=pItemid)
    AND (ipsitemchar_char_id=pCharid)
    AND (ipsitemchar_value=pCharValue)
    AND (ipsitemchar_ipsitem_id=ipsitem_id))
       ) AS
        ipsprice, ipshead, sale, custinfo
  WHERE ( (ipsprice_ipshead_id=ipshead_id)
   AND (sale_ipshead_id=ipshead_id)
   AND (pAsOf BETWEEN sale_startdate AND sale_enddate)
   AND (ipsprice_qtybreak <= pQty)
   AND (cust_id=pCustid) )
  ORDER BY ipsprice_qtybreak DESC, ipsprice_price ASC
  LIMIT 1;

--  Check for a Customer Shipto Price
  SELECT currToCurr(ipshead_curr_id, pCurrid, ipsprice_price, pEffective) INTO _price
  FROM (
  SELECT ipsitem_ipshead_id AS ipsprice_ipshead_id,
         itemuomtouom(ipsitem_item_id, ipsitem_qty_uom_id, NULL, ipsitem_qtybreak) AS ipsprice_qtybreak,
         (ipsitemchar_price * itemuomtouomratio(ipsitem_item_id, NULL, ipsitem_price_uom_id)) * _iteminvpricerat AS ipsprice_price
    FROM ipsiteminfo,ipsitemchar
   WHERE ((ipsitem_item_id=pItemid)
    AND (ipsitemchar_char_id=pCharid)
    AND (ipsitemchar_value=pCharValue)
    AND (ipsitemchar_ipsitem_id=ipsitem_id))
       ) AS
        ipsprice, ipshead, ipsass
  WHERE ( (ipsprice_ipshead_id=ipshead_id)
   AND (ipsass_ipshead_id=ipshead_id)
   AND (pAsOf BETWEEN ipshead_effective AND (ipshead_expires - 1))
   AND (ipsprice_qtybreak <= pQty)
   AND (ipsass_shipto_id != -1)
   AND (ipsass_shipto_id=pShiptoid) )
  ORDER BY ipsprice_qtybreak DESC, ipsprice_price ASC
  LIMIT 1;

  IF (_price IS NOT NULL) THEN
    IF ((_sales IS NOT NULL) AND (_sales < _price)) THEN
      RETURN _sales;
    END IF;
    RETURN _price;
  END IF;

--  Check for a Customer Shipto Pattern Price
  SELECT currToCurr(ipshead_curr_id, pCurrid, ipsprice_price, pEffective) INTO _price
  FROM (
  SELECT ipsitem_ipshead_id AS ipsprice_ipshead_id,
         itemuomtouom(ipsitem_item_id, ipsitem_qty_uom_id, NULL, ipsitem_qtybreak) AS ipsprice_qtybreak,
         (ipsitemchar_price * itemuomtouomratio(ipsitem_item_id, NULL, ipsitem_price_uom_id)) * _iteminvpricerat AS ipsprice_price
    FROM ipsiteminfo,ipsitemchar
   WHERE ((ipsitem_item_id=pItemid)
    AND (ipsitemchar_char_id=pCharid)
    AND (ipsitemchar_value=pCharValue)
    AND (ipsitemchar_ipsitem_id=ipsitem_id))
       ) AS
        ipsprice, ipshead, ipsass, shiptoinfo
  WHERE ( (ipsprice_ipshead_id=ipshead_id)
   AND (ipsass_ipshead_id=ipshead_id)
   AND (pAsOf BETWEEN ipshead_effective AND (ipshead_expires - 1))
   AND (ipsprice_qtybreak <= pQty)
   AND (COALESCE(length(ipsass_shipto_pattern), 0) > 0)
   AND (shipto_num ~ ipsass_shipto_pattern)
   AND (ipsass_cust_id=pCustid)
   AND (shipto_id=pShiptoid) )
  ORDER BY ipsprice_qtybreak DESC, ipsprice_price ASC
  LIMIT 1;

  IF (_price IS NOT NULL) THEN
    IF ((_sales IS NOT NULL) AND (_sales < _price)) THEN
      RETURN _sales;
    END IF;
    RETURN _price;
  END IF;

--  Check for a Customer Price
  SELECT currToCurr(ipshead_curr_id, pCurrid, ipsprice_price, pEffective) INTO _price
  FROM (
  SELECT ipsitem_ipshead_id AS ipsprice_ipshead_id,
         itemuomtouom(ipsitem_item_id, ipsitem_qty_uom_id, NULL, ipsitem_qtybreak) AS ipsprice_qtybreak,
         (ipsitemchar_price * itemuomtouomratio(ipsitem_item_id, NULL, ipsitem_price_uom_id)) * _iteminvpricerat AS ipsprice_price
    FROM ipsiteminfo,ipsitemchar
   WHERE ((ipsitem_item_id=pItemid)
    AND (ipsitemchar_char_id=pCharid)
    AND (ipsitemchar_value=pCharValue)
    AND (ipsitemchar_ipsitem_id=ipsitem_id))
       ) AS
        ipsprice, ipshead, ipsass
  WHERE ( (ipsprice_ipshead_id=ipshead_id)
   AND (ipsass_ipshead_id=ipshead_id)
   AND (pAsOf BETWEEN ipshead_effective AND (ipshead_expires - 1))
   AND (ipsprice_qtybreak <= pQty)
   AND (COALESCE(length(ipsass_shipto_pattern), 0) = 0)
   AND (ipsass_cust_id=pCustid) )
  ORDER BY ipsprice_qtybreak DESC, ipsprice_price ASC
  LIMIT 1;

  IF (_price IS NOT NULL) THEN
    IF ((_sales IS NOT NULL) AND (_sales < _price)) THEN
      RETURN _sales;
    END IF;
    RETURN _price;
  END IF;

--  Check for a Customer Type Price
  SELECT currToCurr(ipshead_curr_id, pCurrid, ipsprice_price, pEffective) INTO _price
  FROM (
  SELECT ipsitem_ipshead_id AS ipsprice_ipshead_id,
         itemuomtouom(ipsitem_item_id, ipsitem_qty_uom_id, NULL, ipsitem_qtybreak) AS ipsprice_qtybreak,
         (ipsitemchar_price * itemuomtouomratio(ipsitem_item_id, NULL, ipsitem_price_uom_id)) * _iteminvpricerat AS ipsprice_price
    FROM ipsiteminfo,ipsitemchar
   WHERE((ipsitem_item_id=pItemid)
    AND (ipsitemchar_char_id=pCharid)
    AND (ipsitemchar_value=pCharValue)
    AND (ipsitemchar_ipsitem_id=ipsitem_id))
       ) AS
        ipsprice, ipshead, ipsass, custinfo
  WHERE ( (ipsprice_ipshead_id=ipshead_id)
   AND (ipsass_ipshead_id=ipshead_id)
   AND (ipsass_custtype_id=cust_custtype_id)
   AND (pAsOf BETWEEN ipshead_effective AND (ipshead_expires - 1))
   AND (ipsprice_qtybreak <= pQty)
   AND (cust_id=pCustid) )
  ORDER BY ipsprice_qtybreak DESC, ipsprice_price ASC
  LIMIT 1;

  IF (_price IS NOT NULL) THEN
    IF ((_sales IS NOT NULL) AND (_sales < _price)) THEN
      RETURN _sales;
    END IF;
    RETURN _price;
  END IF;

--  Check for a Customer Type Pattern Price
  SELECT currToCurr(ipshead_curr_id, pCurrid, ipsprice_price, pEffective) INTO _price
  FROM (
  SELECT ipsitem_ipshead_id AS ipsprice_ipshead_id,
         itemuomtouom(ipsitem_item_id, ipsitem_qty_uom_id, NULL, ipsitem_qtybreak) AS ipsprice_qtybreak,
         (ipsitemchar_price * itemuomtouomratio(ipsitem_item_id, NULL, ipsitem_price_uom_id)) * _iteminvpricerat AS ipsprice_price
    FROM ipsiteminfo,ipsitemchar
   WHERE ((ipsitem_item_id=pItemid)
    AND (ipsitemchar_char_id=pCharid)
    AND (ipsitemchar_value=pCharValue)
    AND (ipsitemchar_ipsitem_id=ipsitem_id))
       ) AS
        ipsprice, ipshead, ipsass, custtype, custinfo
  WHERE ( (ipsprice_ipshead_id=ipshead_id)
   AND (ipsass_ipshead_id=ipshead_id)
   AND (coalesce(length(ipsass_custtype_pattern), 0) > 0)
   AND (custtype_code ~ ipsass_custtype_pattern)
   AND (cust_custtype_id=custtype_id)
   AND (pAsOf BETWEEN ipshead_effective AND (ipshead_expires - 1))
   AND (ipsprice_qtybreak <= pQty)
   AND (cust_id=pCustid) )
  ORDER BY ipsprice_qtybreak DESC, ipsprice_price ASC
  LIMIT 1;

  IF (_price IS NOT NULL) THEN
    IF ((_sales IS NOT NULL) AND (_sales < _price)) THEN
      RETURN _sales;
    END IF;
    RETURN _price;
  END IF;

-- If we have not found another price yet and we have a
-- sales price we will use that.
  IF (_sales IS NOT NULL) THEN
    RETURN _sales;
  END IF;

--  Check for a list price
  SELECT MIN(currToLocal(pCurrid,
                       charass_price - (charass_price * COALESCE(cust_discntprcnt, 0)),
                       pEffective)) AS price,
         item_exclusive INTO _item
  FROM charass,item LEFT OUTER JOIN custinfo ON (cust_id=pCustid)
  WHERE ((item_id=pItemid)
   AND (charass_char_id=pCharid)
   AND (charass_value=pCharValue)
   AND (charass_target_type='I')
   AND (charass_target_id=item_id))
  GROUP BY item_exclusive;
  IF (FOUND) THEN
    IF (NOT _item.item_exclusive) THEN
      IF (_item.price < 0) THEN
        RETURN 0;
      ELSE
        RETURN _item.price;
      END IF;
    ELSE
      RETURN 0;
    END IF;
  ELSE
    RETURN 0;
  END IF;

END;
$_$;


ALTER FUNCTION public.itemcharprice(integer, integer, text, integer, integer, numeric, integer, date, date) OWNER TO admin;

--
-- TOC entry 1881 (class 1255 OID 146566675)
-- Dependencies: 4536 8
-- Name: itemcharvalue(integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemcharvalue(integer, text) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pCharName ALIAS FOR $2;
  _value TEXT;

BEGIN

  SELECT charass_value INTO _value
  FROM charass, char
  WHERE ( (charass_char_id=char_id)
   AND (charass_target_type='I')
   AND (charass_target_id=pItemid)
   AND (char_name=pCharName) );
  IF (NOT FOUND) THEN
    _value = '';
  END IF;

  RETURN _value;

END;
$_$;


ALTER FUNCTION public.itemcharvalue(integer, text) OWNER TO admin;

--
-- TOC entry 1882 (class 1255 OID 146566676)
-- Dependencies: 4536 8
-- Name: itemcost(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemcost(integer) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  _cost NUMERIC;
BEGIN
  SELECT CASE WHEN (itemsite_costmethod='A' AND itemsite_qtyonhand != 0.0) THEN (itemsite_value / itemsite_qtyonhand)
              WHEN (itemsite_costmethod='A' AND itemsite_qtyonhand = 0.0) THEN 0.0
              WHEN (itemsite_costmethod='N') THEN 0.0
              ELSE stdCost(itemsite_item_id)
         END INTO _cost
    FROM itemsite
   WHERE(itemsite_id=pItemsiteid);
  RETURN _cost;
END;
$_$;


ALTER FUNCTION public.itemcost(integer) OWNER TO admin;

--
-- TOC entry 1883 (class 1255 OID 146566677)
-- Dependencies: 4536 8
-- Name: iteminventoryuominuse(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION iteminventoryuominuse(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  _uomid INTEGER;
  _result INTEGER;
BEGIN
  SELECT item_inv_uom_id INTO _uomid
    FROM item
   WHERE(item_id=pItemid);

  SELECT itemuomconv_id INTO _result
    FROM itemuomconv
   WHERE(itemuomconv_item_id=pItemid)
   LIMIT 1;
  IF (FOUND) THEN
    RETURN TRUE;
  END IF;

  SELECT itemsite_id INTO _result
  FROM itemsite WHERE ( (itemsite_item_id=pItemid)
                  AND   ((itemsite_qtyonhand <> 0) OR (itemsite_nnqoh <> 0)) )
  LIMIT 1;
  IF (FOUND) THEN
    RETURN TRUE;
  END IF;

  RETURN FALSE;
END;
$_$;


ALTER FUNCTION public.iteminventoryuominuse(integer) OWNER TO admin;

--
-- TOC entry 1884 (class 1255 OID 146566678)
-- Dependencies: 4536 8
-- Name: iteminvpricerat(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION iteminvpricerat(integer) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  _fromUomid INTEGER;
  _toUomid INTEGER;
  _ratio NUMERIC;
BEGIN

  IF(pItemid IS NULL) THEN
    RETURN 1.0;
  END IF;

  SELECT item_inv_uom_id, item_price_uom_id
    INTO _fromUomid, _toUomid
    FROM item
   WHERE(item_id=pItemid);

  IF(NOT FOUND) THEN
    RAISE EXCEPTION 'No item record found for item_id %', pItemid;
  END IF;

  IF(_fromUomid = _toUomid) THEN
    RETURN 1.0;
  END IF;

  -- Return the ration as inventory / price
  SELECT CASE WHEN(itemuomconv_from_uom_id=_fromUomid) THEN itemuomconv_from_value / itemuomconv_to_value
              ELSE itemuomconv_to_value / itemuomconv_from_value
         END
    INTO _ratio
    FROM itemuomconv
   WHERE((((itemuomconv_from_uom_id=_fromUomid) AND (itemuomconv_to_uom_id=_toUomid))
       OR ((itemuomconv_from_uom_id=_toUomid) AND (itemuomconv_to_uom_id=_fromUomid)))
     AND (itemuomconv_item_id=pItemid));

  IF(NOT FOUND) THEN
    RAISE EXCEPTION 'No itemuomconv record found for item_id % to item_price_uomid %', pItemid, _toUomid;
  END IF;

  RETURN _ratio;
END;
$_$;


ALTER FUNCTION public.iteminvpricerat(integer) OWNER TO admin;

--
-- TOC entry 1885 (class 1255 OID 146566679)
-- Dependencies: 2684 4536 8
-- Name: itemipsprice(integer, integer, integer, numeric, integer, integer, integer, date, date, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemipsprice(pitemid integer, pcustid integer, pshiptoid integer, pqty numeric, pqtyuom integer, ppriceuom integer, pcurrid integer, peffective date, pasof date, psiteid integer) RETURNS SETOF itemprice
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _row  itemprice%ROWTYPE;
  _sale RECORD;
  _ips RECORD;
  _item RECORD;
  _cust RECORD;
  _shipto RECORD;
  _iteminvpricerat NUMERIC := 1.0;
  _listprice NUMERIC := 0.0;
  _qty NUMERIC;
  _asof DATE;
  _wholesalepricecosting BOOLEAN := false;
  _long30markups BOOLEAN := false;
  _itempricingprecedence BOOLEAN := false;

BEGIN
  _wholesalepricecosting := fetchMetricBool('WholesalePriceCosting');
  _long30markups := fetchMetricBool('Long30Markups');
  _itempricingprecedence := fetchMetricBool('ItemPricingPrecedence');

-- Return the itemPrice in the currency passed in as pCurrid
  _qty := itemuomtouom(pItemid, pQtyUOM, NULL, pQty);

-- If no as of passed, use current date
  _asof := COALESCE(pAsOf, CURRENT_DATE);

--  Cache Item, Customer and Shipto
  SELECT item.*, itemCost(itemsite_id) AS invcost INTO _item
  FROM item LEFT OUTER JOIN itemsite ON (itemsite_item_id=item_id AND itemsite_warehous_id=pSiteid)
  WHERE (item_id=pItemid);

  SELECT * INTO _cust
  FROM custinfo JOIN custtype ON (custtype_id=cust_custtype_id)
  WHERE (cust_id=pCustid);

  SELECT * INTO _shipto
  FROM shiptoinfo
  WHERE (shipto_id=pShiptoid);

-- Get a value here so we do not have to call the function several times
  SELECT itemuomtouomratio(pItemid, pPriceUOM, _item.item_price_uom_id) AS ratio
    INTO _iteminvpricerat;

-- First get a sales price if any so we when we find other prices
-- we can determine if we want that price or this price.
--  Check for a Sale Price
  SELECT INTO _sale
    currToCurr(ipshead_curr_id, pCurrid, ipsprice_price, pEffective) AS rightprice, ipsitem_type AS righttype
  FROM (
  SELECT ipsitem_ipshead_id AS ipsprice_ipshead_id, ipsitem_type,
         CASE WHEN (ipsitem_type = 'N') THEN
               (ipsitem_price * itemuomtouomratio(_item.item_id, pPriceUOM, ipsitem_price_uom_id))
              WHEN (ipsitem_type = 'D') THEN
               noNeg(_item.item_listprice - (_item.item_listprice * ipsitem_discntprcnt) - ipsitem_fixedamtdiscount) * _iteminvpricerat
              WHEN ((ipsitem_type = 'M') AND _long30markups AND _wholesalepricecosting) THEN
               (_item.item_listcost / (1.0 - ipsitem_discntprcnt) + ipsitem_fixedamtdiscount) * _iteminvpricerat
              WHEN ((ipsitem_type = 'M') AND _long30markups) THEN
               (_item.invcost / (1.0 - ipsitem_discntprcnt) + ipsitem_fixedamtdiscount) * _iteminvpricerat
              WHEN (ipsitem_type = 'M' AND _wholesalepricecosting) THEN
               (_item.item_listcost + (_item.item_listcost * ipsitem_discntprcnt) + ipsitem_fixedamtdiscount) * _iteminvpricerat
              WHEN (ipsitem_type = 'M') THEN
               (_item.invcost + (_item.invcost * ipsitem_discntprcnt) + ipsitem_fixedamtdiscount) * _iteminvpricerat
              ELSE 0.00
         END AS ipsprice_price,
         CASE WHEN (ipsitem_item_id=_item.item_id) THEN itemuomtouom(ipsitem_item_id, ipsitem_qty_uom_id, NULL, ipsitem_qtybreak)
              ELSE ipsitem_qtybreak
         END AS ipsprice_qtybreak,
         (COALESCE(ipsitem_price_uom_id, -1)=COALESCE(pPriceUOM,-1)) AS uommatched,
         CASE WHEN (_itempricingprecedence) THEN (COALESCE(ipsitem_item_id, -1)=_item.item_id)
              ELSE true END AS itemmatched
    FROM ipsiteminfo
   WHERE(ipsitem_item_id=_item.item_id) OR (ipsitem_prodcat_id=_item.item_prodcat_id) ) AS
        ipsprice, ipshead, ipsass, sale
  WHERE ( (ipsprice_ipshead_id=ipshead_id)
    AND   (sale_ipshead_id=ipsprice_ipshead_id)
    AND   (_asof BETWEEN sale_startdate AND sale_enddate)
    AND   (ipsprice_qtybreak <= _qty)
    AND   (ipsass_ipshead_id=ipshead_id)
    AND ( (ipsass_shipto_id=_shipto.shipto_id)
     OR   ((COALESCE(LENGTH(ipsass_shipto_pattern), 0) > 0) AND (_shipto.shipto_num ~ ipsass_shipto_pattern))
     OR   (ipsass_cust_id=_cust.cust_id)
     OR   (ipsass_custtype_id=_cust.cust_custtype_id)
     OR   ((COALESCE(LENGTH(ipsass_custtype_pattern), 0) > 0) AND (_cust.custtype_code ~ ipsass_custtype_pattern)) )
        )
  ORDER BY itemmatched DESC, uommatched DESC, ipsprice_qtybreak DESC, ipsprice_price ASC
  LIMIT 1;

-- Find the best Price Schedule Price

  SELECT INTO _ips
    currToCurr(ipshead_curr_id, pCurrid, protoprice, pEffective) AS rightprice, ipsitem_type AS righttype

  FROM (
    SELECT *,
           CASE WHEN (COALESCE(ipsass_shipto_id, -1) > 0) THEN 1
             WHEN (COALESCE(LENGTH(ipsass_shipto_pattern), 0) > 0) THEN 2
             WHEN (COALESCE(ipsass_cust_id, -1) > 0) THEN 3
             WHEN (COALESCE(ipsass_custtype_id, -1) > 0) THEN 4
             WHEN (COALESCE(LENGTH(ipsass_custtype_pattern), 0) > 0) THEN 5
             ELSE 99
           END AS assignseq,
           CASE WHEN (ipsitem_type = 'N') THEN
                 (ipsitem_price * itemuomtouomratio(_item.item_id, pPriceUOM, ipsitem_price_uom_id))
                WHEN (ipsitem_type = 'D') THEN
                 noNeg(_item.item_listprice - (_item.item_listprice * ipsitem_discntprcnt) - ipsitem_fixedamtdiscount) * _iteminvpricerat
                WHEN ((ipsitem_type = 'M') AND _long30markups AND _wholesalepricecosting) THEN
                 (_item.item_listcost / (1.0 - ipsitem_discntprcnt) + ipsitem_fixedamtdiscount) * _iteminvpricerat
                WHEN ((ipsitem_type = 'M') AND _long30markups) THEN
                 (_item.invcost / (1.0 - ipsitem_discntprcnt) + ipsitem_fixedamtdiscount) * _iteminvpricerat
                WHEN (ipsitem_type = 'M' AND _wholesalepricecosting) THEN
                 (_item.item_listcost + (_item.item_listcost * ipsitem_discntprcnt) + ipsitem_fixedamtdiscount) * _iteminvpricerat
                WHEN (ipsitem_type = 'M') THEN
                 (_item.invcost + (_item.invcost * ipsitem_discntprcnt) + ipsitem_fixedamtdiscount) * _iteminvpricerat
                ELSE 0.00
           END AS protoprice,
           CASE WHEN (ipsitem_item_id=_item.item_id) THEN itemuomtouom(ipsitem_item_id, ipsitem_qty_uom_id, NULL, ipsitem_qtybreak)
                ELSE ipsitem_qtybreak
           END AS protoqtybreak,
           (COALESCE(ipsitem_price_uom_id, -1)=COALESCE(pPriceUOM,-1)) AS uommatched,
           CASE WHEN (_itempricingprecedence) THEN (COALESCE(ipsitem_item_id, -1)=_item.item_id)
                ELSE true END AS itemmatched
    FROM ipsass JOIN ipshead ON (ipshead_id=ipsass_ipshead_id)
                JOIN ipsiteminfo ON (ipsitem_ipshead_id=ipshead_id)
    WHERE ((ipsitem_item_id=_item.item_id) OR (ipsitem_prodcat_id=_item.item_prodcat_id))
      AND (_asof BETWEEN ipshead_effective AND ipshead_expires)
      AND ((ipsitem_warehous_id=pSiteid) OR (ipsitem_warehous_id IS NULL))
      AND ( (ipsass_shipto_id=_shipto.shipto_id)
       OR   ((COALESCE(LENGTH(ipsass_shipto_pattern), 0) > 0) AND (_shipto.shipto_num ~ ipsass_shipto_pattern))
       OR   (ipsass_cust_id=_cust.cust_id)
       OR   (ipsass_custtype_id=_cust.cust_custtype_id)
       OR   ((COALESCE(LENGTH(ipsass_custtype_pattern), 0) > 0) AND (_cust.custtype_code ~ ipsass_custtype_pattern))
          )
  ) AS proto
  WHERE (protoqtybreak <= pQty)
  ORDER BY assignseq, itemmatched DESC, protoqtybreak DESC, rightprice
  LIMIT 1;

  IF (_ips.rightprice IS NOT NULL) THEN
    IF ((_sale.rightprice IS NOT NULL) AND (_sale.rightprice < _ips.rightprice)) THEN
      RAISE DEBUG 'itemprice, item=%, cust=%, shipto=%, sale price= %', pItemid, pCustid, pShiptoid, _sale.rightprice;
      _row.itemprice_price := _sale.rightprice;
      _row.itemprice_type := _sale.righttype;
      RETURN NEXT _row;
    END IF;
    RAISE DEBUG 'itemprice, item=%, cust=%, shipto=%, schedule price= %', pItemid, pCustid, pShiptoid, _ips.rightprice;
    _row.itemprice_price := _ips.rightprice;
    _row.itemprice_type := _ips.righttype;
    RETURN NEXT _row;
  END IF;

--  If item is exclusive then list list price does not apply
  IF (_item.item_exclusive) THEN
    RAISE DEBUG 'itemprice, item=%, cust=%, shipto=%, item exclusive, price=-9999', pItemid, pCustid, pShiptoid;
    _row.itemprice_price := -9999.0;
    _row.itemprice_type := '';
    RETURN NEXT _row;
  END IF;

--  Check for a list price
  _listprice := noNeg(currToLocal(pCurrid, _item.item_listprice - (_item.item_listprice * COALESCE(_cust.cust_discntprcnt, 0.0)), pEffective)
                      * itemuomtouomratio(pItemid, pPriceUOM, _item.item_price_uom_id));

  RAISE DEBUG 'itemprice, item=%, cust=%, shipto=%, list price= %', pItemid, pCustid, pShiptoid, _listprice;

  _row.itemprice_price := _listprice;
  _row.itemprice_type := 'P';
  RETURN NEXT _row;

  RETURN;

END;
$$;


ALTER FUNCTION public.itemipsprice(pitemid integer, pcustid integer, pshiptoid integer, pqty numeric, pqtyuom integer, ppriceuom integer, pcurrid integer, peffective date, pasof date, psiteid integer) OWNER TO admin;

--
-- TOC entry 1887 (class 1255 OID 146566682)
-- Dependencies: 4536 8
-- Name: itemlocdistqty(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemlocdistqty(integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pLocationid ALIAS FOR $1;
  pParentid ALIAS FOR $2;
  _qty NUMERIC;
  _tempQty NUMERIC;

BEGIN

  SELECT COALESCE(SUM(itemlocdist_qty), 0) INTO _qty
  FROM itemlocdist
  WHERE ( (itemlocdist_source_type='L')
   AND (itemlocdist_source_id=pLocationid)
   AND (itemlocdist_itemlocdist_id=pParentid) );

  SELECT COALESCE(SUM(itemlocdist_qty), 0) INTO _tempQty
  FROM itemlocdist, itemloc
  WHERE ( (itemlocdist_source_type='I')
   AND (itemlocdist_source_id=itemloc_id)
   AND (itemloc_location_id=pLocationid)
   AND (itemlocdist_itemlocdist_id=pParentid) );

  _qty := (_qty + _tempQty);

  RETURN _qty;

END;
$_$;


ALTER FUNCTION public.itemlocdistqty(integer, integer) OWNER TO admin;

--
-- TOC entry 1886 (class 1255 OID 146566681)
-- Dependencies: 4536 8
-- Name: itemlocdistqty(text, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemlocdistqty(text, integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTypes ALIAS FOR $1;
  pLocationid ALIAS FOR $2;
  pParentid ALIAS FOR $3;
  _qty NUMERIC := 0;
  _tempQty NUMERIC;

BEGIN

  IF (strpos(pTypes, 'L') > 0) THEN
    SELECT COALESCE(SUM(itemlocdist_qty), 0) INTO _tempQty
    FROM itemlocdist
    WHERE ( (itemlocdist_source_type='L')
     AND (itemlocdist_source_id=pLocationid)
     AND (itemlocdist_itemlocdist_id=pParentid) );

    _qty := (_qty + _tempQty);
  END IF;

  IF (strpos(pTypes, 'I') > 0) THEN
    SELECT COALESCE(SUM(itemlocdist_qty), 0) INTO _tempQty
    FROM itemlocdist, itemloc
    WHERE ( (itemlocdist_source_type='I')
     AND (itemlocdist_source_id=itemloc_id)
     AND (itemloc_location_id=pLocationid)
     AND (itemlocdist_itemlocdist_id=pParentid) );

    _qty := (_qty + _tempQty);
  END IF;

  RETURN _qty;

END;
$_$;


ALTER FUNCTION public.itemlocdistqty(text, integer, integer) OWNER TO admin;

--
-- TOC entry 1888 (class 1255 OID 146566683)
-- Dependencies: 4536 8
-- Name: itemprice(integer, integer, integer, numeric, integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemprice(pitemid integer, pcustid integer, pshiptoid integer, pqty numeric, pcurrid integer, peffective date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _item RECORD;

BEGIN
  SELECT item_inv_uom_id, item_price_uom_id
    INTO _item
    FROM item
   WHERE(item_id=pItemid);
  IF (FOUND) THEN
    RETURN itemPrice(pItemid, pCustid, pShiptoid, pQty, _item.item_inv_uom_id, _item.item_price_uom_id, pCurrid, pEffective);
  END IF;
  RETURN -9999;
END;
$$;


ALTER FUNCTION public.itemprice(pitemid integer, pcustid integer, pshiptoid integer, pqty numeric, pcurrid integer, peffective date) OWNER TO admin;

--
-- TOC entry 1889 (class 1255 OID 146566684)
-- Dependencies: 4536 8
-- Name: itemprice(integer, integer, integer, numeric, integer, integer, integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemprice(pitemid integer, pcustid integer, pshiptoid integer, pqty numeric, pqtyuom integer, ppriceuom integer, pcurrid integer, peffective date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE

BEGIN
  RETURN itemPrice(pItemid, pCustid, pShiptoid, pQty, pQtyUOM, pPriceUOM, pCurrid, pEffective, CURRENT_DATE);
END;
$$;


ALTER FUNCTION public.itemprice(pitemid integer, pcustid integer, pshiptoid integer, pqty numeric, pqtyuom integer, ppriceuom integer, pcurrid integer, peffective date) OWNER TO admin;

--
-- TOC entry 1890 (class 1255 OID 146566685)
-- Dependencies: 4536 8
-- Name: itemprice(integer, integer, integer, numeric, integer, integer, integer, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemprice(pitemid integer, pcustid integer, pshiptoid integer, pqty numeric, pqtyuom integer, ppriceuom integer, pcurrid integer, peffective date, pasof date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE

BEGIN
  RETURN itemPrice(pItemid, pCustid, pShiptoid, pQty, pQtyUOM, pPriceUOM, pCurrid, pEffective, pAsOf, NULL);
END;
$$;


ALTER FUNCTION public.itemprice(pitemid integer, pcustid integer, pshiptoid integer, pqty numeric, pqtyuom integer, ppriceuom integer, pcurrid integer, peffective date, pasof date) OWNER TO admin;

--
-- TOC entry 1891 (class 1255 OID 146566686)
-- Dependencies: 4536 8
-- Name: itemprice(integer, integer, integer, numeric, integer, integer, integer, date, date, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemprice(pitemid integer, pcustid integer, pshiptoid integer, pqty numeric, pqtyuom integer, ppriceuom integer, pcurrid integer, peffective date, pasof date, psiteid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _r RECORD;

BEGIN
  SELECT * FROM itemIpsPrice(pItemid, pCustid, pShiptoid, pQty, pQtyUOM, pPriceUOM,
                             pCurrid, pEffective, pAsOf, pSiteid) INTO _r;
  RETURN _r.itemprice_price;
END;
$$;


ALTER FUNCTION public.itemprice(pitemid integer, pcustid integer, pshiptoid integer, pqty numeric, pqtyuom integer, ppriceuom integer, pcurrid integer, peffective date, pasof date, psiteid integer) OWNER TO admin;

--
-- TOC entry 1892 (class 1255 OID 146566687)
-- Dependencies: 4536 8
-- Name: itemsellinguom(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemsellinguom(integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;

BEGIN
  RETURN itemUOMByType(pItemid, 'Selling');
END;
$_$;


ALTER FUNCTION public.itemsellinguom(integer) OWNER TO admin;

--
-- TOC entry 1893 (class 1255 OID 146566688)
-- Dependencies: 4536 8
-- Name: itemsrcprice(integer, numeric, integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemsrcprice(pitemsrcid integer, pqty numeric, pcurrid integer, peffective date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _price NUMERIC := 0.0;

BEGIN

  SELECT itemsrcPrice(pItemsrcid, -1, FALSE, pQty, pCurrid, pEffective) INTO _price;

  RETURN _price;

END;
$$;


ALTER FUNCTION public.itemsrcprice(pitemsrcid integer, pqty numeric, pcurrid integer, peffective date) OWNER TO admin;

--
-- TOC entry 1894 (class 1255 OID 146566689)
-- Dependencies: 4536 8
-- Name: itemsrcprice(integer, integer, boolean, numeric, integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemsrcprice(pitemsrcid integer, psiteid integer, pdropship boolean, pqty numeric, pcurrid integer, peffective date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _price NUMERIC := 0.0;
  _r RECORD;
  _effective DATE;

BEGIN
-- If no pEffective passed, use current date
  _effective := COALESCE(pEffective, CURRENT_DATE);

--  Cache Itemsrc and Item
  SELECT *
  INTO _r
  FROM itemsrc JOIN item ON (item_id=itemsrc_item_id)
  WHERE (itemsrc_id=pItemsrcid);
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'itemsrc % not found.', pItemsrcid;
  END IF;

--  Determine price
  SELECT currToCurr(itemsrcp_curr_id, pCurrid, price, _effective) INTO _price
  FROM (
    SELECT *,
           CASE itemsrcp_type WHEN ('N') THEN itemsrcp_price
                              WHEN ('D') THEN (_r.item_listcost - (_r.item_listcost * itemsrcp_discntprcnt) - itemsrcp_fixedamtdiscount)
                              ELSE 0.0
           END AS price
    FROM itemsrcp
    WHERE ( (itemsrcp_itemsrc_id=_r.itemsrc_id)
      AND   ((itemsrcp_warehous_id=pSiteid) OR (itemsrcp_warehous_id=-1))
      AND   ((itemsrcp_dropship=pDropship) OR (NOT itemsrcp_dropship))
      AND   (itemsrcp_qtybreak <= pQty) )
    ORDER BY itemsrcp_qtybreak DESC
    LIMIT 1
       ) AS data
  ;

  RETURN _price;

END;
$$;


ALTER FUNCTION public.itemsrcprice(pitemsrcid integer, psiteid integer, pdropship boolean, pqty numeric, pcurrid integer, peffective date) OWNER TO admin;

--
-- TOC entry 1895 (class 1255 OID 146566690)
-- Dependencies: 4536 8
-- Name: itemuombytype(integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemuombytype(integer, text) RETURNS text
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pUomtype ALIAS FOR $2;
  _uom TEXT;
BEGIN
  SELECT uom_name INTO _uom FROM (
  SELECT uom_name
    FROM item
    JOIN itemuomconv ON (itemuomconv_item_id=item_id)
    JOIN itemuom ON (itemuom_itemuomconv_id=itemuomconv_id)
    JOIN uomtype ON (itemuom_uomtype_id=uomtype_id)
    JOIN uom ON (itemuomconv_to_uom_id=uom_id)
   WHERE((item_id=pItemid)
     AND (uomtype_name=pUomtype)
     AND (item_inv_uom_id != itemuomconv_to_uom_id))
  UNION
  SELECT uom_name
    FROM item
    JOIN itemuomconv ON (itemuomconv_item_id=item_id)
    JOIN itemuom ON (itemuom_itemuomconv_id=itemuomconv_id)
    JOIN uomtype ON (itemuom_uomtype_id=uomtype_id)
    JOIN uom ON (itemuomconv_from_uom_id=uom_id)
   WHERE((item_id=pItemid)
     AND (uomtype_name=pUomtype)
     AND (item_inv_uom_id != itemuomconv_from_uom_id))) data
   LIMIT 1;

  IF (NOT FOUND) THEN
    SELECT uom_name
      INTO _uom
      FROM item
      JOIN uom ON (item_inv_uom_id=uom_id)
     WHERE(item_id=pItemid);
  END IF;

  RETURN _uom;
END;
$_$;


ALTER FUNCTION public.itemuombytype(integer, text) OWNER TO admin;

--
-- TOC entry 1896 (class 1255 OID 146566691)
-- Dependencies: 4536 8
-- Name: itemuomfractionalbytype(integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemuomfractionalbytype(integer, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pUomtype ALIAS FOR $2;
  _frac BOOLEAN;
BEGIN
  SELECT itemuomconv_fractional
    INTO _frac
    FROM item
    JOIN itemuomconv ON (itemuomconv_item_id=item_id)
    JOIN itemuom ON (itemuom_itemuomconv_id=itemuomconv_id)
    JOIN uomtype ON (itemuom_uomtype_id=uomtype_id)
   WHERE((item_id=pItemid)
     AND (uomtype_name=pUomtype))
   LIMIT 1;

  IF (NOT FOUND) THEN
    SELECT item_fractional
      INTO _frac
      FROM item
      JOIN uom ON (item_inv_uom_id=uom_id)
     WHERE(item_id=pItemid);
  END IF;

  RETURN _frac;
END;
$_$;


ALTER FUNCTION public.itemuomfractionalbytype(integer, text) OWNER TO admin;

--
-- TOC entry 1898 (class 1255 OID 146566692)
-- Dependencies: 4536 8
-- Name: itemuomfractionalbyuom(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemuomfractionalbyuom(integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pUomid ALIAS FOR $2;
  _frac BOOLEAN;
BEGIN
  SELECT itemuomconv_fractional
    INTO _frac
    FROM item
    JOIN itemuomconv ON (itemuomconv_item_id=item_id)
   WHERE((item_id=pItemid)
     AND ((itemuomconv_from_uom_id=item_inv_uom_id AND itemuomconv_to_uom_id=pUomid)
       OR (itemuomconv_to_uom_id=item_inv_uom_id AND itemuomconv_from_uom_id=pUomid)))
   LIMIT 1;

  IF (NOT FOUND) THEN
    SELECT item_fractional
      INTO _frac
      FROM item
      JOIN uom ON (item_inv_uom_id=uom_id)
     WHERE(item_id=pItemid);
  END IF;

  RETURN _frac;
END;
$_$;


ALTER FUNCTION public.itemuomfractionalbyuom(integer, integer) OWNER TO admin;

--
-- TOC entry 1899 (class 1255 OID 146566693)
-- Dependencies: 4536 8
-- Name: itemuomratiobytype(integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemuomratiobytype(integer, text) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pUomtype ALIAS FOR $2;
  _ratio NUMERIC;
BEGIN
  -- Return the ration as alternate / inventory uom
  SELECT CASE WHEN(itemuomconv_from_uom_id=item_inv_uom_id) THEN itemuomconv_to_value / itemuomconv_from_value
              ELSE itemuomconv_from_value / itemuomconv_to_value
         END
    INTO _ratio
    FROM item
    JOIN itemuomconv ON (itemuomconv_item_id=item_id)
    JOIN itemuom ON (itemuom_itemuomconv_id=itemuomconv_id)
    JOIN uomtype ON (itemuom_uomtype_id=uomtype_id)
   WHERE((item_id=pItemid)
     AND (uomtype_name=pUomtype))
   LIMIT 1;

  IF (NOT FOUND) THEN
    _ratio := 1.0;
  END IF;

  RETURN _ratio;
END;
$_$;


ALTER FUNCTION public.itemuomratiobytype(integer, text) OWNER TO admin;

--
-- TOC entry 1900 (class 1255 OID 146566694)
-- Dependencies: 4536 8
-- Name: itemuomtouom(integer, integer, integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemuomtouom(integer, integer, integer, numeric) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN itemuomtouom($1, $2, $3, $4, 'qty');
END;
$_$;


ALTER FUNCTION public.itemuomtouom(integer, integer, integer, numeric) OWNER TO admin;

--
-- TOC entry 1901 (class 1255 OID 146566695)
-- Dependencies: 4536 8
-- Name: itemuomtouom(integer, integer, integer, numeric, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemuomtouom(pitemid integer, puomidfrom integer, puomidto integer, pqtyfrom numeric, plocale text) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _uomidFrom INTEGER;
  _uomidTo   INTEGER;
  _uomidInv  INTEGER;
  _valueFrom NUMERIC := 0.0;
  _valueTo   NUMERIC := 0.0;
  _value     NUMERIC := 0.0;
  _item      RECORD;
  _conv      RECORD;
  _frac      BOOLEAN := FALSE;
BEGIN

  SELECT item_inv_uom_id, item_fractional
    INTO _item
    FROM item
   WHERE(item_id=pItemid);
  IF(NOT FOUND) THEN
    RAISE EXCEPTION 'No item record was found for item id %', pItemid;
  END IF;

  _uomidFrom := COALESCE(pUomidFrom, _item.item_inv_uom_id);
  _uomidTo   := COALESCE(pUomidTo,   _item.item_inv_uom_id);
  _uomidInv  := _item.item_inv_uom_id;

  -- Should we round the qty here or not?
  IF(_uomidFrom = _uomidTo) THEN
    -- Both from/to are the same. If it is the item inv uom
    -- then use the item fractional value otherwise assume
    -- it is fractional for now so the user gets the same value back.
    IF(_uomidFrom = _item.item_inv_uom_id) THEN
      _frac := _item.item_fractional;
    ELSE
      _frac := true;
    END IF;
    RETURN roundLocale(_frac, pQtyFrom, pLocale);
  END IF;

  -- Try a direct conversion
  SELECT itemuomconv_from_uom_id, itemuomconv_from_value,
         itemuomconv_to_uom_id, itemuomconv_to_value,
         itemuomconv_fractional
    INTO _conv
    FROM itemuomconv
   WHERE(((itemuomconv_from_uom_id=_uomidFrom AND itemuomconv_to_uom_id=_uomidTo)
       OR (itemuomconv_from_uom_id=_uomidTo AND itemuomconv_to_uom_id=_uomidFrom))
     AND (itemuomconv_item_id=pItemid));
  IF(FOUND) THEN
    IF(_conv.itemuomconv_from_uom_id=_uomidFrom) THEN
      _valueFrom := _conv.itemuomconv_from_value;
      _valueTo := _conv.itemuomconv_to_value;
    ELSE
      _valueFrom := _conv.itemuomconv_to_value;
      _valueTo := _conv.itemuomconv_from_value;
    END IF;

    -- If we are converting to the item inv uom use the item fractional value
    -- otherwise use the conversion fractional value.
    if(_uomidTo = _uomidInv) THEN
      _frac := _item.item_fractional;
    ELSE
      _frac := _conv.itemuomconv_fractional;
    END IF;
    _value := roundLocale(_frac, ((_valueTo/_valueFrom) * pQtyFrom), pLocale);
  ELSE
    -- Try to convert the from uom to the inventory uom
    SELECT itemuomconv_from_uom_id, itemuomconv_from_value,
           itemuomconv_to_uom_id, itemuomconv_to_value,
           itemuomconv_fractional
      INTO _conv
      FROM itemuomconv
     WHERE(((itemuomconv_from_uom_id=_uomidFrom AND itemuomconv_to_uom_id=_uomidInv)
         OR (itemuomconv_from_uom_id=_uomidInv AND itemuomconv_to_uom_id=_uomidFrom))
       AND (itemuomconv_item_id=pItemid));
    IF(NOT FOUND) THEN
      RAISE EXCEPTION 'A conversion for item_id % from uom_id % to inv_uom_id % was not found.', pItemid, _uomidFrom, _uomidInv;
    END IF;
    IF(_conv.itemuomconv_from_uom_id=_uomidInv) THEN
      _valueFrom := _conv.itemuomconv_from_value;
      _valueTo := _conv.itemuomconv_to_value;
    ELSE
      _valueFrom := _conv.itemuomconv_to_value;
      _valueTo := _conv.itemuomconv_from_value;
    END IF;
    _value := (_valueTo / _valueFrom);
    IF (_conv.itemuomconv_fractional OR _item.item_fractional) THEN
      _frac := TRUE;
    END IF;
    -- Try to convert the to uom to the inventory uom
    SELECT itemuomconv_from_uom_id, itemuomconv_from_value,
           itemuomconv_to_uom_id, itemuomconv_to_value,
           itemuomconv_fractional
      INTO _conv
      FROM itemuomconv
     WHERE(((itemuomconv_from_uom_id=_uomidInv AND itemuomconv_to_uom_id=_uomidTo)
         OR (itemuomconv_from_uom_id=_uomidTo AND itemuomconv_to_uom_id=_uomidInv))
       AND (itemuomconv_item_id=pItemid));
    IF(NOT FOUND) THEN
      RAISE EXCEPTION 'A conversion for item_id % from uom_id % to inv_uom_id % was not found.', pItemid, _uomidTo, _uomidInv;
    END IF;
    IF(_conv.itemuomconv_from_uom_id=_uomidInv) THEN
      _valueFrom := _conv.itemuomconv_from_value;
      _valueTo := _conv.itemuomconv_to_value;
    ELSE
      _valueFrom := _conv.itemuomconv_to_value;
      _valueTo := _conv.itemuomconv_from_value;
    END IF;
    _value := _value * (_valueTo / _valueFrom);
    IF (_conv.itemuomconv_fractional OR _item.item_fractional) THEN
      _frac := TRUE;
    END IF;
    _value := roundLocale(_frac, (_value * pQtyFrom), pLocale);
  END IF;

  RETURN _value;
END;
$$;


ALTER FUNCTION public.itemuomtouom(pitemid integer, puomidfrom integer, puomidto integer, pqtyfrom numeric, plocale text) OWNER TO admin;

--
-- TOC entry 1902 (class 1255 OID 146566696)
-- Dependencies: 4536 8
-- Name: itemuomtouomratio(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION itemuomtouomratio(pitemid integer, puomidfrom integer, puomidto integer) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _uomidFrom INTEGER;
  _uomidTo   INTEGER;
  _uomidInv  INTEGER;
  _valueFrom NUMERIC := 0.0;
  _valueTo   NUMERIC := 0.0;
  _value     NUMERIC := 0.0;
  _item      RECORD;
  _conv      RECORD;
BEGIN

  SELECT item_inv_uom_id
    INTO _item
    FROM item
   WHERE(item_id=pItemid);
  IF(NOT FOUND) THEN
    RAISE EXCEPTION 'No item record was found for item id %', pItemid;
  END IF;

  _uomidFrom := COALESCE(pUomidFrom, _item.item_inv_uom_id);
  _uomidTo   := COALESCE(pUomidTo,   _item.item_inv_uom_id);
  _uomidInv  := _item.item_inv_uom_id;

  IF(_uomidFrom = _uomidTo) THEN
    RETURN 1.0;
  END IF;

  -- Try a direct conversion
  SELECT itemuomconv_from_uom_id, itemuomconv_from_value,
         itemuomconv_to_uom_id, itemuomconv_to_value
    INTO _conv
    FROM itemuomconv
   WHERE(((itemuomconv_from_uom_id=_uomidFrom AND itemuomconv_to_uom_id=_uomidTo)
       OR (itemuomconv_from_uom_id=_uomidTo AND itemuomconv_to_uom_id=_uomidFrom))
     AND (itemuomconv_item_id=pItemid));
  IF(FOUND) THEN
    IF(_conv.itemuomconv_from_uom_id=_uomidFrom) THEN
      _valueFrom := _conv.itemuomconv_from_value;
      _valueTo := _conv.itemuomconv_to_value;
    ELSE
      _valueFrom := _conv.itemuomconv_to_value;
      _valueTo := _conv.itemuomconv_from_value;
    END IF;
    _value := (_valueTo / _valueFrom);
  ELSE
    -- Try to convert the from uom to the inventory uom
    SELECT itemuomconv_from_uom_id, itemuomconv_from_value,
           itemuomconv_to_uom_id, itemuomconv_to_value
      INTO _conv
      FROM itemuomconv
     WHERE(((itemuomconv_from_uom_id=_uomidFrom AND itemuomconv_to_uom_id=_uomidInv)
         OR (itemuomconv_from_uom_id=_uomidInv AND itemuomconv_to_uom_id=_uomidFrom))
       AND (itemuomconv_item_id=pItemid));
    IF(NOT FOUND) THEN
      RAISE EXCEPTION 'A conversion for item_id % from uom_id % to inv_uom_id % was not found.', pItemid, _uomidFrom, _uomidInv;
    END IF;
    IF(_conv.itemuomconv_from_uom_id=_uomidInv) THEN
      _valueFrom := _conv.itemuomconv_from_value;
      _valueTo := _conv.itemuomconv_to_value;
    ELSE
      _valueFrom := _conv.itemuomconv_to_value;
      _valueTo := _conv.itemuomconv_from_value;
    END IF;
    _value := (_valueTo / _valueFrom);
    -- Try to convert the to uom to the inventory uom
    SELECT itemuomconv_from_uom_id, itemuomconv_from_value,
           itemuomconv_to_uom_id, itemuomconv_to_value
      INTO _conv
      FROM itemuomconv
     WHERE(((itemuomconv_from_uom_id=_uomidInv AND itemuomconv_to_uom_id=_uomidTo)
         OR (itemuomconv_from_uom_id=_uomidTo AND itemuomconv_to_uom_id=_uomidInv))
       AND (itemuomconv_item_id=pItemid));
    IF(NOT FOUND) THEN
      RAISE EXCEPTION 'A conversion for item_id % from uom_id % to inv_uom_id % was not found.', pItemid, _uomidTo, _uomidInv;
    END IF;
    IF(_conv.itemuomconv_from_uom_id=_uomidInv) THEN
      _valueFrom := _conv.itemuomconv_from_value;
      _valueTo := _conv.itemuomconv_to_value;
    ELSE
      _valueFrom := _conv.itemuomconv_to_value;
      _valueTo := _conv.itemuomconv_from_value;
    END IF;
    _value := _value * (_valueTo / _valueFrom);
  END IF;

  RETURN _value;
END;
$$;


ALTER FUNCTION public.itemuomtouomratio(pitemid integer, puomidfrom integer, puomidto integer) OWNER TO admin;

--
-- TOC entry 1903 (class 1255 OID 146566697)
-- Dependencies: 8
-- Name: last_agg(anyelement, anyelement); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION last_agg(anyelement, anyelement) RETURNS anyelement
    LANGUAGE sql STABLE
    AS $_$
  SELECT $2;
$_$;


ALTER FUNCTION public.last_agg(anyelement, anyelement) OWNER TO admin;

--
-- TOC entry 1904 (class 1255 OID 146566698)
-- Dependencies: 4536 8
-- Name: login(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION login() RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _p RECORD;

BEGIN

  RETURN login(false);

END;
$$;


ALTER FUNCTION public.login() OWNER TO admin;

--
-- TOC entry 1905 (class 1255 OID 146566699)
-- Dependencies: 4536 8
-- Name: login(boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION login(boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _setSearchPath ALIAS FOR $1;
  _p RECORD;

BEGIN
  -- added support for PostgreSQL 9.2.0, Incident 21852
  IF (compareversion('9.2.0') <= 0)
  THEN
    PERFORM pg_try_advisory_lock(datid::integer, pid)
     FROM pg_stat_activity
    WHERE(pid = pg_backend_pid());
  ELSE
    PERFORM pg_try_advisory_lock(datid::integer, procpid)
     FROM pg_stat_activity
    WHERE(procpid = pg_backend_pid());
  END IF;

  -- This is new to version 9.0 and higher and will error on older versions
  IF (compareversion('9.0.0') <= 0) THEN
    SET bytea_output TO escape;
  END IF;

  -- this is temporary until either qt fixes the postgres driver or we find &
  -- fix all of the places in our app that can write strings with backslashes
  SET standard_conforming_strings TO false;

  SELECT usr_id, userCanLogin(usr_username) AS usr_active INTO _p
  FROM usr
  WHERE (usr_username=getEffectiveXtUser());

  IF (NOT FOUND) THEN
    RETURN -1;

  ELSIF (NOT _p.usr_active) THEN
    IF(SELECT metric_value='AdminOnly'
         FROM metric
        WHERE metric_name='AllowedUserLogins') THEN
      RETURN -3;
    END IF;
    RETURN -2;
  END IF;

  IF (_setSearchPath) THEN
    IF EXISTS(SELECT 1
                FROM pg_proc
                JOIN pg_namespace ON (pronamespace=pg_namespace.oid)
               WHERE nspname='public'
                 AND proname='buildsearchpath') THEN
      EXECUTE 'SET SEARCH_PATH TO ' || public.buildSearchPath();
    END IF;
  END IF;

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.login(boolean) OWNER TO admin;

--
-- TOC entry 1906 (class 1255 OID 146566700)
-- Dependencies: 4536 8
-- Name: logout(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION logout() RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  PERFORM pg_advisory_unlock(datid::integer, procpid)
     FROM pg_stat_activity
    WHERE(procpid = pg_backend_pid());

  RETURN 0;
END;
$$;


ALTER FUNCTION public.logout() OWNER TO admin;

--
-- TOC entry 1907 (class 1255 OID 146566701)
-- Dependencies: 4536 8
-- Name: lowercost(integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION lowercost(integer, text) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid	ALIAS FOR $1;
  pCosttype	ALIAS FOR $2;

BEGIN
    RETURN lowerCost(pItemid, pCosttype, TRUE);
END;
$_$;


ALTER FUNCTION public.lowercost(integer, text) OWNER TO admin;

--
-- TOC entry 1908 (class 1255 OID 146566702)
-- Dependencies: 4536 8
-- Name: lowercost(integer, text, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION lowercost(integer, text, boolean) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pCosttype ALIAS FOR $2;
  pActual	ALIAS FOR $3;
  _type CHAR(1);
  _actCost	NUMERIC;
  _actCost1	NUMERIC;
  _actCost2	NUMERIC;
  _stdCost	NUMERIC;
  _stdCost1	NUMERIC;
  _stdCost2	NUMERIC;
  _cost		NUMERIC;
  _cost1	NUMERIC;
  _cost2	NUMERIC;
  _batchsize	NUMERIC;

BEGIN

  SELECT item_type INTO _type
  FROM item
  WHERE (item_id=pItemid);

  _batchsize := COALESCE( (
    SELECT bomhead_batchsize
    FROM bomhead
    WHERE ((bomhead_item_id=pItemId)
     AND  (bomhead_rev_id=getActiveRevId('BOM',pItemId))) LIMIT 1), 1);

  -- find the lowercost in the base currency at the current conversion rate
  IF (_type IN ('M', 'F', 'B', 'T')) THEN

    IF (pActual) THEN
      SELECT SUM( CASE WHEN (bomitemcost_id IS NOT NULL AND bc.costelem_id IS NOT NULL) THEN
                  round(currToBase(bomitemcost_curr_id, bomitemcost_actcost, CURRENT_DATE),6) *
                    itemuomtouom(bomitem_item_id, bomitem_uom_id, NULL, (bomitem_qtyfxd/_batchsize + bomitem_qtyper) * (1 + bomitem_scrap), 'qtyper')
                  ELSE
                  round(currToBase(itemcost_curr_id, itemcost_actcost, CURRENT_DATE),6) *
                    itemuomtouom(bomitem_item_id, bomitem_uom_id, NULL, (bomitem_qtyfxd/_batchsize + bomitem_qtyper) * (1 + bomitem_scrap), 'qtyper')
                  END )
	  INTO _cost
      FROM bomitem(pItemid)
        JOIN item ON (item_id=bomitem_item_id AND item_type <> 'T')
        JOIN itemcost ON (itemcost_item_id=bomitem_item_id)
        JOIN costelem ic ON (ic.costelem_id=itemcost_costelem_id AND ic.costelem_type=pCosttype)
        LEFT OUTER JOIN bomitemcost ON (bomitemcost_bomitem_id=bomitem_id)
        LEFT OUTER JOIN costelem bc ON (bc.costelem_id=bomitemcost_costelem_id AND bc.costelem_type=pCosttype)
      WHERE ( CURRENT_DATE BETWEEN bomitem_effective AND (bomitem_expires - 1) );
    ELSE
      SELECT SUM( CASE WHEN (bomitemcost_id IS NOT NULL AND bc.costelem_id IS NOT NULL) THEN
                  bomitemcost_stdcost *
                    itemuomtouom(bomitem_item_id, bomitem_uom_id, NULL, (bomitem_qtyfxd/_batchsize + bomitem_qtyper) * (1 + bomitem_scrap), 'qtyper')
                  ELSE
                  itemcost_stdcost *
                    itemuomtouom(bomitem_item_id, bomitem_uom_id, NULL, (bomitem_qtyfxd/_batchsize + bomitem_qtyper) * (1 + bomitem_scrap), 'qtyper')
                  END )
	  INTO _cost
      FROM bomitem(pItemid)
        JOIN item ON (item_id=bomitem_item_id AND item_type <> 'T')
        JOIN itemcost ON (itemcost_item_id=bomitem_item_id)
        JOIN costelem ON (costelem_id=itemcost_costelem_id AND costelem_type=pCosttype)
        LEFT OUTER JOIN bomitemcost ON (bomitemcost_bomitem_id=bomitem_id)
        LEFT OUTER JOIN costelem bc ON (bc.costelem_id=bomitemcost_costelem_id AND bc.costelem_type=pCosttype)
      WHERE ( CURRENT_DATE BETWEEN bomitem_effective AND (bomitem_expires - 1) );
    END IF;

    IF (NOT FOUND) THEN
      _cost := NULL;
    END IF;

  ELSIF (_type IN ('C')) THEN
    SELECT SUM(CASE WHEN (bbomitem_qtyper = 0) THEN 0
                    ELSE currToBase(itemcost_curr_id, itemcost_actcost, CURRENT_DATE) / bbomitem_qtyper * bbomitem_costabsorb
               END),
	   SUM(CASE WHEN (bbomitem_qtyper = 0) THEN 0
                    ELSE itemcost_stdcost / bbomitem_qtyper * bbomitem_costabsorb
               END)
	INTO _actCost1, _stdCost1
    FROM itemcost
         JOIN costelem       ON (itemcost_costelem_id=costelem_id)
         JOIN xtmfg.bbomitem ON (bbomitem_parent_item_id=itemcost_item_id)
    WHERE ( (bbomitem_item_id=pItemid)
     AND (CURRENT_DATE BETWEEN bbomitem_effective AND (bbomitem_expires - 1))
     AND (costelem_type=pCosttype) );

    SELECT SUM(CASE WHEN (t.bbomitem_qtyper = 0) THEN 0
                    ELSE currToBase(itemcost_curr_id, itemcost_actcost, CURRENT_DATE) * s.bbomitem_qtyper / t.bbomitem_qtyper * t.bbomitem_costabsorb
               END),
	   SUM(CASE WHEN (t.bbomitem_qtyper = 0) THEN 0
                    ELSE itemcost_stdcost * s.bbomitem_qtyper / t.bbomitem_qtyper * t.bbomitem_costabsorb
               END)
	INTO _actCost2, _stdCost2
    FROM costelem
         JOIN itemcost            ON (costelem_id=itemcost_costelem_id)
         JOIN xtmfg.bbomitem AS s ON (itemcost_item_id=s.bbomitem_item_id)
         JOIN xtmfg.bbomitem AS t ON (s.bbomitem_parent_item_id=t.bbomitem_parent_item_id)
         JOIN  item               ON (s.bbomitem_item_id=item_id)
    WHERE ( (t.bbomitem_item_id=pItemid)
     AND ( CURRENT_DATE BETWEEN s.bbomitem_effective
                        AND (s.bbomitem_expires - 1) )
     AND ( CURRENT_DATE BETWEEN t.bbomitem_effective
                        AND (t.bbomitem_expires - 1) )
     AND (item_type='Y')
     AND (costelem_type=pCosttype) );

    IF (pActual) THEN
	_cost  = _actCost;
	_cost1 = _actCost1;
	_cost2 = _actCost2;
    ELSE
	_cost  = _stdCost;
	_cost1 = _stdCost1;
	_cost2 = _stdCost2;	-- should this be std or act?
    END IF;

    IF (_cost1 IS NULL AND _cost2 IS NULL) THEN
	_cost = NULL;
    ELSE
        _cost = COALESCE(_cost1, 0) + COALESCE(_cost2, 0);
    END IF;

  ELSE
    RETURN NULL;
  END IF;

  RETURN round(_cost,6);

END;
$_$;


ALTER FUNCTION public.lowercost(integer, text, boolean) OWNER TO admin;

--
-- TOC entry 1909 (class 1255 OID 146566703)
-- Dependencies: 4536 8
-- Name: maintainbomworkspace(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION maintainbomworkspace() RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _test TEXT;

BEGIN

  SELECT tablename INTO _test
  FROM pg_tables
  WHERE (tablename='bomwork');
  IF (NOT FOUND) THEN
    CREATE TEMPORARY TABLE bomwork
    ( bomwork_id INTEGER, bomwork_set_id INTEGER, bomwork_parent_id INTEGER,
      bomwork_seqnumber INTEGER, bomwork_parent_seqnumber INTEGER,
      bomwork_item_id INTEGER, bomwork_item_type CHARACTER(1), bomwork_status CHARACTER(1),
      bomwork_qtyper NUMERIC(20, 8), bomwork_scrap NUMERIC(20, 10),
      bomwork_level INTEGER, bomwork_effective DATE, bomwork_expires DATE,
      bomwork_stdunitcost NUMERIC(16, 4), bomwork_actunitcost NUMERIC(16, 4),
      bomwork_createwo BOOLEAN, bomwork_issuemethod CHARACTER(1) );
    CREATE INDEX bomwork_set_id_idx ON bomwork(bomwork_set_id);
  END IF;

  RETURN 1;

END;
$$;


ALTER FUNCTION public.maintainbomworkspace() OWNER TO admin;

--
-- TOC entry 1910 (class 1255 OID 146566704)
-- Dependencies: 4536 8
-- Name: markapcheckasposted(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION markapcheckasposted(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RAISE NOTICE 'markAPCheckAsPosted() is deprecated - use markCheckAsPosted() instead';
  RETURN markCheckAsPosted($1);

END;
$_$;


ALTER FUNCTION public.markapcheckasposted(integer) OWNER TO admin;

--
-- TOC entry 1911 (class 1255 OID 146566705)
-- Dependencies: 4536 8
-- Name: markapcheckasprinted(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION markapcheckasprinted(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RAISE NOTICE 'markAPCheckAsPrinted() is deprecated - use markCheckAsPrinted()';
  RETURN markCheckAsPrinted($1);
END;
$_$;


ALTER FUNCTION public.markapcheckasprinted(integer) OWNER TO admin;

--
-- TOC entry 1912 (class 1255 OID 146566706)
-- Dependencies: 4536 8
-- Name: markcheckasposted(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION markcheckasposted(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCheckid ALIAS FOR $1;

BEGIN

  UPDATE checkhead
  SET checkhead_posted=TRUE
  WHERE (checkhead_id=pCheckid);

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.markcheckasposted(integer) OWNER TO admin;

--
-- TOC entry 1913 (class 1255 OID 146566707)
-- Dependencies: 4536 8
-- Name: markcheckasprinted(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION markcheckasprinted(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCheckid ALIAS FOR $1;

BEGIN

  UPDATE checkhead
  SET checkhead_printed=TRUE
  WHERE (checkhead_id=pCheckid);

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.markcheckasprinted(integer) OWNER TO admin;

--
-- TOC entry 1914 (class 1255 OID 146566708)
-- Dependencies: 4536 8
-- Name: massexpirebomitem(integer, date, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION massexpirebomitem(integer, date, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pExpireDate ALIAS FOR $2;
  pECN ALIAS FOR $3;

BEGIN

  UPDATE bomitem
  SET bomitem_expires=pExpireDate
  WHERE ( (bomitem_expires >= CURRENT_DATE)
   AND (bomitem_item_id=pItemid)
   AND (bomitem_rev_id=getActiveRevId('BOM',bomitem_parent_item_id)) );

  RETURN TRUE;
END;
$_$;


ALTER FUNCTION public.massexpirebomitem(integer, date, text) OWNER TO admin;

--
-- TOC entry 1915 (class 1255 OID 146566709)
-- Dependencies: 4536 8
-- Name: massreplacebomitem(integer, integer, date, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION massreplacebomitem(integer, integer, date, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pNewItemid ALIAS FOR $1;
  pOriginalItemid ALIAS FOR $2;
  pEffectiveDate ALIAS FOR $3;
  pECN ALIAS FOR $4;
  _effectiveDate DATE;
  _result		INTEGER;

BEGIN

  _effectiveDate := COALESCE(pEffectiveDate, CURRENT_DATE);

  IF (BOMContains(pOriginalItemid, pNewItemid) OR
      BOMContains(pNewItemid, pOriginalItemid)) THEN
    RETURN -1;
  END IF;

  INSERT INTO bomitem
  ( bomitem_parent_item_id, bomitem_seqnumber,
    bomitem_item_id, bomitem_qtyfxd, bomitem_qtyper, bomitem_uom_id,
    bomitem_scrap, bomitem_effective, bomitem_expires, bomitem_ecn,
    bomitem_createwo, bomitem_issuemethod, bomitem_subtype,
    bomitem_booitem_seq_id, bomitem_schedatwooper, bomitem_moddate, bomitem_rev_id,
    bomitem_char_id, bomitem_value )
  SELECT bomitem_parent_item_id, bomitem_seqnumber,
         pNewItemid, bomitem_qtyfxd, bomitem_qtyper, bomitem_uom_id,
         bomitem_scrap, _effectiveDate, endOfTime(), pECN,
         bomitem_createwo, bomitem_issuemethod, 'I',
         bomitem_booitem_seq_id, bomitem_schedatwooper, CURRENT_DATE, getActiveRevId('BOM',bomitem_parent_item_id),
         bomitem_char_id, bomitem_value
  FROM bomitem
  WHERE ( (_effectiveDate < bomitem_expires)
   AND (bomitem_item_id=pOriginalItemid)
   AND (bomitem_rev_id=getActiveRevId('BOM',bomitem_parent_item_id)) );

  UPDATE bomitem
  SET bomitem_expires=_effectiveDate
  WHERE ( (_effectiveDate < bomitem_expires)
   AND (bomitem_item_id=pOriginalItemid)
   AND (bomitem_rev_id=getActiveRevid('BOM',bomitem_parent_item_id)) );

  RETURN 1;
END;
$_$;


ALTER FUNCTION public.massreplacebomitem(integer, integer, date, text) OWNER TO admin;

--
-- TOC entry 1916 (class 1255 OID 146566710)
-- Dependencies: 4536 8
-- Name: merge2crmaccts(integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION merge2crmaccts(integer, integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSourceId ALIAS FOR $1;
  pTargetId ALIAS FOR $2;
  _purge    BOOLEAN := COALESCE($3, FALSE);

  _coldesc    RECORD;
  _count      INTEGER := 0;
  _hassubtype BOOLEAN;
  _mrgcol     BOOLEAN;
  _result     INTEGER := 0;
  _sel        RECORD;
  _colname    TEXT;
  _tmpid      INTEGER;

BEGIN
  -- Validate
  IF (pSourceId = pTargetId) THEN
    RAISE NOTICE 'Tried to merge a CRM Account with itself: %.', pSourceId;
    RETURN 0;
  ELSIF (pSourceId IS NULL) THEN
    RAISE EXCEPTION 'Merge source id cannot be null [xtuple: merge, -1]';
  ELSIF NOT(EXISTS(SELECT 1 FROM crmacct WHERE crmacct_id=pSourceId)) THEN
    RAISE EXCEPTION 'Merge source % not found [xtuple: merge, -2, %]',
                    pSourceId, pSourceId;
  ELSIF (pTargetId IS NULL) THEN
    RAISE EXCEPTION 'Merge target id cannot be null [xtuple: merge, -3]';
  ELSIF NOT(EXISTS(SELECT 1 FROM crmacct WHERE crmacct_id=pTargetId)) THEN
    RAISE EXCEPTION 'Merge target % not found [xtuple: merge, -4, %]',
                    pTargetId, pTargetId;
  ELSIF NOT(EXISTS(SELECT 1
                     FROM crmacctsel
                    WHERE (crmacctsel_src_crmacct_id=pSourceId)
                      AND (crmacctsel_dest_crmacct_id=pTargetId))) THEN
    RAISE EXCEPTION 'Source % and target % have not been selected for merging [xtuple: merge, -5, %, %]',
                    pSourceId, pTargetId, pSourceId, pTargetId;
  END IF;

  _result:= changeFkeyPointers('public', 'crmacct', pSourceId, pTargetId,
                               ARRAY[ 'crmacctsel', 'crmacctmrgd' ], _purge)
          + changePseudoFKeyPointers('public', 'alarm', 'alarm_source_id',
                                     pSourceId, 'public', 'crmacct', pTargetId,
                                     'alarm_source', 'CRMA', _purge)
          + changePseudoFKeyPointers('public', 'charass', 'charass_target_id',
                                     pSourceId, 'public', 'crmacct', pTargetId,
                                     'charass_target_type', 'CRMACCT', _purge)
          + changePseudoFKeyPointers('public', 'comment', 'comment_source_id',
                                     pSourceId, 'public', 'crmacct', pTargetId,
                                     'comment_source', 'CRMA', _purge)
          + changePseudoFKeyPointers('public', 'docass', 'docass_source_id',
                                     pSourceId, 'public', 'crmacct', pTargetId,
                                     'docass_source_type', 'CRMA', _purge)
          + changePseudoFKeyPointers('public', 'docass', 'docass_target_id',
                                     pSourceId, 'public', 'crmacct', pTargetId,
                                     'docass_target_type', 'CRMA', _purge)
          + changePseudoFKeyPointers('public', 'imageass', 'imageass_source_id',
                                     pSourceId, 'public', 'crmacct', pTargetId,
                                     'imageass_source', 'CRMA', _purge)
          ;

  -- TODO: find a generic way to handle pseudofkeys in packages - see 9401
  IF (fetchMetricBool('EnableBatchManager') AND packageIsEnabled('xtbatch')) THEN
    _result:= _result
            + changePseudoFKeyPointers('xtbatch', 'emlassc', 'emlassc_assc_id',
                                       pSourceId, 'public', 'crmacct', pTargetId,
                                       'emlassc_type', 'CRMA', _purge);
  END IF;

  -- back up all of the values in the target record that are about to be changed
  FOR _coldesc IN SELECT attname, typname
                    FROM pg_attribute
                    JOIN pg_type      ON (atttypid=pg_type.oid)
                    JOIN pg_class     ON (attrelid=pg_class.oid)
                    JOIN pg_namespace ON (relnamespace=pg_namespace.oid)
                   WHERE (attnum >= 0)
                     AND (relname='crmacct')
                     AND (nspname='public')
                     AND (attname NOT IN ('crmacct_id', 'crmacct_number'))
  LOOP

    -- if we're supposed to merge this column at all
    EXECUTE 'SELECT ' || quote_ident('crmacctsel_mrg_' || _coldesc.attname) || '
               FROM crmacctsel
              WHERE ((crmacctsel_src_crmacct_id='  || pSourceId || ')
                 AND (crmacctsel_dest_crmacct_id=' || pTargetId || '))' INTO _mrgcol;

    IF (_mrgcol) THEN
      _colname := REPLACE(_coldesc.attname, 'crmacctsel_mrg_', '');

      -- optionally back up the old value from the destination
      -- we'll back up the old value from the source further down
      IF (NOT _purge) THEN
        BEGIN
          EXECUTE 'INSERT INTO mrgundo (
                       mrgundo_schema,      mrgundo_table,
                       mrgundo_pkey_col,    mrgundo_pkey_id,
                       mrgundo_col,         mrgundo_value,      mrgundo_type,
                       mrgundo_base_schema, mrgundo_base_table, mrgundo_base_id
                 ) SELECT ''public'',     ''crmacct'',
                          ''crmacct_id'', crmacct_id, '   ||
                          quote_literal(_colname)         || ', ' ||
                          quote_ident(_colname)           || ', ' ||
                          quote_literal(_coldesc.typname) || ',
                          ''public'', ''crmacct'', crmacct_id
                     FROM crmacct
                    WHERE (crmacct_id=' || pTargetId || ');' ;
        EXCEPTION WHEN unique_violation THEN
          RAISE EXCEPTION 'Could not make a backup copy of % when merging % into % [xtuple: merge, -8, %, %, public, crmacct, %]',
                       _colname, pSourceId, pTargetId,
                       _colname, pSourceId, pTargetId;
        END;
      END IF;

      -- TODO: what do we do about users?
      /* update the destination crmacct in one of 3 different ways:
         - crmacct_notes might be concatenated from more than one source record
	 - foreign keys to crm account subtype records (e.g. crmacct_cust_id)
           must not leave orphaned records and must avoid uniqueness violations
         - some fields can simply be updated in place
       */
      IF (_colname = 'crmacct_notes') THEN
        EXECUTE 'UPDATE crmacct dest
                    SET '      || quote_ident(_colname) ||
                      '=dest.' || quote_ident(_colname) ||
                      E' || E''\\n'' || src.' || _colname || '
                  FROM crmacct src
                  JOIN crmacctsel ON (src.crmacct_id=crmacctsel_src_crmacct_id)
                 WHERE ((dest.crmacct_id=crmacctsel_dest_crmacct_id)
                    AND (dest.crmacct_id!=crmacctsel_src_crmacct_id));';

      ELSIF (_colname IN ('crmacct_cust_id', 'crmacct_prospect_id',
                          'crmacct_vend_id', 'crmacct_taxauth_id',
                          'crmacct_emp_id',  'crmacct_salesrep_id')) THEN
        IF (_colname IN ('crmacct_cust_id', 'crmacct_prospect_id')) THEN
          EXECUTE 'SELECT src.' || quote_ident(_colname) || ' IS NOT NULL
                      AND (dest.crmacct_prospect_id IS NOT NULL OR
                           dest.crmacct_cust_id IS NOT NULL)
                     FROM crmacct src
                     JOIN crmacctsel ON (src.crmacct_id=crmacctsel_src_crmacct_id)
                     JOIN crmacct dest ON (crmacctsel_dest_crmacct_id=dest.crmacct_id)
                    WHERE ((src.crmacct_id='  || pSourceId || ')
                       AND (dest.crmacct_id=' || pTargetId || '))' INTO _hassubtype;
          IF (_hassubtype) THEN
            RAISE EXCEPTION 'Cannot merge two CRM Accounts that both refer to Customers and/or Prospects [xtuple: merge, -6, %, %]',
                            pSourceId, pTargetId;
          END IF;
        ELSE
          EXECUTE 'SELECT src.' || quote_ident(_colname) || ' IS NOT NULL
                      AND dest.'|| quote_ident(_colname) || ' IS NOT NULL
                     FROM crmacct src
                     JOIN crmacctsel ON (src.crmacct_id=crmacctsel_src_crmacct_id)
                     JOIN crmacct dest ON (crmacctsel_dest_crmacct_id=dest.crmacct_id)
                    WHERE ((src.crmacct_id='  || pSourceId || ')
                       AND (dest.crmacct_id=' || pTargetId || '))' INTO _hassubtype;

          IF (_hassubtype) THEN
            RAISE EXCEPTION 'Cannot merge CRM Accounts until the % child records have been merged [xtuple: merge, -7, %, %, %]',
                            _colname, _colname, pSourceId, pTargetId;
          END IF;

        END IF;

        /* clearing the source separately from setting the target avoids
           problems with triggers updating the wrong records */
        EXECUTE 'SELECT ' || quote_ident(_colname) || ' FROM crmacct
                  WHERE crmacct_id=' || pSourceId
        INTO _tmpid;

        -- now we have the data to back up the source
        IF (NOT _purge) THEN
          BEGIN
            EXECUTE 'INSERT INTO mrgundo (
                         mrgundo_schema,      mrgundo_table,
                         mrgundo_pkey_col,    mrgundo_pkey_id,
                         mrgundo_col,         mrgundo_value,      mrgundo_type,
                         mrgundo_base_schema, mrgundo_base_table, mrgundo_base_id
                   ) SELECT ''public'',     ''crmacct'',
                            ''crmacct_id'', crmacct_id, '   ||
                            quote_literal(_colname)         || ', ' ||
                            quote_ident(_colname)           || ', ' ||
                            quote_literal(_coldesc.typname) || ',
                            ''public'', ''crmacct'', '      || pTargetId || '
                       FROM crmacct
                      WHERE (crmacct_id=' || pSourceId || ');' ;
          EXCEPTION WHEN unique_violation THEN
            RAISE EXCEPTION 'Could not make a backup copy of % when merging % into % [xtuple: merge, -8, %, %, public, crmacct, %]',
                         _colname, pSourceId, pTargetId,
                         _colname, pSourceId, pTargetId;
          END;
        END IF;

        EXECUTE 'UPDATE crmacct SET ' || quote_ident(_colname) || '=NULL
              WHERE (crmacct_id=' || pSourceId || ');';

        EXECUTE 'UPDATE crmacct
                    SET ' || quote_ident(_colname) || '=' || quote_literal(_tmpid) || '
              WHERE (crmacct_id=' || pTargetId || ');';

      ELSE
        EXECUTE 'UPDATE crmacct dest
                    SET '      || quote_ident(_colname) || '
                        =src.' || quote_ident(_colname) || '
                  FROM crmacct src
                 WHERE ((dest.crmacct_id=' || pTargetId || ')
                    AND (src.crmacct_id='  || pSourceId || '));';
      END IF;

      GET DIAGNOSTICS _count = ROW_COUNT;
      _result := _result + _count;
    END IF;

  END LOOP;

  IF (_purge) THEN
    DELETE FROM crmacct WHERE crmacct = pSourceId;
  ELSE
    INSERT INTO mrgundo (
           mrgundo_schema,      mrgundo_table,
           mrgundo_pkey_col,    mrgundo_pkey_id,
           mrgundo_col,         mrgundo_value,      mrgundo_type,
           mrgundo_base_schema, mrgundo_base_table, mrgundo_base_id
    ) SELECT 'public',         'crmacct',
             'crmacct_id',     pSourceId,
             'crmacct_active', crmacct_active, 'bool',
             'public',         'crmacct',       pTargetId
        FROM crmacct
       WHERE crmacct_active AND (crmacct_id = pSourceId);
    GET DIAGNOSTICS _count = ROW_COUNT;
    IF (_count > 0) THEN
      _result := _result + _count;
      UPDATE crmacct SET crmacct_active = false WHERE (crmacct_id=pSourceId);
    END IF;

    -- make a special record of the source crm account so we can delete it later
    INSERT INTO mrgundo (
           mrgundo_schema,      mrgundo_table,
           mrgundo_pkey_col,    mrgundo_pkey_id,
           mrgundo_col,         mrgundo_value,      mrgundo_type,
           mrgundo_base_schema, mrgundo_base_table, mrgundo_base_id
     ) VALUES (
           'public',     'crmacct',
           'crmacct_id', pSourceId,
           NULL,         NULL,       NULL,
           'public',     'crmacct', pTargetId);
  END IF;

  DELETE FROM crmacctsel WHERE (crmacctsel_src_crmacct_id=pSourceId);

  RETURN _result;
END;
$_$;


ALTER FUNCTION public.merge2crmaccts(integer, integer, boolean) OWNER TO admin;

--
-- TOC entry 9064 (class 0 OID 0)
-- Dependencies: 1916
-- Name: FUNCTION merge2crmaccts(integer, integer, boolean); Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON FUNCTION merge2crmaccts(integer, integer, boolean) IS 'This function merges two crmacct records as decribed in crmacctsel records. For each field in the crmacctsel record marked TRUE, the data are copied from the crmacct record with crmacct_id=pSourceId to the record with crmacct_id=pTargetId. If the purge argument is TRUE, the source record is deleted. If it is FALSE, then mrgundo records are created so the merge can later be undone.';


--
-- TOC entry 1919 (class 1255 OID 146566712)
-- Dependencies: 4536 8
-- Name: mergecrmaccts(integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION mergecrmaccts(integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTargetId     ALIAS FOR $1;
  _purge        BOOLEAN := COALESCE($2, FALSE);

  _retval       INTEGER;
BEGIN

  /* if crmacctsel says the target should not keep its original
     notes, clear them.  notes are special because the merge allows
     concatenating them from multiple sources. this needs to be
     kept in sync with merge2crmaccts' similar check.
   */
  IF NOT (SELECT crmacctsel_mrg_crmacct_notes
            FROM crmacctsel
           WHERE crmacctsel_src_crmacct_id=crmacctsel_dest_crmacct_id
             AND crmacctsel_dest_crmacct_id=pTargetId) THEN
    IF (NOT _purge) THEN
      INSERT INTO mrgundo (
             mrgundo_schema,      mrgundo_table,
             mrgundo_pkey_col,    mrgundo_pkey_id,
             mrgundo_col,         mrgundo_value,      mrgundo_type,
             mrgundo_base_schema, mrgundo_base_table, mrgundo_base_id)
      SELECT 'public', 'crmacct', crmacct_id,
             'public', 'crmacct', 'crmacct_id', crmacct_id,
             'crmacct_notes', crmacct_notes, 'text',
             'public', 'crmacct', crmacct_id
        FROM crmacct
       WHERE (crmacct_id=pTargetId);
    END IF;

    UPDATE crmacct
       SET crmacct_notes = ''
     WHERE (crmacct_id=pTargetId);
  END IF;

  -- merge the data from the various source records
  SELECT SUM(merge2crmaccts(crmacctsel_src_crmacct_id, pTargetId, _purge))
         INTO _retval
    FROM crmacctsel
   WHERE ((crmacctsel_dest_crmacct_id=pTargetId)
      AND (crmacctsel_dest_crmacct_id!=crmacctsel_src_crmacct_id));

  DELETE FROM crmacctsel WHERE crmacctsel_dest_crmacct_id=pTargetId;

  RETURN COALESCE(_retval, 0);

END;
$_$;


ALTER FUNCTION public.mergecrmaccts(integer, boolean) OWNER TO admin;

--
-- TOC entry 9065 (class 0 OID 0)
-- Dependencies: 1919
-- Name: FUNCTION mergecrmaccts(integer, boolean); Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON FUNCTION mergecrmaccts(integer, boolean) IS 'This function uses the crmacctsel table to merge multiple crmacct records together. Only the merges into the specified target account are performed. Most of the work is done by repeated calls to the merge2crmaccts function. If the purge argument is FALSE, data are kept to allow reversing the merge.';


--
-- TOC entry 1920 (class 1255 OID 146566713)
-- Dependencies: 4536 8
-- Name: movebomitemdown(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION movebomitemdown(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pBomitemid ALIAS FOR $1;
  _nextBomitem RECORD;

BEGIN

  SELECT nextbomitem.bomitem_seqnumber AS next_seqnumber,
         thisbomitem.bomitem_seqnumber AS this_seqnumber,
         thisbomitem.bomitem_parent_item_id AS parent_item_id,
         thisbomitem.bomitem_rev_id AS rev_id
          INTO _nextBomitem
  FROM bomitem AS nextbomitem, bomitem AS thisbomitem
  WHERE ((nextbomitem.bomitem_seqnumber > thisbomitem.bomitem_seqnumber)
   AND (nextbomitem.bomitem_parent_item_id=thisbomitem.bomitem_parent_item_id)
   AND (nextbomitem.bomitem_rev_id=thisbomitem.bomitem_rev_id)
   AND (thisbomitem.bomitem_id=pBomitemid))
  ORDER BY next_seqnumber
  LIMIT 1;

  IF (FOUND) THEN
--  Swap the seqnumber of the current bomitem and the next bomitem
--  There is the potential for multiple bomitems with the same seqnumber

    UPDATE bomitem
    SET bomitem_seqnumber=0
    WHERE (bomitem_seqnumber=_nextBomitem.next_seqnumber)
      AND (bomitem_parent_item_id=_nextBomitem.parent_item_id)
      AND (bomitem_rev_id=_nextBomitem.rev_id);

    UPDATE bomitem
    SET bomitem_seqnumber=_nextBomitem.next_seqnumber
    WHERE (bomitem_seqnumber=_nextBomitem.this_seqnumber)
      AND (bomitem_parent_item_id=_nextBomitem.parent_item_id)
      AND (bomitem_rev_id=_nextBomitem.rev_id);

    UPDATE bomitem
    SET bomitem_seqnumber=_nextBomitem.this_seqnumber
    WHERE (bomitem_seqnumber=0)
      AND (bomitem_parent_item_id=_nextBomitem.parent_item_id)
      AND (bomitem_rev_id=_nextBomitem.rev_id);
  END IF;

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.movebomitemdown(integer) OWNER TO admin;

--
-- TOC entry 1921 (class 1255 OID 146566714)
-- Dependencies: 4536 8
-- Name: movebomitemup(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION movebomitemup(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pBomitemid ALIAS FOR $1;
  _nextBomitem RECORD;

BEGIN

  SELECT nextbomitem.bomitem_seqnumber AS next_seqnumber,
         thisbomitem.bomitem_seqnumber AS this_seqnumber,
         thisbomitem.bomitem_parent_item_id AS parent_item_id,
         thisbomitem.bomitem_rev_id AS rev_id
          INTO _nextBomitem
  FROM bomitem AS nextbomitem, bomitem AS thisbomitem
  WHERE ((nextbomitem.bomitem_seqnumber < thisbomitem.bomitem_seqnumber)
   AND (nextbomitem.bomitem_parent_item_id=thisbomitem.bomitem_parent_item_id)
   AND (nextbomitem.bomitem_rev_id=thisbomitem.bomitem_rev_id)
   AND (thisbomitem.bomitem_id=pBomitemid))
  ORDER BY next_seqnumber DESC
  LIMIT 1;

  IF (FOUND) THEN
--  Swap the seqnumber of the current bomitem and the next bomitem
--  There is the potential for multiple bomitems with the same seqnumber

    UPDATE bomitem
    SET bomitem_seqnumber=0
    WHERE (bomitem_seqnumber=_nextBomitem.next_seqnumber)
      AND (bomitem_parent_item_id=_nextBomitem.parent_item_id)
      AND (bomitem_rev_id=_nextBomitem.rev_id);

    UPDATE bomitem
    SET bomitem_seqnumber=_nextBomitem.next_seqnumber
    WHERE (bomitem_seqnumber=_nextBomitem.this_seqnumber)
      AND (bomitem_parent_item_id=_nextBomitem.parent_item_id)
      AND (bomitem_rev_id=_nextBomitem.rev_id);

    UPDATE bomitem
    SET bomitem_seqnumber=_nextBomitem.this_seqnumber
    WHERE (bomitem_seqnumber=0)
      AND (bomitem_parent_item_id=_nextBomitem.parent_item_id)
      AND (bomitem_rev_id=_nextBomitem.rev_id);
  END IF;

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.movebomitemup(integer) OWNER TO admin;

--
-- TOC entry 1922 (class 1255 OID 146566715)
-- Dependencies: 4536 8
-- Name: moveccarddown(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION moveccarddown(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCcardid ALIAS FOR $1;
  _nextCcard RECORD;

BEGIN

  SELECT nextCcard.ccard_id, nextCcard.ccard_seq AS next_seqnumber,
         thisCcard.ccard_seq AS this_seqnumber INTO _nextCcard
  FROM Ccard AS nextCcard, Ccard AS thisCcard
  WHERE ((nextCcard.ccard_seq > thisCcard.ccard_seq)
   AND (nextCcard.ccard_cust_id=thisCcard.ccard_cust_id)
   AND (thisCcard.ccard_id=pCcardid))
  ORDER BY next_seqnumber
  LIMIT 1;

  IF (FOUND) THEN
--  Swap the seqnumber of the current Ccard and the next Ccard

    UPDATE Ccard
    SET ccard_seq=_nextCcard.next_seqnumber
    WHERE (ccard_id=pCcardid);

    UPDATE Ccard
    SET ccard_seq=_nextCcard.this_seqnumber
    WHERE (ccard_id=_nextCcard.ccard_id);
  END IF;

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.moveccarddown(integer) OWNER TO admin;

--
-- TOC entry 1923 (class 1255 OID 146566716)
-- Dependencies: 4536 8
-- Name: moveccardup(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION moveccardup(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCcardid ALIAS FOR $1;
  _nextCcard RECORD;

BEGIN

  SELECT nextCcard.ccard_id AS ccard_id, nextCcard.ccard_seq AS next_seqnumber,
         thisCcard.ccard_seq AS this_seqnumber INTO _nextCcard
  FROM ccard AS nextCcard, ccard AS thisCcard
  WHERE ((nextCcard.ccard_seq < thisCcard.ccard_seq)
   AND (nextCcard.ccard_cust_id=thisCcard.ccard_cust_id)
   AND (thisCcard.ccard_id=pCcardid))
  ORDER BY next_seqnumber DESC
  LIMIT 1;

  IF (FOUND) THEN
--  Swap the seqnumber of the current Ccard and the next Ccard

    UPDATE Ccard
    SET ccard_seq=_nextCcard.next_seqnumber
    WHERE (ccard_id=pCcardid);

    UPDATE Ccard
    SET ccard_seq=_nextCcard.this_seqnumber
    WHERE (ccard_id=_nextCcard.ccard_id);
  END IF;

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.moveccardup(integer) OWNER TO admin;

--
-- TOC entry 1925 (class 1255 OID 146566717)
-- Dependencies: 4536 8
-- Name: moveflgroupdown(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION moveflgroupdown(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pFlgrpid ALIAS FOR $1;
  _from RECORD;
  _to RECORD;

BEGIN

  SELECT flgrp_id AS id,
         flgrp_flhead_id AS flhead_id,
         flgrp_flgrp_id AS flgrp_id,
         flgrp_order AS ord INTO _from
    FROM flgrp
   WHERE (flgrp_id=pFlgrpid);
  IF (NOT FOUND) THEN
    RETURN -1;
  END IF;

  SELECT id, type, ord INTO _to
    FROM (SELECT flitem_id AS id, 'I' AS type, flitem_order AS ord
            FROM flitem
           WHERE ((flitem_flgrp_id=_from.flgrp_id)
             AND  (flitem_flhead_id=_from.flhead_id))
           UNION
          SELECT flgrp_id AS id, 'G' AS type, flgrp_order AS ord
            FROM flgrp
           WHERE ((flgrp_flgrp_id=_from.flgrp_id)
             AND  (flgrp_flhead_id=_from.flhead_id))
           UNION
          SELECT flspec_id AS id, 'S' AS type, flspec_order AS ord
            FROM flspec
           WHERE ((flspec_flgrp_id=_from.flgrp_id)
             AND  (flspec_flhead_id=_from.flhead_id)) ) AS data
   WHERE (ord > _from.ord)
   ORDER BY ord
   LIMIT 1;
  IF (FOUND) THEN
    UPDATE flgrp
       SET flgrp_order=_to.ord
     WHERE (flgrp_id=_from.id);

    IF (_to.type='I') THEN
      UPDATE flitem
         SET flitem_order=_from.ord
       WHERE (flitem_id=_to.id);
    ELSE
      IF (_to.type='G') THEN
        UPDATE flgrp
           SET flgrp_order=_from.ord
         WHERE (flgrp_id=_to.id);
      ELSE
        IF (_to.type='S') THEN
          UPDATE flspec
             SET flspec_order=_from.ord
           WHERE (flspec_id=_to.id);
        END IF;
      END IF;
    END IF;
  END IF;

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.moveflgroupdown(integer) OWNER TO admin;

--
-- TOC entry 1926 (class 1255 OID 146566718)
-- Dependencies: 4536 8
-- Name: moveflgroupup(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION moveflgroupup(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pFlgrpid ALIAS FOR $1;
  _from RECORD;
  _to RECORD;

BEGIN

  SELECT flgrp_id AS id,
         flgrp_flhead_id AS flhead_id,
         flgrp_flgrp_id AS flgrp_id,
         flgrp_order AS ord INTO _from
    FROM flgrp
   WHERE (flgrp_id=pFlgrpid);
  IF (NOT FOUND) THEN
    RETURN -1;
  END IF;

  SELECT id, type, ord INTO _to
    FROM (SELECT flitem_id AS id, 'I' AS type, flitem_order AS ord
            FROM flitem
           WHERE ((flitem_flgrp_id=_from.flgrp_id)
             AND  (flitem_flhead_id=_from.flhead_id))
           UNION
          SELECT flgrp_id AS id, 'G' AS type, flgrp_order AS ord
            FROM flgrp
           WHERE ((flgrp_flgrp_id=_from.flgrp_id)
             AND  (flgrp_flhead_id=_from.flhead_id))
           UNION
          SELECT flspec_id AS id, 'S' AS type, flspec_order AS ord
            FROM flspec
           WHERE ((flspec_flgrp_id=_from.flgrp_id)
             AND  (flspec_flhead_id=_from.flhead_id)) ) AS data
   WHERE (ord < _from.ord)
   ORDER BY ord DESC
   LIMIT 1;
  IF (FOUND) THEN
    UPDATE flgrp
       SET flgrp_order=_to.ord
     WHERE (flgrp_id=_from.id);

    IF (_to.type='I') THEN
      UPDATE flitem
         SET flitem_order=_from.ord
       WHERE (flitem_id=_to.id);
    ELSE
      IF (_to.type='G') THEN
        UPDATE flgrp
           SET flgrp_order=_from.ord
         WHERE (flgrp_id=_to.id);
      ELSE
        IF (_to.type='S') THEN
          UPDATE flspec
             SET flspec_order=_from.ord
           WHERE (flspec_id=_to.id);
        END IF;
      END IF;
    END IF;
  END IF;

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.moveflgroupup(integer) OWNER TO admin;

--
-- TOC entry 1927 (class 1255 OID 146566719)
-- Dependencies: 4536 8
-- Name: moveflitemdown(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION moveflitemdown(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pFlitemid ALIAS FOR $1;
  _from RECORD;
  _to RECORD;

BEGIN

  SELECT flitem_id AS id,
         flitem_flhead_id AS flhead_id,
         flitem_flgrp_id AS flgrp_id,
         flitem_order AS ord INTO _from
    FROM flitem
   WHERE (flitem_id=pFlitemid);
  IF (NOT FOUND) THEN
    RETURN -1;
  END IF;

  SELECT id, type, ord INTO _to
    FROM (SELECT flitem_id AS id, 'I' AS type, flitem_order AS ord
            FROM flitem
           WHERE ((flitem_flgrp_id=_from.flgrp_id)
             AND  (flitem_flhead_id=_from.flhead_id))
           UNION
          SELECT flgrp_id AS id, 'G' AS type, flgrp_order AS ord
            FROM flgrp
           WHERE ((flgrp_flgrp_id=_from.flgrp_id)
             AND  (flgrp_flhead_id=_from.flhead_id))
           UNION
          SELECT flspec_id AS id, 'S' AS type, flspec_order AS ord
            FROM flspec
           WHERE ((flspec_flgrp_id=_from.flgrp_id)
             AND  (flspec_flhead_id=_from.flhead_id)) ) AS data
   WHERE (ord > _from.ord)
   ORDER BY ord
   LIMIT 1;
  IF (FOUND) THEN
    UPDATE flitem
       SET flitem_order=_to.ord
     WHERE (flitem_id=_from.id);

    IF (_to.type='I') THEN
      UPDATE flitem
         SET flitem_order=_from.ord
       WHERE (flitem_id=_to.id);
    ELSE
      IF (_to.type='G') THEN
        UPDATE flgrp
           SET flgrp_order=_from.ord
         WHERE (flgrp_id=_to.id);
      ELSE
        IF (_to.type='S') THEN
          UPDATE flspec
             SET flspec_order=_from.ord
           WHERE (flspec_id=_to.id);
        END IF;
      END IF;
    END IF;
  END IF;

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.moveflitemdown(integer) OWNER TO admin;

--
-- TOC entry 1928 (class 1255 OID 146566720)
-- Dependencies: 4536 8
-- Name: moveflitemup(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION moveflitemup(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pFlitemid ALIAS FOR $1;
  _from RECORD;
  _to RECORD;

BEGIN

  SELECT flitem_id AS id,
         flitem_flhead_id AS flhead_id,
         flitem_flgrp_id AS flgrp_id,
         flitem_order AS ord INTO _from
    FROM flitem
   WHERE (flitem_id=pFlitemid);
  IF (NOT FOUND) THEN
    RETURN -1;
  END IF;

  SELECT id, type, ord INTO _to
    FROM (SELECT flitem_id AS id, 'I' AS type, flitem_order AS ord
            FROM flitem
           WHERE ((flitem_flgrp_id=_from.flgrp_id)
             AND  (flitem_flhead_id=_from.flhead_id))
           UNION
          SELECT flgrp_id AS id, 'G' AS type, flgrp_order AS ord
            FROM flgrp
           WHERE ((flgrp_flgrp_id=_from.flgrp_id)
             AND  (flgrp_flhead_id=_from.flhead_id))
           UNION
          SELECT flspec_id AS id, 'S' AS type, flspec_order AS ord
            FROM flspec
           WHERE ((flspec_flgrp_id=_from.flgrp_id)
             AND  (flspec_flhead_id=_from.flhead_id)) ) AS data
   WHERE (ord < _from.ord)
   ORDER BY ord DESC
   LIMIT 1;
  IF (FOUND) THEN
    UPDATE flitem
       SET flitem_order=_to.ord
     WHERE (flitem_id=_from.id);

    IF (_to.type='I') THEN
      UPDATE flitem
         SET flitem_order=_from.ord
       WHERE (flitem_id=_to.id);
    ELSE
      IF (_to.type='G') THEN
        UPDATE flgrp
           SET flgrp_order=_from.ord
         WHERE (flgrp_id=_to.id);
      ELSE
        IF (_to.type='S') THEN
          UPDATE flspec
             SET flspec_order=_from.ord
           WHERE (flspec_id=_to.id);
        END IF;
      END IF;
    END IF;
  END IF;

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.moveflitemup(integer) OWNER TO admin;

--
-- TOC entry 1930 (class 1255 OID 146566721)
-- Dependencies: 4536 8
-- Name: moveflspecdown(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION moveflspecdown(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pFlspecid ALIAS FOR $1;
  _from RECORD;
  _to RECORD;

BEGIN

  SELECT flspec_id AS id,
         flspec_flhead_id AS flhead_id,
         flspec_flgrp_id AS flgrp_id,
         flspec_order AS ord INTO _from
    FROM flspec
   WHERE (flspec_id=pFlspecid);
  IF (NOT FOUND) THEN
    RETURN -1;
  END IF;

  SELECT id, type, ord INTO _to
    FROM (SELECT flitem_id AS id, 'I' AS type, flitem_order AS ord
            FROM flitem
           WHERE ((flitem_flgrp_id=_from.flgrp_id)
             AND  (flitem_flhead_id=_from.flhead_id))
           UNION
          SELECT flgrp_id AS id, 'G' AS type, flgrp_order AS ord
            FROM flgrp
           WHERE ((flgrp_flgrp_id=_from.flgrp_id)
             AND  (flgrp_flhead_id=_from.flhead_id))
           UNION
          SELECT flspec_id AS id, 'S' AS type, flspec_order AS ord
            FROM flspec
           WHERE ((flspec_flgrp_id=_from.flgrp_id)
             AND  (flspec_flhead_id=_from.flhead_id)) ) AS data
   WHERE (ord > _from.ord)
   ORDER BY ord
   LIMIT 1;
  IF (FOUND) THEN
    UPDATE flspec
       SET flspec_order=_to.ord
     WHERE (flspec_id=_from.id);

    IF (_to.type='I') THEN
      UPDATE flitem
         SET flitem_order=_from.ord
       WHERE (flitem_id=_to.id);
    ELSE
      IF (_to.type='G') THEN
        UPDATE flgrp
           SET flgrp_order=_from.ord
         WHERE (flgrp_id=_to.id);
      ELSE
        IF (_to.type='S') THEN
          UPDATE flspec
             SET flspec_order=_from.ord
           WHERE (flspec_id=_to.id);
        END IF;
      END IF;
    END IF;
  END IF;

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.moveflspecdown(integer) OWNER TO admin;

--
-- TOC entry 1931 (class 1255 OID 146566722)
-- Dependencies: 4536 8
-- Name: moveflspecup(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION moveflspecup(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pFlspecid ALIAS FOR $1;
  _from RECORD;
  _to RECORD;

BEGIN

  SELECT flspec_id AS id,
         flspec_flhead_id AS flhead_id,
         flspec_flgrp_id AS flgrp_id,
         flspec_order AS ord INTO _from
    FROM flspec
   WHERE (flspec_id=pFlspecid);
  IF (NOT FOUND) THEN
    RETURN -1;
  END IF;

  SELECT id, type, ord INTO _to
    FROM (SELECT flitem_id AS id, 'I' AS type, flitem_order AS ord
            FROM flitem
           WHERE ((flitem_flgrp_id=_from.flgrp_id)
             AND  (flitem_flhead_id=_from.flhead_id))
           UNION
          SELECT flgrp_id AS id, 'G' AS type, flgrp_order AS ord
            FROM flgrp
           WHERE ((flgrp_flgrp_id=_from.flgrp_id)
             AND  (flgrp_flhead_id=_from.flhead_id))
           UNION
          SELECT flspec_id AS id, 'S' AS type, flspec_order AS ord
            FROM flspec
           WHERE ((flspec_flgrp_id=_from.flgrp_id)
             AND  (flspec_flhead_id=_from.flhead_id)) ) AS data
   WHERE (ord < _from.ord)
   ORDER BY ord DESC
   LIMIT 1;
  IF (FOUND) THEN
    UPDATE flspec
       SET flspec_order=_to.ord
     WHERE (flspec_id=_from.id);

    IF (_to.type='I') THEN
      UPDATE flitem
         SET flitem_order=_from.ord
       WHERE (flitem_id=_to.id);
    ELSE
      IF (_to.type='G') THEN
        UPDATE flgrp
           SET flgrp_order=_from.ord
         WHERE (flgrp_id=_to.id);
      ELSE
        IF (_to.type='S') THEN
          UPDATE flspec
             SET flspec_order=_from.ord
           WHERE (flspec_id=_to.id);
        END IF;
      END IF;
    END IF;
  END IF;

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.moveflspecup(integer) OWNER TO admin;

--
-- TOC entry 1932 (class 1255 OID 146566723)
-- Dependencies: 4536 8
-- Name: movescript(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION movescript(integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pscriptid ALIAS FOR $1;
  poldpkgid ALIAS FOR $2;
  pnewpkgid ALIAS FOR $3;

  _deletestr    TEXT;
  _destination  TEXT;
  _insertstr    TEXT;
  _rows         INTEGER;
  _selectstr    TEXT;
  _source       TEXT;
  _record       RECORD;

BEGIN
  IF (poldpkgid = pnewpkgid) THEN
    RETURN 0;
  END IF;

  IF (poldpkgid = -1) THEN
    _source = 'public.script';
  ELSE
    SELECT pkghead_name || '.pkgscript' INTO _source
    FROM pkghead
    WHERE pkghead_id=poldpkgid;

    IF NOT FOUND THEN
      RETURN -1;
    END IF;
  END IF;

  IF (pnewpkgid = -1) THEN
    _destination = 'public.script';
  ELSE
    SELECT pkghead_name || '.pkgscript' INTO _destination
    FROM pkghead
    WHERE pkghead_id=pnewpkgid;

    IF NOT FOUND THEN
      RETURN -2;
    END IF;
  END IF;

  _selectstr := ' SELECT * FROM ' || _source ||
                ' WHERE script_id = ' || pscriptid;
  EXECUTE _selectstr INTO _record;

  _deletestr := 'DELETE FROM ONLY ' || _source ||
                ' WHERE script_id = ' || pscriptid;
  EXECUTE _deletestr;
  GET DIAGNOSTICS _rows = ROW_COUNT;
  RAISE NOTICE '% rows from %', _rows, _deletestr;
  IF (_rows < 1) THEN
    RETURN -3;
  ELSIF (_rows > 1) THEN
    RAISE EXCEPTION 'Tried to delete % scripts with the id % when there should be exactly 1',
                    _rows, pscriptid;
  END IF;

  _insertstr := 'INSERT INTO ' || _destination ||
                ' (script_id, script_name, script_order, script_enabled, ' ||
                '  script_source, script_notes) VALUES ('
                || _record.script_id      || ','
                || quote_literal(_record.script_name)    || ','
                || _record.script_order   || ','
                || _record.script_enabled || ','
                || quote_literal(_record.script_source)  || ','
                || quote_literal(_record.script_notes )  || ');'
                ;
  EXECUTE _insertstr;
  GET DIAGNOSTICS _rows = ROW_COUNT;
  RAISE NOTICE '% rows from %', _rows, _insertstr;
  IF (_rows < 1) THEN
    RETURN -4;
  ELSIF (_rows > 1) THEN
    RAISE EXCEPTION 'Tried to insert % scripts with the id % when there should be exactly 1',
                    _rows, pscriptid;
  END IF;

  RETURN pscriptid;

END;
$_$;


ALTER FUNCTION public.movescript(integer, integer, integer) OWNER TO admin;

--
-- TOC entry 1933 (class 1255 OID 146566724)
-- Dependencies: 4536 8
-- Name: moveuiform(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION moveuiform(integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  puiformid ALIAS FOR $1;
  poldpkgid ALIAS FOR $2;
  pnewpkgid ALIAS FOR $3;

  _deletestr    TEXT;
  _destination  TEXT;
  _insertstr    TEXT;
  _rows         INTEGER;
  _selectstr    TEXT;
  _source       TEXT;
  _record       RECORD;

BEGIN
  IF (poldpkgid = pnewpkgid) THEN
    RETURN 0;
  END IF;

  IF (poldpkgid = -1) THEN
    _source = 'public.uiform';
  ELSE
    SELECT pkghead_name || '.pkguiform' INTO _source
    FROM pkghead
    WHERE pkghead_id=poldpkgid;

    IF NOT FOUND THEN
      RETURN -1;
    END IF;
  END IF;

  IF (pnewpkgid = -1) THEN
    _destination = 'public.uiform';
  ELSE
    SELECT pkghead_name || '.pkguiform' INTO _destination
    FROM pkghead
    WHERE pkghead_id=pnewpkgid;

    IF NOT FOUND THEN
      RETURN -2;
    END IF;
  END IF;

  _selectstr := ' SELECT * FROM ' || _source ||
                ' WHERE uiform_id = ' || puiformid;
  EXECUTE _selectstr INTO _record;

  _deletestr := 'DELETE FROM ONLY ' || _source ||
                ' WHERE uiform_id = ' || puiformid;
  EXECUTE _deletestr;
  GET DIAGNOSTICS _rows = ROW_COUNT;
  RAISE NOTICE '% rows from %', _rows, _deletestr;
  IF (_rows < 1) THEN
    RETURN -3;
  ELSIF (_rows > 1) THEN
    RAISE EXCEPTION 'Tried to delete % uiforms with the id % when there should be exactly 1',
                    _rows, puiformid;
  END IF;

  _insertstr := 'INSERT INTO ' || _destination ||
                ' (uiform_id, uiform_name, uiform_order, uiform_enabled, ' ||
                '  uiform_source, uiform_notes) VALUES ('
                || _record.uiform_id      || ','
                || quote_literal(_record.uiform_name)    || ','
                || _record.uiform_order   || ','
                || _record.uiform_enabled || ','
                || quote_literal(_record.uiform_source)  || ','
                || quote_literal(_record.uiform_notes )  || ');'
                ;
  EXECUTE _insertstr;
  GET DIAGNOSTICS _rows = ROW_COUNT;
  RAISE NOTICE '% rows from %', _rows, _insertstr;
  IF (_rows < 1) THEN
    RETURN -4;
  ELSIF (_rows > 1) THEN
    RAISE EXCEPTION 'Tried to insert % uiforms with the id % when there should be exactly 1',
                    _rows, puiformid;
  END IF;

  RETURN puiformid;

END;
$_$;


ALTER FUNCTION public.moveuiform(integer, integer, integer) OWNER TO admin;

--
-- TOC entry 1934 (class 1255 OID 146566725)
-- Dependencies: 4536 8
-- Name: moveupdown(integer, text, text, text, text, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION moveupdown(pid integer, pschema text, ptable text, pseqcol text, pjoincol text, pextra text, pdir text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
  _keyfield TEXT;
  _keysize  INTEGER;
  _qry      TEXT;
  _r        RECORD;
  _rowcnt   INTEGER;
  _schema   TEXT := COALESCE(pSchema, 'public');
BEGIN
  RAISE DEBUG 'moveUpDown(%, %, %, %, %, %, %) entered',
              pId, pSchema, pTable, pSeqCol, pJoinCol, pExtra, pDir;

  IF (UPPER(pDir) NOT IN ('UP', 'DOWN')) THEN
     RAISE EXCEPTION 'Cannot change the order of records; unsure what % means for sequencing [xtuple: moveUpDown, -1, %, %.%]',
                     pDir, pDir, _schema, pTable;
  END IF;

  SELECT attname, ARRAY_UPPER(conkey, 1) INTO _keyfield, _keysize
    FROM pg_attribute
    JOIN pg_constraint ON (attrelid=conrelid AND attnum=conkey[1])
    JOIN pg_class      ON (conrelid=pg_class.oid)
    JOIN pg_namespace  ON (relnamespace=pg_namespace.oid)
   WHERE ((contype='p')
      AND (nspname=_schema)
      AND (relname=pTable));

  RAISE DEBUG 'SELECT attname... returned %, %', _keyfield, _keysize;

  IF (_keysize > 1) THEN
    RAISE EXCEPTION 'Cannot change the order of records because %.% has a composite primary key [xtuple: moveUpDown, -2, %.%]',
                     _schema, pTable,
                     _schema, pTable;
  END IF;

  /* SELECT next._keyfield AS nextid,
            next.pSeqCol   AS nextseq,
            this.pSeqCol   AS thisseq
       FROM _schema.pTable AS next,
            _schema.pTable AS this
      WHERE (this._keyfield=$1)
          AND (next.pSeqCol [> or <] this.pSeqCol)
        [ AND (next.pJoinCol=this.pJoinCol) ]
        [ AND (pExtra) ]
      ORDER BY nextseq [ DESC or ASC ]
      LIMIT 1;
  */

  _qry := 'SELECT next.' || quote_ident(_keyfield) || ' AS nextid,
                  next.' || quote_ident(pSeqCol)   || ' AS nextseq,
                  this.' || quote_ident(pSeqCol)   || ' AS thisseq
             FROM ' || _schema || '.' || quote_ident(pTable) || ' AS next,
                  ' || _schema || '.' || quote_ident(pTable) || ' AS this
            WHERE ((this.' || quote_ident(_keyfield)  || '=$1)
               AND (next.' || quote_ident(pSeqCol)    ||
                    CASE pDir WHEN 'UP' THEN ' < ' ELSE ' > ' END ||
                   'this.' || quote_ident(pSeqCol) || ')' ||
               CASE WHEN pJoinCol IS NULL THEN ''
                    ELSE ' AND (next.' || quote_ident(pJoinCol)  ||
                         '=this.' || quote_ident(pJoinCol) || ')'
               END ||
          '     AND (' || COALESCE(pExtra, 'TRUE') || '))
            ORDER BY nextseq ' ||
               CASE pDir WHEN 'UP' THEN 'DESC' ELSE 'ASC' END ||
          ' LIMIT 1;';
  RAISE DEBUG 'moveUpDown about to use % when running %', pId, _qry;

  EXECUTE _qry INTO _r USING pId;
  GET DIAGNOSTICS _rowcnt = ROW_COUNT;
  RAISE DEBUG 'next id %, next seq %, this id %, this seq %',
               _r.nextid, _r.nextseq, pId, _r.thisseq;

  IF (_rowcnt > 0) THEN
    _qry := 'UPDATE ' || _schema || '.' || quote_ident(pTable)  ||
              ' SET ' || pSeqCol || '=CAST($1 AS INTEGER)
             WHERE (' || quote_ident(_keyfield) || '=$2);';

    EXECUTE _qry USING -1,         _r.nextid;
    EXECUTE _qry USING _r.nextseq, pId;
    EXECUTE _qry USING _r.thisseq, _r.nextid;
    RETURN _r.nextid;
  END IF;

  RETURN pId;
END;
$_$;


ALTER FUNCTION public.moveupdown(pid integer, pschema text, ptable text, pseqcol text, pjoincol text, pextra text, pdir text) OWNER TO admin;

--
-- TOC entry 9066 (class 0 OID 0)
-- Dependencies: 1934
-- Name: FUNCTION moveupdown(pid integer, pschema text, ptable text, pseqcol text, pjoincol text, pextra text, pdir text); Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON FUNCTION moveupdown(pid integer, pschema text, ptable text, pseqcol text, pjoincol text, pextra text, pdir text) IS 'moveUpDown moves a particular record up or down in an ordered list.
      pId argument names the record to move.
      pSchema (uses public if NULL) and pTable name the table holding the list.
      pSeqCol is the column that holds the sequence number.
      pJoinCol is the column that distinguishes one list from another in the same table, or NULL if the table holds only one list.
      pExtra is an extra join clause that may be required, or NULL.
      pDir is either UP, meaning move the pId record closer to the beginning,
                or DOWN.
Returns the id of the record with which pId was swapped,
      or pId if the record was already at the end in the specified direction.';


--
-- TOC entry 1897 (class 1255 OID 146566726)
-- Dependencies: 4536 8
-- Name: nextperiodbyinterval(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION nextperiodbyinterval(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPeriodid ALIAS FOR $1;
  pInterval ALIAS FOR $2;
  _periodid INTEGER;
BEGIN
  SELECT b.period_id INTO _periodid
    FROM period AS a, period AS b
   WHERE ((a.period_id=pPeriodid)
     AND  (b.period_start >= a.period_start))
   ORDER BY b.period_start
   LIMIT 1 OFFSET pInterval;
  IF (NOT FOUND) THEN
    RETURN -1;
  END IF;
  RETURN _periodid;
END;
$_$;


ALTER FUNCTION public.nextperiodbyinterval(integer, integer) OWNER TO admin;

--
-- TOC entry 1917 (class 1255 OID 146566727)
-- Dependencies: 4536 8
-- Name: nextprsubnumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION nextprsubnumber(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPrNumber ALIAS FOR $1;
  _subNumber INTEGER;

BEGIN

  SELECT MAX(pr_subnumber) INTO _subNumber
  FROM pr
  WHERE (pr_number=pPrNumber);

  IF (_subNumber IS NULL)
    THEN _subNumber := 0;
  END IF;

  RETURN (_subNumber + 1);

END;
$_$;


ALTER FUNCTION public.nextprsubnumber(integer) OWNER TO admin;

--
-- TOC entry 1918 (class 1255 OID 146566728)
-- Dependencies: 8
-- Name: nextwosubnumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION nextwosubnumber(integer) RETURNS integer
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
SELECT COALESCE((MAX(wo_subnumber) + 1), 1)
FROM wo
WHERE (wo_number=($1));
$_$;


ALTER FUNCTION public.nextwosubnumber(integer) OWNER TO admin;

--
-- TOC entry 1924 (class 1255 OID 146566729)
-- Dependencies: 4536 8
-- Name: noneg(numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION noneg(numeric) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pValue ALIAS FOR $1;

BEGIN

  IF (pValue < 0) THEN
    RETURN 0;
  ELSE
   RETURN pValue;
  END IF;

END;
$_$;


ALTER FUNCTION public.noneg(numeric) OWNER TO admin;

--
-- TOC entry 1929 (class 1255 OID 146566730)
-- Dependencies: 4536 8
-- Name: nopos(numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION nopos(numeric) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pValue ALIAS FOR $1;

BEGIN

  IF (pValue > 0) THEN
    RETURN 0;
  ELSE
   RETURN pValue;
  END IF;

END;
$_$;


ALTER FUNCTION public.nopos(numeric) OWNER TO admin;

--
-- TOC entry 1936 (class 1255 OID 146566731)
-- Dependencies: 4536 8
-- Name: normalizetrialbal(integer, character); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION normalizetrialbal(integer, character) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTrialbalid ALIAS FOR $1;
  pSide ALIAS FOR $2;
  _value NUMERIC;
  _r RECORD;

BEGIN

  SELECT accnt_type, trialbal_beginning, trialbal_ending INTO _r
  FROM trialbal, accnt
  WHERE ( (trialbal_accnt_id=accnt_id)
   AND (trialbal_id=pTrialbalid) );
  IF (NOT FOUND) THEN
    RETURN -1;
  END IF;

-- If we are looking for the Ending Balance, cache it
  IF (pSide = 'E') THEN
    _value = _r.trialbal_ending;

--  We had better been looking for the Beginning Balance!
  ELSE
    _value = _r.trialbal_beginning;
  END IF;

--  If the accnt_type is Asset or Expense, swap the sense
  IF (_r.accnt_type IN ('A', 'E')) THEN
    _value := (_value * -1);
  END IF;

  RETURN _value;

END;
$_$;


ALTER FUNCTION public.normalizetrialbal(integer, character) OWNER TO admin;

--
-- TOC entry 1937 (class 1255 OID 146566732)
-- Dependencies: 4536 8
-- Name: numofdatabaseusers(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION numofdatabaseusers() RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _count INTEGER;

BEGIN

  -- in version 9.2.0 the column "procpid" was changed to just "pid" Incident #21852
  IF (compareversion('9.2.0') <= 0)
  THEN
  SELECT count(*)
    INTO _count
    FROM pg_stat_activity, pg_locks
   WHERE((database=datid)
     AND (classid=datid)
     AND (objsubid=2)
     AND (pg_stat_activity.pid = pg_backend_pid()));
  ELSE
  SELECT count(*)
    INTO _count
    FROM pg_stat_activity, pg_locks
   WHERE((database=datid)
     AND (classid=datid)
     AND (objsubid=2)
     AND (procpid = pg_backend_pid()));
  END IF;

  IF (_count IS NULL) THEN
    _count := 0;
  END IF;

  RETURN _count;

END;
$$;


ALTER FUNCTION public.numofdatabaseusers() OWNER TO admin;

--
-- TOC entry 1938 (class 1255 OID 146566733)
-- Dependencies: 4536 8
-- Name: numofserverusers(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION numofserverusers() RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _count INTEGER;

BEGIN

  SELECT COUNT(*) INTO _count
  FROM pg_stat_activity;
  IF (_count IS NULL) THEN
    _count := 0;
  END IF;

  RETURN _count;

END;
$$;


ALTER FUNCTION public.numofserverusers() OWNER TO admin;

--
-- TOC entry 1939 (class 1255 OID 146566734)
-- Dependencies: 4536 8
-- Name: openaccountingperiod(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION openaccountingperiod(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPeriodid ALIAS FOR $1;
  _r RECORD;

BEGIN

--  Check to make use that the period is closed
  IF ( ( SELECT (NOT period_closed)
         FROM period
         WHERE (period_id=pPeriodid) ) ) THEN
    RETURN -1;
  END IF;

  IF ( ( SELECT (count(period_id) > 0)
           FROM period
          WHERE ((period_end > (
            SELECT period_end
            FROM period
            WHERE (period_id=pPeriodId))
          )
           AND (period_closed)) ) ) THEN
    RETURN -3;
  END IF;

--  Make sure the year is open
  IF ( ( SELECT (yearperiod_closed)
         FROM yearperiod
           JOIN period ON (period_yearperiod_id=yearperiod_id)
         WHERE (period_id=pPeriodid) ) ) THEN
    RETURN -4;
  END IF;

--  Reset the period_closed flag
  UPDATE period
  SET period_closed=FALSE
  WHERE (period_id=pPeriodid);

--  Post any unposted G/L Transactions into the new period
  FOR _r IN SELECT DISTINCT gltrans_sequence
            FROM gltrans, period
            WHERE ( (NOT gltrans_posted)
             AND (gltrans_date BETWEEN period_start AND period_end)
             AND (period_id=pPeriodid) ) LOOP
    PERFORM postIntoTrialBalance(_r.gltrans_sequence);
  END LOOP;

  RETURN pPeriodid;

END;
$_$;


ALTER FUNCTION public.openaccountingperiod(integer) OWNER TO admin;

--
-- TOC entry 1940 (class 1255 OID 146566735)
-- Dependencies: 4536 8
-- Name: openaccountingyearperiod(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION openaccountingyearperiod(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pYearPeriodId ALIAS FOR $1;
  _r RECORD;

BEGIN

--  Check to make use that the yearperiod is closed
  IF ( ( SELECT (NOT yearperiod_closed)
         FROM yearperiod
         WHERE (yearperiod_id=pYearPeriodId) ) ) THEN
    RETURN -1;
  END IF;

  IF ( ( SELECT (count(yearperiod_id) > 0)
           FROM yearperiod
          WHERE ((yearperiod_end> (
            SELECT yearperiod_end
            FROM yearperiod
            WHERE (yearperiod_id=pYearPeriodId))
          )
           AND (yearperiod_closed)) ) ) THEN
    RETURN -2;
  END IF;

--  Reset the yearperiod_closed flag
  UPDATE yearperiod
  SET yearperiod_closed=FALSE
  WHERE (yearperiod_id=pYearPeriodId);

  RETURN pYearPeriodid;

END;
$_$;


ALTER FUNCTION public.openaccountingyearperiod(integer) OWNER TO admin;

--
-- TOC entry 1941 (class 1255 OID 146566736)
-- Dependencies: 4536 8
-- Name: openapitemsvalue(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION openapitemsvalue(pvendid integer, pperiodid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _value NUMERIC;

BEGIN

  SELECT SUM( (apopen_amount - apopen_paid) / apopen_curr_rate *
               CASE WHEN (apopen_doctype IN ('D', 'V')) THEN 1 ELSE -1 END )
               INTO _value
  FROM apopen
  WHERE ( (apopen_open)
    AND   (apopen_vend_id=pVendid)
    AND   (apopen_duedate BETWEEN findPeriodStart(pPeriodid) AND findPeriodEnd(pPeriodid)) );

  RETURN COALESCE(_value, 0.0);

END;
$$;


ALTER FUNCTION public.openapitemsvalue(pvendid integer, pperiodid integer) OWNER TO admin;

--
-- TOC entry 1942 (class 1255 OID 146566737)
-- Dependencies: 4536 8
-- Name: openaritemsvalue(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION openaritemsvalue(integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCustid ALIAS FOR $1;
  pPeriodid ALIAS FOR $2;
  _value NUMERIC;

BEGIN

  SELECT SUM( CASE WHEN (aropen_doctype IN ('C', 'R')) THEN ((aropen_amount - aropen_paid) * -1)
                   ELSE (aropen_amount - aropen_paid)
              END )  INTO _value
  FROM aropen
  WHERE ( (aropen_open)
    AND (aropen_cust_id=pCustid)
    AND (aropen_duedate BETWEEN findPeriodStart(pPeriodid) AND findPeriodEnd(pPeriodid)) );

  IF (_value IS NULL) THEN
    _value := 0;
  END IF;

  RETURN _value;

END;
$_$;


ALTER FUNCTION public.openaritemsvalue(integer, integer) OWNER TO admin;

--
-- TOC entry 1943 (class 1255 OID 146566738)
-- Dependencies: 4536 8
-- Name: openrecurringitems(integer, text, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION openrecurringitems(integer, text, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pParentid  ALIAS FOR $1;
  pType      TEXT := UPPER($2);
  pDatetime  TIMESTAMP WITH TIME ZONE := COALESCE($3, CURRENT_TIMESTAMP);

  _count     INTEGER := -1;
  _countstmt TEXT;
  _rt        RECORD;

BEGIN
  IF (pParentid IS NULL) THEN
    RETURN -11;
  END IF;

  SELECT * INTO _rt FROM recurtype WHERE (UPPER(recurtype_type)=pType);
  GET DIAGNOSTICS _count = ROW_COUNT;
  IF (_count <= 0) THEN
    RETURN -10;
  END IF;

  _countstmt := 'SELECT COUNT(*) FROM [fulltable]'
             || ' WHERE (NOT ([done])'
             || '    AND ([schedcol]>=''$1'')'
             || '    AND ([table]_recurring_[table]_id=''$2''));';
  _countstmt := REPLACE(_countstmt, '[fulltable]',    _rt.recurtype_table);
  _countstmt := REPLACE(_countstmt, '[table]',
                        REGEXP_REPLACE(_rt.recurtype_table, E'.*\\.', ''));
  _countstmt := REPLACE(_countstmt, '[done]',     _rt.recurtype_donecheck);
  _countstmt := REPLACE(_countstmt, '[schedcol]', _rt.recurtype_schedcol);

  -- 8.4+: EXECUTE _countstmt INTO _count USING pDatetime, pParentid;
  EXECUTE REPLACE(REPLACE(_countstmt, '$1', pDatetime::TEXT),
                                      '$2', pParentid::TEXT) INTO _count;

  RETURN _count;
END;
$_$;


ALTER FUNCTION public.openrecurringitems(integer, text, timestamp with time zone) OWNER TO admin;

--
-- TOC entry 231 (class 1259 OID 146566739)
-- Dependencies: 6038 6039 8
-- Name: ophead; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE ophead (
    ophead_id integer NOT NULL,
    ophead_name text NOT NULL,
    ophead_crmacct_id integer,
    ophead_owner_username text,
    ophead_opstage_id integer,
    ophead_opsource_id integer,
    ophead_optype_id integer,
    ophead_probability_prcnt integer,
    ophead_amount numeric(20,4),
    ophead_target_date date,
    ophead_actual_date date,
    ophead_notes text,
    ophead_curr_id integer,
    ophead_active boolean DEFAULT true,
    ophead_cntct_id integer,
    ophead_username text,
    ophead_start_date date,
    ophead_assigned_date date,
    ophead_priority_id integer,
    ophead_number text NOT NULL,
    CONSTRAINT ophead_ophead_number_check CHECK ((ophead_number <> ''::text))
);


ALTER TABLE public.ophead OWNER TO admin;


--
-- TOC entry 1944 (class 1255 OID 146566747)
-- Dependencies: 2878 4536 8
-- Name: ophead(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION ophead() RETURNS SETOF ophead
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _row ophead%ROWTYPE;
  _priv TEXT;
  _grant BOOLEAN;

BEGIN
  -- This query will give us the most permissive privilege the user has been granted
  SELECT privilege, granted INTO _priv, _grant
  FROM privgranted
  WHERE privilege IN ('MaintainAllOpportunities','ViewAllOpportunities','MaintainPersonalOpportunities','ViewPersonalOpportunities')
  ORDER BY granted DESC, sequence
  LIMIT 1;

  -- If have an 'All' privilege return all results
  IF (_priv ~ 'All' AND _grant) THEN
    FOR _row IN
      SELECT * FROM ophead
    LOOP
      RETURN NEXT _row;
    END LOOP;
  -- Otherwise if have any other grant, must be personal privilege.
  ELSIF (_grant) THEN
    FOR _row IN
      SELECT * FROM ophead
      WHERE getEffectiveXtUser() IN (ophead_owner_username, ophead_username)
    LOOP
      RETURN NEXT _row;
    END LOOP;
  END IF;

  RETURN;

END;
$$;


ALTER FUNCTION public.ophead() OWNER TO admin;

--
-- TOC entry 9069 (class 0 OID 0)
-- Dependencies: 1944
-- Name: FUNCTION ophead(); Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON FUNCTION ophead() IS 'A table function that returns Opportunity results according to privilege settings.';


--
-- TOC entry 1946 (class 1255 OID 146566749)
-- Dependencies: 4536 8
-- Name: orderedbypo(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION orderedbypo(integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pLookAhead ALIAS FOR $2;
  _qty NUMERIC;

BEGIN

  SELECT orderedByPo(pItemsiteid, startOfTime(), (CURRENT_DATE + pLookAhead)) INTO _qty;
  RETURN _qty;

END;
$_$;


ALTER FUNCTION public.orderedbypo(integer, integer) OWNER TO admin;

--
-- TOC entry 1945 (class 1255 OID 146566748)
-- Dependencies: 4536 8
-- Name: orderedbypo(integer, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION orderedbypo(integer, date, date) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pStartDate ALIAS FOR $2;
  pEndDate ALIAS FOR $3;
  _qty NUMERIC;

BEGIN

  SELECT COALESCE(SUM(noNeg(poitem_qty_ordered - poitem_qty_received) * poitem_invvenduomratio), 0.0) INTO _qty
  FROM poitem
  WHERE ( (poitem_itemsite_id=pItemsiteid)
    AND (poitem_status <> 'C')
    AND (poitem_duedate BETWEEN pStartDate AND pEndDate) );

  RETURN _qty;

END;
$_$;


ALTER FUNCTION public.orderedbypo(integer, date, date) OWNER TO admin;

--
-- TOC entry 1947 (class 1255 OID 146566750)
-- Dependencies: 4536 8
-- Name: orderedbywo(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION orderedbywo(integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pLookAheadDays ALIAS FOR $2;

BEGIN

  RETURN orderedByWo(pItemsiteid, startOfTime(), (CURRENT_DATE + pLookAheadDays));

END;
$_$;


ALTER FUNCTION public.orderedbywo(integer, integer) OWNER TO admin;

--
-- TOC entry 1948 (class 1255 OID 146566751)
-- Dependencies: 4536 8
-- Name: orderedbywo(integer, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION orderedbywo(integer, date, date) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pStartDate ALIAS FOR $2;
  pEndDate ALIAS FOR $3;
  _itemType CHARACTER(1);
  _qty NUMERIC := 0;

BEGIN
  SELECT item_type INTO _itemType
  FROM itemsite, item
  WHERE ( (itemsite_item_id=item_id)
   AND (itemsite_id=pItemsiteid) );

  IF (_itemType NOT IN ('C','T')) THEN
    SELECT COALESCE(SUM(noNeg(wo_qtyord - wo_qtyrcv)), 0.0) INTO _qty
    FROM wo
    WHERE ( (wo_status <> 'C')
     AND (wo_itemsite_id=pItemsiteid)
     AND (wo_duedate BETWEEN pStartDate AND pEndDate) );
  ELSIF (_itemType = 'C') THEN
    SELECT COALESCE(SUM((noNeg(wo_qtyord - wo_qtyrcv) * brddist_stdqtyper)), 0.0) INTO _qty
    FROM wo, xtmfg.brddist
    WHERE ( (wo_status <> 'C')
     AND (brddist_wo_id=wo_id)
     AND (brddist_itemsite_id=pItemsiteid)
     AND (wo_duedate BETWEEN pStartDate AND pEndDate) );
  ELSIF (_itemType = 'T' AND fetchMetricBool('Routings')) THEN -- Tooling:  Determine quantity already returned
    SELECT
      -- Qty Required
      COALESCE(SUM(noNeg(womatl_qtyreq)),0)  -
      -- Qty Returned
     (SELECT COALESCE(SUM(abs(invhist_invqty)),0)
      FROM wo
        JOIN womatl ON (womatl_wo_id=wo_id)
        JOIN womatlpost ON (womatl_id=womatlpost_womatl_id)
        JOIN invhist ON ((womatlpost_invhist_id=invhist_id)
                     AND (invhist_invqty < 0))
      LEFT OUTER JOIN xtmfg.wooper ON (womatl_wooper_id=wooper_id)
    WHERE ( NOT (COALESCE(wooper_rncomplete,wo_status = 'C'))
     AND (womatl_itemsite_id=pItemsiteid)
     AND (wo_duedate BETWEEN pStartDate AND pEndDate) )
       )
   INTO _qty
    FROM wo
      JOIN womatl ON (womatl_wo_id=wo_id)
      LEFT OUTER JOIN xtmfg.wooper ON (womatl_wooper_id=wooper_id)
    WHERE ( NOT (COALESCE(wooper_rncomplete,wo_status = 'C'))
     AND (womatl_itemsite_id=pItemsiteid)
     AND (wo_duedate BETWEEN pStartDate AND pEndDate) )
    GROUP BY womatl_qtyreq;
  ELSIF (_itemType = 'T') THEN -- Tooling:  Determine quantity already returned
    SELECT
      -- Qty Required
      COALESCE(SUM(noNeg(womatl_qtyreq)),0)  -
      -- Qty Returned
     (SELECT COALESCE(SUM(abs(invhist_invqty)),0)
      FROM wo
        JOIN womatl ON (womatl_wo_id=wo_id)
        JOIN womatlpost ON (womatl_id=womatlpost_womatl_id)
        JOIN invhist ON ((womatlpost_invhist_id=invhist_id)
                     AND (invhist_invqty < 0))
    WHERE ( NOT (wo_status = 'C')
     AND (womatl_itemsite_id=pItemsiteid)
     AND (wo_duedate BETWEEN pStartDate AND pEndDate) )
       )
   INTO _qty
    FROM wo
      JOIN womatl ON (womatl_wo_id=wo_id)
    WHERE ( NOT (wo_status = 'C')
     AND (womatl_itemsite_id=pItemsiteid)
     AND (wo_duedate BETWEEN pStartDate AND pEndDate) )
    GROUP BY womatl_qtyreq;
  END IF;

  RETURN COALESCE(_qty,0);

END;
$_$;


ALTER FUNCTION public.orderedbywo(integer, date, date) OWNER TO admin;

--
-- TOC entry 1949 (class 1255 OID 146566752)
-- Dependencies: 2690 4536 8
-- Name: orderhead(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION orderhead() RETURNS SETOF ordhead
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _row ordhead%ROWTYPE;
  _query TEXT;
BEGIN

  _query := '
  SELECT DISTINCT * FROM (
  SELECT pohead_id		AS orderhead_id,
	 ''PO''			AS orderhead_type,
	 pohead_number		AS orderhead_number,
	 pohead_status		AS orderhead_status,
	 pohead_orderdate	AS orderhead_orderdate,
	 (SELECT count(*)
	   FROM poitem
	   WHERE poitem_pohead_id=pohead_id) AS orderhead_linecount,
	 pohead_vend_id		AS orderhead_from_id,
	 vend_name		AS orderhead_from,
	 NULL			AS orderhead_to_id,
	 ''''			AS orderhead_to,
	 pohead_curr_id		AS orderhead_curr_id,
	 pohead_agent_username	AS orderhead_agent_username,
	 pohead_shipvia		AS orderhead_shipvia
  FROM pohead LEFT OUTER JOIN vendinfo ON (pohead_vend_id=vend_id)
  UNION
  SELECT cohead_id		AS orderhead_id,
	 ''SO''			AS orderhead_type,
	 cohead_number		AS orderhead_number,
	 COALESCE(coitem_status,''C'') AS orderhead_status,
	 cohead_orderdate	AS orderhead_orderdate,
	 (SELECT count(*)
	   FROM coitem
	   WHERE coitem_cohead_id=cohead_id) AS orderhead_linecount,
	 NULL			AS orderhead_from_id,
	 ''''			AS orderhead_from,
	 cohead_cust_id		AS orderhead_to_id,
	 cust_name		AS orderhead_to,
	 cohead_curr_id		AS orderhead_curr_id,
	 ''''			AS orderhead_agent_username,
	 cohead_shipvia		AS orderhead_shipvia
  FROM cohead LEFT OUTER JOIN custinfo ON (cohead_cust_id=cust_id)
              LEFT OUTER JOIN coitem ON ((cohead_id=coitem_cohead_id)
                                     AND (coitem_status=''O''))';

  IF (fetchmetricbool('MultiWhs')) THEN
    _query := _query || '
    UNION
    SELECT tohead_id		AS orderhead_id,
	 ''TO''			AS orderhead_type,
  	 tohead_number		AS orderhead_number,
	 tohead_status		AS orderhead_status,
	 tohead_orderdate	AS orderhead_orderdate,
	 (SELECT count(*)
	   FROM toitem
	   WHERE toitem_tohead_id=tohead_id) AS orderhead_linecount,
	 tohead_src_warehous_id	 AS orderhead_from_id,
	 tohead_srcname		AS orderhead_from,
	 tohead_dest_warehous_id AS orderhead_to_id,
	 tohead_destname	AS orderhead_to,
	 tohead_freight_curr_id	AS orderhead_curr_id,
	 tohead_agent_username	AS orderhead_agent_username,
	 tohead_shipvia		AS orderhead_shipvia
    FROM tohead';
  END IF;

  IF (fetchmetricbool('EnableReturnAuth')) THEN
    _query := _query || '
  UNION
    SELECT rahead_id		AS orderhead_id,
	 ''RA''			AS orderhead_type,
	 rahead_number		AS orderhead_number,
	 COALESCE(raitem_status,''C'') AS orderhead_status,
	 rahead_authdate	AS orderhead_orderdate,
	 (SELECT count(*)
	   FROM raitem
	   WHERE raitem_rahead_id=rahead_id) AS orderhead_linecount,
	 rahead_cust_id		AS orderhead_from_id,
	 cust_name		AS orderhead_from,
	 NULL			AS orderhead_to_id,
	 ''''			AS orderhead_to,
	 rahead_curr_id		AS orderhead_curr_id,
	 ''''			AS orderhead_agent_username,
	 ''''			AS orderhead_shipvia
    FROM rahead LEFT OUTER JOIN custinfo ON (rahead_cust_id=cust_id)
              LEFT OUTER JOIN raitem ON ((rahead_id=raitem_rahead_id)
                                     AND (raitem_status=''O''))';
  END IF;

  _query := _query || ') AS data ORDER BY orderhead_type, orderhead_number ;';

  FOR _row IN EXECUTE _query
  LOOP
    RETURN NEXT _row;
  END LOOP;

  RETURN;
END;
$$;


ALTER FUNCTION public.orderhead() OWNER TO admin;

--
-- TOC entry 1950 (class 1255 OID 146566753)
-- Dependencies: 2693 4536 8
-- Name: orderitem(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION orderitem() RETURNS SETOF orditem
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _row orditem%ROWTYPE;
  _query TEXT;
BEGIN

  _query := '
  SELECT poitem_id		AS orderitem_id,
	 ''PO''			AS orderitem_orderhead_type,
	 poitem_pohead_id	AS orderitem_orderhead_id,
	 poitem_linenumber	AS orderitem_linenumber,
	 poitem_status		AS orderitem_status,
	 poitem_itemsite_id	AS orderitem_itemsite_id,
	 poitem_duedate		AS orderitem_scheddate,
	 poitem_qty_ordered	AS orderitem_qty_ordered,
	 poitem_qty_returned	AS orderitem_qty_shipped,
	 poitem_qty_received	AS orderitem_qty_received,
	 uom_id			AS orderitem_qty_uom_id,
	 poitem_invvenduomratio	AS orderitem_qty_invuomratio,
	 poitem_unitprice	AS orderitem_unitcost,
	 pohead_curr_id         AS orderitem_unitcost_curr_id,
	 poitem_freight		AS orderitem_freight,
	 poitem_freight_received AS orderitem_freight_received,
	 pohead_curr_id         AS orderitem_freight_curr_id

  FROM poitem LEFT OUTER JOIN pohead ON (poitem_pohead_id=pohead_id)
              LEFT OUTER JOIN uom ON (uom_name=poitem_vend_uom)
  UNION
  SELECT coitem_id		AS orderitem_id,
	 ''SO''			AS orderitem_orderhead_type,
	 coitem_cohead_id	AS orderitem_orderhead_id,
	 coitem_linenumber	AS orderitem_linenumber,
	 coitem_status		AS orderitem_status,
	 coitem_itemsite_id	AS orderitem_itemsite_id,
	 coitem_scheddate	AS orderitem_scheddate,
	 coitem_qtyord		AS orderitem_qty_ordered,
	 coitem_qtyshipped	AS orderitem_qty_shipped,
	 coitem_qtyreturned	AS orderitem_qty_received,
	 coitem_qty_uom_id	AS orderitem_qty_uom_id,
	 coitem_qty_invuomratio	AS orderitem_qty_invuomratio,
	 coitem_unitcost	AS orderitem_unitcost,
	 basecurrid()		AS orderitem_unitcost_curr_id,
	 NULL			AS orderitem_freight,
	 NULL			AS orderitem_freight_received,
	 basecurrid()		AS orderitem_freight_curr_id
  FROM coitem';

  IF (fetchmetricbool('MultiWhs')) THEN
    _query := _query || '
    UNION
    SELECT toitem_id		AS orderitem_id,
      ''TO''			AS orderitem_orderhead_type,
      toitem_tohead_id	AS orderitem_orderhead_id,
      toitem_linenumber	AS orderitem_linenumber,
      toitem_status		AS orderitem_status,
      itemsite_id		AS orderitem_itemsite_id,
      toitem_duedate		AS orderitem_scheddate,
      toitem_qty_ordered	AS orderitem_qty_ordered,
      toitem_qty_shipped	AS orderitem_qty_shipped,
      toitem_qty_received	AS orderitem_qty_received,
      uom_id			AS orderitem_qty_uom_id,
      1			AS orderitem_qty_invuomratio,
      toitem_stdcost		AS orderitem_unitcost,
      basecurrid()		AS orderitem_unitcost_curr_id,
      toitem_freight		AS orderitem_freight,
      toitem_freight_received AS orderitem_freight_received,
      toitem_freight_curr_id	AS orderitem_freight_curr_id
    FROM tohead, itemsite, toitem LEFT OUTER JOIN uom ON (uom_name=toitem_uom)
    WHERE ((toitem_tohead_id=tohead_id)
     AND  (tohead_src_warehous_id=itemsite_warehous_id)
     AND  (toitem_item_id=itemsite_item_id)) ';
  END IF;

  IF (fetchmetricbool('EnableReturnAuth')) THEN
    _query := _query || '
    UNION
    SELECT raitem_id		AS orderitem_id,
      ''RA''			AS orderitem_orderhead_type,
      raitem_rahead_id	AS orderitem_orderhead_id,
      raitem_linenumber	AS orderitem_linenumber,
      raitem_status		AS orderitem_status,
      raitem_itemsite_id	AS orderitem_itemsite_id,
      raitem_scheddate	AS orderitem_scheddate,
      raitem_qtyauthorized	AS orderitem_qty_ordered,
      0			AS orderitem_qty_shipped,
      raitem_qtyreceived	AS orderitem_qty_received,
      raitem_qty_uom_id	AS orderitem_qty_uom_id,
      raitem_qty_invuomratio	AS orderitem_qty_invuomratio,
      raitem_unitprice	AS orderitem_unitcost,
      basecurrid()		AS orderitem_unitcost_curr_id,
      NULL			AS orderitem_freight,
      NULL			AS orderitem_freight_received,
      basecurrid()		AS orderitem_freight_curr_id
    FROM raitem';
  END IF;

  FOR _row IN EXECUTE _query
  LOOP
    RETURN NEXT _row;
  END LOOP;

  RETURN;
END;
$$;


ALTER FUNCTION public.orderitem() OWNER TO admin;

--
-- TOC entry 1955 (class 1255 OID 146566754)
-- Dependencies: 2687 4536 8
-- Name: orderitemdata(text, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION orderitemdata(text, integer, integer) RETURNS SETOF orderitemtype
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pOrdertype ALIAS FOR $1;
  pOrderheadid ALIAS FOR $2;
  pOrderitemid ALIAS FOR $3;
  _row orderitemtype%ROWTYPE;
  _set RECORD;

BEGIN

  IF(UPPER(pOrdertype)='PO') THEN
    FOR _set IN
      SELECT poitem_id              AS orderitem_id,
             'PO'                   AS orderitem_orderhead_type,
             poitem_pohead_id       AS orderitem_orderhead_id,
             poitem_linenumber      AS orderitem_linenumber,
             poitem_status          AS orderitem_status,
             poitem_itemsite_id     AS orderitem_itemsite_id,
             poitem_duedate         AS orderitem_scheddate,
             poitem_qty_ordered     AS orderitem_qty_ordered,
             poitem_qty_returned    AS orderitem_qty_shipped,
             poitem_qty_received    AS orderitem_qty_received,
             uom_id                 AS orderitem_qty_uom_id,
             poitem_invvenduomratio AS orderitem_qty_invuomratio,
             poitem_unitprice       AS orderitem_unitcost,
             (SELECT pohead_curr_id FROM pohead WHERE pohead_id=poitem_pohead_id)
                                    AS orderitem_unitcost_curr_id,
             poitem_freight         AS orderitem_freight,
             poitem_freight_received AS orderitem_freight_received,
             (SELECT pohead_curr_id FROM pohead WHERE pohead_id=poitem_pohead_id)
                                    AS orderitem_freight_curr_id
        FROM poitem LEFT OUTER JOIN uom ON (uom_name=poitem_vend_uom)
       WHERE(((pOrderheadid IS NULL) OR (poitem_pohead_id=pOrderheadid))
         AND ((pOrderitemid IS NULL) OR (poitem_id=pOrderitemid))) LOOP

      _row.orderitem_id := _set.orderitem_id;
      _row.orderitem_orderhead_type := _set.orderitem_orderhead_type;
      _row.orderitem_orderhead_id := _set.orderitem_orderhead_id;
      _row.orderitem_linenumber := _set.orderitem_linenumber;
      _row.orderitem_status := _set.orderitem_status;
      _row.orderitem_itemsite_id := _set.orderitem_itemsite_id;
      _row.orderitem_scheddate := _set.orderitem_scheddate;
      _row.orderitem_qty_ordered := _set.orderitem_qty_ordered;
      _row.orderitem_qty_shipped := _set.orderitem_qty_shipped;
      _row.orderitem_qty_received := _set.orderitem_qty_received;
      _row.orderitem_qty_uom_id := _set.orderitem_qty_uom_id;
      _row.orderitem_qty_invuomratio := _set.orderitem_qty_invuomratio;
      _row.orderitem_unitcost := _set.orderitem_unitcost;
      _row.orderitem_unitcost_curr_id := _set.orderitem_unitcost_curr_id;
      _row.orderitem_freight := _set.orderitem_freight;
      _row.orderitem_freight_received := _set.orderitem_freight_received;
      _row.orderitem_freight_curr_id := _set.orderitem_freight_curr_id;

      RETURN NEXT _row;
    END LOOP;
  ELSEIF(UPPER(pOrdertype)='SO') THEN
    FOR _set IN
      SELECT coitem_id              AS orderitem_id,
             'SO'                   AS orderitem_orderhead_type,
             coitem_cohead_id       AS orderitem_orderhead_id,
             coitem_linenumber      AS orderitem_linenumber,
             coitem_status          AS orderitem_status,
             coitem_itemsite_id     AS orderitem_itemsite_id,
             coitem_scheddate       AS orderitem_scheddate,
             coitem_qtyord          AS orderitem_qty_ordered,
             coitem_qtyshipped      AS orderitem_qty_shipped,
             coitem_qtyreturned     AS orderitem_qty_received,
             coitem_qty_uom_id      AS orderitem_qty_uom_id,
             coitem_qty_invuomratio AS orderitem_qty_invuomratio,
             coitem_unitcost        AS orderitem_unitcost,
             basecurrid()           AS orderitem_unitcost_curr_id,
             NULL                   AS orderitem_freight,
             NULL                   AS orderitem_freight_received,
             basecurrid()           AS orderitem_freight_curr_id
        FROM coitem
       WHERE(((pOrderheadid IS NULL) OR (coitem_cohead_id=pOrderheadid))
         AND ((pOrderitemid IS NULL) OR (coitem_id=pOrderitemid))) LOOP

      _row.orderitem_id := _set.orderitem_id;
      _row.orderitem_orderhead_type := _set.orderitem_orderhead_type;
      _row.orderitem_orderhead_id := _set.orderitem_orderhead_id;
      _row.orderitem_linenumber := _set.orderitem_linenumber;
      _row.orderitem_status := _set.orderitem_status;
      _row.orderitem_itemsite_id := _set.orderitem_itemsite_id;
      _row.orderitem_scheddate := _set.orderitem_scheddate;
      _row.orderitem_qty_ordered := _set.orderitem_qty_ordered;
      _row.orderitem_qty_shipped := _set.orderitem_qty_shipped;
      _row.orderitem_qty_received := _set.orderitem_qty_received;
      _row.orderitem_qty_uom_id := _set.orderitem_qty_uom_id;
      _row.orderitem_qty_invuomratio := _set.orderitem_qty_invuomratio;
      _row.orderitem_unitcost := _set.orderitem_unitcost;
      _row.orderitem_unitcost_curr_id := _set.orderitem_unitcost_curr_id;
      _row.orderitem_freight := _set.orderitem_freight;
      _row.orderitem_freight_received := _set.orderitem_freight_received;
      _row.orderitem_freight_curr_id := _set.orderitem_freight_curr_id;

      RETURN NEXT _row;
    END LOOP;
  ELSEIF(UPPER(pOrdertype)='RA') THEN
    FOR _set IN
      SELECT raitem_id              AS orderitem_id,
             'RA'                   AS orderitem_orderhead_type,
             raitem_rahead_id       AS orderitem_orderhead_id,
             raitem_linenumber      AS orderitem_linenumber,
             raitem_status          AS orderitem_status,
             raitem_itemsite_id     AS orderitem_itemsite_id,
             raitem_scheddate       AS orderitem_scheddate,
             raitem_qtyauthorized   AS orderitem_qty_ordered,
             0                      AS orderitem_qty_shipped,
             raitem_qtyreceived     AS orderitem_qty_received,
             raitem_qty_uom_id      AS orderitem_qty_uom_id,
             raitem_qty_invuomratio AS orderitem_qty_invuomratio,
             raitem_unitprice       AS orderitem_unitcost,
             basecurrid()           AS orderitem_unitcost_curr_id,
             NULL                   AS orderitem_freight,
             NULL                   AS orderitem_freight_received,
             basecurrid()           AS orderitem_freight_curr_id
        FROM raitem
       WHERE(((pOrderheadid IS NULL) OR (raitem_rahead_id=pOrderheadid))
         AND ((pOrderitemid IS NULL) OR (raitem_id=pOrderitemid))) LOOP

      _row.orderitem_id := _set.orderitem_id;
      _row.orderitem_orderhead_type := _set.orderitem_orderhead_type;
      _row.orderitem_orderhead_id := _set.orderitem_orderhead_id;
      _row.orderitem_linenumber := _set.orderitem_linenumber;
      _row.orderitem_status := _set.orderitem_status;
      _row.orderitem_itemsite_id := _set.orderitem_itemsite_id;
      _row.orderitem_scheddate := _set.orderitem_scheddate;
      _row.orderitem_qty_ordered := _set.orderitem_qty_ordered;
      _row.orderitem_qty_shipped := _set.orderitem_qty_shipped;
      _row.orderitem_qty_received := _set.orderitem_qty_received;
      _row.orderitem_qty_uom_id := _set.orderitem_qty_uom_id;
      _row.orderitem_qty_invuomratio := _set.orderitem_qty_invuomratio;
      _row.orderitem_unitcost := _set.orderitem_unitcost;
      _row.orderitem_unitcost_curr_id := _set.orderitem_unitcost_curr_id;
      _row.orderitem_freight := _set.orderitem_freight;
      _row.orderitem_freight_received := _set.orderitem_freight_received;
      _row.orderitem_freight_curr_id := _set.orderitem_freight_curr_id;

      RETURN NEXT _row;
    END LOOP;
  ELSEIF(UPPER(pOrdertype)='TO') THEN
    FOR _set IN
      SELECT toitem_id              AS orderitem_id,
             'TO'                   AS orderitem_orderhead_type,
             toitem_tohead_id       AS orderitem_orderhead_id,
             toitem_linenumber      AS orderitem_linenumber,
             toitem_status          AS orderitem_status,
             itemsite_id            AS orderitem_itemsite_id,
             toitem_duedate         AS orderitem_scheddate,
             toitem_qty_ordered     AS orderitem_qty_ordered,
             toitem_qty_shipped     AS orderitem_qty_shipped,
             toitem_qty_received    AS orderitem_qty_received,
             uom_id                 AS orderitem_qty_uom_id,
             1                      AS orderitem_qty_invuomratio,
             toitem_stdcost         AS orderitem_unitcost,
             basecurrid()           AS orderitem_unitcost_curr_id,
             toitem_freight         AS orderitem_freight,
             toitem_freight_received AS orderitem_freight_received,
             toitem_freight_curr_id AS orderitem_freight_curr_id
        FROM tohead, itemsite, toitem LEFT OUTER JOIN uom ON (uom_name=toitem_uom)
       WHERE((toitem_tohead_id=tohead_id)
         AND (tohead_src_warehous_id=itemsite_warehous_id)
         AND (toitem_item_id=itemsite_item_id)
         AND ((pOrderheadid IS NULL) OR (toitem_tohead_id=pOrderheadid))
         AND ((pOrderitemid IS NULL) OR (toitem_id=pOrderitemid))) LOOP

      _row.orderitem_id := _set.orderitem_id;
      _row.orderitem_orderhead_type := _set.orderitem_orderhead_type;
      _row.orderitem_orderhead_id := _set.orderitem_orderhead_id;
      _row.orderitem_linenumber := _set.orderitem_linenumber;
      _row.orderitem_status := _set.orderitem_status;
      _row.orderitem_itemsite_id := _set.orderitem_itemsite_id;
      _row.orderitem_scheddate := _set.orderitem_scheddate;
      _row.orderitem_qty_ordered := _set.orderitem_qty_ordered;
      _row.orderitem_qty_shipped := _set.orderitem_qty_shipped;
      _row.orderitem_qty_received := _set.orderitem_qty_received;
      _row.orderitem_qty_uom_id := _set.orderitem_qty_uom_id;
      _row.orderitem_qty_invuomratio := _set.orderitem_qty_invuomratio;
      _row.orderitem_unitcost := _set.orderitem_unitcost;
      _row.orderitem_unitcost_curr_id := _set.orderitem_unitcost_curr_id;
      _row.orderitem_freight := _set.orderitem_freight;
      _row.orderitem_freight_received := _set.orderitem_freight_received;
      _row.orderitem_freight_curr_id := _set.orderitem_freight_curr_id;

      RETURN NEXT _row;
    END LOOP;
  END IF;

  RETURN;
END;
$_$;


ALTER FUNCTION public.orderitemdata(text, integer, integer) OWNER TO admin;

--
-- TOC entry 1956 (class 1255 OID 146566755)
-- Dependencies: 8
-- Name: packageisenabled(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION packageisenabled(integer) RETURNS boolean
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT COUNT(*) >= 8
  FROM pg_inherits, pg_class, pg_namespace, pkghead
  WHERE ((inhrelid=pg_class.oid)
     AND (relnamespace=pg_namespace.oid)
     AND  (nspname=lower(pkghead_name))
     AND  (pkghead_id=$1));
$_$;


ALTER FUNCTION public.packageisenabled(integer) OWNER TO admin;

--
-- TOC entry 1957 (class 1255 OID 146566756)
-- Dependencies: 8
-- Name: packageisenabled(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION packageisenabled(text) RETURNS boolean
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT COUNT(*) >= 8
  FROM pg_inherits, pg_class, pg_namespace
  WHERE ((inhrelid=pg_class.oid)
     AND (relnamespace=pg_namespace.oid)
     AND  (nspname=lower($1)));
$_$;


ALTER FUNCTION public.packageisenabled(text) OWNER TO admin;

--
-- TOC entry 1958 (class 1255 OID 146566757)
-- Dependencies: 8
-- Name: pgp_key_id(bytea); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION pgp_key_id(bytea) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgcrypto', 'pgp_key_id_w';


ALTER FUNCTION public.pgp_key_id(bytea) OWNER TO admin;

--
-- TOC entry 1959 (class 1255 OID 146566758)
-- Dependencies: 8
-- Name: pgp_pub_decrypt(bytea, bytea); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION pgp_pub_decrypt(bytea, bytea) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgcrypto', 'pgp_pub_decrypt_text';


ALTER FUNCTION public.pgp_pub_decrypt(bytea, bytea) OWNER TO admin;

--
-- TOC entry 1960 (class 1255 OID 146566759)
-- Dependencies: 8
-- Name: pgp_pub_decrypt(bytea, bytea, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION pgp_pub_decrypt(bytea, bytea, text) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgcrypto', 'pgp_pub_decrypt_text';


ALTER FUNCTION public.pgp_pub_decrypt(bytea, bytea, text) OWNER TO admin;

--
-- TOC entry 1961 (class 1255 OID 146566760)
-- Dependencies: 8
-- Name: pgp_pub_decrypt(bytea, bytea, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION pgp_pub_decrypt(bytea, bytea, text, text) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgcrypto', 'pgp_pub_decrypt_text';


ALTER FUNCTION public.pgp_pub_decrypt(bytea, bytea, text, text) OWNER TO admin;

--
-- TOC entry 1962 (class 1255 OID 146566761)
-- Dependencies: 8
-- Name: pgp_pub_decrypt_bytea(bytea, bytea); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION pgp_pub_decrypt_bytea(bytea, bytea) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgcrypto', 'pgp_pub_decrypt_bytea';


ALTER FUNCTION public.pgp_pub_decrypt_bytea(bytea, bytea) OWNER TO admin;

--
-- TOC entry 1963 (class 1255 OID 146566762)
-- Dependencies: 8
-- Name: pgp_pub_decrypt_bytea(bytea, bytea, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION pgp_pub_decrypt_bytea(bytea, bytea, text) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgcrypto', 'pgp_pub_decrypt_bytea';


ALTER FUNCTION public.pgp_pub_decrypt_bytea(bytea, bytea, text) OWNER TO admin;

--
-- TOC entry 1964 (class 1255 OID 146566763)
-- Dependencies: 8
-- Name: pgp_pub_decrypt_bytea(bytea, bytea, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION pgp_pub_decrypt_bytea(bytea, bytea, text, text) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgcrypto', 'pgp_pub_decrypt_bytea';


ALTER FUNCTION public.pgp_pub_decrypt_bytea(bytea, bytea, text, text) OWNER TO admin;

--
-- TOC entry 1965 (class 1255 OID 146566764)
-- Dependencies: 8
-- Name: pgp_pub_encrypt(text, bytea); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION pgp_pub_encrypt(text, bytea) RETURNS bytea
    LANGUAGE c STRICT
    AS '$libdir/pgcrypto', 'pgp_pub_encrypt_text';


ALTER FUNCTION public.pgp_pub_encrypt(text, bytea) OWNER TO admin;

--
-- TOC entry 1966 (class 1255 OID 146566765)
-- Dependencies: 8
-- Name: pgp_pub_encrypt(text, bytea, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION pgp_pub_encrypt(text, bytea, text) RETURNS bytea
    LANGUAGE c STRICT
    AS '$libdir/pgcrypto', 'pgp_pub_encrypt_text';


ALTER FUNCTION public.pgp_pub_encrypt(text, bytea, text) OWNER TO admin;

--
-- TOC entry 1967 (class 1255 OID 146566766)
-- Dependencies: 8
-- Name: pgp_pub_encrypt_bytea(bytea, bytea); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION pgp_pub_encrypt_bytea(bytea, bytea) RETURNS bytea
    LANGUAGE c STRICT
    AS '$libdir/pgcrypto', 'pgp_pub_encrypt_bytea';


ALTER FUNCTION public.pgp_pub_encrypt_bytea(bytea, bytea) OWNER TO admin;

--
-- TOC entry 1968 (class 1255 OID 146566767)
-- Dependencies: 8
-- Name: pgp_pub_encrypt_bytea(bytea, bytea, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION pgp_pub_encrypt_bytea(bytea, bytea, text) RETURNS bytea
    LANGUAGE c STRICT
    AS '$libdir/pgcrypto', 'pgp_pub_encrypt_bytea';


ALTER FUNCTION public.pgp_pub_encrypt_bytea(bytea, bytea, text) OWNER TO admin;

--
-- TOC entry 1969 (class 1255 OID 146566768)
-- Dependencies: 8
-- Name: pgp_sym_decrypt(bytea, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION pgp_sym_decrypt(bytea, text) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgcrypto', 'pgp_sym_decrypt_text';


ALTER FUNCTION public.pgp_sym_decrypt(bytea, text) OWNER TO admin;

--
-- TOC entry 1970 (class 1255 OID 146566769)
-- Dependencies: 8
-- Name: pgp_sym_decrypt(bytea, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION pgp_sym_decrypt(bytea, text, text) RETURNS text
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgcrypto', 'pgp_sym_decrypt_text';


ALTER FUNCTION public.pgp_sym_decrypt(bytea, text, text) OWNER TO admin;

--
-- TOC entry 1971 (class 1255 OID 146566770)
-- Dependencies: 8
-- Name: pgp_sym_decrypt_bytea(bytea, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION pgp_sym_decrypt_bytea(bytea, text) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgcrypto', 'pgp_sym_decrypt_bytea';


ALTER FUNCTION public.pgp_sym_decrypt_bytea(bytea, text) OWNER TO admin;

--
-- TOC entry 1972 (class 1255 OID 146566771)
-- Dependencies: 8
-- Name: pgp_sym_decrypt_bytea(bytea, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION pgp_sym_decrypt_bytea(bytea, text, text) RETURNS bytea
    LANGUAGE c IMMUTABLE STRICT
    AS '$libdir/pgcrypto', 'pgp_sym_decrypt_bytea';


ALTER FUNCTION public.pgp_sym_decrypt_bytea(bytea, text, text) OWNER TO admin;

--
-- TOC entry 1973 (class 1255 OID 146566772)
-- Dependencies: 8
-- Name: pgp_sym_encrypt(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION pgp_sym_encrypt(text, text) RETURNS bytea
    LANGUAGE c STRICT
    AS '$libdir/pgcrypto', 'pgp_sym_encrypt_text';


ALTER FUNCTION public.pgp_sym_encrypt(text, text) OWNER TO admin;

--
-- TOC entry 1974 (class 1255 OID 146566773)
-- Dependencies: 8
-- Name: pgp_sym_encrypt(text, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION pgp_sym_encrypt(text, text, text) RETURNS bytea
    LANGUAGE c STRICT
    AS '$libdir/pgcrypto', 'pgp_sym_encrypt_text';


ALTER FUNCTION public.pgp_sym_encrypt(text, text, text) OWNER TO admin;

--
-- TOC entry 1975 (class 1255 OID 146566774)
-- Dependencies: 8
-- Name: pgp_sym_encrypt_bytea(bytea, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION pgp_sym_encrypt_bytea(bytea, text) RETURNS bytea
    LANGUAGE c STRICT
    AS '$libdir/pgcrypto', 'pgp_sym_encrypt_bytea';


ALTER FUNCTION public.pgp_sym_encrypt_bytea(bytea, text) OWNER TO admin;

--
-- TOC entry 1976 (class 1255 OID 146566775)
-- Dependencies: 8
-- Name: pgp_sym_encrypt_bytea(bytea, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION pgp_sym_encrypt_bytea(bytea, text, text) RETURNS bytea
    LANGUAGE c STRICT
    AS '$libdir/pgcrypto', 'pgp_sym_encrypt_bytea';


ALTER FUNCTION public.pgp_sym_encrypt_bytea(bytea, text, text) OWNER TO admin;

--
-- TOC entry 1977 (class 1255 OID 146566776)
-- Dependencies: 4536 8
-- Name: pkgmaybemodified(name); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION pkgmaybemodified(name) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pschemaname ALIAS FOR $1;
  _returnval  BOOLEAN;
BEGIN
  SELECT pkghead_indev INTO _returnval
  FROM pkghead
  WHERE (pkghead_name=pschemaname);
  IF (NOT FOUND) THEN
    RETURN FALSE;
  END IF;
  RETURN _returnval;
END;
$_$;


ALTER FUNCTION public.pkgmaybemodified(name) OWNER TO admin;

--
-- TOC entry 1978 (class 1255 OID 146566777)
-- Dependencies: 8
-- Name: plpgsql_call_handler(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION plpgsql_call_handler() RETURNS language_handler
    LANGUAGE c
    AS '$libdir/plpgsql', 'plpgsql_call_handler';


ALTER FUNCTION public.plpgsql_call_handler() OWNER TO admin;

--
-- TOC entry 1979 (class 1255 OID 146566778)
-- Dependencies: 8
-- Name: plpgsql_validator(oid); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION plpgsql_validator(oid) RETURNS void
    LANGUAGE c
    AS '$libdir/plpgsql', 'plpgsql_validator';


ALTER FUNCTION public.plpgsql_validator(oid) OWNER TO admin;

--
-- TOC entry 1935 (class 1255 OID 146566779)
-- Dependencies: 4536 8
-- Name: postapcheck(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postapcheck(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RAISE NOTICE 'postAPCheck() is deprecated - use postCheck() instead';
  RETURN postCheck($1, fetchJournalNumber('AP-CK'));
END;
$_$;


ALTER FUNCTION public.postapcheck(integer) OWNER TO admin;

--
-- TOC entry 1951 (class 1255 OID 146566780)
-- Dependencies: 4536 8
-- Name: postapcheck(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postapcheck(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RAISE NOTICE 'postAPCheck() is deprecated - use postCheck() instead';
  RETURN postCheck($1, $2);
END;
$_$;


ALTER FUNCTION public.postapcheck(integer, integer) OWNER TO admin;

--
-- TOC entry 1952 (class 1255 OID 146566781)
-- Dependencies: 4536 8
-- Name: postapchecks(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postapchecks(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  RAISE NOTICE 'postAPChecks() is deprecated - use postChecks() instead';
  RETURN postChecks($1);

END;
$_$;


ALTER FUNCTION public.postapchecks(integer) OWNER TO admin;

--
-- TOC entry 1981 (class 1255 OID 146566782)
-- Dependencies: 4536 8
-- Name: postapcreditmemoapplication(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postapcreditmemoapplication(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pApopenid ALIAS FOR $1;
  _src RECORD;
  _r RECORD;
  _totalAmount NUMERIC := 0.0;
  _exchGain NUMERIC := 0.0;
  _apaccntid INTEGER;

BEGIN

  SELECT apopen_docnumber, (apopen_amount - apopen_paid) AS balance,
--         SUM(currtocurr(apcreditapply_curr_id, apopen_curr_id,
--				 apcreditapply_amount, CURRENT_DATE)) AS toApply,
	 SUM(apcreditapply_amount) AS toApply,
	 apopen_curr_rate INTO _src
  FROM apopen, apcreditapply
  WHERE ( (apcreditapply_source_apopen_id=apopen_id)
   AND (apopen_id=pApopenid) )
  GROUP BY apopen_docnumber, apopen_amount, apopen_paid,
	   apopen_curr_rate;
  IF (NOT FOUND) THEN
    RETURN -1;
  ELSIF (_src.toApply = 0) THEN
    RETURN -2;
  ELSIF (_src.toApply > _src.balance) THEN
    RETURN -3;
--  ELSIF (_src.toApply IS NULL AND _src.junk IS NOT NULL) THEN
--    RETURN -4;		-- missing exchange rate
  ELSIF (_src.toApply IS NULL) THEN
    RETURN -6;		-- amount to apply is NULL for some unknown reason
  END IF;

  SELECT apopen_id, apopen_vend_id, apopen_docnumber, apopen_doctype, apopen_amount,
         apopen_curr_id, apopen_curr_rate, apopen_docdate, apopen_accnt_id INTO _src
  FROM apopen
  WHERE (apopen_id=pApopenid);
  IF (NOT FOUND) THEN
    RETURN -5;
  END IF;

  FOR _r IN SELECT apcreditapply_id, apcreditapply_target_apopen_id,
		   apcreditapply_amount AS apply_amountSource,
                   currToCurr(apcreditapply_curr_id, apopen_curr_id,
                              apcreditapply_amount, CURRENT_DATE) AS apply_amountTarget,
                   apopen_id, apopen_doctype, apopen_docnumber, apopen_curr_id, apopen_curr_rate, apopen_docdate
            FROM apcreditapply, apopen
            WHERE ( (apcreditapply_source_apopen_id=pApopenid)
             AND (apcreditapply_target_apopen_id=apopen_id) ) LOOP

    IF (_r.apply_amountTarget IS NULL) THEN
      RETURN -4;	-- missing exchange rate
    END IF;

    IF (_r.apply_amountTarget > 0) THEN

--  Update the apopen item to post the paid amount
      UPDATE apopen
      SET apopen_paid = (apopen_paid + _r.apply_amountTarget)
      WHERE (apopen_id=_r.apcreditapply_target_apopen_id);

      UPDATE apopen
      SET apopen_open = false,
        apopen_closedate = current_date
      WHERE ( (apopen_id=_r.apcreditapply_target_apopen_id)
        AND (apopen_amount <= apopen_paid) );

--  Cache the running amount posted
      _totalAmount := (_totalAmount + _r.apply_amountSource);

--  Record the application
      INSERT INTO apapply
      ( apapply_vend_id, apapply_amount,
        apapply_source_apopen_id, apapply_source_doctype, apapply_source_docnumber,
        apapply_target_apopen_id, apapply_target_doctype, apapply_target_docnumber,
        apapply_postdate, apapply_journalnumber, apapply_username, apapply_curr_id )
      VALUES
      ( _src.apopen_vend_id, round(_r.apply_amountSource, 2),
        pApopenid, 'C', _src.apopen_docnumber,
        _r.apopen_id, _r.apopen_doctype, _r.apopen_docnumber,
        CURRENT_DATE, 0, getEffectiveXtUser(), _src.apopen_curr_id );

    END IF;

--  Delete the posted apcreditapply record
    DELETE FROM apcreditapply
    WHERE (apcreditapply_id=_r.apcreditapply_id);

  END LOOP;

--  Record the amount posted and mark the source apopen as closed if it is completely posted
  UPDATE apopen
  SET apopen_paid = (apopen_paid + _totalAmount)
  WHERE (apopen_id=pApopenid);

  UPDATE apopen
  SET apopen_open = false,
    apopen_closedate = current_date
  WHERE ( (apopen_id=pApopenid)
    AND (apopen_amount <= apopen_paid) );

  IF (_r.apopen_curr_id = _src.apopen_curr_id) THEN
    IF (_r.apopen_docdate > _src.apopen_docdate) THEN
      _exchGain := (_totalAmount / _r.apopen_curr_rate - _totalAmount / _src.apopen_curr_rate) * -1;
    ELSE
      _exchGain := _totalAmount / _src.apopen_curr_rate - _totalAmount / _r.apopen_curr_rate;
    END IF;
  END IF;

-- do not post gain/loss to alternate prepaid
--  IF (_src.apopen_accnt_id > -1) THEN
--    _apaccntid := _src.apopen_accnt_id;
--  ELSE
    _apaccntid := findAPAccount(_src.apopen_vend_id);
--  END IF;

  PERFORM insertGLTransaction(fetchJournalNumber('AP-MISC'), 'A/P', 'CM',
                            _src.apopen_docnumber, 'CM Application',
                            _apaccntid,
			    getGainLossAccntId(_apaccntid), -1,
                            _exchGain,
                            CURRENT_DATE);


  RETURN pApopenid;

END;
$_$;


ALTER FUNCTION public.postapcreditmemoapplication(integer) OWNER TO admin;

--
-- TOC entry 1982 (class 1255 OID 146566783)
-- Dependencies: 4536 8
-- Name: postapopenitems(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postapopenitems() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  UPDATE apopen
  SET apopen_posted=TRUE
  WHERE (NOT apopen_posted);

  RETURN TRUE;

END;
$$;


ALTER FUNCTION public.postapopenitems() OWNER TO admin;

--
-- TOC entry 1983 (class 1255 OID 146566784)
-- Dependencies: 4536 8
-- Name: postarcreditmemoapplication(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postarcreditmemoapplication(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pAropenid ALIAS FOR $1;
BEGIN
  RETURN postARCreditMemoApplication(pAropenid, CURRENT_DATE);
END;
$_$;


ALTER FUNCTION public.postarcreditmemoapplication(integer) OWNER TO admin;

--
-- TOC entry 1984 (class 1255 OID 146566785)
-- Dependencies: 4536 8
-- Name: postarcreditmemoapplication(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postarcreditmemoapplication(integer, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pAropenid ALIAS FOR $1;
  _applyDate DATE := COALESCE($2, CURRENT_DATE);
  _p RECORD;
  _r RECORD;
  _totalAmount NUMERIC := 0;
  _totalTarget NUMERIC := 0;
  _exchGain NUMERIC := 0;
  _result NUMERIC;
  _araccntid INTEGER;

BEGIN

  SELECT aropen_docnumber,
         ROUND(aropen_amount - aropen_paid, 2) AS balance,
         aropen_open, aropen_curr_rate,
         ROUND(SUM(currToCurr(arcreditapply_curr_id, aropen_curr_id,
              COALESCE(arcreditapply_amount, 0), _applyDate)), 2) AS toApply INTO _p
  FROM aropen, arcreditapply
  WHERE ( (arcreditapply_source_aropen_id=aropen_id)
   AND (aropen_id=pAropenid) )
  GROUP BY aropen_docnumber, aropen_amount, aropen_paid, aropen_open, aropen_curr_rate;
  IF (NOT FOUND) THEN
    RETURN -1;
  ELSIF (_p.toApply = 0) THEN
    RETURN -2;
  ELSIF (_p.toApply > _p.balance) THEN
    RETURN -3;
  END IF;

  SELECT aropen_cust_id, aropen_docnumber, aropen_doctype, aropen_amount,
         aropen_curr_id, aropen_docdate, aropen_accnt_id, aropen_cust_id,
         aropen_curr_rate INTO _p
  FROM aropen
  WHERE (aropen_id=pAropenid);
  IF (NOT FOUND) THEN
    RETURN -5;
  END IF;

  FOR _r IN SELECT arcreditapply_id, arcreditapply_target_aropen_id,
                   arcreditapply_amount AS arcreditapply_amountSource,
                   arcreditapply_reftype, arcreditapply_ref_id,
                   currToCurr(arcreditapply_curr_id, aropen_curr_id,
                              arcreditapply_amount, _applyDate) AS arcreditapply_amountTarget,
                   aropen_id, aropen_doctype, aropen_docnumber, aropen_docdate, aropen_curr_rate
            FROM arcreditapply, aropen
            WHERE ( (arcreditapply_source_aropen_id=pAropenid)
             AND (arcreditapply_target_aropen_id=aropen_id) ) LOOP

    IF (_r.arcreditapply_amountTarget IS NULL) THEN
      RETURN -4;
    END IF;

    IF (_r.arcreditapply_amountTarget > 0) THEN

--  Update the aropen item to post the paid amount
      UPDATE aropen
      SET aropen_paid = round(aropen_paid + _r.arcreditapply_amountTarget, 2)
      WHERE (aropen_id=_r.arcreditapply_target_aropen_id);

      UPDATE aropen
      SET aropen_open = (round(aropen_amount, 2) > round(aropen_paid, 2))
      WHERE (aropen_id=_r.arcreditapply_target_aropen_id);

--  Cache the running amount posted
      _totalAmount := (_totalAmount + _r.arcreditapply_amountSource);
      _totalTarget := (_totalTarget + _r.arcreditapply_amountTarget);

--  Record the application
      INSERT INTO arapply
      ( arapply_cust_id,
        arapply_source_aropen_id, arapply_source_doctype, arapply_source_docnumber,
        arapply_target_aropen_id, arapply_target_doctype, arapply_target_docnumber,
        arapply_fundstype, arapply_refnumber,
        arapply_applied, arapply_closed, arapply_postdate, arapply_distdate,
        arapply_journalnumber, arapply_username, arapply_curr_id,
        arapply_reftype, arapply_ref_id )
      VALUES
      ( _p.aropen_cust_id,
        pAropenid, _p.aropen_doctype, _p.aropen_docnumber,
        _r.aropen_id, _r.aropen_doctype, _r.aropen_docnumber,
        '', '',
        round(_r.arcreditapply_amountSource, 2), TRUE, _applyDate, _applyDate,
        0, getEffectiveXtUser(), _p.aropen_curr_id,
        _r.arcreditapply_reftype, _r.arcreditapply_ref_id );

    END IF;

--  Delete the posted arcreditapply record
    DELETE FROM arcreditapply
    WHERE (arcreditapply_id=_r.arcreditapply_id);

    IF (_r.aropen_docdate > _p.aropen_docdate) THEN
      _exchGain := (_totalTarget / _r.aropen_curr_rate - _totalAmount / _p.aropen_curr_rate) * -1;
    ELSE
      _exchGain := _totalAmount / _p.aropen_curr_rate - _totalTarget / _r.aropen_curr_rate;
    END IF;

    IF (_p.aropen_accnt_id > -1) THEN
      _araccntid := _p.aropen_accnt_id;
    ELSE
      _araccntid := findARAccount(_p.aropen_cust_id);
    END IF;

    IF (_exchGain <> 0) THEN
        PERFORM insertGLTransaction(fetchJournalNumber('AR-MISC'), 'A/R',
                                    'CR', _p.aropen_docnumber, 'CM Application',
                                    _araccntid, getGainLossAccntId(_araccntid),
                                    -1, _exchGain * -1, _applyDate);
    END IF;

  END LOOP;

-- TODO: If this is a Customer Deposit (aropen_doctype='R')
--       the we need to convert the total to a base transaction
  IF(_p.aropen_doctype='R') THEN
    SELECT insertGLTransaction(fetchJournalNumber('AR-MISC'), 'A/R',
                               'CD', _p.aropen_docnumber, 'CM Application',
                               cr.accnt_id, db.accnt_id,
                               -1, currToBase(_p.aropen_curr_id, _totalAmount, _p.aropen_docdate),
                               _applyDate)
      INTO _result
      FROM accnt AS cr, accnt AS db
     WHERE ((db.accnt_id = findDeferredAccount(_p.aropen_cust_id))
       AND  (cr.accnt_id = findARAccount(_p.aropen_cust_id)) );
    IF(NOT FOUND OR _result < 0) THEN
      RAISE EXCEPTION 'There was an error posting the Customer Deposit GL Transactions.';
    END IF;
  END IF;

--  Record the amount posted and mark the source aropen as closed if it is completely posted
  UPDATE aropen
  SET aropen_paid = round(aropen_paid + _totalAmount, 2)
  WHERE (aropen_id=pAropenid);

  UPDATE aropen
  SET aropen_open = (round(aropen_amount, 2) > round(aropen_paid, 2))
  WHERE (aropen_id=pAropenid);

  RETURN pAropenid;

END;
$_$;


ALTER FUNCTION public.postarcreditmemoapplication(integer, date) OWNER TO admin;

--
-- TOC entry 1985 (class 1255 OID 146566787)
-- Dependencies: 4536 8
-- Name: postaropenitems(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postaropenitems() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  UPDATE aropen
  SET aropen_posted=TRUE
  WHERE (NOT aropen_posted);

  RETURN TRUE;

END;
$$;


ALTER FUNCTION public.postaropenitems() OWNER TO admin;

--
-- TOC entry 1986 (class 1255 OID 146566788)
-- Dependencies: 4536 8
-- Name: postbankadjustment(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postbankadjustment(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pBankadjid ALIAS FOR $1;
  _sequence INTEGER;
  _r RECORD;

BEGIN

--  Post the G/L transaction
  SELECT insertGLTransaction( fetchJournalNumber('GL-MISC'), 'G/L', 'AD',
                              bankadj_docnumber, (bankadjtype_name || '-' || bankadj_notes),
                              bankadjtype_accnt_id, bankaccnt_accnt_id, bankadj_id,
                              round(currToBase(bankaccnt_curr_id,
                                         CASE WHEN(bankadjtype_iscredit) THEN
                                             (bankadj_amount * -1)
                                         ELSE bankadj_amount END,
                                         bankadj_date), 2),
                              bankadj_date, TRUE, TRUE ) INTO _sequence
    FROM bankadj, bankaccnt, bankadjtype
   WHERE ( (bankadj_bankaccnt_id=bankaccnt_id)
     AND   (bankadj_bankadjtype_id=bankadjtype_id)
     AND   (NOT bankadj_posted)
     AND   (bankadj_id=pBankadjid) );
  IF ( NOT FOUND ) THEN
    RETURN -1;
  END IF;

  IF (_sequence >= 0) THEN
--  Update the bankadj record with this sequence and mark it posted
    UPDATE bankadj
       SET bankadj_sequence = _sequence,
           bankadj_posted = TRUE
     WHERE bankadj_id=pBankadjid;
  END IF;

  RETURN _sequence;

END;
$_$;


ALTER FUNCTION public.postbankadjustment(integer) OWNER TO admin;

--
-- TOC entry 1987 (class 1255 OID 146566789)
-- Dependencies: 4536 8
-- Name: postbankreconciliation(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postbankreconciliation(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pBankrecid ALIAS FOR $1;
  _accntid INTEGER;
  _sequence INTEGER;
  _gltransid INTEGER;
  _r RECORD;

BEGIN

-- Check the accnt information to make sure it is valid
  SELECT accnt_id INTO _accntid
    FROM bankrec, bankaccnt, accnt
   WHERE ( (bankaccnt_accnt_id=accnt_id)
     AND   (bankrec_bankaccnt_id=bankaccnt_id)
     AND   (bankrec_id=pBankrecid) );
  IF ( NOT FOUND ) THEN
    RETURN -1;
  END IF;

-- Delete any bankrecitem records that are not marked as cleared for cleanliness
  DELETE FROM bankrecitem
   WHERE ( (NOT bankrecitem_cleared)
     AND   (bankrecitem_bankrec_id=pBankrecid) );

-- Post any bankadj items that were marked as cleared and convert the bankrecitem
  FOR _r IN SELECT bankrecitem_id, bankrecitem_source_id
              FROM bankrecitem, bankadj
             WHERE ( (bankrecitem_source = 'AD')
               AND   (bankrecitem_source_id=bankadj_id)
               AND   (bankrecitem_cleared)
               AND   (NOT bankadj_posted)
               AND   (bankrecitem_bankrec_id=pBankrecid) ) LOOP

    SELECT postBankAdjustment(_r.bankrecitem_source_id) INTO _sequence;

    IF (_sequence < 0) THEN
      RETURN -10;
    END IF;

    SELECT gltrans_id INTO _gltransid
      FROM gltrans
     WHERE ( (gltrans_sequence=_sequence)
       AND   (gltrans_accnt_id=_accntid) );
    IF ( NOT FOUND ) THEN
      RETURN -11;
    END IF;

    UPDATE bankrecitem
       SET bankrecitem_source = 'GL',
           bankrecitem_source_id=_gltransid
     WHERE (bankrecitem_id=_r.bankrecitem_id);

  END LOOP;

-- Mark all the gltrans items that have been cleared as reconciled.
  UPDATE gltrans
     SET gltrans_rec = TRUE
   WHERE ( (gltrans_id IN (SELECT bankrecitem_source_id
                             FROM bankrecitem
                            WHERE ((bankrecitem_source = 'GL')
                              AND  (bankrecitem_cleared)
                              AND  (bankrecitem_bankrec_id=pBankrecid) ) ) )
     AND   (gltrans_accnt_id=_accntid) ) ;

-- Mark all the sltrans items that have been cleared as reconciled.
  UPDATE sltrans
     SET sltrans_rec = TRUE
   WHERE ( (sltrans_id IN (SELECT bankrecitem_source_id
                             FROM bankrecitem
                            WHERE ((bankrecitem_source = 'SL')
                              AND  (bankrecitem_cleared)
                              AND  (bankrecitem_bankrec_id=pBankrecid) ) ) )
     AND   (sltrans_accnt_id=_accntid) ) ;

-- Mark the bankrec record as posted
  UPDATE bankrec SET
    bankrec_posted = TRUE,
    bankrec_postdate = now()
   WHERE (bankrec_id=pBankrecid);

  RETURN pBankrecid;
END;
$_$;


ALTER FUNCTION public.postbankreconciliation(integer) OWNER TO admin;

--
-- TOC entry 1988 (class 1255 OID 146566790)
-- Dependencies: 4536 8
-- Name: postbillingselection(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postbillingselection(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCobmiscid ALIAS FOR $1;

BEGIN

  RAISE NOTICE 'postBillingselection(integer) has been deprecated.  Please use createInvoice(integer).';
  RETURN createInvoice(pCobmiscid);

END;
$_$;


ALTER FUNCTION public.postbillingselection(integer) OWNER TO admin;

--
-- TOC entry 1989 (class 1255 OID 146566791)
-- Dependencies: 4536 8
-- Name: postbillingselectionconsolidated(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postbillingselectionconsolidated(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCustid ALIAS FOR $1;

BEGIN

  RAISE NOTICE 'postBillingselectionConsolidated(integer) has been deprecated.  Please use createInvoiceConsolidated(integer).';
  RETURN createInvoiceConsolidated(pCustid);

END;
$_$;


ALTER FUNCTION public.postbillingselectionconsolidated(integer) OWNER TO admin;

--
-- TOC entry 1990 (class 1255 OID 146566792)
-- Dependencies: 4536 8
-- Name: postbillingselections(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postbillingselections() RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  RAISE NOTICE 'postBillingselections() has been deprecated.  Please use createInvoices().';
  RETURN createInvoices();

END;
$$;


ALTER FUNCTION public.postbillingselections() OWNER TO admin;

--
-- TOC entry 1991 (class 1255 OID 146566793)
-- Dependencies: 4536 8
-- Name: postbillingselections(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postbillingselections(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RAISE NOTICE 'postBillingselections(int) has been deprecated.  Please use createInvoices(int).';
  RETURN createInvoices($1, false);
END;
$_$;


ALTER FUNCTION public.postbillingselections(integer) OWNER TO admin;

--
-- TOC entry 1651 (class 1255 OID 146566794)
-- Dependencies: 4536 8
-- Name: postbillingselections(integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postbillingselections(integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCustTypeId ALIAS FOR $1;
  pConsolidate ALIAS FOR $2;

BEGIN

  RAISE NOTICE 'postBillingselections(int,bool) has been deprecated.  Please use createInvoices(int,bool).';
  RETURN createInvoices(pCustTypeId, pConsolidate);

END;
$_$;


ALTER FUNCTION public.postbillingselections(integer, boolean) OWNER TO admin;

--
-- TOC entry 1711 (class 1255 OID 146566795)
-- Dependencies: 4536 8
-- Name: postcashreceipt(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postcashreceipt(pcashrcptid integer, pjournalnumber integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _ccpayid  INTEGER;
  _cctype TEXT;
  _p RECORD;
  _r RECORD;
  _t RECORD;
  _v RECORD;
  _postToAR NUMERIC;
  _postToMisc NUMERIC;
  _postToCM NUMERIC;
  _posted_base NUMERIC := 0;
  _posted NUMERIC := 0;
  _sequence INTEGER;
  _aropenid INTEGER;
  _arMemoNumber TEXT;
  _arAccntid INTEGER;
  _closed BOOLEAN;
  _debitAccntid INTEGER;
  _exchGain NUMERIC;
  _comment TEXT;
  _predist BOOLEAN;
  _check INTEGER;

BEGIN
  _posted := 0;
  _posted_base := 0;

  SELECT fetchGLSequence() INTO _sequence;

  SELECT accnt_id INTO _arAccntid
  FROM cashrcpt, accnt, salescat
  WHERE ((cashrcpt_salescat_id=salescat_id)
    AND  (salescat_ar_accnt_id=accnt_id)
    AND  (cashrcpt_id=pCashrcptid));
  IF (NOT FOUND) THEN
    SELECT accnt_id INTO _arAccntid
    FROM cashrcpt LEFT OUTER JOIN accnt ON (accnt_id=findARAccount(cashrcpt_cust_id))
    WHERE ( (findARAccount(cashrcpt_cust_id)=0 OR accnt_id > 0) -- G/L interface might be disabled
     AND (cashrcpt_id=pCashrcptid) );
    IF (NOT FOUND) THEN
      RETURN -5;
    END IF;
  END IF;

  SELECT cashrcpt_cust_id, (cust_number||'-'||cust_name) AS custnote,
         cashrcpt_fundstype, cashrcpt_number, cashrcpt_docnumber,
         cashrcpt_distdate, cashrcpt_amount, cashrcpt_discount,
         (cashrcpt_amount / cashrcpt_curr_rate) AS cashrcpt_amount_base,
	 (cashrcpt_discount / cashrcpt_curr_rate) AS cashrcpt_discount_base,
         cashrcpt_notes,
         cashrcpt_bankaccnt_id AS bankaccnt_id,
         accnt_id AS prepaid_accnt_id,
         cashrcpt_usecustdeposit,
         COALESCE(cashrcpt_applydate, cashrcpt_distdate) AS applydate,
         cashrcpt_curr_id, cashrcpt_curr_rate, cashrcpt_posted, cashrcpt_void INTO _p
  FROM cashrcpt LEFT OUTER JOIN custinfo ON (cashrcpt_cust_id=cust_id)
                LEFT OUTER JOIN accnt ON (accnt_id=findPrepaidAccount(cashrcpt_cust_id))
  WHERE ( (findPrepaidAccount(cashrcpt_cust_id)=0 OR accnt_id > 0) -- G/L interface might be disabled
     AND (cashrcpt_id=pCashrcptid) );
  IF (NOT FOUND) THEN
    RETURN -7;
  END IF;

  IF (COALESCE(_p.cashrcpt_distdate > _p.applydate, false)) THEN
    RAISE EXCEPTION 'Cannot post cashrcpt % because application date is before distribution date.', _p.cashrcpt_docnumber;
  END IF;

  IF (COALESCE(_p.cashrcpt_posted, false)) THEN
    RAISE EXCEPTION 'Cannot post cashrcpt % because the document has already been posted.', _p.cashrcpt_docnumber;
  END IF;

  IF (COALESCE(_p.cashrcpt_void, false)) THEN
    RAISE EXCEPTION 'Cannot post cashrcpt % because the document has been voided.', _p.cashrcpt_docnumber;
  END IF;

  _predist := COALESCE(_p.cashrcpt_distdate < _p.applydate, false);

  IF (_p.cashrcpt_fundstype IN ('A', 'D', 'M', 'V')) THEN
    SELECT ccpay_id, ccpay_type INTO _ccpayid, _cctype
    FROM ccpay
    WHERE ((ccpay_r_ordernum IN (CAST(pCashrcptid AS TEXT), _p.cashrcpt_docnumber))
       AND (ccpay_status IN ('C', 'A')));

    IF NOT FOUND THEN
      -- the following select seems to work except for xikar - bug 8848. why?
      -- raise warning so there is some visibility if people fall into this path.
      SELECT ccpay_id, ccpay_type INTO _ccpayid, _cctype
      FROM ccpay
      WHERE ((ccpay_order_number IN (CAST(pCashrcptid AS TEXT), _p.cashrcpt_docnumber))
         AND (ccpay_status IN ('C', 'A')));
      IF (NOT FOUND) THEN
        RETURN -8;
      ELSE
        RAISE NOTICE 'PostCashReceipt() found ccpay_id % for order number %/% (ref 8848).',
                      _ccpayid, pCashrcptid, _p.cashrcpt_docnumber;
      END IF;
    END IF;

-- If there is a ccpay entry and the card was charged directly, use the prepaid account
    IF (_cctype = 'C' ) THEN
      _debitAccntid := findPrepaidAccount(_p.cashrcpt_cust_id);
-- If there is a ccpay entry and the card was preauthed and then charged, use the Bank account
    ELSE
      SELECT accnt_id INTO _debitAccntid
      FROM cashrcpt, bankaccnt, accnt
      WHERE ( (cashrcpt_bankaccnt_id=bankaccnt_id)
       AND (bankaccnt_accnt_id=accnt_id)
       AND (cashrcpt_id=pCashrcptid) );
      IF (NOT FOUND) THEN
        RETURN -6;
      END IF;
    END IF;
  ELSE
    SELECT accnt_id INTO _debitAccntid
    FROM cashrcpt, bankaccnt, accnt
    WHERE ( (cashrcpt_bankaccnt_id=bankaccnt_id)
     AND (bankaccnt_accnt_id=accnt_id)
     AND (cashrcpt_id=pCashrcptid) );
    IF (NOT FOUND) THEN
      RETURN -6;
    END IF;
  END IF;

--  Determine the amount to post to A/R Open Items
  SELECT COALESCE(SUM(cashrcptitem_amount), 0) INTO _postToAR
  FROM cashrcptitem JOIN aropen ON (aropen_id=cashrcptitem_aropen_id)
  WHERE (cashrcptitem_cashrcpt_id=pCashrcptid);
  IF (NOT FOUND) THEN
    _postToAR := 0;
  END IF;

--  Determine the amount to post to Misc. Distributions
  SELECT COALESCE(SUM(cashrcptmisc_amount), 0) INTO _postToMisc
  FROM cashrcptmisc
  WHERE (cashrcptmisc_cashrcpt_id=pCashrcptid);
  IF (NOT FOUND) THEN
    _postToMisc := 0;
  END IF;

--  Determine the amount to post to Discount Credit Memo
  SELECT COALESCE(SUM(cashrcptitem_discount), 0) INTO _postToCM
  FROM cashrcptitem JOIN aropen ON ( (aropen_id=cashrcptitem_aropen_id) AND (aropen_doctype IN ('I', 'D')) )
  WHERE (cashrcptitem_cashrcpt_id=pCashrcptid);
  IF (NOT FOUND) THEN
    _postToCM := 0;
  END IF;

--  Check to see if the C/R is over applied
  IF ((_postToAR + _postToMisc) > _p.cashrcpt_amount) THEN
    RETURN -1;
  END IF;

--  Check to see if the C/R is positive amount
  IF (_p.cashrcpt_amount <= 0) THEN
    RETURN -2;
  END IF;

--  Distribute A/R Applications
    FOR _r IN SELECT aropen_id, aropen_doctype, aropen_docnumber, aropen_docdate,
                     aropen_duedate, aropen_curr_id, aropen_curr_rate, aropen_amount,
                     round(aropen_amount - aropen_paid, 2) <=
                        round(currToCurr(_p.cashrcpt_curr_id, aropen_curr_id,abs(cashrcptitem_amount + cashrcptitem_discount),_p.cashrcpt_distdate),2)
                                 AS closed,
                     cashrcptitem_id, cashrcptitem_amount, cashrcptitem_discount,
                     (cashrcptitem_amount / _p.cashrcpt_curr_rate) AS cashrcptitem_amount_base,
		     (cashrcptitem_discount / _p.cashrcpt_curr_rate) AS cashrcptitem_discount_base,
                     round(aropen_paid +
                       currToCurr(_p.cashrcpt_curr_id, aropen_curr_id,abs(cashrcptitem_amount),_p.cashrcpt_distdate),2) AS new_paid,
                     round(currToCurr(_p.cashrcpt_curr_id, aropen_curr_id,cashrcptitem_discount,_p.cashrcpt_distdate),2) AS new_discount
              FROM cashrcptitem JOIN aropen ON (aropen_id=cashrcptitem_aropen_id)
              WHERE ((cashrcptitem_cashrcpt_id=pCashrcptid)
               AND (NOT _predist OR aropen_doctype IN ('C','R'))) LOOP

  --  Handle discount
      IF (_r.cashrcptitem_discount_base > 0) THEN
        PERFORM postCashReceiptDisc(_r.cashrcptitem_id, pJournalNumber);
      END IF;

  --  Update the aropen item to post the paid amount
      UPDATE aropen
      SET aropen_paid = _r.new_paid + _r.new_discount,
          aropen_open = (NOT _r.closed),
          aropen_closedate = CASE WHEN _r.closed THEN _p.cashrcpt_distdate END
      WHERE (aropen_id=_r.aropen_id);

  --  Cache the running amount posted
      _posted_base := _posted_base + _r.cashrcptitem_amount_base;
      _posted := _posted + _r.cashrcptitem_amount;

  --  Record the cashrcpt application
    IF (_r.aropen_doctype IN ('I','D')) THEN
      INSERT INTO arapply
      ( arapply_cust_id,
        arapply_source_aropen_id, arapply_source_doctype, arapply_source_docnumber,
        arapply_target_aropen_id, arapply_target_doctype, arapply_target_docnumber,
        arapply_fundstype, arapply_refnumber, arapply_reftype, arapply_ref_id,
        arapply_applied, arapply_closed,
        arapply_postdate, arapply_distdate, arapply_journalnumber, arapply_username,
        arapply_curr_id )
      VALUES
      ( _p.cashrcpt_cust_id,
        -1, 'K', _p.cashrcpt_number,
        _r.aropen_id, _r.aropen_doctype, _r.aropen_docnumber,
        _p.cashrcpt_fundstype, _p.cashrcpt_docnumber, 'CRA', _r.cashrcptitem_id,
        round(_r.cashrcptitem_amount, 2), _r.closed,
        _p.applydate, _p.cashrcpt_distdate, pJournalNumber, getEffectiveXtUser(), _p.cashrcpt_curr_id);
    ELSE
      INSERT INTO arapply
      ( arapply_cust_id,
        arapply_source_aropen_id, arapply_source_doctype, arapply_source_docnumber,
        arapply_target_aropen_id, arapply_target_doctype, arapply_target_docnumber,
        arapply_fundstype, arapply_refnumber, arapply_reftype, arapply_ref_id,
        arapply_applied, arapply_closed, arapply_postdate, arapply_distdate,
        arapply_journalnumber, arapply_username, arapply_curr_id )
      VALUES
      ( _p.cashrcpt_cust_id,
        _r.aropen_id, _r.aropen_doctype, _r.aropen_docnumber,
        -1, 'R', _p.cashrcpt_number,
        '', '', 'CRA', _r.cashrcptitem_id,
        round(abs(_r.cashrcptitem_amount), 2), _r.closed,
        _p.applydate, _p.cashrcpt_distdate, pJournalNumber, getEffectiveXtUser(), _p.cashrcpt_curr_id );
    END IF;

      _exchGain := arCurrGain(_r.aropen_id,_p.cashrcpt_curr_id, abs(_r.cashrcptitem_amount),
                             _p.cashrcpt_distdate);

       PERFORM insertIntoGLSeries( _sequence, 'A/R', 'CR',
                          (_r.aropen_doctype || '-' || _r.aropen_docnumber),
                          CASE WHEN _r.aropen_doctype != 'R' THEN _arAccntid
                          ELSE findDeferredAccount(_p.cashrcpt_cust_id) END,
                          round(_r.cashrcptitem_amount_base + _exchGain, 2),
                          _p.cashrcpt_distdate, _p.custnote, pCashrcptid );

      IF (_exchGain <> 0) THEN
          PERFORM insertIntoGLSeries(_sequence, 'A/R', 'CR',
                 _r.aropen_doctype || '-' || _r.aropen_docnumber,
                 getGainLossAccntId(
                   CASE WHEN _r.aropen_doctype != 'R' THEN _arAccntid
                   ELSE findDeferredAccount(_p.cashrcpt_cust_id) END
                 ), round(_exchGain, 2) * -1,
                 _p.cashrcpt_distdate, _p.custnote, pCashrcptid);
      END IF;

    END LOOP;

--  Distribute Misc. Applications
  FOR _r IN SELECT cashrcptmisc_id, cashrcptmisc_accnt_id, cashrcptmisc_amount,
                   (cashrcptmisc_amount / cashrcpt_curr_rate) AS cashrcptmisc_amount_base,
                   cashrcptmisc_notes, cashrcpt_curr_id
            FROM cashrcptmisc JOIN
                 cashrcpt ON (cashrcptmisc_cashrcpt_id = cashrcpt_id)
            WHERE (cashrcptmisc_cashrcpt_id=pCashrcptid)  LOOP

--  Cache the running amount posted
    _posted_base := (_posted_base + _r.cashrcptmisc_amount_base);
    _posted := (_posted + _r.cashrcptmisc_amount);

--  Record the cashrcpt application
    INSERT INTO arapply
    ( arapply_cust_id,
      arapply_source_aropen_id, arapply_source_doctype, arapply_source_docnumber,
      arapply_target_aropen_id, arapply_target_doctype, arapply_target_docnumber,
      arapply_fundstype, arapply_refnumber,
      arapply_applied, arapply_closed,
      arapply_postdate, arapply_distdate, arapply_journalnumber, arapply_username,
      arapply_curr_id, arapply_reftype, arapply_ref_id )
    VALUES
    ( _p.cashrcpt_cust_id,
      -1, 'K', '',
      -1, 'Misc.', '',
      _p.cashrcpt_fundstype, _p.cashrcpt_docnumber,
      round(_r.cashrcptmisc_amount, 2), TRUE,
      _p.applydate, _p.cashrcpt_distdate, pJournalNumber, getEffectiveXtUser(),
      _r.cashrcpt_curr_id, 'CRD', _r.cashrcptmisc_id );
    PERFORM insertIntoGLSeries( _sequence, 'A/R', 'CR', _r.cashrcptmisc_notes,
                                _r.cashrcptmisc_accnt_id,
                                round(_r.cashrcptmisc_amount_base, 2),
                                _p.cashrcpt_distdate, _p.custnote, pCashrcptid );

  END LOOP;

--  Post any remaining Cash to an A/R Cash Despoit (Credit Memo)
--  this credit memo may absorb an occasional currency exchange rounding error
  IF (round(_posted_base, 2) < round(_p.cashrcpt_amount_base, 2)) THEN
    _comment := ('Unapplied from ' || _p.cashrcpt_fundstype || '-' || _p.cashrcpt_docnumber);
    PERFORM insertIntoGLSeries( _sequence, 'A/R', 'CR',
                                _comment,
                                _p.prepaid_accnt_id,
                                round(_p.cashrcpt_amount_base, 2) -
                                                        round(_posted_base, 2),
                                _p.cashrcpt_distdate, _p.custnote, pCashrcptid );
    SELECT fetchArMemoNumber() INTO _arMemoNumber;
    IF(_p.cashrcpt_usecustdeposit) THEN
      -- Post Customer Deposit
      SELECT createARCashDeposit(_p.cashrcpt_cust_id, _arMemoNumber, '',
                                 _p.cashrcpt_distdate, (_p.cashrcpt_amount - _posted),
                                 _comment, pJournalNumber, _p.cashrcpt_curr_id) INTO _aropenid;
    ELSE
      -- Post A/R Credit Memo
      _aropenid := createARCreditMemo(NULL, _p.cashrcpt_cust_id, _arMemoNumber, '',
                                _p.cashrcpt_distdate, (_p.cashrcpt_amount - _posted),
                                _comment, -1, -1, -1, _p.cashrcpt_distdate, -1, NULL, 0,
                                pJournalNumber, _p.cashrcpt_curr_id, _arAccntid);
    END IF;

    IF (_ccpayid IS NOT NULL) THEN
      INSERT INTO payaropen (payaropen_ccpay_id, payaropen_aropen_id,
                             payaropen_amount,   payaropen_curr_id
                   ) VALUES (_ccpayid,           _aropenid,
                             _p.cashrcpt_amount, _p.cashrcpt_curr_id);
    END IF;

    -- Create Cash Receipt Item to capture posting
    IF (_predist=false) THEN
      INSERT INTO cashrcptitem
        ( cashrcptitem_cashrcpt_id, cashrcptitem_aropen_id, cashrcptitem_amount, cashrcptitem_applied )
      VALUES
        ( pCashrcptid, _aropenid, (_p.cashrcpt_amount - _posted), false );
    END IF;

  ELSIF (round(_posted_base, 2) > round((_p.cashrcpt_amount_base), 2)) THEN
    PERFORM insertIntoGLSeries(_sequence, 'A/R', 'CR',
                   'Currency Exchange Rounding - ' || _p.cashrcpt_docnumber,
                   getGainLossAccntId(_debitAccntid),
                   round(_posted_base, 2) - round((_p.cashrcpt_amount_base + _p.cashrcpt_discount_base), 2),
                   _p.cashrcpt_distdate, _p.custnote, pCashrcptid);
  END IF;

--  Debit Cash
  PERFORM insertIntoGLSeries( _sequence, 'A/R', 'CR',
                    (_p.cashrcpt_fundstype || '-' || _p.cashrcpt_docnumber),
                     _debitAccntid, round(_p.cashrcpt_amount_base, 2) * -1,
                     _p.cashrcpt_distdate,
                     _p.custnote, pCashrcptid );

  PERFORM postGLSeries(_sequence, pJournalNumber);

  -- convert the cashrcptitem records to applications against the cm/cd if we are _predist
  IF(_predist=true) THEN
    FOR _r IN SELECT *
              FROM cashrcptitem
              WHERE ((cashrcptitem_cashrcpt_id=pCashrcptid)
                AND (cashrcptitem_amount > 0)) LOOP

      -- Handle discount if applicable
      IF (_r.cashrcptitem_discount > 0) THEN
        PERFORM postCashReceiptDisc(_r.cashrcptitem_id, pJournalNumber);
      END IF;

      INSERT INTO arcreditapply (arcreditapply_source_aropen_id, arcreditapply_target_aropen_id,
                                 arcreditapply_amount, arcreditapply_curr_id)
                          VALUES(_aropenid, _r.cashrcptitem_aropen_id,
                                 _r.cashrcptitem_amount, _p.cashrcpt_curr_id);
      _posted := (_posted + _r.cashrcptitem_amount);

    END LOOP;

    PERFORM postArCreditMemoApplication(_aropenid, _p.applydate);

    -- If there is any left over go ahead and create an additional cashrcptitem record for it with the amount
    IF (round(_posted, 2) < round(_p.cashrcpt_amount, 2)) THEN
      INSERT INTO cashrcptitem
        ( cashrcptitem_cashrcpt_id, cashrcptitem_aropen_id, cashrcptitem_amount, cashrcptitem_applied )
      VALUES
        ( pCashrcptid, _aropenid, (_p.cashrcpt_amount - _posted), false );
    END IF;
  END IF;

--  Update the posted cashrcpt
  UPDATE cashrcpt SET cashrcpt_posted=TRUE,
                      cashrcpt_posteddate=CURRENT_DATE,
                      cashrcpt_postedby=getEffectiveXtUser()
  WHERE (cashrcpt_id=pCashrcptid);

  RETURN 1;

END;
$$;


ALTER FUNCTION public.postcashreceipt(pcashrcptid integer, pjournalnumber integer) OWNER TO admin;

--
-- TOC entry 1728 (class 1255 OID 146566797)
-- Dependencies: 4536 8
-- Name: postcashreceiptdisc(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postcashreceiptdisc(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCashrcptItemId ALIAS FOR $1;
  pJournalNumber ALIAS FOR $2;
  _r RECORD;
  _t RECORD;
  _v RECORD;
  _ardiscountid INTEGER;
  _arMemoNumber TEXT;
  _arAccntid INTEGER;
  _discountAccntid INTEGER;
  _comment      TEXT;
  _discprcnt NUMERIC;
  _check INTEGER;

BEGIN

    -- Fetch base records for processing
    SELECT aropen_id, aropen_doctype, aropen_amount,
           cashrcptitem_discount,
           cashrcpt_cust_id, cashrcpt_distdate, cashrcpt_applydate,
           cashrcpt_curr_id, cashrcpt_fundstype, cashrcpt_docnumber,
           round(currToCurr(cashrcpt_curr_id, aropen_curr_id, cashrcptitem_discount, cashrcpt_distdate),2) AS aropen_discount
      INTO _r
    FROM cashrcptitem
      JOIN cashrcpt ON (cashrcptitem_cashrcpt_id=cashrcpt_id)
      JOIN aropen ON ( (aropen_id=cashrcptitem_aropen_id) AND (aropen_doctype IN ('I', 'D')) )
    WHERE (cashrcptitem_id=pCashrcptItemId);

    -- Get discount account
    _discountAccntid := findardiscountaccount(_r.cashrcpt_cust_id);

    IF (_r.cashrcptitem_discount > 0) THEN
      --  Determine discount percentage
      _discprcnt := _r.aropen_discount / _r.aropen_amount;

      SELECT fetchArMemoNumber() INTO _arMemoNumber;
      _comment := 'Discount Credit from ' || _r.cashrcpt_fundstype || '-' || _r.cashrcpt_docnumber;

      -- Create misc credit memo record
      _ardiscountid := nextval('aropen_aropen_id_seq');
      INSERT INTO aropen (
        aropen_id, aropen_docdate, aropen_duedate, aropen_doctype,
        aropen_docnumber, aropen_curr_id, aropen_posted, aropen_amount)
      VALUES (
        _ardiscountid, _r.cashrcpt_distdate, _r.cashrcpt_distdate, 'C',
        _arMemoNumber, _r.cashrcpt_curr_id, false,_r.cashrcptitem_discount);

      IF (fetchMetricBool('CreditTaxDiscount')) THEN
        --  proportional tax credits calculated and implemented for the credit memo generated by the discount
        IF (_r.aropen_doctype  = 'I') THEN
          -- Tax for invoices
          SELECT aropen_cobmisc_id AS invcheadid,
                 invchead_curr_id,
                 invchead_invcdate INTO _t
          FROM aropen
            LEFT OUTER JOIN invchead ON (aropen_cobmisc_id = invchead_id)
            LEFT OUTER JOIN invcitem ON (invchead_id = invcitem_invchead_id)
          WHERE aropen_id = _r.aropen_id;

          FOR _v IN SELECT tax_sales_accnt_id,
                           tax_id,
                           round(sum(taxdetail_tax), 2) AS tax,
                           currToBase(_t.invchead_curr_id, round(sum(taxdetail_tax), 2), _t.invchead_invcdate) AS taxbasevalue
          FROM tax
            JOIN calculateTaxDetailSummary('I', _t.invcheadid, 'T') ON (taxdetail_tax_id=tax_id)
            GROUP BY tax_id, tax_sales_accnt_id
          LOOP
            INSERT INTO aropentax(
              taxhist_parent_id, taxhist_taxtype_id, taxhist_tax_id,
              taxhist_percent, taxhist_amount, taxhist_tax,
              taxhist_docdate, taxhist_basis)
            VALUES (
              _ardiscountid, getadjustmenttaxtypeid(), _v.tax_id,
              0.00, 0.00, (round((_v.tax * _discprcnt), 2) * -1),
              _r.cashrcpt_distdate, 0.00);
          END LOOP;

        ELSIF (_r.aropen_doctype  = 'D') THEN
          -- Tax for debit memos
          INSERT INTO aropentax(
            taxhist_parent_id, taxhist_taxtype_id, taxhist_tax_id,
            taxhist_percent, taxhist_amount, taxhist_tax,
            taxhist_docdate, taxhist_basis)
          SELECT
            _ardiscountid, taxhist_taxtype_id, taxhist_tax_id,
            0.00, 0.00, (round((taxhist_tax * _discprcnt), 2) * -1),
            _r.cashrcpt_distdate, 0.00
          FROM aropentax
          WHERE (taxhist_parent_id=_r.aropen_id);

        END IF;
      END IF; -- End taxes

      -- Create credit memo for discount
      SELECT createARCreditMemo(_ardiscountid, _r.cashrcpt_cust_id, _arMemoNumber, '',
                                _r.cashrcpt_distdate, _r.cashrcptitem_discount,
                                _comment, -1, -1, _discountAccntid, _r.cashrcpt_distdate,
                                -1, NULL, 0,
                                pJournalNumber, _r.cashrcpt_curr_id) INTO _ardiscountid;

      -- Apply discount credit memo
      INSERT INTO arcreditapply (
        arcreditapply_source_aropen_id, arcreditapply_target_aropen_id,
        arcreditapply_amount, arcreditapply_curr_id )
      VALUES (
        _ardiscountid, _r.aropen_id, _r.cashrcptitem_discount, _r.cashrcpt_curr_id );

      SELECT postARCreditMemoApplication(_ardiscountid, _r.cashrcpt_applydate) INTO _check;
      IF (_check < 0) THEN
        RAISE EXCEPTION 'Error posting discount credit memo application. Code %', _check;
      END IF;

   END IF; -- End handle Discount

   RETURN 1;

END;
$_$;


ALTER FUNCTION public.postcashreceiptdisc(integer, integer) OWNER TO admin;

--
-- TOC entry 1750 (class 1255 OID 146566799)
-- Dependencies: 4536 8
-- Name: postcccashreceipt(integer, integer, text, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postcccashreceipt(pccpay integer, pdocid integer, pdoctype text DEFAULT NULL::text, pamount numeric DEFAULT NULL::numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _aropenid     INTEGER;
  _bankaccnt_id INTEGER;
  _c            RECORD;
  _ccOrderDesc  TEXT;
  _journal      INTEGER;
  _realaccnt    INTEGER;
  _return       INTEGER := 0;

BEGIN
  SELECT * INTO _c
     FROM ccpay, ccard, custinfo
     WHERE ( (ccpay_id = pCCpay)
       AND   (ccpay_ccard_id = ccard_id)
       AND   (ccpay_cust_id = cust_id) );

  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Cannot find the Credit Card transaction information [xtuple: postCCcashReceipt, -11, %]',
                    pCCpay;
  END IF;

  IF (pamount IS NOT NULL) THEN
    _c.ccpay_amount = pamount;
  END IF;

  SELECT bankaccnt_id, bankaccnt_accnt_id INTO _bankaccnt_id, _realaccnt
  FROM ccbank JOIN bankaccnt ON (ccbank_bankaccnt_id=bankaccnt_id)
  WHERE (ccbank_ccard_type=_c.ccard_type);

  IF (_bankaccnt_id IS NULL) THEN
    RAISE EXCEPTION 'Cannot find the default Bank Account for this Credit Card [xtuple: postCCcredit, -1, %]',
                    _c.ccard_type;
  END IF;

  _ccOrderDesc := (_c.ccard_type || '-' || _c.ccpay_order_number::TEXT ||
		   '-' || _c.ccpay_order_number_seq::TEXT);

  _journal := fetchJournalNumber('C/R');

  IF (pdoctype = 'cashrcpt') THEN
    IF (COALESCE(pdocid, -1) < 0) THEN
      INSERT INTO cashrcpt (
        cashrcpt_cust_id,   cashrcpt_amount,     cashrcpt_curr_id,
        cashrcpt_fundstype, cashrcpt_docnumber,  cashrcpt_notes,
        cashrcpt_distdate,  cashrcpt_bankaccnt_id,
        cashrcpt_usecustdeposit
      ) VALUES (
        _c.ccpay_cust_id,   _c.ccpay_amount,     _c.ccpay_curr_id,
        _c.ccard_type,      _c.ccpay_r_ordernum, _ccOrderDesc,
        CURRENT_DATE,       _bankaccnt_id,
        fetchMetricBool('EnableCustomerDeposits'))
      RETURNING cashrcpt_id INTO _return;
    ELSE
      UPDATE cashrcpt
      SET cashrcpt_cust_id=_c.ccpay_cust_id,
          cashrcpt_amount=_c.ccpay_amount,
          cashrcpt_curr_id=_c.ccpay_curr_id,
          cashrcpt_fundstype=_c.ccard_type,
          cashrcpt_docnumber=_c.ccpay_r_ordernum,
          cashrcpt_notes=_ccOrderDesc,
          cashrcpt_distdate=CURRENT_DATE,
          cashrcpt_bankaccnt_id=_bankaccnt_id
      WHERE (cashrcpt_id=pdocid);
      _return := pdocid;
    END IF;

  ELSIF (pdoctype = 'cohead') THEN
    SELECT createARCreditMemo(NULL,               _c.ccpay_cust_id,
                             fetchArMemoNumber(), cohead_number,
                             CURRENT_DATE,        _c.ccpay_amount,
                             'Unapplied from ' || _ccOrderDesc,
                             NULL,                NULL, NULL,
                             CURRENT_DATE,        NULL,
                             cohead_salesrep_id,  NULL,
                             _journal,            _c.ccpay_curr_id,
                             NULL,                pCCpay) INTO _aropenid
      FROM cohead
     WHERE cohead_id = pdocid;
    IF (COALESCE(_aropenid, -1) < 0) THEN       -- coalesce handles not-found case
      RAISE EXCEPTION '[xtuple: createARCreditMemo, %]', _aropenid;
    END IF;

    INSERT INTO payaropen (payaropen_ccpay_id, payaropen_aropen_id,
                           payaropen_amount,   payaropen_curr_id)
                  VALUES  (pccpay,             _aropenid,
                           _c.ccpay_amount,    _c.ccpay_curr_id);
    INSERT INTO aropenalloc (aropenalloc_aropen_id, aropenalloc_doctype, aropenalloc_doc_id,
                             aropenalloc_amount,    aropenalloc_curr_id)
                     VALUES (_aropenid, 'S',          pdocid,
                             _c.ccpay_amount,    _c.ccpay_curr_id);
    _return := _aropenid;
  END IF;

  PERFORM insertGLTransaction(_journal, 'A/R', 'CR', _ccOrderDesc,
                              ('Cash Receipt from Credit Card ' || _c.cust_name),
                              findPrepaidAccount(_c.ccpay_cust_id),
                              _realaccnt,
                              NULL,
			      ROUND(currToBase(_c.ccpay_curr_id,
					       _c.ccpay_amount,
					       _c.ccpay_transaction_datetime::DATE),2),
                              CURRENT_DATE);

  RETURN _return;
END;
$$;


ALTER FUNCTION public.postcccashreceipt(pccpay integer, pdocid integer, pdoctype text, pamount numeric) OWNER TO admin;

--
-- TOC entry 1992 (class 1255 OID 146566801)
-- Dependencies: 4536 8
-- Name: postcccredit(integer, text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postcccredit(integer, text, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCCpay	ALIAS FOR $1;
  preftype      ALIAS FOR $2;
  prefid        ALIAS FOR $3;
  _c		RECORD;
  _ccOrderDesc	TEXT;
  _cglaccnt     INTEGER;
  _dglaccnt	INTEGER;
  _glseriesres  INTEGER;
  _notes	TEXT := 'Credit via Credit Card';
  _r		RECORD;
  _sequence	INTEGER;
  _dmaropenid	INTEGER;

BEGIN
  IF ((preftype = 'cohead') AND NOT EXISTS(SELECT cohead_id
					     FROM cohead
					     WHERE (cohead_id=prefid))) THEN
    RAISE EXCEPTION 'Cannot find original Sales Order for this Credit Card credit [xtuple: postCCcredit, -2, %, %, %]',
                    pCCpay, preftype, prefid;
  ELSIF ((preftype = 'aropen') AND NOT EXISTS(SELECT aropen_id
                                                FROM aropen
                                                WHERE (aropen_id=prefid))) THEN
    RAISE EXCEPTION 'Cannot find original A/R Open record for this Credit Card credit [xtuple: postCCcredit, -2, %, %, %]',
                    pCCpay, preftype, prefid;
  ELSIF ((preftype = 'cmhead') AND NOT EXISTS(SELECT cmhead_id
                                                FROM cmhead
                                               WHERE cmhead_id=prefid)) THEN
    RAISE EXCEPTION 'Cannot find original Credit Memo record for this Credit Card credit [xtuple: postCCcredit, -2, %, %, %]',
                    pCCpay, preftype, prefid;
  END IF;

  SELECT * INTO _c
     FROM ccpay
     JOIN ccard  ON (ccpay_ccard_id = ccard_id)
     JOIN ccbank ON (ccard_type=ccbank_ccard_type)
    WHERE (ccpay_id = pCCpay);

  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Cannot find the record for this Credit Card credit [xtuple: postCCcredit, -3, %, %, %]',
                    pCCpay, preftype, prefid;
  END IF;

  IF (preftype = 'cohead') THEN
    _dglaccnt := findPrepaidAccount(_c.ccpay_cust_id);
  ELSE
    _dglaccnt := findARAccount(_c.ccpay_cust_id);
  END IF;

  SELECT bankaccnt_accnt_id INTO _cglaccnt
  FROM bankaccnt
  WHERE (bankaccnt_id=_c.ccbank_bankaccnt_id);

  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Cannot find the default Bank Account for this Credit Card [xtuple: postCCcredit, -1, %]',
                    pCCpay;
  END IF;

  IF (_c.ccpay_type != 'R') THEN
    RAISE EXCEPTION 'This Credit Card transaction is not a credit/refund [xtuple: postCCcredit, -4, %]',
                    pCCpay;
  END IF;

  _sequence := fetchGLSequence();

  IF (_c.ccpay_r_ref IS NOT NULL) THEN
    _ccOrderDesc := (_c.ccard_type || '-' || _c.ccpay_r_ref);
  ELSE
    _ccOrderDesc := (_c.ccard_type || '-' || _c.ccpay_order_number::TEXT ||
		     '-' || COALESCE(_c.ccpay_order_number_seq::TEXT, ''));
  END IF;

  _glseriesres := insertIntoGLSeries(_sequence, 'A/R', 'CC', _ccOrderDesc,
                                     _dglaccnt,
                                     ROUND(currToBase(_c.ccpay_curr_id,
                                                      _c.ccpay_amount,
                                                      _c.ccpay_transaction_datetime::DATE), 2) * -1,
                                     CURRENT_DATE, _notes);
  IF (_glseriesres < 0) THEN
    RAISE EXCEPTION 'Could not write debit side of Credit Card credit to the G/L [xtuple: insertIntoGLSeries, %]',
                    _glseriesres;
  END IF;

  _glseriesres := insertIntoGLSeries(_sequence, 'A/R', 'CC', _ccOrderDesc,
                                     _cglaccnt,
                                     ROUND(currToBase(_c.ccpay_curr_id,
                                                      _c.ccpay_amount,
                                                      _c.ccpay_transaction_datetime::DATE),2),
                                     CURRENT_DATE, _notes);
  IF (_glseriesres < 0) THEN
    RAISE EXCEPTION 'Could not write credit side of Credit Card credit to the G/L [xtuple: insertIntoGLSeries, %]',
                    _glseriesres;
  END IF;

  _glseriesres := postGLSeries(_sequence, fetchJournalNumber('C/R') );
  IF (_glseriesres < 0) THEN
    RAISE EXCEPTION 'Could not post Credit Card credit to the G/L [xtuple: postglseries, %]',
                    _glseriesres;
  END IF;

  IF (preftype = 'aropen') THEN
    SELECT * INTO _r
    FROM aropen
    WHERE (aropen_id=prefid);

  ELSE
    SELECT aropen.* INTO _r
    FROM ccpay n
      JOIN ccpay o  ON (o.ccpay_id=n.ccpay_ccpay_id)
      JOIN payaropen ON (payaropen_ccpay_id=o.ccpay_id)
      JOIN aropen ON (payaropen_aropen_id=aropen_id)
    WHERE (n.ccpay_id=pCCpay);
  END IF;

  IF (FOUND) THEN
    SELECT createardebitmemo(
            NULL,
            _r.aropen_cust_id, NULL, fetchARMemoNumber(),
            _r.aropen_ordernumber, current_date, _c.ccpay_amount,
            _notes,
            -1, -1, -1, CURRENT_DATE, -1, NULL, 0,
            _r.aropen_curr_id) INTO _dmaropenid;

    IF (_r.aropen_open) THEN
      PERFORM applyARCreditMemoToBalance(_r.aropen_id, _dmaropenid);
      PERFORM postARCreditMemoApplication(_r.aropen_id);
    END IF;

  END IF;

  IF (preftype = 'cohead') THEN
    INSERT INTO payco (
      payco_ccpay_id, payco_cohead_id, payco_amount, payco_curr_id
    ) VALUES (
      pCCpay, prefid, 0 - _c.ccpay_amount, _c.ccpay_curr_id
    );
  END IF;

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.postcccredit(integer, text, integer) OWNER TO admin;

--
-- TOC entry 1993 (class 1255 OID 146566802)
-- Dependencies: 4536 8
-- Name: postccvoid(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postccvoid(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pccpayid ALIAS FOR $1;

BEGIN
  -- for now this is very simple: mark the ccpay record voided.
  -- in the future this might be expanded to back out changes to other tables
  -- but for now the VOID request is sent to the credit card processing company
  -- before those other tables are modified.

  UPDATE ccpay SET ccpay_status = 'V' WHERE (ccpay_id=pccpayid);

  IF (NOT FOUND) THEN
    RETURN -1;
  END IF;

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.postccvoid(integer) OWNER TO admin;

--
-- TOC entry 1994 (class 1255 OID 146566803)
-- Dependencies: 4536 8
-- Name: postcheck(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postcheck(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pcheckid		ALIAS FOR $1;
  _journalNumber	INTEGER := $2;
  _amount_base		NUMERIC := 0;
  _credit_glaccnt	INTEGER;
  _exchGain		NUMERIC := 0;
  _exchGainTmp		NUMERIC := 0;
  _gltransNote		TEXT;
  _p			RECORD;
  _r			RECORD;
  _t			RECORD;
  _sequence		INTEGER;
  _test                 INTEGER;
  _cm                   BOOLEAN;
  _amount_check         NUMERIC := 0;

BEGIN

  _cm := FALSE;

  SELECT fetchGLSequence() INTO _sequence;
  IF (_journalNumber IS NULL) THEN
    _journalNumber := fetchJournalNumber('AP-CK');
  END IF;

  SELECT checkhead.*,
         checkhead_amount / checkhead_curr_rate AS checkhead_amount_base,
         bankaccnt_accnt_id AS bankaccntid INTO _p
  FROM checkhead
   JOIN bankaccnt ON (checkhead_bankaccnt_id=bankaccnt_id)
  WHERE (checkhead_id=pcheckid);

  IF (FOUND) THEN
    IF (_p.checkhead_recip_type = 'V') THEN
      SELECT
        vend_number AS checkrecip_number,
        vend_name AS checkrecip_name,
        findAPAccount(vend_id) AS checkrecip_accnt_id,
        'A/P'::text AS checkrecip_gltrans_source
        INTO _t
      FROM vendinfo
      WHERE (vend_id=_p.checkhead_recip_id);
    ELSIF (_p.checkhead_recip_type = 'C') THEN
      SELECT
        cust_number AS checkrecip_number,
        cust_name AS checkrecip_name,
        findARAccount(cust_id) AS checkrecip_accnt_id,
        'A/R'::text AS checkrecip_gltrans_source
        INTO _t
      FROM custinfo
      WHERE (cust_id=_p.checkhead_recip_id);
    ELSIF (_p.checkhead_recip_type = 'T') THEN
      SELECT
        taxauth_code AS checkrecip_number,
        taxauth_name AS checkrecip_name,
        taxauth_accnt_id AS checkrecip_accnt_id,
        'G/L'::text AS checkrecip_gltrans_source
        INTO _t
      FROM taxauth
      WHERE (taxauth_id=_p.checkhead_recip_id);
    ELSE
      RETURN -11;
    END IF;
  ELSE
    RETURN -11;
  END IF;

  IF (_p.checkhead_posted) THEN
    RETURN -10;
  END IF;

  IF (_p.checkhead_recip_type = 'C') THEN
    SELECT checkitem_id FROM checkitem INTO _test
    WHERE (checkitem_checkhead_id=pcheckid)
    LIMIT 1;
    IF (FOUND) THEN
      _cm := TRUE;
    END IF;
  END IF;

  _gltransNote := _t.checkrecip_number || '-' || _t.checkrecip_name;

  IF (_p.checkhead_misc AND NOT _cm) THEN
    IF (COALESCE(_p.checkhead_expcat_id, -1) < 0) THEN
      IF (_p.checkhead_recip_type = 'V') THEN
	PERFORM createAPCreditMemo( _p.checkhead_recip_id, _journalNumber,
				    CAST(fetchAPMemoNumber() AS text), '',
				    _p.checkhead_checkdate, _p.checkhead_amount,
				    _gltransNote || ' ' || _p.checkhead_notes,
				    -1, _p.checkhead_checkdate,
				    -1, _p.checkhead_curr_id );
	_credit_glaccnt := findAPPrepaidAccount(_p.checkhead_recip_id);

      ELSIF (_p.checkhead_recip_type = 'C') THEN
	PERFORM createARDebitMemo(NULL, _p.checkhead_recip_id, NULL,
	  			     fetchARMemoNumber(), '',
				     _p.checkhead_checkdate, _p.checkhead_amount,
				     _gltransNote || ' ' || _p.checkhead_notes,
                                     -1, -1, -1, _p.checkhead_checkdate, -1, NULL, 0,
				     _p.checkhead_curr_id );
        _credit_glaccnt := findPrepaidAccount(_p.checkhead_recip_id);
      ELSIF (_p.checkhead_recip_type = 'T') THEN
	-- TODO: should we create a credit memo for the tax authority? how?
	_credit_glaccnt := _t.checkrecip_accnt_id;

      END IF; -- recip type

    ELSE
      IF (_cm) THEN
        _credit_glaccnt := findARAccount(_p.checkhead_recip_id);
      ELSE
        SELECT expcat_exp_accnt_id INTO _credit_glaccnt
        FROM expcat
        WHERE (expcat_id=_p.checkhead_expcat_id);
        IF (NOT FOUND) THEN
          RETURN -12;
        END IF;
      END IF;
    END IF;

    IF (COALESCE(_credit_glaccnt, -1) < 0) THEN
      RETURN -13;
    END IF;

    PERFORM insertIntoGLSeries( _sequence, _t.checkrecip_gltrans_source, 'CK',
				CAST(_p.checkhead_number AS TEXT),
				_credit_glaccnt,
				round(_p.checkhead_amount_base, 2) * -1,
				_p.checkhead_checkdate, _gltransNote, pcheckid );

    _amount_base := _p.checkhead_amount_base;

  ELSE
    FOR _r IN SELECT checkitem_amount, checkitem_discount,
                     CASE WHEN (checkitem_apopen_id IS NOT NULL AND apopen_doctype='C') THEN
                            checkitem_amount / apopen_curr_rate * -1.0
                          WHEN (checkitem_apopen_id IS NOT NULL) THEN
                            checkitem_amount / apopen_curr_rate
                          ELSE
                            currToBase(checkitem_curr_id,
                                       checkitem_amount,
                                       COALESCE(checkitem_docdate, _p.checkhead_checkdate))
                     END AS checkitem_amount_base,
                     currTocurr(checkitem_curr_id, _p.checkhead_curr_id,
                                CASE WHEN (checkitem_apopen_id IS NOT NULL AND apopen_doctype='C') THEN
                                          checkitem_amount * -1.0
                                     ELSE checkitem_amount END,
                                  _p.checkhead_checkdate) AS amount_check,
                     apopen_id, apopen_doctype, apopen_docnumber,
                     aropen_id, aropen_doctype, aropen_docnumber,
                     checkitem_curr_id, checkitem_curr_rate, apopen_curr_rate,
                     COALESCE(checkitem_docdate, _p.checkhead_checkdate) AS docdate
              FROM (checkitem LEFT OUTER JOIN
		    apopen ON (checkitem_apopen_id=apopen_id)) LEFT OUTER JOIN
		    aropen ON (checkitem_aropen_id=aropen_id)
              WHERE (checkitem_checkhead_id=pcheckid) LOOP

      _exchGainTmp := 0;
      IF (_r.apopen_id IS NOT NULL) THEN
	--  take the discount if specified before we do anything else
        IF(_r.checkitem_discount > 0.0) THEN
          PERFORM createAPDiscount(_r.apopen_id, _r.checkitem_discount);
        END IF;

        UPDATE apopen

        SET apopen_paid = round(apopen_paid + _r.checkitem_amount, 2),
            apopen_open = round(apopen_amount, 2) >
			  round(apopen_paid + _r.checkitem_amount, 2),
            apopen_closedate = CASE WHEN (round(apopen_amount, 2) <=
			                  round(apopen_paid + _r.checkitem_amount, 2)) THEN _p.checkhead_checkdate END
        WHERE (apopen_id=_r.apopen_id);

	--  Post the application
        INSERT INTO apapply
        ( apapply_vend_id, apapply_postdate, apapply_username,
          apapply_source_apopen_id, apapply_source_doctype, apapply_source_docnumber,
          apapply_target_apopen_id, apapply_target_doctype, apapply_target_docnumber,
          apapply_journalnumber, apapply_amount, apapply_curr_id, apapply_checkhead_id )
        VALUES
        ( _p.checkhead_recip_id, _p.checkhead_checkdate, getEffectiveXtUser(),
          -1, 'K', _p.checkhead_number,
          _r.apopen_id, _r.apopen_doctype, _r.apopen_docnumber,
          _journalNumber, _r.checkitem_amount, _r.checkitem_curr_id, _p.checkhead_id );
      END IF; -- if check item's apopen_id is not null

      IF (_r.aropen_id IS NOT NULL) THEN

        UPDATE aropen
        SET aropen_paid = round(aropen_paid + _r.checkitem_amount, 2),
            aropen_open = round(aropen_amount, 2) >
			  round(aropen_paid + _r.checkitem_amount, 2),
            aropen_closedate = CASE WHEN (round(aropen_amount, 2) <=
			                  round(aropen_paid + _r.checkitem_amount, 2)) THEN _p.checkhead_checkdate END
        WHERE (aropen_id=_r.aropen_id);

	--  Post the application
        INSERT INTO arapply
        ( arapply_cust_id, arapply_postdate, arapply_distdate, arapply_username,
          arapply_source_aropen_id, arapply_source_doctype, arapply_source_docnumber,
          arapply_target_aropen_id, arapply_target_doctype, arapply_target_docnumber,
          arapply_journalnumber, arapply_applied, arapply_curr_id )
        VALUES
        ( _p.checkhead_recip_id, _p.checkhead_checkdate, _p.checkhead_checkdate, getEffectiveXtUser(),
          _r.aropen_id,_r.aropen_doctype, _r.aropen_docnumber,
          -1, 'K',_p.checkhead_number ,
          _journalNumber, _r.checkitem_amount, _r.checkitem_curr_id );

      END IF; -- if check item's aropen_id is not null

      IF (_r.apopen_id IS NOT NULL) THEN
        SELECT apCurrGain(_r.apopen_id,_r.checkitem_curr_id, _r.checkitem_amount,
                        _p.checkhead_checkdate)
              INTO _exchGainTmp;
      ELSIF (_r.aropen_id IS NOT NULL) THEN
        SELECT arCurrGain(_r.aropen_id,_r.checkitem_curr_id, _r.checkitem_amount,
                        _p.checkhead_checkdate)
              INTO _exchGainTmp;
      END IF;
      _exchGain := _exchGain + _exchGainTmp;

      PERFORM insertIntoGLSeries( _sequence, _t.checkrecip_gltrans_source,
                                  'CK', CAST(_p.checkhead_number AS TEXT),
                                  _t.checkrecip_accnt_id,
                                  round(_r.checkitem_amount_base, 2) * -1.0,
                                  _p.checkhead_checkdate, _gltransNote, pcheckid );
      IF (_exchGainTmp <> 0) THEN
	PERFORM insertIntoGLSeries( _sequence, _t.checkrecip_gltrans_source,
                                   'CK', CAST(_p.checkhead_number AS TEXT),
                                   getGainLossAccntId(_t.checkrecip_accnt_id),
                                   round(_exchGainTmp,2),
                                   _p.checkhead_checkdate, _gltransNote, pcheckid );
      END IF;

      _amount_check := (_amount_check + _r.amount_check);
      _amount_base := (_amount_base + _r.checkitem_amount_base);

    END LOOP;

    IF( (_amount_check - _p.checkhead_amount) <> 0.0 ) THEN
      _exchGainTmp := currToBase(_p.checkhead_curr_id,
                                 _amount_check - _p.checkhead_amount,
                                 _p.checkhead_checkdate);
      _exchGain := _exchGain + _exchGainTmp;
    END IF;
    --  ensure that the check balances, attribute rounding errors to gain/loss
    IF round(_amount_base, 2) - round(_exchGain, 2) <> round(_p.checkhead_amount_base, 2) THEN
      IF round(_amount_base - _exchGain, 2) = round(_p.checkhead_amount_base, 2) THEN
	PERFORM insertIntoGLSeries( _sequence, _t.checkrecip_gltrans_source,
				    'CK',
				    CAST(_p.checkhead_number AS TEXT),
                                    getGainLossAccntId(_p.bankaccntid),
				    round(_amount_base, 2) -
				      round(_exchGain, 2) -
				      round(_p.checkhead_amount_base, 2),
				    _p.checkhead_checkdate, _gltransNote, pcheckid );
      ELSE
	RAISE EXCEPTION 'checkhead_id % does not balance (% - % <> %)', pcheckid,
	      _amount_base, _exchGain, _p.checkhead_amount_base;
      END IF;
    END IF;
  END IF;

  PERFORM insertIntoGLSeries( _sequence, _t.checkrecip_gltrans_source, 'CK',
			      CAST(_p.checkhead_number AS TEXT),
                              _p.bankaccntid,
			      round(_p.checkhead_amount_base, 2),
                              _p.checkhead_checkdate, _gltransNote, pcheckid );

  PERFORM postGLSeries(_sequence, _journalNumber);

  UPDATE checkhead
  SET checkhead_posted=TRUE,
      checkhead_journalnumber=_journalNumber
  WHERE (checkhead_id=pcheckid);

  RETURN _journalNumber;

END;
$_$;


ALTER FUNCTION public.postcheck(integer, integer) OWNER TO admin;

--
-- TOC entry 1995 (class 1255 OID 146566805)
-- Dependencies: 4536 8
-- Name: postchecks(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postchecks(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pBankaccntid ALIAS FOR $1;
  _journalNumber INTEGER;

BEGIN

  SELECT fetchJournalNumber('AP-CK') INTO _journalNumber;

  PERFORM postCheck(checkhead_id, _journalNumber)
  FROM checkhead
  WHERE ( (NOT checkhead_void)
    AND   (NOT checkhead_posted)
    AND   (checkhead_printed)
    AND   (checkhead_bankaccnt_id=pBankaccntid) );

  RETURN _journalNumber;

END;
$_$;


ALTER FUNCTION public.postchecks(integer) OWNER TO admin;

--
-- TOC entry 1996 (class 1255 OID 146566806)
-- Dependencies: 4536 8
-- Name: postcomment(integer, text, integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postcomment(pcmnttypeid integer, psource text, psourceid integer, ptext text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE

BEGIN
  RETURN postComment(pCmnttypeid, pSource, pSourceid, pText, NULL);
END
$$;


ALTER FUNCTION public.postcomment(pcmnttypeid integer, psource text, psourceid integer, ptext text) OWNER TO admin;

--
-- TOC entry 1998 (class 1255 OID 146566808)
-- Dependencies: 4536 8
-- Name: postcomment(text, text, integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postcomment(pcmnttypename text, psource text, psourceid integer, ptext text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _cmnttypeid INTEGER;

BEGIN
  SELECT cmnttype_id INTO _cmnttypeid
  FROM cmnttype
  WHERE (cmnttype_name=pCmnttypename);
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Comment type % not found.', pCmnttypename;
  END IF;

  RETURN postComment(_cmnttypeid, pSource, pSourceid, pText, NULL);
END
$$;


ALTER FUNCTION public.postcomment(pcmnttypename text, psource text, psourceid integer, ptext text) OWNER TO admin;

--
-- TOC entry 1997 (class 1255 OID 146566807)
-- Dependencies: 4536 8
-- Name: postcomment(integer, text, integer, text, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postcomment(pcmnttypeid integer, psource text, psourceid integer, ptext text, ppublic boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _commentid INTEGER;
  _public BOOLEAN;

BEGIN
  _public := COALESCE(pPublic, fetchmetricbool('CommentPublicDefault'));

  INSERT INTO comment
  ( comment_cmnttype_id, comment_source, comment_source_id,
    comment_date, comment_user, comment_text, comment_public )
  VALUES
  ( pCmnttypeid, pSource, pSourceid,
    CURRENT_TIMESTAMP, getEffectiveXtUser(), pText, _public )
  RETURNING comment_id INTO _commentid;

  RETURN _commentid;

END;
$$;


ALTER FUNCTION public.postcomment(pcmnttypeid integer, psource text, psourceid integer, ptext text, ppublic boolean) OWNER TO admin;

--
-- TOC entry 1999 (class 1255 OID 146566809)
-- Dependencies: 4536 8
-- Name: postcost(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postcost(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemcostid ALIAS FOR $1;
  _p RECORD;

BEGIN

  SELECT round(currToBase(itemcost_curr_id, itemcost_actcost, CURRENT_DATE),6) AS newcost,
         itemcost_curr_id, CURRENT_DATE AS effective,
         item_number,
         itemcost_stdcost AS oldcost INTO _p
  FROM itemcost, item
  WHERE ((itemcost_item_id=item_id)
    AND  (itemcost_id=pItemcostid));

  IF (_p.newcost IS NULL) THEN
      RAISE EXCEPTION 'There is no valid Exchange Rate for this currency. (%, %)',
                  _p.itemcost_curr_id, _p.effective;
      RETURN FALSE;
  END IF;

  RETURN updateStdCost(pItemcostid, _p.newcost, _p.oldcost, 'Post Cost',
               ('Post Actual Cost to Standard for item ' || _p.item_number));

END;
$_$;


ALTER FUNCTION public.postcost(integer) OWNER TO admin;

--
-- TOC entry 2001 (class 1255 OID 146566810)
-- Dependencies: 4536 8
-- Name: postcountslip(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postcountslip(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCntslipid ALIAS FOR $1;
  _p RECORD;
  _comments TEXT;
  _temp TEXT;

BEGIN

  SELECT itemsite_loccntrl, itemsite_controlmethod,
         cntslip_posted, cntslip_lotserial, cntslip_comments,
         cntslip_number, cntslip_qty INTO _p
  FROM cntslip, invcnt, itemsite
  WHERE ( (cntslip_cnttag_id=invcnt_id)
   AND (invcnt_itemsite_id=itemsite_id)
   AND (cntslip_id=pCntslipid) );

  IF (NOT _p.cntslip_posted) THEN
    SELECT ( E'\nCount Slip #' || _p.cntslip_number ||
             ' counted ' || formatQty(_p.cntslip_qty) ) INTO _comments;

--  Add the Location name if the itemsite is MLC
    IF (_p.itemsite_loccntrl) THEN
      SELECT ( ', Location:' || location_name ) INTO _temp
      FROM location, cntslip
      WHERE ( (cntslip_location_id=location_id)
       AND (cntslip_id=pCntslipid) );

      _comments := (_comments || _temp);
    END IF;

--  Add the Lot/Serial if the itemsite is Lot or Serial controlled
    IF (_p.itemsite_controlmethod = 'L') THEN
      _comments := (_comments || ( ', Lot #:' || _p.cntslip_lotserial));
    ELSIF (_p.itemsite_controlmethod = 'S') THEN
      _comments := (_comments || ( ', Serial #:' || _p.cntslip_lotserial));
    END IF;

    _comments := (_comments || ' ' || _p.cntslip_comments);

    UPDATE cntslip
    SET cntslip_posted=TRUE
    WHERE (cntslip_id=pCntslipid);

    UPDATE invcnt
    SET invcnt_qoh_after = ( COALESCE(invcnt_qoh_after, 0) + cntslip_qty),
        invcnt_comments = (invcnt_comments || _comments)
    FROM cntslip
    WHERE ( (cntslip_cnttag_id=invcnt_id)
     AND (cntslip_id=pCntslipid) );

    RETURN 1;

  ELSE
    RETURN -1;
  END IF;

END;
$_$;


ALTER FUNCTION public.postcountslip(integer) OWNER TO admin;

--
-- TOC entry 2002 (class 1255 OID 146566811)
-- Dependencies: 4536 8
-- Name: postcounttag(integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postcounttag(integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pInvcntid ALIAS FOR $1;
  pThaw ALIAS FOR $2;
  _avgCostingMethod TEXT;
  _invhistid INTEGER;
  _postDate TIMESTAMP;
  _runningQty NUMERIC;
  _errorCode INTEGER;
  _itemlocSeries INTEGER := 0;
  _hasDetail BOOLEAN;
  _p RECORD;
  _itemloc RECORD;
  _cntslip RECORD;
  _lsid INTEGER;

BEGIN

  SELECT COALESCE(fetchMetricText('CountAvgCostMethod'), 'STD') INTO _avgCostingMethod;

  SELECT invcnt_id, invcnt_tagnumber, invcnt_qoh_after,
         invcnt_location_id,
         item_number,
         itemsite_id, itemsite_freeze,
         itemsite_qtyonhand,
         itemsite_loccntrl, itemsite_location_id,
         CASE WHEN (itemsite_costmethod = 'N') THEN 0
              WHEN ( (itemsite_costmethod = 'A') AND
                     (itemsite_qtyonhand = 0) AND
                     (_avgCostingMethod = 'ACT') ) THEN actcost(itemsite_item_id)
              WHEN ( (itemsite_costmethod = 'A') AND
                     (_avgCostingMethod IN ('ACT', 'AVG')) ) THEN avgcost(itemsite_id)
              ELSE stdcost(itemsite_item_id)
         END AS cost, itemsite_costmethod,
         itemsite_controlmethod,
         itemsite_value INTO _p
  FROM invcnt, itemsite, item
  WHERE ( (invcnt_itemsite_id=itemsite_id)
   AND (itemsite_item_id=item_id)
   AND (invcnt_qoh_after IS NOT NULL)
   AND (NOT invcnt_posted)
   AND (invcnt_id=pInvcntid) );
  IF (FOUND) THEN
-- If the invcnt_location_id is not null then
-- call a separate function so as not to affect
-- the existing functionality.
    IF (_p.invcnt_location_id IS NOT NULL) THEN
      RETURN postCountTagLocation(pInvcntid, pThaw);
    END IF;

    SELECT NEXTVAL('invhist_invhist_id_seq') INTO _invhistid;

    IF (_p.itemsite_freeze) THEN
      SELECT invcnt_tagdate INTO _postDate
      FROM invcnt
      WHERE (invcnt_id=pInvcntid) ;
    ELSE
      _postDate = CURRENT_TIMESTAMP;
    END IF;

    _hasDetail = FALSE;

--  Post the detail indicated by cntslips
    IF ( (_p.itemsite_loccntrl) OR
         (_p.itemsite_controlmethod IN ('L', 'S')) ) THEN

      SELECT NEXTVAL('itemloc_series_seq') INTO _itemlocSeries;

--  Adjust any existing detail to 0
      FOR _itemloc IN SELECT itemloc_id, itemloc_location_id,
                             itemloc_ls_id, itemloc_qty
                      FROM itemloc
                      WHERE (itemloc_itemsite_id=_p.itemsite_id) LOOP

        _hasDetail = TRUE;

--  Create the itemlocdist flushing records
        INSERT INTO itemlocdist
        ( itemlocdist_series, itemlocdist_source_type, itemlocdist_source_id,
          itemlocdist_expiration,
          itemlocdist_itemsite_id, itemlocdist_invhist_id, itemlocdist_flush )
        VALUES
        ( _itemlocSeries, 'I', _itemloc.itemloc_id,
          endOfTime(),
          _p.itemsite_id, _invhistid, TRUE );

      END LOOP;

--  Clear the running detail Qty
      _runningQty := 0;

--  Adjust the detail to the cntslip indicated value
      FOR _cntslip IN SELECT cntslip_location_id, cntslip_lotserial,
                             cntslip_lotserial_expiration,
                             cntslip_lotserial_warrpurc,
                             SUM(cntslip_qty) AS qty,
                             itemsite_item_id
                      FROM cntslip, invcnt, itemsite
                      WHERE ((cntslip_cnttag_id=pInvcntid)
                      AND (cntslip_cnttag_id=invcnt_id)
                      AND (invcnt_itemsite_id=itemsite_id))
                      GROUP BY cntslip_location_id, cntslip_lotserial,
                      cntslip_lotserial_expiration, cntslip_lotserial_warrpurc,itemsite_item_id LOOP

--  Handle the LotSerial
        IF (LENGTH(_cntslip.cntslip_lotserial)>0) THEN
          SELECT ls_id INTO _lsid
          FROM ls
          WHERE ((ls_item_id=_cntslip.itemsite_item_id)
          AND (UPPER(ls_number)=UPPER(_cntslip.cntslip_lotserial)));

          IF (NOT FOUND) THEN
            _lsid := NEXTVAL('ls_ls_id_seq');
            INSERT INTO ls
            VALUES (_lsid,_cntslip.itemsite_item_id,UPPER(_cntslip.cntslip_lotserial));
          END IF;
        END IF;

--  Track the running Qty
        _runningQty := (_runningQty + _cntslip.qty);
        _hasDetail = TRUE;

--  Create the itemlocdist populating record
        INSERT INTO itemlocdist
        ( itemlocdist_series, itemlocdist_source_type, itemlocdist_source_id,
          itemlocdist_itemsite_id,
          itemlocdist_ls_id, itemlocdist_expiration, itemlocdist_warranty,
          itemlocdist_qty, itemlocdist_invhist_id )
        VALUES
        ( _itemlocSeries, 'L', _cntslip.cntslip_location_id,
          _p.itemsite_id,
          _lsid, COALESCE(_cntslip.cntslip_lotserial_expiration, endOfTime()),
          _cntslip.cntslip_lotserial_warrpurc,_cntslip.qty, _invhistid );

      END LOOP;

      IF (_runningQty > _p.invcnt_qoh_after) THEN
--  The total Count Slip Qty is greater than the Count Tag Qty,
--  Don't post the Count.
        _errorCode = -1;

      ELSIF ( (_runningQty < _p.invcnt_qoh_after) AND
              (_p.itemsite_controlmethod IN ('L', 'S')) ) THEN
--  The total Count Slip Qty is less than the Count Tag Qty,
--  and the Item Site is Lot/Serial controlled.
--  Don't post the Count.
        _errorCode = -2;

      ELSIF (_runningQty < _p.invcnt_qoh_after) THEN
        IF ( (NOT _p.itemsite_loccntrl) OR
             (_p.itemsite_location_id = -1) ) THEN
--  The total Count Slip Qty is less than the Count Tag Qty,
--  and there isn't a default location to post into.
--  Don't post the Count.
          _errorCode = -3;

        ELSIF ( SELECT (metric_value='f')
                FROM metric
                WHERE (metric_name='PostCountTagToDefault') ) THEN
--  The total Count Slip Qty is less than the Count Tag Qty,
--  and we don't post Count Tags to default Locations
--  Don't post the Count.
          _errorCode = -4;

        ELSE
--  Distribute the remaining qty into the default location.
          INSERT INTO itemlocdist
          ( itemlocdist_series, itemlocdist_source_type, itemlocdist_source_id,
            itemlocdist_itemsite_id,
            itemlocdist_expiration,
            itemlocdist_qty, itemlocdist_invhist_id )
          SELECT _itemlocSeries, 'L', _p.itemsite_location_id,
                 _p.itemsite_id,
                 endOfTime(),
                 (_p.invcnt_qoh_after - _runningQty), _invhistid;

          _hasDetail = TRUE;
          _errorCode = 0;
        END IF;
      ELSE
--  The Count Slip Qty. must equal the Count Tag Qty.
        _errorCode = 0;
      END IF;

--  If we shouldn't post the count then delete the itemlocdist records,
--  and return with the error.
      IF (_errorCode <> 0) THEN
        DELETE FROM itemlocdist
        WHERE (itemlocdist_series=_itemlocSeries);

        RETURN _errorCode;
      END IF;

    END IF;

--  Mod. the Count Tag.
    UPDATE invcnt
    SET invcnt_qoh_before=_p.itemsite_qtyonhand,
        invcnt_postdate=_postDate,
        invcnt_posted=TRUE,
        invcnt_invhist_id=_invhistid,
        invcnt_post_username=getEffectiveXtUser()
    WHERE (invcnt_id=pInvcntid);

--  Create the CC transaction
    INSERT INTO invhist
     ( invhist_id, invhist_itemsite_id,
       invhist_transdate, invhist_transtype, invhist_invqty,
       invhist_qoh_before, invhist_qoh_after,
       invhist_docnumber, invhist_comments,
       invhist_invuom, invhist_unitcost, invhist_hasdetail,
       invhist_costmethod, invhist_value_before, invhist_value_after,
       invhist_series )
    SELECT _invhistid, itemsite_id,
           _postDate, 'CC', (invcnt_qoh_after - invcnt_qoh_before),
           invcnt_qoh_before, invcnt_qoh_after,
           invcnt_tagnumber, invcnt_comments,
           uom_name, _p.cost, _hasDetail,
           _p.itemsite_costmethod, _p.itemsite_value,
           _p.itemsite_value + (_p.cost * (invcnt_qoh_after - invcnt_qoh_before)),
           _itemlocSeries
    FROM itemsite, invcnt, item, uom
    WHERE ( (invcnt_itemsite_id=itemsite_id)
     AND (itemsite_item_id=item_id)
     AND (item_inv_uom_id=uom_id)
     AND (itemsite_controlmethod <> 'N')
     AND (invcnt_id=pInvcntid) );

    IF ( SELECT metric_value
        FROM metric
        WHERE ((metric_name = 'EnableAsOfQOH')
        AND (metric_value = 't'))) THEN
      IF (NOT postIntoInvBalance(_invhistid)) THEN
        RAISE EXCEPTION 'Post into Inventory Balance for invhist_id=% was unsuccessful',_invhistid;
      END IF;
    END IF;

--  Update the QOH
--  Avoid negative value when average cost item
    UPDATE itemsite
    SET itemsite_qtyonhand=_p.invcnt_qoh_after,
        itemsite_nnqoh = 0,
        itemsite_value = CASE WHEN ((itemsite_costmethod='A') AND (_p.itemsite_value + (_p.cost * (_p.invcnt_qoh_after - itemsite_qtyonhand))) < 0.0) THEN 0.0
                              ELSE (_p.itemsite_value + (_p.cost * (_p.invcnt_qoh_after - itemsite_qtyonhand)))
                         END,
        itemsite_datelastcount=_postDate
    WHERE (itemsite_id=_p.itemsite_id);

--  Post the detail, if any
    IF (_hasDetail) THEN
      PERFORM distributeItemlocSeries(_itemlocSeries);
    END IF;

--  Thaw the itemsite if it's frozen
    IF (pThaw) THEN
      PERFORM thawItemSite(invcnt_itemsite_id)
      FROM invcnt
      WHERE (invcnt_id=pInvcntid);
    END IF;

--  Distribute to G/L
    PERFORM insertGLTransaction( 'I/M', 'CT', _p.invcnt_tagnumber, ('Post Count Tag #' || _p.invcnt_tagnumber || ' for Item ' || _p.item_number),
                                 costcat_adjustment_accnt_id, costcat_asset_accnt_id, _invhistid,
                                 ( (_p.invcnt_qoh_after - _p.itemsite_qtyonhand) * _p.cost), _postDate::DATE )
    FROM invcnt, itemsite, costcat
    WHERE ( (invcnt_itemsite_id=itemsite_id)
     AND (itemsite_costcat_id=costcat_id)
     AND (invcnt_id=pInvcntid) );

    RETURN 0;

  ELSE
    RETURN -9;
  END IF;

END;
$_$;


ALTER FUNCTION public.postcounttag(integer, boolean) OWNER TO admin;

--
-- TOC entry 2003 (class 1255 OID 146566813)
-- Dependencies: 4536 8
-- Name: postcounttaglocation(integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postcounttaglocation(integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pInvcntid ALIAS FOR $1;
  pThaw ALIAS FOR $2;
  _avgCostingMethod TEXT;
  _invhistid INTEGER;
  _postDate TIMESTAMP;
  _runningQty NUMERIC;
  _errorCode INTEGER;
  _itemlocSeries INTEGER := 0;
  _hasDetail BOOLEAN;
  _p RECORD;
  _itemloc RECORD;
  _cntslip RECORD;
  _origLocQty NUMERIC;
  _netable BOOLEAN;
  _lsid INTEGER;
BEGIN

  SELECT COALESCE(fetchMetricText('CountAvgCostMethod'), 'STD') INTO _avgCostingMethod;

  SELECT invcnt_id, invcnt_tagnumber, invcnt_qoh_after,
         invcnt_location_id, invcnt_tagdate,
         item_number,
         itemsite_id, itemsite_freeze,
         itemsite_qtyonhand,
         itemsite_loccntrl, COALESCE(invcnt_location_id, -1) AS itemsite_location_id,
         CASE WHEN (itemsite_costmethod = 'N') THEN 0
              WHEN ( (itemsite_costmethod = 'A') AND
                     (itemsite_qtyonhand = 0) AND
                     (_avgCostingMethod = 'ACT') ) THEN actcost(itemsite_item_id)
              WHEN ( (itemsite_costmethod = 'A') AND
                     (_avgCostingMethod IN ('ACT', 'AVG')) ) THEN avgcost(itemsite_id)
              ELSE stdcost(itemsite_item_id)
         END AS cost, itemsite_costmethod,
         itemsite_controlmethod, itemsite_value INTO _p
  FROM invcnt, itemsite, item
  WHERE ( (invcnt_itemsite_id=itemsite_id)
   AND (itemsite_item_id=item_id)
   AND (invcnt_qoh_after IS NOT NULL)
   AND (NOT invcnt_posted)
   AND (invcnt_id=pInvcntid) );
  IF (NOT FOUND) THEN
    RETURN -9;
  END IF;

  SELECT COALESCE(SUM(itemloc_qty),0.0), location_netable INTO _origLocQty,_netable
    FROM itemloc,location
   WHERE ((itemloc_itemsite_id=_p.itemsite_id)
     AND  (location_id=itemloc_location_id)
     AND  (itemloc_location_id=_p.invcnt_location_id))
   GROUP BY location_netable;
  IF (NOT FOUND) THEN
    _origLocQty := 0.0;
    _netable := TRUE;
  END IF;

  SELECT NEXTVAL('invhist_invhist_id_seq') INTO _invhistid;

  IF (_p.itemsite_freeze) THEN
    _postDate := _p.invcnt_tagdate;
  ELSE
    _postDate := CURRENT_TIMESTAMP;
  END IF;

  _hasDetail = FALSE;

--  Post the detail indicated by cntslips
  IF ( (_p.itemsite_loccntrl) OR
       (_p.itemsite_controlmethod IN ('L', 'S')) ) THEN

    SELECT NEXTVAL('itemloc_series_seq') INTO _itemlocSeries;

--  Adjust any existing detail to 0
    FOR _itemloc IN SELECT itemloc_id, itemloc_location_id,
                           itemloc_ls_id, itemloc_qty
                    FROM itemloc
                    WHERE ((itemloc_itemsite_id=_p.itemsite_id)
                      AND  (itemloc_location_id=_p.invcnt_location_id)) LOOP

      _hasDetail = TRUE;

--  Create the itemlocdist flushing records
      INSERT INTO itemlocdist
      ( itemlocdist_series, itemlocdist_source_type, itemlocdist_source_id,
        itemlocdist_expiration,
        itemlocdist_itemsite_id, itemlocdist_invhist_id, itemlocdist_flush )
      VALUES
      ( _itemlocSeries, 'I', _itemloc.itemloc_id,
        endOfTime(),
        _p.itemsite_id, _invhistid, TRUE );

    END LOOP;

--  Clear the running detail Qty
    _runningQty := 0;

--  Adjust the detail to the cntslip indicated value
    FOR _cntslip IN SELECT cntslip_location_id, cntslip_lotserial,
                           cntslip_lotserial_expiration,
                           cntslip_lotserial_warrpurc,
                           SUM(cntslip_qty) AS qty,
                           itemsite_item_id
                    FROM cntslip,invcnt,itemsite
                    WHERE ((cntslip_cnttag_id=pInvcntid)
                    AND (cntslip_cnttag_id=invcnt_id)
                    AND (invcnt_itemsite_id=itemsite_id))
                    GROUP BY cntslip_location_id, cntslip_lotserial, cntslip_lotserial_expiration,
                    cntslip_lotserial_warrpurc, itemsite_item_id LOOP

--  Handle the LotSerial
      IF (LENGTH(_cntslip.cntslip_lotserial)>0) THEN
        SELECT ls_id INTO _lsid
        FROM ls
        WHERE ((ls_item_id=_cntslip.itemsite_item_id)
        AND (UPPER(ls_number)=UPPER(_cntslip.cntslip_lotserial)));

        IF (NOT FOUND) THEN
          _lsid := NEXTVAL('ls_ls_id_seq');
          INSERT INTO ls
          VALUES (_lsid,_cntslip.itemsite_item_id,UPPER(_cntslip.cntslip_lotserial));
        END IF;
      END IF;

--  Track the running Qty
      _runningQty := (_runningQty + _cntslip.qty);
      _hasDetail = TRUE;

--  Create the itemlocdist populating record
      INSERT INTO itemlocdist
      ( itemlocdist_series, itemlocdist_source_type, itemlocdist_source_id,
        itemlocdist_itemsite_id,
        itemlocdist_ls_id, itemlocdist_expiration, itemlocdist_warranty,
        itemlocdist_qty, itemlocdist_invhist_id )
      VALUES
      ( _itemlocSeries, 'L', _cntslip.cntslip_location_id,
        _p.itemsite_id,
        _lsid, COALESCE(_cntslip.cntslip_lotserial_expiration, endOfTime()),
        _cntslip.cntslip_lotserial_warrpurc,
        _cntslip.qty, _invhistid );

    END LOOP;

    IF (_runningQty > _p.invcnt_qoh_after) THEN
--  The total Count Slip Qty is greater than the Count Tag Qty,
--  Don't post the Count.
      _errorCode = -1;

    ELSIF ( (_runningQty < _p.invcnt_qoh_after) AND
            (_p.itemsite_controlmethod IN ('L', 'S')) ) THEN
--  The total Count Slip Qty is less than the Count Tag Qty,
--  and the Item Site is Lot/Serial controlled.
--  Don't post the Count.
      _errorCode = -2;

    ELSIF (_runningQty < _p.invcnt_qoh_after) THEN
      IF ( (NOT _p.itemsite_loccntrl) OR
           (_p.itemsite_location_id = -1) ) THEN
--  The total Count Slip Qty is less than the Count Tag Qty,
--  and there isn't a default location to post into.
--  Don't post the Count.
        _errorCode = -3;

      ELSIF ( SELECT (metric_value='f')
              FROM metric
              WHERE (metric_name='PostCountTagToDefault') ) THEN
--  The total Count Slip Qty is less than the Count Tag Qty,
--  and we don't post Count Tags to default Locations
--  Don't post the Count.
        _errorCode = -4;

      ELSE
--  Distribute the remaining qty into the default location.
        INSERT INTO itemlocdist
        ( itemlocdist_series, itemlocdist_source_type, itemlocdist_source_id,
          itemlocdist_itemsite_id,
          itemlocdist_ls_id, itemlocdist_expiration,
          itemlocdist_qty, itemlocdist_invhist_id )
        SELECT _itemlocSeries, 'L', _p.itemsite_location_id,
               _p.itemsite_id,
               _lsid, endOfTime(),
               (_p.invcnt_qoh_after - _runningQty), _invhistid;

        _hasDetail = TRUE;
        _errorCode = 0;
      END IF;
    ELSE
--  The Count Slip Qty. must equal the Count Tag Qty.
      _errorCode = 0;
    END IF;

--  If we shouldn't post the count then delete the itemlocdist records,
--  and return with the error.
    IF (_errorCode <> 0) THEN
      DELETE FROM itemlocdist
      WHERE (itemlocdist_series=_itemlocSeries);

      RETURN _errorCode;
    END IF;

  END IF;

--  Mod. the Count Tag.
  UPDATE invcnt
  SET invcnt_qoh_before=_origLocQty,
      invcnt_postdate=_postDate,
      invcnt_posted=TRUE,
      invcnt_invhist_id=_invhistid,
      invcnt_post_username=getEffectiveXtUser()
  WHERE (invcnt_id=pInvcntid);

--  Create the CC transaction
  INSERT INTO invhist
   ( invhist_id, invhist_itemsite_id,
     invhist_transdate, invhist_transtype, invhist_invqty,
     invhist_qoh_before, invhist_qoh_after,
     invhist_docnumber, invhist_comments,
     invhist_invuom, invhist_unitcost, invhist_hasdetail,
     invhist_costmethod, invhist_value_before, invhist_value_after,
     invhist_series )
  SELECT _invhistid, itemsite_id,
         _postDate, 'CC', (invcnt_qoh_after - invcnt_qoh_before),
         invcnt_qoh_before, invcnt_qoh_after,
         invcnt_tagnumber, invcnt_comments,
         uom_name, _p.cost, _hasDetail,
         _p.itemsite_costmethod, _p.itemsite_value,
         _p.itemsite_value + (_p.cost * (invcnt_qoh_after - invcnt_qoh_before)),
         _itemlocSeries
  FROM itemsite, invcnt, item, uom
  WHERE ( (invcnt_itemsite_id=itemsite_id)
   AND (itemsite_item_id=item_id)
   AND (item_inv_uom_id=uom_id)
   AND (itemsite_controlmethod <> 'N')
   AND (invcnt_id=pInvcntid) );

--  Update the QOH
  IF (_netable) THEN
    UPDATE itemsite
    SET itemsite_qtyonhand= itemsite_qtyonhand + (_p.invcnt_qoh_after - _origLocQty),
        itemsite_datelastcount=_postDate
    WHERE (itemsite_id=_p.itemsite_id);
  ELSE
    UPDATE itemsite
    SET itemsite_nnqoh =  itemsite_nnqoh - _origLocQty,
	itemsite_qtyonhand = itemsite_qtyonhand + _p.invcnt_qoh_after,
        itemsite_datelastcount=_postDate
    WHERE (itemsite_id=_p.itemsite_id);
  END IF;

--  Post the detail, if any
  IF (_hasDetail) THEN
    PERFORM distributeItemlocSeries(_itemlocSeries);
  END IF;

--  Thaw the itemsite if it's frozen
  IF (pThaw) THEN
    PERFORM thawItemSite(invcnt_itemsite_id)
    FROM invcnt
    WHERE (invcnt_id=pInvcntid);
  END IF;

--  Distribute to G/L
  PERFORM insertGLTransaction( 'I/M', 'CT', _p.invcnt_tagnumber, ('Post Count Tag #' || _p.invcnt_tagnumber || ' for Item ' || _p.item_number),
                               costcat_adjustment_accnt_id, costcat_asset_accnt_id, _invhistid,
                               ( (_p.invcnt_qoh_after - _origLocQty) * _p.cost), CURRENT_DATE )
  FROM invcnt, itemsite, costcat
  WHERE ( (invcnt_itemsite_id=itemsite_id)
   AND (itemsite_costcat_id=costcat_id)
   AND (invcnt_id=pInvcntid) );

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.postcounttaglocation(integer, boolean) OWNER TO admin;

--
-- TOC entry 2004 (class 1255 OID 146566815)
-- Dependencies: 4536 8
-- Name: postcounttaglocation(integer, boolean, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postcounttaglocation(integer, boolean, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
  pInvcntid ALIAS FOR $1;
  pThaw ALIAS FOR $2;
  pAvgCostingMethod ALIAS FOR $3;
  _invhistid INTEGER;
  _postDate TIMESTAMP;
  _runningQty NUMERIC;
  _errorCode INTEGER;
  _itemlocSeries INTEGER := 0;
  _hasDetail BOOLEAN;
  _p RECORD;
  _itemloc RECORD;
  _cntslip RECORD;
  _origLocQty NUMERIC;
  _netable BOOLEAN;
  _lsid INTEGER;
BEGIN

  SELECT invcnt_id, invcnt_tagnumber, invcnt_qoh_after,
         invcnt_location_id, invcnt_tagdate,
         item_number,
         itemsite_id, itemsite_freeze,
         itemsite_qtyonhand,
         itemsite_loccntrl, COALESCE(invcnt_location_id, -1) AS itemsite_location_id,
         CASE WHEN (itemsite_costmethod = 'N') THEN 0
              WHEN ( (itemsite_costmethod = 'A') AND
                     (itemsite_qtyonhand = 0) AND
                     (pAvgCostingMethod = 'ACT') ) THEN actcost(itemsite_item_id)
              WHEN ( (itemsite_costmethod = 'A') AND
                     (pAvgCostingMethod IN ('ACT', 'AVG')) ) THEN avgcost(itemsite_id)
              ELSE stdcost(itemsite_item_id)
         END AS cost, itemsite_costmethod,
         itemsite_controlmethod, itemsite_value INTO _p
  FROM invcnt, itemsite, item
  WHERE ( (invcnt_itemsite_id=itemsite_id)
   AND (itemsite_item_id=item_id)
   AND (invcnt_qoh_after IS NOT NULL)
   AND (NOT invcnt_posted)
   AND (invcnt_id=pInvcntid) );
  IF (NOT FOUND) THEN
    RETURN -9;
  END IF;

  SELECT COALESCE(SUM(itemloc_qty),0.0), location_netable INTO _origLocQty,_netable
    FROM itemloc,location
   WHERE ((itemloc_itemsite_id=_p.itemsite_id)
     AND  (location_id=itemloc_location_id)
     AND  (itemloc_location_id=_p.invcnt_location_id))
   GROUP BY location_netable;
  IF (NOT FOUND) THEN
    _origLocQty := 0.0;
    _netable := TRUE;
  END IF;

  SELECT NEXTVAL('invhist_invhist_id_seq') INTO _invhistid;

  IF (_p.itemsite_freeze) THEN
    _postDate := _p.invcnt_tagdate;
  ELSE
    _postDate := CURRENT_TIMESTAMP;
  END IF;

  _hasDetail = FALSE;

--  Post the detail indicated by cntslips
  IF ( (_p.itemsite_loccntrl) OR
       (_p.itemsite_controlmethod IN ('L', 'S')) ) THEN

    SELECT NEXTVAL('itemloc_series_seq') INTO _itemlocSeries;

--  Adjust any existing detail to 0
    FOR _itemloc IN SELECT itemloc_id, itemloc_location_id,
                           itemloc_ls_id, itemloc_qty
                    FROM itemloc
                    WHERE ((itemloc_itemsite_id=_p.itemsite_id)
                      AND  (itemloc_location_id=_p.invcnt_location_id)) LOOP

      _hasDetail = TRUE;

--  Create the itemlocdist flushing records
      INSERT INTO itemlocdist
      ( itemlocdist_series, itemlocdist_source_type, itemlocdist_source_id,
        itemlocdist_expiration,
        itemlocdist_itemsite_id, itemlocdist_invhist_id, itemlocdist_flush )
      VALUES
      ( _itemlocSeries, 'I', _itemloc.itemloc_id,
        endOfTime(),
        _p.itemsite_id, _invhistid, TRUE );

    END LOOP;

--  Clear the running detail Qty
    _runningQty := 0;

--  Adjust the detail to the cntslip indicated value
    FOR _cntslip IN SELECT cntslip_location_id, cntslip_lotserial,
                           cntslip_lotserial_expiration,
                           cntslip_lotserial_warrpurc,
                           SUM(cntslip_qty) AS qty,
                           itemsite_item_id
                    FROM cntslip,invcnt,itemsite
                    WHERE ((cntslip_cnttag_id=pInvcntid)
                    AND (cntslip_cnttag_id=invcnt_id)
                    AND (invcnt_itemsite_id=itemsite_id))
                    GROUP BY cntslip_location_id, cntslip_lotserial, cntslip_lotserial_expiration,
                    cntslip_lotserial_warrpurc, itemsite_item_id LOOP

--  Handle the LotSerial
      IF (LENGTH(_cntslip.cntslip_lotserial)>0) THEN
        SELECT ls_id INTO _lsid
        FROM ls
        WHERE ((ls_item_id=_cntslip.itemsite_item_id)
        AND (UPPER(ls_number)=UPPER(_cntslip.cntslip_lotserial)));

        IF (NOT FOUND) THEN
          _lsid := NEXTVAL('ls_ls_id_seq');
          INSERT INTO ls
          VALUES (_lsid,_cntslip.itemsite_item_id,UPPER(_cntslip.cntslip_lotserial));
        END IF;
      END IF;

--  Track the running Qty
      _runningQty := (_runningQty + _cntslip.qty);
      _hasDetail = TRUE;

--  Create the itemlocdist populating record
      INSERT INTO itemlocdist
      ( itemlocdist_series, itemlocdist_source_type, itemlocdist_source_id,
        itemlocdist_itemsite_id,
        itemlocdist_ls_id, itemlocdist_expiration, itemlocdist_warranty,
        itemlocdist_qty, itemlocdist_invhist_id )
      VALUES
      ( _itemlocSeries, 'L', _cntslip.cntslip_location_id,
        _p.itemsite_id,
        _lsid, COALESCE(_cntslip.cntslip_lotserial_expiration, endOfTime()),
        _cntslip.cntslip_lotserial_warrpurc,
        _cntslip.qty, _invhistid );

    END LOOP;

    IF (_runningQty > _p.invcnt_qoh_after) THEN
--  The total Count Slip Qty is greater than the Count Tag Qty,
--  Don't post the Count.
      _errorCode = -1;

    ELSIF ( (_runningQty < _p.invcnt_qoh_after) AND
            (_p.itemsite_controlmethod IN ('L', 'S')) ) THEN
--  The total Count Slip Qty is less than the Count Tag Qty,
--  and the Item Site is Lot/Serial controlled.
--  Don't post the Count.
      _errorCode = -2;

    ELSIF (_runningQty < _p.invcnt_qoh_after) THEN
      IF ( (NOT _p.itemsite_loccntrl) OR
           (_p.itemsite_location_id = -1) ) THEN
--  The total Count Slip Qty is less than the Count Tag Qty,
--  and there isn't a default location to post into.
--  Don't post the Count.
        _errorCode = -3;

      ELSIF ( SELECT (metric_value='f')
              FROM metric
              WHERE (metric_name='PostCountTagToDefault') ) THEN
--  The total Count Slip Qty is less than the Count Tag Qty,
--  and we don't post Count Tags to default Locations
--  Don't post the Count.
        _errorCode = -4;

      ELSE
--  Distribute the remaining qty into the default location.
        INSERT INTO itemlocdist
        ( itemlocdist_series, itemlocdist_source_type, itemlocdist_source_id,
          itemlocdist_itemsite_id,
          itemlocdist_ls_id, itemlocdist_expiration,
          itemlocdist_qty, itemlocdist_invhist_id )
        SELECT _itemlocSeries, 'L', _p.itemsite_location_id,
               _p.itemsite_id,
               _lsid, endOfTime(),
               (_p.invcnt_qoh_after - _runningQty), _invhistid;

        _hasDetail = TRUE;
        _errorCode = 0;
      END IF;
    ELSE
--  The Count Slip Qty. must equal the Count Tag Qty.
      _errorCode = 0;
    END IF;

--  If we shouldn't post the count then delete the itemlocdist records,
--  and return with the error.
    IF (_errorCode <> 0) THEN
      DELETE FROM itemlocdist
      WHERE (itemlocdist_series=_itemlocSeries);

      RETURN _errorCode;
    END IF;

  END IF;

--  Mod. the Count Tag.
  UPDATE invcnt
  SET invcnt_qoh_before=_origLocQty,
      invcnt_postdate=_postDate,
      invcnt_posted=TRUE,
      invcnt_invhist_id=_invhistid,
      invcnt_post_username=CURRENT_USER
  WHERE (invcnt_id=pInvcntid);

--  Create the CC transaction
  INSERT INTO invhist
   ( invhist_id, invhist_itemsite_id,
     invhist_transdate, invhist_transtype, invhist_invqty,
     invhist_qoh_before, invhist_qoh_after,
     invhist_docnumber, invhist_comments,
     invhist_invuom, invhist_unitcost, invhist_hasdetail,
     invhist_costmethod, invhist_value_before, invhist_value_after,
     invhist_series )
  SELECT _invhistid, itemsite_id,
         _postDate, 'CC', (invcnt_qoh_after - invcnt_qoh_before),
         invcnt_qoh_before, invcnt_qoh_after,
         invcnt_tagnumber, invcnt_comments,
         uom_name, _p.cost, _hasDetail,
         _p.itemsite_costmethod, _p.itemsite_value,
         _p.itemsite_value + (_p.cost * (invcnt_qoh_after - invcnt_qoh_before)),
         _itemlocSeries
  FROM itemsite, invcnt, item, uom
  WHERE ( (invcnt_itemsite_id=itemsite_id)
   AND (itemsite_item_id=item_id)
   AND (item_inv_uom_id=uom_id)
   AND (itemsite_controlmethod <> 'N')
   AND (invcnt_id=pInvcntid) );

--  Update the QOH
  IF (_netable) THEN
    UPDATE itemsite
    SET itemsite_qtyonhand= itemsite_qtyonhand + (_p.invcnt_qoh_after - _origLocQty),
        itemsite_datelastcount=_postDate
    WHERE (itemsite_id=_p.itemsite_id);
  ELSE
    UPDATE itemsite
    SET itemsite_nnqoh =  itemsite_nnqoh - _origLocQty,
	itemsite_qtyonhand = itemsite_qtyonhand + _p.invcnt_qoh_after,
        itemsite_datelastcount=_postDate
    WHERE (itemsite_id=_p.itemsite_id);
  END IF;

--  Post the detail, if any
  IF (_hasDetail) THEN
    PERFORM distributeItemlocSeries(_itemlocSeries);
  END IF;

--  Thaw the itemsite if it's frozen
  IF (pThaw) THEN
    PERFORM thawItemSite(invcnt_itemsite_id)
    FROM invcnt
    WHERE (invcnt_id=pInvcntid);
  END IF;

--  Distribute to G/L
  PERFORM insertGLTransaction( 'I/M', 'CT', _p.invcnt_tagnumber, ('Post Count Tag #' || _p.invcnt_tagnumber || ' for Item ' || _p.item_number),
                               costcat_adjustment_accnt_id, costcat_asset_accnt_id, _invhistid,
                               ( (_p.invcnt_qoh_after - _origLocQty) * _p.cost), CURRENT_DATE )
  FROM invcnt, itemsite, costcat
  WHERE ( (invcnt_itemsite_id=itemsite_id)
   AND (itemsite_costcat_id=costcat_id)
   AND (invcnt_id=pInvcntid) );

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.postcounttaglocation(integer, boolean, text) OWNER TO admin;

--
-- TOC entry 2005 (class 1255 OID 146566817)
-- Dependencies: 4536 8
-- Name: postcounttags(integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postcounttags(integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWarehousid ALIAS FOR $1;
  pThaw ALIAS FOR $2;
  _invcnt RECORD;
  _result INTEGER := 0;
  _return INTEGER := 0;

BEGIN

  FOR _invcnt IN SELECT invcnt_id
                 FROM invcnt, itemsite
                 WHERE ( (invcnt_itemsite_id=itemsite_id)
                  AND ( (pWarehousid=-1) OR (itemsite_warehous_id=pWarehousid) )
                  AND (invcnt_qoh_after IS NOT NULL)
                  AND (NOT invcnt_posted) ) LOOP
    SELECT postCountTag(_invcnt.invcnt_id, pThaw) INTO _result;
    IF (_result < _return) THEN
      _return := _result;
    END IF;
  END LOOP;

  RETURN _return;

END;
$_$;


ALTER FUNCTION public.postcounttags(integer, boolean) OWNER TO admin;

--
-- TOC entry 2006 (class 1255 OID 146566818)
-- Dependencies: 4536 8
-- Name: postcreditmemo(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postcreditmemo(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCmheadid ALIAS FOR $1;
  pItemlocSeries ALIAS FOR $2;
  _return INTEGER;

BEGIN

  SELECT postCreditMemo(pCmheadid, fetchJournalNumber('AR-CM'), pItemlocSeries) INTO _return;

  RETURN _return;

END;
$_$;


ALTER FUNCTION public.postcreditmemo(integer, integer) OWNER TO admin;

--
-- TOC entry 2007 (class 1255 OID 146566819)
-- Dependencies: 4536 8
-- Name: postcreditmemo(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postcreditmemo(integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCmheadid ALIAS FOR $1;
  pJournalNumber ALIAS FOR $2;
  pItemlocSeries ALIAS FOR $3;
  _r RECORD;
  _p RECORD;
  _aropenid INTEGER;
  _cohistid INTEGER;
  _sequence INTEGER;
  _itemlocSeries INTEGER;
  _invhistid INTEGER;
  _test INTEGER;
  _totalAmount NUMERIC   := 0;
  _commissionDue NUMERIC := 0;
  _toApply NUMERIC;
  _toClose BOOLEAN;
  _glDate	DATE;
  _taxBaseValue	NUMERIC	:= 0;

BEGIN

--  Cache some parameters
  SELECT cmhead.*,
         findARAccount(cmhead_cust_id) AS ar_accnt_id,
         ( SELECT COALESCE(SUM(taxhist_tax), 0)
           FROM cmheadtax
           WHERE ( (taxhist_parent_id = cmhead_id)
             AND   (taxhist_taxtype_id = getAdjustmentTaxtypeId()) ) ) AS adjtax
         INTO _p
  FROM cmhead
  WHERE (cmhead_id=pCmheadid);

  IF (_p.cmhead_posted) THEN
    RETURN -10;
  END IF;

  IF (_p.cmhead_hold) THEN
    RETURN -11;
  END IF;

  _glDate := COALESCE(_p.cmhead_gldistdate, _p.cmhead_docdate);

  _itemlocSeries = pItemlocSeries;

  SELECT fetchGLSequence() INTO _sequence;

--  Start by handling taxes
  FOR _r IN SELECT tax_sales_accnt_id,
              round(sum(taxdetail_tax),2) AS tax,
              currToBase(_p.cmhead_curr_id, round(sum(taxdetail_tax),2), _p.cmhead_docdate) AS taxbasevalue
            FROM tax
             JOIN calculateTaxDetailSummary('CM', pCmheadid, 'T') ON (taxdetail_tax_id=tax_id)
	    GROUP BY tax_id, tax_sales_accnt_id LOOP

    PERFORM insertIntoGLSeries( _sequence, 'A/R', 'CM', _p.cmhead_number,
                                _r.tax_sales_accnt_id,
                                _r.taxbasevalue,
                                _glDate, _p.cmhead_billtoname );

    _totalAmount := _totalAmount + _r.tax * -1;
  END LOOP;

-- Update item tax records with posting data
  UPDATE cmitemtax SET
    taxhist_docdate=_p.cmhead_docdate,
    taxhist_distdate=_glDate,
    taxhist_curr_id=_p.cmhead_curr_id,
    taxhist_curr_rate=curr_rate,
    taxhist_journalnumber=pJournalNumber
  FROM cmhead
   JOIN cmitem ON (cmhead_id=cmitem_cmhead_id),
   curr_rate
  WHERE ((cmhead_id=pCmheadId)
    AND (taxhist_parent_id=cmitem_id)
    AND (_p.cmhead_curr_id=curr_id)
    AND (_p.cmhead_docdate BETWEEN curr_effective
                           AND curr_expires) );

-- Update Header taxes (Freight and Adjustments) with posting data
  UPDATE cmheadtax SET
    taxhist_docdate=_p.cmhead_docdate,
    taxhist_distdate=_glDate,
    taxhist_curr_id=_p.cmhead_curr_id,
    taxhist_curr_rate=curr_rate,
    taxhist_journalnumber=pJournalNumber
  FROM curr_rate
  WHERE ((taxhist_parent_id=pCmheadId)
    AND (_p.cmhead_curr_id=curr_id)
    AND (_p.cmhead_docdate BETWEEN curr_effective
                           AND curr_expires) );

-- Process line items
-- Always use std cost
  FOR _r IN SELECT *, stdCost(item_id) AS std_cost
            FROM creditmemoitem
            WHERE ( (cmitem_cmhead_id=pCmheadid)
              AND   (cmitem_qtycredit <> 0 ) ) LOOP

--  Calcuate the Commission to be debited
    _commissionDue := (_commissionDue + (_r.extprice * _p.cmhead_commission));

    IF (_r.extprice <> 0) THEN
--  Debit the Sales Account for the current cmitem
      SELECT insertIntoGLSeries( _sequence, 'A/R', 'CM', _p.cmhead_number,
                                 CASE WHEN _p.cmhead_rahead_id IS NULL THEN
                                   getPrjAccntId(_p.cmhead_prj_id, salesaccnt_credit_accnt_id)
                                 ELSE
                                   getPrjAccntId(_p.cmhead_prj_id, salesaccnt_returns_accnt_id)
                                 END,
                               round(currToBase(_p.cmhead_curr_id,
                                                _r.extprice * -1,
                                                _p.cmhead_docdate), 2),
                                 _glDate, _p.cmhead_billtoname) INTO _test
      FROM salesaccnt
      WHERE (salesaccnt_id=findSalesAccnt(_r.cmitem_itemsite_id, 'IS', _p.cmhead_cust_id,
                                          _p.cmhead_saletype_id, _p.cmhead_shipzone_id));
      IF (NOT FOUND) THEN
        PERFORM deleteGLSeries(_sequence);
        RETURN -12;
      END IF;
    END IF;

--  Record Sales History for this C/M Item
    SELECT nextval('cohist_cohist_id_seq') INTO _cohistid;
    INSERT INTO cohist
    ( cohist_id, cohist_cust_id, cohist_itemsite_id, cohist_shipto_id,
      cohist_shipdate, cohist_shipvia,
      cohist_ordernumber, cohist_ponumber, cohist_orderdate,
      cohist_doctype, cohist_invcnumber, cohist_invcdate,
      cohist_qtyshipped, cohist_unitprice, cohist_unitcost,
      cohist_salesrep_id, cohist_commission, cohist_commissionpaid,
      cohist_billtoname, cohist_billtoaddress1,
      cohist_billtoaddress2, cohist_billtoaddress3,
      cohist_billtocity, cohist_billtostate, cohist_billtozip,
      cohist_shiptoname, cohist_shiptoaddress1,
      cohist_shiptoaddress2, cohist_shiptoaddress3,
      cohist_shiptocity, cohist_shiptostate, cohist_shiptozip,
      cohist_curr_id, cohist_taxtype_id, cohist_taxzone_id,
      cohist_shipzone_id, cohist_saletype_id )
    VALUES
    ( _cohistid, _p.cmhead_cust_id, _r.cmitem_itemsite_id, _p.cmhead_shipto_id,
      _p.cmhead_docdate, '',
      _p.cmhead_number, _p.cmhead_custponumber, _p.cmhead_docdate,
      'C', _p.cmhead_invcnumber, _p.cmhead_docdate,
      (_r.qty * -1), _r.unitprice, _r.std_cost,
      _p.cmhead_salesrep_id, (_p.cmhead_commission * _r.extprice * -1), FALSE,
      _p.cmhead_billtoname, _p.cmhead_billtoaddress1,
      _p.cmhead_billtoaddress2, _p.cmhead_billtoaddress3,
      _p.cmhead_billtocity, _p.cmhead_billtostate, _p.cmhead_billtozip,
      _p.cmhead_shipto_name, _p.cmhead_shipto_address1,
      _p.cmhead_shipto_address2, _p.cmhead_shipto_address3,
      _p.cmhead_shipto_city, _p.cmhead_shipto_state, _p.cmhead_shipto_zipcode,
      _p.cmhead_curr_id, _r.cmitem_taxtype_id, _p.cmhead_taxzone_id,
      _p.cmhead_shipzone_id, _p.cmhead_saletype_id );
    INSERT INTO cohisttax
    ( taxhist_parent_id, taxhist_taxtype_id, taxhist_tax_id,
      taxhist_basis, taxhist_basis_tax_id, taxhist_sequence,
      taxhist_percent, taxhist_amount, taxhist_tax,
      taxhist_docdate, taxhist_distdate, taxhist_curr_id, taxhist_curr_rate,
      taxhist_journalnumber )
    SELECT _cohistid, taxhist_taxtype_id, taxhist_tax_id,
           taxhist_basis, taxhist_basis_tax_id, taxhist_sequence,
           taxhist_percent, taxhist_amount, taxhist_tax,
           taxhist_docdate, taxhist_distdate, taxhist_curr_id, taxhist_curr_rate,
           taxhist_journalnumber
    FROM cmitemtax
    WHERE (taxhist_parent_id=_r.cmitem_id);

    _totalAmount := _totalAmount + round(_r.extprice, 2);

  END LOOP;

--  Credit the Misc. Account for Miscellaneous Charges
  IF (_p.cmhead_misc <> 0) THEN
    SELECT insertIntoGLSeries( _sequence, 'A/R', 'CM', _p.cmhead_number,
                               getPrjAccntId(_p.cmhead_prj_id, accnt_id), round(currToBase(_p.cmhead_curr_id,
                                                          _p.cmhead_misc * -1,
                                                          _p.cmhead_docdate), 2),
                               _glDate, _p.cmhead_billtoname) INTO _test
    FROM accnt
    WHERE (accnt_id=_p.cmhead_misc_accnt_id);

--  If the Misc. Charges Account was not found then punt
    IF (NOT FOUND) THEN
      PERFORM deleteGLSeries(_sequence);
      RETURN -14;
    END IF;

--  Record the Sales History for any Misc. Charge
    INSERT INTO cohist
    ( cohist_cust_id, cohist_itemsite_id, cohist_shipto_id,
      cohist_misc_type, cohist_misc_descrip, cohist_misc_id,
      cohist_shipdate, cohist_shipvia,
      cohist_ordernumber, cohist_ponumber, cohist_orderdate,
      cohist_doctype, cohist_invcnumber, cohist_invcdate,
      cohist_qtyshipped, cohist_unitprice, cohist_unitcost,
      cohist_salesrep_id, cohist_commission, cohist_commissionpaid,
      cohist_billtoname, cohist_billtoaddress1,
      cohist_billtoaddress2, cohist_billtoaddress3,
      cohist_billtocity, cohist_billtostate, cohist_billtozip,
      cohist_shiptoname, cohist_shiptoaddress1,
      cohist_shiptoaddress2, cohist_shiptoaddress3,
      cohist_shiptocity, cohist_shiptostate, cohist_shiptozip,
      cohist_curr_id,
      cohist_shipzone_id, cohist_saletype_id )
    VALUES
    ( _p.cmhead_cust_id, -1, _p.cmhead_shipto_id,
      'M', _p.cmhead_misc_descrip, _p.cmhead_misc_accnt_id,
      _p.cmhead_docdate, '',
      _p.cmhead_number, _p.cmhead_custponumber, _p.cmhead_docdate,
      'C', _p.cmhead_invcnumber, _p.cmhead_docdate,
      1, (_p.cmhead_misc * -1), (_p.cmhead_misc * -1),
      _p.cmhead_salesrep_id, 0, FALSE,
      _p.cmhead_billtoname, _p.cmhead_billtoaddress1,
      _p.cmhead_billtoaddress2, _p.cmhead_billtoaddress3,
      _p.cmhead_billtocity, _p.cmhead_billtostate, _p.cmhead_billtozip,
      _p.cmhead_shipto_name, _p.cmhead_shipto_address1,
      _p.cmhead_shipto_address2, _p.cmhead_shipto_address3,
      _p.cmhead_shipto_city, _p.cmhead_shipto_state, _p.cmhead_shipto_zipcode,
      _p.cmhead_curr_id,
      _p.cmhead_shipzone_id, _p.cmhead_saletype_id );

--  Cache the Misc. Amount distributed
    _totalAmount := _totalAmount + _p.cmhead_misc;
  END IF;

  -- Credit Tax Adjustments
  IF (_p.adjtax <> 0) THEN
  --  Record the Sales History for Tax Adjustment
    SELECT nextval('cohist_cohist_id_seq') INTO _cohistid;
    INSERT INTO cohist
    ( cohist_id, cohist_cust_id, cohist_itemsite_id, cohist_shipto_id,
      cohist_misc_type, cohist_misc_descrip,
      cohist_shipdate, cohist_shipvia,
      cohist_ordernumber, cohist_ponumber, cohist_orderdate,
      cohist_doctype, cohist_invcnumber, cohist_invcdate,
      cohist_qtyshipped, cohist_unitprice, cohist_unitcost,
      cohist_salesrep_id, cohist_commission, cohist_commissionpaid,
      cohist_billtoname, cohist_billtoaddress1,
      cohist_billtoaddress2, cohist_billtoaddress3,
      cohist_billtocity, cohist_billtostate, cohist_billtozip,
      cohist_shiptoname, cohist_shiptoaddress1,
      cohist_shiptoaddress2, cohist_shiptoaddress3,
      cohist_shiptocity, cohist_shiptostate, cohist_shiptozip,
      cohist_curr_id, cohist_taxtype_id, cohist_taxzone_id,
      cohist_shipzone_id, cohist_saletype_id )
    VALUES
    ( _cohistid, _p.cmhead_cust_id, -1, _p.cmhead_shipto_id,
      'T', 'Misc Tax Adjustment',
      _p.cmhead_docdate, '',
      _p.cmhead_number, _p.cmhead_custponumber, _p.cmhead_docdate,
      'C', _p.cmhead_invcnumber, _p.cmhead_docdate,
      0, 0, 0,
      _p.cmhead_salesrep_id, 0, FALSE,
      _p.cmhead_billtoname, _p.cmhead_billtoaddress1,
      _p.cmhead_billtoaddress2, _p.cmhead_billtoaddress3,
      _p.cmhead_billtocity, _p.cmhead_billtostate, _p.cmhead_billtozip,
      _p.cmhead_shipto_name, _p.cmhead_shipto_address1,
      _p.cmhead_shipto_address2, _p.cmhead_shipto_address3,
      _p.cmhead_shipto_city, _p.cmhead_shipto_state, _p.cmhead_shipto_zipcode,
      _p.cmhead_curr_id, getAdjustmentTaxtypeId(), _p.cmhead_taxzone_id,
      _p.cmhead_shipzone_id, _p.cmhead_saletype_id );
    INSERT INTO cohisttax
    ( taxhist_parent_id, taxhist_taxtype_id, taxhist_tax_id,
      taxhist_basis, taxhist_basis_tax_id, taxhist_sequence,
      taxhist_percent, taxhist_amount, taxhist_tax,
      taxhist_docdate, taxhist_distdate, taxhist_curr_id, taxhist_curr_rate,
      taxhist_journalnumber  )
    SELECT _cohistid, taxhist_taxtype_id, taxhist_tax_id,
           (taxhist_basis * -1), taxhist_basis_tax_id, taxhist_sequence,
           taxhist_percent, taxhist_amount, taxhist_tax,
           taxhist_docdate, taxhist_distdate, taxhist_curr_id, taxhist_curr_rate,
           taxhist_journalnumber
    FROM cmheadtax
    WHERE ( (taxhist_parent_id=_p.cmhead_id)
      AND   (taxhist_taxtype_id=getAdjustmentTaxtypeId()) );

  END IF;

--  Debit the Freight Account
  IF (_p.cmhead_freight <> 0) THEN
    SELECT insertIntoGLSeries( _sequence, 'A/R', 'CM', _p.cmhead_number,
                               getPrjAccntId(_p.cmhead_prj_id, accnt_id),
                               round(currToBase(_p.cmhead_curr_id,
                                                _p.cmhead_freight * -1,
                                                _p.cmhead_docdate), 2),
                               _glDate, _p.cmhead_billtoname) INTO _test
    FROM accnt
    WHERE (accnt_id=findFreightAccount(_p.cmhead_cust_id));

--  If the Freight Charges Account was not found then punt
    IF (NOT FOUND) THEN
      PERFORM deleteGLSeries(_sequence);
      RETURN -16;
    END IF;

--  Cache the Amount Distributed to Freight
    _totalAmount := _totalAmount + _p.cmhead_freight;

--  Record the Sales History for any Freight
    SELECT nextval('cohist_cohist_id_seq') INTO _cohistid;
    INSERT INTO cohist
    ( cohist_id, cohist_cust_id, cohist_itemsite_id, cohist_shipto_id,
      cohist_misc_type, cohist_misc_descrip,
      cohist_shipdate, cohist_shipvia,
      cohist_ordernumber, cohist_ponumber, cohist_orderdate,
      cohist_doctype, cohist_invcnumber, cohist_invcdate,
      cohist_qtyshipped, cohist_unitprice, cohist_unitcost,
      cohist_salesrep_id, cohist_commission, cohist_commissionpaid,
      cohist_billtoname, cohist_billtoaddress1,
      cohist_billtoaddress2, cohist_billtoaddress3,
      cohist_billtocity, cohist_billtostate, cohist_billtozip,
      cohist_shiptoname, cohist_shiptoaddress1,
      cohist_shiptoaddress2, cohist_shiptoaddress3,
      cohist_shiptocity, cohist_shiptostate, cohist_shiptozip,
      cohist_curr_id, cohist_taxtype_id, cohist_taxzone_id,
      cohist_shipzone_id, cohist_saletype_id )
    VALUES
    ( _cohistid, _p.cmhead_cust_id, -1, _p.cmhead_shipto_id,
      'F', 'Freight Charge',
      _p.cmhead_docdate, '',
      _p.cmhead_number, _p.cmhead_custponumber, _p.cmhead_docdate,
      'C', _p.cmhead_invcnumber, _p.cmhead_docdate,
      1, (_p.cmhead_freight * -1), (_p.cmhead_freight * -1),
      _p.cmhead_salesrep_id, 0, FALSE,
      _p.cmhead_billtoname, _p.cmhead_billtoaddress1,
      _p.cmhead_billtoaddress2, _p.cmhead_billtoaddress3,
      _p.cmhead_billtocity, _p.cmhead_billtostate, _p.cmhead_billtozip,
      _p.cmhead_shipto_name, _p.cmhead_shipto_address1,
      _p.cmhead_shipto_address2, _p.cmhead_shipto_address3,
      _p.cmhead_shipto_city, _p.cmhead_shipto_state, _p.cmhead_shipto_zipcode,
      _p.cmhead_curr_id, getFreightTaxtypeId(), _p.cmhead_taxzone_id,
      _p.cmhead_shipzone_id, _p.cmhead_saletype_id );
    INSERT INTO cohisttax
    ( taxhist_parent_id, taxhist_taxtype_id, taxhist_tax_id,
      taxhist_basis, taxhist_basis_tax_id, taxhist_sequence,
      taxhist_percent, taxhist_amount, taxhist_tax,
      taxhist_docdate, taxhist_distdate, taxhist_curr_id, taxhist_curr_rate,
      taxhist_journalnumber  )
    SELECT _cohistid, taxhist_taxtype_id, taxhist_tax_id,
           (taxhist_basis * -1), taxhist_basis_tax_id, taxhist_sequence,
           taxhist_percent, taxhist_amount, taxhist_tax,
           taxhist_docdate, taxhist_distdate, taxhist_curr_id, taxhist_curr_rate,
           taxhist_journalnumber
    FROM cmheadtax
    WHERE ( (taxhist_parent_id=_p.cmhead_id)
      AND   (taxhist_taxtype_id=getFreightTaxtypeId()) );

  END IF;

  _totalAmount := _totalAmount;

--  Credit the A/R for the total Amount
  IF (_totalAmount <> 0) THEN
    IF (_p.ar_accnt_id != -1) THEN
      PERFORM insertIntoGLSeries( _sequence, 'A/R', 'CM', _p.cmhead_number,
                                  _p.ar_accnt_id,
                                  round(currToBase(_p.cmhead_curr_id,
                                                   _totalAmount,
                                                   _p.cmhead_docdate), 2),
                                  _glDate, _p.cmhead_billtoname);
    ELSE
      PERFORM deleteGLSeries(_sequence);
      RETURN -18;
    END IF;
  END IF;

--  Commit the GLSeries;
  PERFORM postGLSeries(_sequence, pJournalNumber);

--  Create the Invoice aropen item
  SELECT NEXTVAL('aropen_aropen_id_seq') INTO _aropenid;
  INSERT INTO aropen
  ( aropen_id, aropen_username, aropen_journalnumber,
    aropen_open, aropen_posted,
    aropen_cust_id, aropen_ponumber,
    aropen_docnumber,
    aropen_applyto, aropen_doctype,
    aropen_docdate, aropen_duedate, aropen_distdate, aropen_terms_id,
    aropen_amount, aropen_paid,
    aropen_salesrep_id, aropen_commission_due, aropen_commission_paid,
    aropen_ordernumber, aropen_notes,
    aropen_rsncode_id, aropen_curr_id )
  SELECT _aropenid, getEffectiveXtUser(), pJournalNumber,
         TRUE, FALSE,
         cmhead_cust_id, cmhead_custponumber,
         cmhead_number,
         CASE WHEN (cmhead_invcnumber='-1') THEN 'OPEN'
              ELSE (cmhead_invcnumber::TEXT)
         END,
         'C',
         cmhead_docdate, cmhead_docdate, _glDate, -1,
         _totalAmount, 0,
         cmhead_salesrep_id, (_commissionDue * -1), FALSE,
         cmhead_number::TEXT, cmhead_comments,
         cmhead_rsncode_id, cmhead_curr_id
  FROM cmhead
  WHERE (cmhead_id=pCmheadid);

-- Handle the Inventory and G/L Transactions for any returned Inventory where cmitem_updateinv is true
  FOR _r IN SELECT cmitem_itemsite_id AS itemsite_id, cmitem_id,
                   (cmitem_qtyreturned * cmitem_qty_invuomratio) AS qty,
                   cmhead_number, cmhead_cust_id AS cust_id, item_number,
                   cmhead_saletype_id AS saletype_id, cmhead_shipzone_id AS shipzone_id,
                   stdCost(item_id) AS std_cost, cmhead_prj_id,
                   itemsite_costmethod
            FROM cmhead, cmitem, itemsite, item
            WHERE ( (cmitem_cmhead_id=cmhead_id)
             AND (cmitem_itemsite_id=itemsite_id)
             AND (itemsite_item_id=item_id)
             AND (cmitem_qtyreturned <> 0)
             AND (cmitem_updateinv)
             AND (cmhead_id=pCmheadid) ) LOOP

--  Return credited stock to inventory
    IF (_itemlocSeries = 0) THEN
      _itemlocSeries := NEXTVAL('itemloc_series_seq');
    END IF;
    IF (_r.itemsite_costmethod != 'J') THEN
      SELECT postInvTrans(itemsite_id, 'RS', _r.qty,
                         'S/O', 'CM', _r.cmhead_number, '',
                         ('Credit Return ' || _r.item_number),
                         costcat_asset_accnt_id,
                         getPrjAccntId(_r.cmhead_prj_id, resolveCOSAccount(itemsite_id, _r.cust_id, _r.saletype_id, _r.shipzone_id)),
                         _itemlocSeries, _glDate, _r.std_cost) INTO _invhistid
        FROM itemsite, costcat
       WHERE ((itemsite_costcat_id=costcat_id)
          AND (itemsite_id=_r.itemsite_id));
    ELSE
      RAISE DEBUG 'postCreditMemo(%, %, %) tried to postInvTrans a %-costed item',
                  pCmheadid, pJournalNumber, pItemlocSeries,
                  _r.itemsite_costmethod;
    END IF;

  END LOOP;

--  Update coitem to reflect the returned qty where cmitem_updateinv is true
  FOR _r IN SELECT cmitem_qtyreturned, cmitem_itemsite_id, cohead_id
            FROM cmitem, cmhead, invchead, cohead
            WHERE ( (cmitem_cmhead_id=cmhead_id)
             AND (cmhead_invcnumber=invchead_invcnumber)
             AND (invchead_ordernumber=cohead_number)
             AND (cmitem_qtyreturned <> 0)
             AND (cmitem_updateinv)
             AND (cmhead_id=pCmheadid) ) LOOP
    UPDATE coitem
    SET coitem_qtyreturned = (coitem_qtyreturned + _r.cmitem_qtyreturned)
    WHERE coitem_id IN ( SELECT coitem_id
                         FROM coitem
                         WHERE ( (coitem_cohead_id=_r.cohead_id)
                          AND (coitem_itemsite_id = _r.cmitem_itemsite_id) )
                         LIMIT 1 );
  END LOOP;

--  Mark the cmhead as posted
  UPDATE cmhead
  SET cmhead_posted=TRUE, cmhead_gldistdate=_glDate
  WHERE (cmhead_id=pCmheadid);

--  Find the apply-to document and make the application
  SELECT cmhead_number, cmhead_curr_id, cmhead_docdate,
         aropen_id, aropen_cust_id, aropen_docnumber,
         currToCurr(aropen_curr_id, cmhead_curr_id, aropen_amount - aropen_paid,
                    cmhead_docdate) AS balance INTO _p
  FROM aropen, cmhead
  WHERE ( (aropen_doctype='I')
   AND (aropen_docnumber=cmhead_invcnumber)
   AND (cmhead_id=pCmheadid) );
  IF (FOUND) THEN

    IF round(_totalAmount, 2) <= round(_p.balance, 2) THEN
      _toApply = _totalAmount;
    ELSE
      _toApply = _p.balance;
    END IF;

    UPDATE aropen
    SET aropen_paid = round(aropen_paid + currToCurr(_p.cmhead_curr_id,
                                                     aropen_curr_id, _toApply,
                                                     _p.cmhead_docdate), 2)
    WHERE (aropen_id=_p.aropen_id);

--  Alter the new A/R Open Item to reflect the application
    UPDATE aropen
    SET aropen_paid = round(currToCurr(_p.cmhead_curr_id, aropen_curr_id,
                                       _toApply, _p.cmhead_docdate), 2)
    WHERE (aropen_id=_aropenid);

--  Record the application
    INSERT INTO arapply
    ( arapply_cust_id,
      arapply_source_aropen_id, arapply_source_doctype, arapply_source_docnumber,
      arapply_target_aropen_id, arapply_target_doctype, arapply_target_docnumber,
      arapply_fundstype, arapply_refnumber,
      arapply_applied, arapply_closed,
      arapply_postdate, arapply_distdate, arapply_journalnumber, arapply_curr_id )
    VALUES
    ( _p.aropen_cust_id,
      _aropenid, 'C', _p.cmhead_number,
      _p.aropen_id, 'I', _p.aropen_docnumber,
      '', '',
      round(_toApply, 2), _toClose,
      CURRENT_DATE, _p.cmhead_docdate, 0, _p.cmhead_curr_id );

  END IF;

  RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.postcreditmemo(integer, integer, integer) OWNER TO admin;

--
-- TOC entry 2008 (class 1255 OID 146566821)
-- Dependencies: 4536 8
-- Name: postcreditmemos(boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postcreditmemos(boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPostUnprinted ALIAS FOR $1;
  _cmhead RECORD;
  _result INTEGER;
  _return INTEGER        := 0;
  _itemlocSeries INTEGER := 0;

BEGIN

  _itemlocSeries := 0;

  FOR _cmhead IN SELECT cmhead_id
                 FROM cmhead
                 WHERE ( (NOT cmhead_posted)
                   AND   (NOT cmhead_hold)
                   AND   (checkCreditMemoSitePrivs(cmhead_id))
                   AND   ((pPostUnprinted) OR (cmhead_printed)) ) LOOP

    SELECT postCreditMemo(_cmhead.cmhead_id, _itemlocSeries) INTO _result;
    IF (_result < _return) THEN
      _return := _result;
    END IF;

  END LOOP;

  RETURN _return;

END;
$_$;


ALTER FUNCTION public.postcreditmemos(boolean) OWNER TO admin;

--
-- TOC entry 2009 (class 1255 OID 146566822)
-- Dependencies: 4536 8
-- Name: postcreditmemos(boolean, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postcreditmemos(boolean, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPostUnprinted ALIAS FOR $1;
  pJournalNumber ALIAS FOR $2;
  _r RECORD;
  _itemlocSeries INTEGER := 0;

BEGIN

  _itemlocSeries := 0;

  FOR _r IN SELECT cmhead_id
            FROM cmhead
            WHERE ( (NOT cmhead_posted)
              AND   (NOT cmhead_hold)
              AND   (checkCreditMemoSitePrivs(cmhead_id))
              AND   ((pPostUnprinted) OR (cmhead_printed)) ) LOOP

    SELECT postCreditMemo(_r.cmhead_id, pJournalNumber, _itemlocSeries) INTO _itemlocSeries;

  END LOOP;

  RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.postcreditmemos(boolean, integer) OWNER TO admin;

--
-- TOC entry 2010 (class 1255 OID 146566823)
-- Dependencies: 4536 8
-- Name: postevent(text, text, integer, integer, text, numeric, numeric, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postevent(pevnttypename text, pordtype text, pordid integer, pwhsid integer, pnumber text, pnewvalue numeric, poldvalue numeric, pnewdate date, polddate date) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _evnttypeid INTEGER;
  _whsid INTEGER;

BEGIN
  -- Find event type
  SELECT evnttype_id INTO _evnttypeid
  FROM evnttype
  WHERE (evnttype_name=pEvnttypename);
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Event type % not found.', pEvnttypename;
  END IF;

  IF (pWhsid IS NULL) THEN
    -- Find user preferred warehouse
    SELECT usrpref_value  INTO _whsid
    FROM usrpref
    WHERE usrpref_username = getEffectiveXtUser()
      AND usrpref_name = 'PreferredWarehouse';
  ELSE
    _whsid := pWhsid;
  END IF;

  INSERT INTO evntlog ( evntlog_evnttime, evntlog_evnttype_id,
                        evntlog_ordtype, evntlog_ord_id,
                        evntlog_warehous_id, evntlog_number,
                        evntlog_newvalue, evntlog_oldvalue,
                        evntlog_newdate, evntlog_olddate,
                        evntlog_username )
  SELECT CURRENT_TIMESTAMP, evnttype_id,
         pOrdtype, pOrdid,
         _whsid, pNumber,
         pNewValue, pOldValue,
         pNewDate, pOldDate,
         evntnot_username
  FROM evnttype JOIN evntnot ON ( (evntnot_evnttype_id=evnttype_id) AND
                                  (evntnot_warehous_id=_whsid) )
  WHERE (evnttype_id=_evnttypeid);

  RETURN 0;

END
$$;


ALTER FUNCTION public.postevent(pevnttypename text, pordtype text, pordid integer, pwhsid integer, pnumber text, pnewvalue numeric, poldvalue numeric, pnewdate date, polddate date) OWNER TO admin;

--
-- TOC entry 1772 (class 1255 OID 146566824)
-- Dependencies: 4536 8
-- Name: postglseries(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postglseries(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSequence ALIAS FOR $1;
  _journalNumber INTEGER;
  _returnValue INTEGER;

BEGIN

  SELECT postGLSeries(pSequence, fetchJournalNumber('G/L')) INTO _returnValue;
  RETURN _returnValue;

END;
$_$;


ALTER FUNCTION public.postglseries(integer) OWNER TO admin;

--
-- TOC entry 1793 (class 1255 OID 146566825)
-- Dependencies: 4536 8
-- Name: postglseries(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postglseries(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSequence ALIAS FOR $1;
  pJournalNumber ALIAS FOR $2;
  _returnValue INTEGER;

BEGIN

  SELECT postGLSeries(pSequence, pJournalNumber, true) INTO _returnValue;
  RETURN _returnValue;

END;
$_$;


ALTER FUNCTION public.postglseries(integer, integer) OWNER TO admin;

--
-- TOC entry 1804 (class 1255 OID 146566826)
-- Dependencies: 4536 8
-- Name: postglseries(integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postglseries(integer, integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSequence 		ALIAS FOR $1;
  pJournalNumber 	ALIAS FOR $2;
  pPostZero		ALIAS FOR $3;
  _glseries RECORD;
  _transCount INTEGER := 0;
  _delta NUMERIC;
  _discrepDate DATE;
  _discrepAccntid INTEGER;
  _rows INTEGER;
BEGIN

/*  Make sure we don't create an imbalance across companies.
    The 'IgnoreCompanyBalance' metric is a back door mechanism to
    allow legacy users to create transactions accross companies if
    they have been using the company segment for something else
    and they MUST continue to be able to do so.  It can only be
    implemented by direct sql update to the metric table and should
    otherwise be discouraged.
*/
  IF (COALESCE(fetchMetricValue('GLCompanySize'),0) > 0
    AND fetchMetricBool('IgnoreCompany') = false)  THEN

    SELECT count(accnt_company) INTO _rows
    FROM (
      SELECT DISTINCT accnt_company
      FROM accnt
        JOIN glseries ON (glseries_accnt_id=accnt_id)
      WHERE (glseries_sequence=pSequence)) _data;

    IF (_rows > 1) THEN
      RAISE EXCEPTION 'G/L Series can not be posted because multiple companies are referenced in the same series.';
    END IF;
  END IF;

--  Make sure that we balance
  SELECT SUM(glseries_amount), MAX(glseries_distdate) INTO _delta, _discrepDate
    FROM glseries
   WHERE (glseries_sequence=pSequence);
  IF ( _delta <> 0 ) THEN
    IF (COALESCE(fetchMetricValue('GLCompanySize'),0) = 0) THEN
      SELECT accnt_id INTO _discrepAccntid
        FROM accnt, metric
       WHERE ((metric_name='GLSeriesDiscrepancyAccount')
         AND  (accnt_id=CAST(metric_value AS INTEGER)));
    ELSE
       SELECT company_dscrp_accnt_id INTO _discrepAccntid
        FROM company
          JOIN accnt ON (accnt_company=company_number)
          JOIN glseries ON (glseries_accnt_id=accnt_id)
       WHERE (glseries_sequence=pSequence)
       LIMIT 1;
    END IF;

    IF (NOT FOUND) THEN
      RETURN -5;
    END IF;

    INSERT INTO glseries
           ( glseries_sequence, glseries_source, glseries_doctype, glseries_docnumber,
             glseries_accnt_id, glseries_amount, glseries_distdate, glseries_notes )
    SELECT glseries_sequence, glseries_source, glseries_doctype, glseries_docnumber,
             _discrepAccntid, (_delta * -1), _discrepDate, 'G/L Series Discrepancy'
      FROM glseries
     WHERE (glseries_sequence=pSequence)
     LIMIT 1;
  END IF;

--  March through the glseries members, posting them one at a time
  FOR _glseries IN SELECT glseries_source, glseries_doctype, glseries_docnumber,
                          glseries_accnt_id, glseries_distdate, glseries_notes,
                          glseries_misc_id,
                          SUM(glseries_amount) as amount
                     FROM glseries
                    WHERE ((glseries_amount<>0.0)
                      AND  (glseries_sequence=pSequence))
                    GROUP BY glseries_source, glseries_doctype, glseries_docnumber,
                             glseries_accnt_id, glseries_distdate, glseries_notes,
                             glseries_misc_id LOOP

-- refuse to accept postings into closed periods
    IF (SELECT BOOL_AND(COALESCE(period_closed, FALSE))
        FROM accnt LEFT OUTER JOIN
             period ON (_glseries.glseries_distdate BETWEEN period_start AND period_end)
        WHERE (accnt_id = _glseries.glseries_accnt_id)) THEN
      RAISE EXCEPTION 'Cannot post to closed period (%).', _glseries.glseries_distdate;
      RETURN -4;        -- remove raise exception when all callers check return code
    END IF;

-- refuse to accept postings into frozen periods without proper priv
    IF (SELECT NOT BOOL_AND(checkPrivilege('PostFrozenPeriod')) AND
               BOOL_AND(COALESCE(period_freeze, FALSE))
        FROM accnt LEFT OUTER JOIN
             period ON (_glseries.glseries_distdate BETWEEN period_start AND period_end)
        WHERE (accnt_id = _glseries.glseries_accnt_id)) THEN
      RAISE EXCEPTION 'Cannot post to frozen period (%).', _glseries.glseries_distdate;
      RETURN -4;        -- remove raise exception when all callers check return code
    END IF;

-- refuse to accept postings into nonexistent periods
    IF NOT EXISTS(SELECT period_id
                  FROM period
                  WHERE (_glseries.glseries_distdate BETWEEN period_start AND period_end)) THEN
      RAISE EXCEPTION 'Cannot post to nonexistent period (%).', pDistDate;
    END IF;

    IF (_glseries.amount != 0 OR pPostZero) THEN
      IF (fetchMetricBool('UseJournals')) THEN
       INSERT INTO sltrans
        ( sltrans_posted, sltrans_created, sltrans_date, sltrans_misc_id,
          sltrans_sequence, sltrans_accnt_id, sltrans_source, sltrans_notes,
          sltrans_doctype, sltrans_docnumber, sltrans_amount, sltrans_journalnumber )
        VALUES
        ( FALSE, CURRENT_TIMESTAMP, _glseries.glseries_distdate, _glseries.glseries_misc_id,
          pSequence, _glseries.glseries_accnt_id, _glseries.glseries_source, _glseries.glseries_notes,
          _glseries.glseries_doctype, _glseries.glseries_docnumber, _glseries.amount, pJournalNumber );
      ELSE
       INSERT INTO gltrans
        ( gltrans_posted, gltrans_exported, gltrans_created, gltrans_date, gltrans_misc_id,
          gltrans_sequence, gltrans_accnt_id, gltrans_source, gltrans_notes,
          gltrans_doctype, gltrans_docnumber, gltrans_amount, gltrans_journalnumber )
        VALUES
        ( FALSE, FALSE, CURRENT_TIMESTAMP, _glseries.glseries_distdate, _glseries.glseries_misc_id,
          pSequence, _glseries.glseries_accnt_id, _glseries.glseries_source, _glseries.glseries_notes,
          _glseries.glseries_doctype, _glseries.glseries_docnumber, _glseries.amount, pJournalNumber );
      END IF;

      _transCount := _transCount + 1;
    END IF;
  END LOOP;

--  Delete all of the posted glseries members
  DELETE FROM glseries
  WHERE (glseries_sequence=pSequence);

  PERFORM postIntoTrialBalance(pSequence);

  RETURN _transCount;

END;
$_$;


ALTER FUNCTION public.postglseries(integer, integer, boolean) OWNER TO admin;

--
-- TOC entry 1853 (class 1255 OID 146566828)
-- Dependencies: 4536 8
-- Name: postglseriesnosumm(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postglseriesnosumm(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSequence ALIAS FOR $1;
  _journalNumber INTEGER;
  _returnValue INTEGER;

BEGIN

  SELECT postGLSeriesNoSumm(pSequence, fetchJournalNumber('G/L')) INTO _returnValue;
  RETURN _returnValue;

END;
$_$;


ALTER FUNCTION public.postglseriesnosumm(integer) OWNER TO admin;

--
-- TOC entry 1854 (class 1255 OID 146566829)
-- Dependencies: 4536 8
-- Name: postglseriesnosumm(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postglseriesnosumm(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSequence ALIAS FOR $1;
  pJournalNumber ALIAS FOR $2;
  _glseries RECORD;
  _transCount INTEGER := 0;
  _rows INTEGER;

BEGIN

/*  Make sure we don't create an imbalance across companies.
    The 'IgnoreCompanyBalance' metric is a back door mechanism to
    allow legacy users to create transactions accross companies if
    they have been using the company segment for something else
    and they MUST continue to be able to do so.  It can only be
    implemented by direct sql update to the metric table and should
    otherwise be discouraged.
*/
  IF (COALESCE(fetchMetricValue('GLCompanySize'),0) > 0
    AND fetchMetricBool('IgnoreCompany') = false)  THEN

    SELECT count(accnt_company) INTO _rows
    FROM (
      SELECT DISTINCT accnt_company
      FROM accnt
        JOIN glseries ON (glseries_accnt_id=accnt_id)
      WHERE (glseries_sequence=pSequence)) _data;

    IF (_rows > 1) THEN
      RAISE EXCEPTION 'G/L Series can not be posted because multiple companies are referenced in the same series.';
    END IF;
  END IF;

--  Make sure that we balance
  IF ( ( SELECT SUM(glseries_amount)
         FROM glseries
         WHERE (glseries_sequence=pSequence) ) <> 0 ) THEN
    RETURN -1;
  END IF;

--  March through the glseries members, posting them one at a time
  FOR _glseries IN SELECT glseries_source, glseries_doctype, glseries_docnumber,
                          glseries_accnt_id, glseries_distdate, glseries_notes,
                          glseries_misc_id, glseries_amount as amount
                     FROM glseries
                    WHERE ((glseries_amount<>0.0)
                      AND  (glseries_sequence=pSequence)) LOOP

-- refuse to accept postings into closed periods
    IF (SELECT BOOL_AND(COALESCE(period_closed, FALSE))
        FROM accnt LEFT OUTER JOIN
             period ON (_glseries.glseries_distdate BETWEEN period_start AND period_end)
        WHERE (accnt_id = _glseries.glseries_accnt_id)) THEN
      RAISE EXCEPTION 'Cannot post to closed period (%).', _glseries.glseries_distdate;
      RETURN -4;        -- remove raise exception when all callers check return code
    END IF;

-- refuse to accept postings into frozen periods without proper priv
    IF (SELECT NOT BOOL_AND(checkPrivilege('PostFrozenPeriod')) AND
               BOOL_AND(COALESCE(period_freeze, FALSE))
        FROM accnt LEFT OUTER JOIN
             period ON (_glseries.glseries_distdate BETWEEN period_start AND period_end)
        WHERE (accnt_id = _glseries.glseries_accnt_id)) THEN
      RAISE EXCEPTION 'Cannot post to frozen period (%).', _glseries.glseries_distdate;
      RETURN -4;        -- remove raise exception when all callers check return code
    END IF;

-- refuse to accept postings into nonexistent periods
    IF NOT EXISTS(SELECT period_id
                  FROM period
                  WHERE (_glseries.glseries_distdate BETWEEN period_start AND period_end)) THEN
      RAISE EXCEPTION 'Cannot post to nonexistent period (%).', pDistDate;
    END IF;

    IF (fetchMetricBool('UseJournals')) THEN
      INSERT INTO sltrans
      ( sltrans_posted, sltrans_created, sltrans_date, sltrans_misc_id,
        sltrans_sequence, sltrans_accnt_id, sltrans_source, sltrans_notes,
        sltrans_doctype, sltrans_docnumber, sltrans_amount, sltrans_journalnumber )
      VALUES
      ( FALSE, CURRENT_TIMESTAMP, _glseries.glseries_distdate, _glseries.glseries_misc_id,
        pSequence, _glseries.glseries_accnt_id, _glseries.glseries_source, _glseries.glseries_notes,
        _glseries.glseries_doctype, _glseries.glseries_docnumber, _glseries.amount, pJournalNumber );
    ELSE
      INSERT INTO gltrans
      ( gltrans_posted, gltrans_exported, gltrans_created, gltrans_date, gltrans_misc_id,
        gltrans_sequence, gltrans_accnt_id, gltrans_source, gltrans_notes,
        gltrans_doctype, gltrans_docnumber, gltrans_amount, gltrans_journalnumber )
      VALUES
      ( FALSE, FALSE, CURRENT_TIMESTAMP, _glseries.glseries_distdate, _glseries.glseries_misc_id,
        pSequence, _glseries.glseries_accnt_id, _glseries.glseries_source, _glseries.glseries_notes,
        _glseries.glseries_doctype, _glseries.glseries_docnumber, _glseries.amount, pJournalNumber );
    END IF;

    _transCount := _transCount + 1;

  END LOOP;

--  Delete all of the posted glseries members
  DELETE FROM glseries
  WHERE (glseries_sequence=pSequence);

  PERFORM postIntoTrialBalance(pSequence);

  RETURN _transCount;

END;
$_$;


ALTER FUNCTION public.postglseriesnosumm(integer, integer) OWNER TO admin;

--
-- TOC entry 1868 (class 1255 OID 146566831)
-- Dependencies: 4536 8
-- Name: postintoinvbalance(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postintoinvbalance(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pInvhistId ALIAS FOR $1;
  _invbalid INTEGER;
  _r RECORD;
  _count INTEGER;
  _qty NUMERIC;

BEGIN

--  Grab the invhist record to post
--  Special fix for transit sites when transtype=TS and invqty<0
--  Set the sense to 1 to correct invhist populated incorrectly.
  SELECT invhist.*,
         CASE WHEN (invhist_transtype='TS' AND invhist_invqty < 0.0 AND warehous_transit) THEN 1
              ELSE invhistSense(invhist_id)
         END AS sense,
         period_id INTO _r
  FROM invhist
    JOIN itemsite ON (itemsite_id=invhist_itemsite_id)
    JOIN whsinfo ON (warehous_id=itemsite_warehous_id)
    LEFT OUTER JOIN period ON (invhist_transdate::date BETWEEN period_start AND period_end)
  WHERE ( invhist_id=pInvhistId );

  GET DIAGNOSTICS _count = ROW_COUNT;

--  If we can post into a Inv Balance, do so
  IF ( _count > 0 ) THEN

--  Validate
    IF (_r.period_id IS NULL) THEN
      RAISE EXCEPTION 'No accounting period exists for invhist_id %, transaction date %.  Transaction can not be posted.', _r.invhist_id, formatDate(_r.invhist_transdate);
    END IF;

--  If cycle count, then we need to reference balance which needs to be accurate
--    IF (_r.invhist_transtype = 'CC') THEN
--      PERFORM forwardupdateitemsite(_r.invhist_itemsite_id);
--    END IF;

--  Try to find an existing invbal
    SELECT
      invbal_id,
--      CASE WHEN (_r.invhist_transtype != 'CC') THEN _r.invhist_invqty ELSE _r.invhist_invqty - invbal_qoh_ending END
      _r.invhist_invqty
      INTO _invbalid, _qty
    FROM invbal
    WHERE ( (invbal_period_id=_r.period_id)
      AND (invbal_itemsite_id=_r.invhist_itemsite_id) );

    GET DIAGNOSTICS _count = ROW_COUNT;
    IF (_count > 0) THEN

--  We found a invbal, update it with the Inventory Transaction
--  Note - two stage update to avoid any funny value caching logic
    IF (_r.sense * _qty > 0) THEN
      UPDATE invbal SET
        invbal_qty_in = (invbal_qty_in + abs(_qty)),
        invbal_value_in = (invbal_value_in + abs(_qty) * _r.invhist_unitcost)
      WHERE (invbal_id=_invbalid);
    ELSIF (_r.sense * _qty < 0) THEN
      UPDATE invbal SET
        invbal_qty_out = (invbal_qty_out + abs(_qty)),
        invbal_value_out = (invbal_value_out + abs(_qty) *  _r.invhist_unitcost)
      WHERE (invbal_id=_invbalid);
    END IF;

    -- Non-netable transactions have their own balances
    IF (_r.invhist_transtype = 'NN') THEN
      UPDATE invbal SET
        invbal_nn_in = (invbal_nn_in + _qty * -1),
        invbal_nnval_in = (invbal_nnval_in + _qty * -1 * _r.invhist_unitcost)
      WHERE (invbal_id=_invbalid);
    END IF;

    UPDATE invbal SET
      invbal_qoh_ending = (invbal_qoh_beginning + invbal_qty_in - invbal_qty_out),
      invbal_value_ending = (invbal_value_beginning + invbal_value_in - invbal_value_out),
      invbal_nn_ending = (invbal_nn_beginning + invbal_nn_in - invbal_nn_out),
      invbal_nnval_ending = (invbal_nnval_beginning + invbal_nnval_in - invbal_nnval_out),
      invbal_dirty=true
    WHERE (invbal_id=_invbalid);
  ELSE

--  No existing invbal, make one
    SELECT NEXTVAL('invbal_invbal_id_seq') INTO _invbalid;
      INSERT INTO invbal
        ( invbal_id, invbal_itemsite_id, invbal_period_id,
          invbal_qoh_beginning,
          invbal_qoh_ending,
          invbal_qty_in,
          invbal_qty_out,
          invbal_value_beginning,
          invbal_value_ending,
          invbal_value_in,
          invbal_value_out,
          invbal_nn_beginning,
          invbal_nn_ending,
          invbal_nn_in,
          invbal_nn_out,
          invbal_nnval_beginning,
          invbal_nnval_ending,
          invbal_nnval_in,
          invbal_nnval_out,
          invbal_dirty )
      VALUES
        ( _invbalid, _r.invhist_itemsite_id, _r.period_id,
         -- Netable
          0,
          _r.invhist_invqty * _r.sense,
          CASE WHEN (_r.sense > 0) THEN _r.invhist_invqty
               ELSE 0
          END,
          CASE WHEN (_r.sense < 0) THEN (_r.invhist_invqty)
               ELSE 0
          END,
          0,
          _r.invhist_invqty * _r.invhist_unitcost * _r.sense,
          CASE WHEN (_r.sense > 0) THEN _r.invhist_invqty * _r.invhist_unitcost
               ELSE 0
          END,
          CASE WHEN (_r.sense < 0) THEN (_r.invhist_invqty  * _r.invhist_unitcost)
               ELSE 0
          END,
          -- Non netable
          0,
          CASE WHEN (_r.invhist_transtype='NN') THEN _r.invhist_invqty * -1
               ELSE 0
          END,
          CASE WHEN (_r.sense > 0 AND _r.invhist_transtype='NN') THEN _r.invhist_invqty * -1
               ELSE 0
          END,
          CASE WHEN (_r.sense < 0 AND _r.invhist_transtype='NN') THEN _r.invhist_invqty * -1
               ELSE 0
          END,
          0,
          CASE WHEN (_r.invhist_transtype='NN') THEN _r.invhist_invqty * _r.invhist_unitcost * -1
               ELSE 0
          END,
          CASE WHEN (_r.sense > 0 AND _r.invhist_transtype='NN') THEN _r.invhist_invqty * -1 * _r.invhist_unitcost
               ELSE 0
          END,
          CASE WHEN (_r.sense < 0 AND _r.invhist_transtype='NN') THEN (_r.invhist_invqty  * -1 * _r.invhist_unitcost)
               ELSE 0
          END,
          true );
    END IF;
  ELSE
    RETURN FALSE;
  END IF;

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.postintoinvbalance(integer) OWNER TO admin;

--
-- TOC entry 2000 (class 1255 OID 146566833)
-- Dependencies: 4536 8
-- Name: postintotrialbalance(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postintotrialbalance(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSequence ALIAS FOR $1;
  _trialbalid INTEGER;
  _r RECORD;

BEGIN

--  March through all of the G/L Transactions for the passed sequence that are not posted
  FOR _r IN SELECT gltrans_id, gltrans_date, gltrans_accnt_id, gltrans_amount,
                   accnt_forwardupdate, period_id, period_closed, period_freeze
            FROM accnt, gltrans LEFT OUTER JOIN period ON (gltrans_date BETWEEN period_start AND period_end)
            WHERE ( (gltrans_accnt_id=accnt_id)
             AND (NOT gltrans_posted)
             AND (NOT gltrans_deleted)
             AND (gltrans_sequence=pSequence) ) LOOP

--  If we can post into a Trial Balance, do so
    IF ( (NOT _r.period_closed) AND ( (NOT _r.period_freeze) OR (checkPrivilege('PostFrozenPeriod')) ) ) THEN

--  Try to find an existing trialbal
      SELECT trialbal_id INTO _trialbalid
      FROM trialbal
      WHERE ( (trialbal_period_id=_r.period_id)
       AND (trialbal_accnt_id=_r.gltrans_accnt_id) );
      IF (FOUND) THEN

--  We found a trialbal, update it with the G/L Transaction
--  Note - two stage update to avoid any funny value caching logic
        IF (_r.gltrans_amount > 0) THEN
          UPDATE trialbal
          SET trialbal_credits = (trialbal_credits + _r.gltrans_amount)
          WHERE (trialbal_id=_trialbalid);
        ELSE
          UPDATE trialbal
          SET trialbal_debits = (trialbal_debits + (_r.gltrans_amount * -1))
          WHERE (trialbal_id=_trialbalid);
        END IF;

        UPDATE trialbal
        SET trialbal_ending = (trialbal_beginning - trialbal_debits + trialbal_credits),
            trialbal_dirty=TRUE
        WHERE (trialbal_id=_trialbalid);
      ELSE

--  No existing trialbal, make one
        SELECT NEXTVAL('trialbal_trialbal_id_seq') INTO _trialbalid;
        INSERT INTO trialbal
        ( trialbal_id, trialbal_accnt_id, trialbal_period_id,
          trialbal_beginning, trialbal_dirty,
          trialbal_ending,
          trialbal_credits,
          trialbal_debits )
        VALUES
        ( _trialbalid, _r.gltrans_accnt_id, _r.period_id,
          0, TRUE,
          _r.gltrans_amount,
          CASE WHEN (_r.gltrans_amount > 0) THEN _r.gltrans_amount
               ELSE 0
          END,
          CASE WHEN (_r.gltrans_amount < 0) THEN (_r.gltrans_amount * -1)
               ELSE 0
          END );
      END IF;

--  Forward update if we should
      IF (_r.accnt_forwardupdate AND fetchmetricbool('ManualForwardUpdate')) THEN
        PERFORM forwardUpdateTrialBalance(_trialbalid);
      END IF;

--  Mark the G/L Transaction as posted
      UPDATE gltrans
      SET gltrans_posted=TRUE
      WHERE (gltrans_id=_r.gltrans_id);

    END IF;

  END LOOP;

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.postintotrialbalance(integer) OWNER TO admin;

--
-- TOC entry 2012 (class 1255 OID 146566834)
-- Dependencies: 4536 8
-- Name: postinvhist(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postinvhist(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pInvhistId ALIAS FOR $1;
  _r RECORD;
BEGIN

    IF ( SELECT metric_value
        FROM metric
        WHERE ((metric_name = 'EnableAsOfQOH')
        AND (metric_value = 't'))) THEN
      IF (NOT postIntoInvBalance(pInvhistId)) THEN
        RAISE EXCEPTION 'Post into Inventory Balance for invhist_id=% was unsuccessful',pInvhistId;
      END IF;
    END IF;

    --Update itemsite qoh and change posted flag
    UPDATE itemsite SET
      itemsite_qtyonhand = (itemsite_qtyonhand + (invhist_invqty * invhistSense(invhist_id))),
      itemsite_value = itemsite_value + invhist_value_after - invhist_value_before
    FROM invhist
    WHERE ( (itemsite_id=invhist_itemsite_id)
    AND (invhist_id=pInvhistId)
    AND (NOT invhist_posted) );

    --Flag as posted
    UPDATE invhist SET
      invhist_posted=TRUE
    WHERE ( (invhist_id=pInvhistId)
    AND (invhist_posted=FALSE) );

RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.postinvhist(integer) OWNER TO admin;

--
-- TOC entry 2013 (class 1255 OID 146566835)
-- Dependencies: 4536 8
-- Name: postinvoice(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postinvoice(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pInvcheadid ALIAS FOR $1;
  _return INTEGER;

BEGIN

  SELECT postInvoice(pInvcheadid, fetchJournalNumber('AR-IN')) INTO _return;

  RETURN _return;

END;
$_$;


ALTER FUNCTION public.postinvoice(integer) OWNER TO admin;

--
-- TOC entry 2014 (class 1255 OID 146566836)
-- Dependencies: 4536 8
-- Name: postinvoice(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postinvoice(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pInvcheadid ALIAS FOR $1;
  pJournalNumber ALIAS FOR $2;
  _itemlocSeries INTEGER;
  _return INTEGER;

BEGIN

  SELECT NEXTVAL('itemloc_series_seq') INTO _itemlocSeries;
  SELECT postInvoice(pInvcheadid, pJournalNumber, _itemlocseries) INTO _return;

  RETURN _return;

END;
$_$;


ALTER FUNCTION public.postinvoice(integer, integer) OWNER TO admin;

--
-- TOC entry 2015 (class 1255 OID 146566837)
-- Dependencies: 4536 8
-- Name: postinvoice(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postinvoice(integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pInvcheadid ALIAS FOR $1;
  pJournalNumber ALIAS FOR $2;
  pItemlocSeries ALIAS FOR $3;
  _aropenid INTEGER;
  _cohistid INTEGER;
  _itemlocSeries INTEGER := 0;
  _invhistid INTEGER := 0;
  _amount NUMERIC;
  _roundedBase NUMERIC;
  _sequence INTEGER;
  _r RECORD;
  _p RECORD;
  _test INTEGER;
  _totalAmount          NUMERIC := 0;
  _totalRoundedBase     NUMERIC := 0;
  _totalAmountBase      NUMERIC := 0;
  _appliedAmount        NUMERIC := 0;
  _commissionDue        NUMERIC := 0;
  _tmpAccntId INTEGER;
  _tmpCurrId  INTEGER;
  _firstExchDate        DATE;
  _glDate		DATE;
  _exchGain             NUMERIC := 0;

BEGIN

  IF ( ( SELECT invchead_posted
         FROM invchead
         WHERE (invchead_id=pInvcheadid) ) ) THEN
    RETURN -10;
  END IF;

--  Cache some parameters
  SELECT invchead.*, fetchGLSequence() AS sequence,
         findFreightAccount(invchead_cust_id) AS freightaccntid,
         findARAccount(invchead_cust_id) AS araccntid,
         ( SELECT COALESCE(SUM(taxhist_tax), 0)
           FROM invcheadtax
           WHERE ( (taxhist_parent_id = invchead_id)
             AND   (taxhist_taxtype_id = getFreightTaxtypeId()) ) ) AS freighttax,
         ( SELECT COALESCE(SUM(taxhist_tax), 0)
           FROM invcheadtax
           WHERE ( (taxhist_parent_id = invchead_id)
             AND   (taxhist_taxtype_id = getAdjustmentTaxtypeId()) ) ) AS adjtax
       INTO _p
  FROM invchead
  WHERE (invchead_id=pInvcheadid);

  _itemlocSeries = pItemlocSeries;

  _glDate := COALESCE(_p.invchead_gldistdate, _p.invchead_invcdate);

  IF (_p.invchead_salesrep_id < 0) THEN
    RAISE NOTICE 'Patch negative invchead_salesrep_id until invchead_salesrep_id is a true fkey';
    _p.invchead_salesrep_id := NULL;
  END IF;

-- the 1st MC iteration used the cohead_orderdate so we could get curr exch
-- gain/loss between the sales and invoice dates, but see issue 3892.  leave
-- this condition TRUE until we make this configurable or decide not to.
  IF TRUE THEN
      _firstExchDate := _p.invchead_invcdate;
  ELSE
-- can we save a select by using: _firstExchDate := _p.invchead_orderdate;
      SELECT cohead_orderdate INTO _firstExchDate
      FROM cohead JOIN invchead ON (cohead_number = invchead_ordernumber)
      WHERE (invchead_id = pInvcheadid);
  END IF;

--  Start by handling taxes
  FOR _r IN SELECT tax_sales_accnt_id,
              round(sum(taxdetail_tax),2) AS tax,
              currToBase(_p.invchead_curr_id, round(sum(taxdetail_tax),2), _firstExchDate) AS taxbasevalue
            FROM tax
             JOIN calculateTaxDetailSummary('I', pInvcheadid, 'T') ON (taxdetail_tax_id=tax_id)
	    GROUP BY tax_id, tax_sales_accnt_id LOOP

    PERFORM insertIntoGLSeries( _p.sequence, 'A/R', 'IN', _p.invchead_invcnumber,
                                _r.tax_sales_accnt_id,
                                _r.taxbasevalue,
                                _glDate, _p.invchead_billto_name );

    _totalAmount := _totalAmount + _r.tax;
    _totalRoundedBase := _totalRoundedBase + _r.taxbasevalue;
  END LOOP;

-- Update item tax records with posting data
    UPDATE invcitemtax SET
      taxhist_docdate=_firstExchDate,
      taxhist_distdate=_glDate,
      taxhist_curr_id=_p.invchead_curr_id,
      taxhist_curr_rate=curr_rate,
      taxhist_journalnumber=pJournalNumber
    FROM invchead
     JOIN invcitem ON (invchead_id=invcitem_invchead_id),
     curr_rate
    WHERE ((invchead_id=pInvcheadId)
      AND (taxhist_parent_id=invcitem_id)
      AND (_p.invchead_curr_id=curr_id)
      AND ( _firstExchDate BETWEEN curr_effective
                           AND curr_expires) );

-- Update Invchead taxes (Freight and Adjustments) with posting data
    UPDATE invcheadtax SET
      taxhist_docdate=_firstExchDate,
      taxhist_distdate=_glDate,
      taxhist_curr_id=_p.invchead_curr_id,
      taxhist_curr_rate=curr_rate,
      taxhist_journalnumber=pJournalNumber
    FROM curr_rate
    WHERE ((taxhist_parent_id=pInvcheadid)
      AND (_p.invchead_curr_id=curr_id)
      AND ( _firstExchDate BETWEEN curr_effective
                           AND curr_expires) );

--  March through the Non-Misc. Invcitems
  FOR _r IN SELECT *
            FROM invoiceitem
            WHERE ( (invcitem_invchead_id = pInvcheadid)
              AND   (invcitem_item_id <> -1) ) LOOP

--  Cache the amount due for this line
    _amount := _r.extprice;

    IF (_amount > 0) THEN
--  Credit the Sales Account for the invcitem item
      IF (_r.invcitem_rev_accnt_id IS NOT NULL) THEN
        SELECT getPrjAccntId(_p.invchead_prj_id, _r.invcitem_rev_accnt_id)
	INTO _tmpAccntId;
      ELSEIF (_r.itemsite_id IS NULL) THEN
	SELECT getPrjAccntId(_p.invchead_prj_id, salesaccnt_sales_accnt_id)
	INTO _tmpAccntId
	FROM salesaccnt
	WHERE (salesaccnt_id=findSalesAccnt(_r.invcitem_item_id, 'I', _p.invchead_cust_id,
                                            _p.invchead_saletype_id, _p.invchead_shipzone_id));
      ELSE
	SELECT getPrjAccntId(_p.invchead_prj_id, salesaccnt_sales_accnt_id)
	INTO _tmpAccntId
	FROM salesaccnt
	WHERE (salesaccnt_id=findSalesAccnt(_r.itemsite_id, 'IS', _p.invchead_cust_id,
                                            _p.invchead_saletype_id, _p.invchead_shipzone_id));
      END IF;

--  If the Sales Account Assignment was not found then punt
      IF (NOT FOUND) THEN
        PERFORM deleteGLSeries(_p.sequence);
        DELETE FROM cohist
         WHERE ((cohist_sequence=_p.sequence)
           AND  (cohist_invcnumber=_p.invchead_invcnumber));
        RETURN -11;
      END IF;

      _roundedBase := round(currToBase(_p.invchead_curr_id, _amount, _firstExchDate), 2);
      SELECT insertIntoGLSeries( _p.sequence, 'A/R', 'IN',
                                 _p.invchead_invcnumber, _tmpAccntId,
                                 _roundedBase, _glDate, _p.invchead_billto_name ) INTO _test;

      _totalAmount := (_totalAmount + _amount);
      _totalRoundedBase := _totalRoundedBase + _roundedBase;
      _commissionDue := (_commissionDue + (_amount * _p.invchead_commission));
    END IF;

    _totalAmount := _totalAmount;
    _totalRoundedBase := _totalRoundedBase;

--  Record Sales History for this S/O Item
    SELECT nextval('cohist_cohist_id_seq') INTO _cohistid;
    INSERT INTO cohist
    ( cohist_id, cohist_cust_id, cohist_itemsite_id, cohist_shipto_id,
      cohist_shipdate, cohist_shipvia,
      cohist_ordernumber, cohist_ponumber, cohist_orderdate,
      cohist_doctype, cohist_invcnumber, cohist_invcdate,
      cohist_qtyshipped, cohist_unitprice, cohist_unitcost,
      cohist_salesrep_id, cohist_commission, cohist_commissionpaid,
      cohist_billtoname, cohist_billtoaddress1,
      cohist_billtoaddress2, cohist_billtoaddress3,
      cohist_billtocity, cohist_billtostate, cohist_billtozip,
      cohist_shiptoname, cohist_shiptoaddress1,
      cohist_shiptoaddress2, cohist_shiptoaddress3,
      cohist_shiptocity, cohist_shiptostate, cohist_shiptozip,
      cohist_curr_id, cohist_sequence, cohist_taxtype_id, cohist_taxzone_id,
      cohist_shipzone_id, cohist_saletype_id )
    VALUES
    ( _cohistid, _p.invchead_cust_id, _r.itemsite_id, _p.invchead_shipto_id,
      _p.invchead_shipdate, _p.invchead_shipvia,
      COALESCE(_p.invchead_ordernumber, _r.cohead_number), _p.invchead_ponumber, _p.invchead_orderdate,
      'I', _p.invchead_invcnumber, _p.invchead_invcdate,
      _r.qty, _r.unitprice, _r.unitcost,
      _p.invchead_salesrep_id, (_p.invchead_commission * _r.extprice), FALSE,
      _p.invchead_billto_name, _p.invchead_billto_address1,
      _p.invchead_billto_address2, _p.invchead_billto_address3,
      _p.invchead_billto_city, _p.invchead_billto_state, _p.invchead_billto_zipcode,
      _p.invchead_shipto_name, _p.invchead_shipto_address1,
      _p.invchead_shipto_address2, _p.invchead_shipto_address3,
      _p.invchead_shipto_city, _p.invchead_shipto_state,
      _p.invchead_shipto_zipcode, _p.invchead_curr_id,
      _p.sequence, _r.invcitem_taxtype_id, _p.invchead_taxzone_id,
      _p.invchead_shipzone_id, _p.invchead_saletype_id );
    INSERT INTO cohisttax
    ( taxhist_parent_id, taxhist_taxtype_id, taxhist_tax_id,
      taxhist_basis, taxhist_basis_tax_id, taxhist_sequence,
      taxhist_percent, taxhist_amount, taxhist_tax,
      taxhist_docdate, taxhist_distdate, taxhist_curr_id, taxhist_curr_rate,
      taxhist_journalnumber )
    SELECT _cohistid, taxhist_taxtype_id, taxhist_tax_id,
           taxhist_basis, taxhist_basis_tax_id, taxhist_sequence,
           taxhist_percent, taxhist_amount, taxhist_tax,
           taxhist_docdate, taxhist_distdate, taxhist_curr_id, taxhist_curr_rate,
           taxhist_journalnumber
    FROM invcitemtax
    WHERE (taxhist_parent_id=_r.invcitem_id);

  END LOOP;

--  March through the Misc. Invcitems
  FOR _r IN SELECT *
            FROM invoiceitem JOIN salescat ON (salescat_id = invcitem_salescat_id)
            WHERE ( (invcitem_item_id = -1)
              AND   (invcitem_invchead_id=pInvcheadid) ) LOOP

--  Cache the amount due for this line and the commission due for such
    _amount := _r.extprice;

    IF (_amount > 0) THEN
--  Credit the Sales Account for the invcitem item
      _roundedBase = round(currToBase(_p.invchead_curr_id, _amount,
                                      _firstExchDate), 2);
      SELECT insertIntoGLSeries( _p.sequence, 'A/R', 'IN', _p.invchead_invcnumber,
                                 getPrjAccntId(_p.invchead_prj_id, COALESCE(_r.invcitem_rev_accnt_id, _r.salescat_sales_accnt_id)),
                                 _roundedBase,
                                 _glDate, _p.invchead_billto_name ) INTO _test;
      IF (_test < 0) THEN
        PERFORM deleteGLSeries(_p.sequence);
        DELETE FROM cohist
         WHERE ((cohist_sequence=_p.sequence)
           AND  (cohist_invcnumber=_p.invchead_invcnumber));
        RETURN _test;
      END IF;

      _totalAmount := (_totalAmount + _amount);
      _totalRoundedBase :=  _totalRoundedBase + _roundedBase;
      _commissionDue := (_commissionDue + (_amount * _p.invchead_commission));
    END IF;

--  Record Sales History for this S/O Item
    SELECT nextval('cohist_cohist_id_seq') INTO _cohistid;
    INSERT INTO cohist
    ( cohist_id, cohist_cust_id, cohist_itemsite_id, cohist_shipto_id,
      cohist_misc_type, cohist_misc_descrip,
      cohist_shipdate, cohist_shipvia,
      cohist_ordernumber, cohist_ponumber, cohist_orderdate,
      cohist_doctype, cohist_invcnumber, cohist_invcdate,
      cohist_qtyshipped, cohist_unitprice, cohist_unitcost,
      cohist_salesrep_id, cohist_commission, cohist_commissionpaid,
      cohist_billtoname, cohist_billtoaddress1,
      cohist_billtoaddress2, cohist_billtoaddress3,
      cohist_billtocity, cohist_billtostate, cohist_billtozip,
      cohist_shiptoname, cohist_shiptoaddress1,
      cohist_shiptoaddress2, cohist_shiptoaddress3,
      cohist_shiptocity, cohist_shiptostate, cohist_shiptozip,
      cohist_curr_id, cohist_sequence, cohist_taxtype_id, cohist_taxzone_id,
      cohist_shipzone_id, cohist_saletype_id )
    VALUES
    ( _cohistid, _p.invchead_cust_id, -1, _p.invchead_shipto_id,
      'M', (_r.invcitem_number || '-' || _r.invcitem_descrip),
      _p.invchead_shipdate, _p.invchead_shipvia,
      COALESCE(_p.invchead_ordernumber, _r.cohead_number), _p.invchead_ponumber, _p.invchead_orderdate,
      'I', _p.invchead_invcnumber, _p.invchead_invcdate,
      _r.qty, _r.unitprice, 0,
      _p.invchead_salesrep_id, (_p.invchead_commission * _r.extprice), FALSE,
      _p.invchead_billto_name, _p.invchead_billto_address1,
      _p.invchead_billto_address2, _p.invchead_billto_address3,
      _p.invchead_billto_city, _p.invchead_billto_state, _p.invchead_billto_zipcode,
      _p.invchead_shipto_name, _p.invchead_shipto_address1,
      _p.invchead_shipto_address2, _p.invchead_shipto_address3,
      _p.invchead_shipto_city, _p.invchead_shipto_state,
      _p.invchead_shipto_zipcode, _p.invchead_curr_id,
      _p.sequence, _r.invcitem_taxtype_id, _p.invchead_taxzone_id,
      _p.invchead_shipzone_id, _p.invchead_saletype_id );
    INSERT INTO cohisttax
    ( taxhist_parent_id, taxhist_taxtype_id, taxhist_tax_id,
      taxhist_basis, taxhist_basis_tax_id, taxhist_sequence,
      taxhist_percent, taxhist_amount, taxhist_tax,
      taxhist_docdate, taxhist_distdate, taxhist_curr_id, taxhist_curr_rate,
      taxhist_journalnumber )
    SELECT _cohistid, taxhist_taxtype_id, taxhist_tax_id,
           taxhist_basis, taxhist_basis_tax_id, taxhist_sequence,
           taxhist_percent, taxhist_amount, taxhist_tax,
           taxhist_docdate, taxhist_distdate, taxhist_curr_id, taxhist_curr_rate,
           taxhist_journalnumber
    FROM invcitemtax
    WHERE (taxhist_parent_id=_r.invcitem_id);

  END LOOP;

--  Credit the Freight Account for Freight Charges
  IF (_p.invchead_freight <> 0) THEN
    IF (_p.freightaccntid <> -1) THEN
      _roundedBase = round(currToBase(_p.invchead_curr_id, _p.invchead_freight,
                                      _firstExchDate), 2);
      SELECT insertIntoGLSeries( _p.sequence, 'A/R', 'IN', _p.invchead_invcnumber,
                                 getPrjAccntId(_p.invchead_prj_id,_p.freightaccntid),
                                 _roundedBase,
                                 _glDate, _p.invchead_billto_name ) INTO _test;

--  Cache the Freight Amount distributed
        _totalAmount := (_totalAmount + _p.invchead_freight);
        _totalRoundedBase := _totalRoundedBase + _roundedBase;
    ELSE
      _test := -14;
    END IF;

--  If the Freight Account was not found then punt
    IF (_test < 0) THEN
      PERFORM deleteGLSeries(_p.sequence);
      DELETE FROM cohist
       WHERE ((cohist_sequence=_p.sequence)
         AND  (cohist_invcnumber=_p.invchead_invcnumber));
      RETURN _test;
    END IF;

--  Record Sales History for the Freight
    SELECT nextval('cohist_cohist_id_seq') INTO _cohistid;
    INSERT INTO cohist
    ( cohist_id, cohist_cust_id, cohist_itemsite_id, cohist_shipto_id,
      cohist_misc_type, cohist_misc_descrip,
      cohist_shipdate, cohist_shipvia,
      cohist_ordernumber, cohist_ponumber, cohist_orderdate,
      cohist_doctype, cohist_invcnumber, cohist_invcdate,
      cohist_qtyshipped, cohist_unitprice, cohist_unitcost,
      cohist_salesrep_id, cohist_commission, cohist_commissionpaid,
      cohist_billtoname, cohist_billtoaddress1,
      cohist_billtoaddress2, cohist_billtoaddress3,
      cohist_billtocity, cohist_billtostate, cohist_billtozip,
      cohist_shiptoname, cohist_shiptoaddress1,
      cohist_shiptoaddress2, cohist_shiptoaddress3,
      cohist_shiptocity, cohist_shiptostate, cohist_shiptozip,
      cohist_curr_id, cohist_sequence, cohist_taxtype_id, cohist_taxzone_id,
      cohist_shipzone_id, cohist_saletype_id )
    VALUES
    ( _cohistid, _p.invchead_cust_id, -1, _p.invchead_shipto_id,
      'F', 'Freight',
      _p.invchead_shipdate, _p.invchead_shipvia,
      _p.invchead_ordernumber, _p.invchead_ponumber, _p.invchead_orderdate,
      'I', _p.invchead_invcnumber, _p.invchead_invcdate,
      1, _p.invchead_freight, _p.invchead_freight,
      _p.invchead_salesrep_id, 0, FALSE,
      _p.invchead_billto_name, _p.invchead_billto_address1,
      _p.invchead_billto_address2, _p.invchead_billto_address3,
      _p.invchead_billto_city, _p.invchead_billto_state, _p.invchead_billto_zipcode,
      _p.invchead_shipto_name, _p.invchead_shipto_address1,
      _p.invchead_shipto_address2, _p.invchead_shipto_address3,
      _p.invchead_shipto_city, _p.invchead_shipto_state,
      _p.invchead_shipto_zipcode, _p.invchead_curr_id,
      _p.sequence, getFreightTaxtypeId(), _p.invchead_taxzone_id,
      _p.invchead_shipzone_id, _p.invchead_saletype_id );
    INSERT INTO cohisttax
    ( taxhist_parent_id, taxhist_taxtype_id, taxhist_tax_id,
      taxhist_basis, taxhist_basis_tax_id, taxhist_sequence,
      taxhist_percent, taxhist_amount, taxhist_tax,
      taxhist_docdate, taxhist_distdate, taxhist_curr_id, taxhist_curr_rate,
      taxhist_journalnumber )
    SELECT _cohistid, taxhist_taxtype_id, taxhist_tax_id,
           taxhist_basis, taxhist_basis_tax_id, taxhist_sequence,
           taxhist_percent, taxhist_amount, taxhist_tax,
           taxhist_docdate, taxhist_distdate, taxhist_curr_id, taxhist_curr_rate,
           taxhist_journalnumber
    FROM invcheadtax
    WHERE ( (taxhist_parent_id=_p.invchead_id)
      AND   (taxhist_taxtype_id=getFreightTaxtypeId()) );

  END IF;

--  Credit the Misc. Account for Miscellaneous Charges
  IF (_p.invchead_misc_amount <> 0) THEN
    _roundedBase := round(currToBase(_p.invchead_curr_id, _p.invchead_misc_amount,
                                     _firstExchDate), 2);
    SELECT insertIntoGLSeries( _p.sequence, 'A/R', 'IN', _p.invchead_invcnumber,
                               getPrjAccntId(_p.invchead_prj_id, _p.invchead_misc_accnt_id),
                               _roundedBase,
                               _glDate, _p.invchead_billto_name ) INTO _test;

--  If the Misc. Charges Account was not found then punt
    IF (_test < 0) THEN
      PERFORM deleteGLSeries(_p.sequence);
      DELETE FROM cohist
       WHERE ((cohist_sequence=_p.sequence)
         AND  (cohist_invcnumber=_p.invchead_invcnumber));
      RETURN _test;
    END IF;

--  Cache the Misc. Amount distributed
    _totalAmount := (_totalAmount + _p.invchead_misc_amount);
    _totalRoundedBase := _totalRoundedBase + _roundedBase;

--  Record Sales History for the Misc. Charge
    INSERT INTO cohist
    ( cohist_cust_id, cohist_itemsite_id, cohist_shipto_id,
      cohist_misc_type, cohist_misc_descrip, cohist_misc_id,
      cohist_shipdate, cohist_shipvia,
      cohist_ordernumber, cohist_ponumber, cohist_orderdate,
      cohist_doctype, cohist_invcnumber, cohist_invcdate,
      cohist_qtyshipped, cohist_unitprice, cohist_unitcost,
      cohist_salesrep_id, cohist_commission, cohist_commissionpaid,
      cohist_billtoname, cohist_billtoaddress1,
      cohist_billtoaddress2, cohist_billtoaddress3,
      cohist_billtocity, cohist_billtostate, cohist_billtozip,
      cohist_shiptoname, cohist_shiptoaddress1,
      cohist_shiptoaddress2, cohist_shiptoaddress3,
      cohist_shiptocity, cohist_shiptostate, cohist_shiptozip,
      cohist_curr_id, cohist_sequence,
      cohist_shipzone_id, cohist_saletype_id )
    VALUES
    ( _p.invchead_cust_id, -1, _p.invchead_shipto_id,
      'M', _p.invchead_misc_descrip, _p.invchead_misc_accnt_id,
      _p.invchead_shipdate, _p.invchead_shipvia,
      _p.invchead_ordernumber, _p.invchead_ponumber, _p.invchead_orderdate,
      'I', _p.invchead_invcnumber, _p.invchead_invcdate,
      1, _p.invchead_misc_amount, _p.invchead_misc_amount,
      _p.invchead_salesrep_id, 0, FALSE,
      _p.invchead_billto_name, _p.invchead_billto_address1,
      _p.invchead_billto_address2, _p.invchead_billto_address3,
      _p.invchead_billto_city, _p.invchead_billto_state, _p.invchead_billto_zipcode,
      _p.invchead_shipto_name, _p.invchead_shipto_address1,
      _p.invchead_shipto_address2, _p.invchead_shipto_address3,
      _p.invchead_shipto_city, _p.invchead_shipto_state,
      _p.invchead_shipto_zipcode, _p.invchead_curr_id,
      _p.sequence,
      _p.invchead_shipzone_id, _p.invchead_saletype_id );

  END IF;

--  Record Sales History for the Tax Adjustment
  IF (_p.adjtax <> 0) THEN
    SELECT nextval('cohist_cohist_id_seq') INTO _cohistid;
    INSERT INTO cohist
    ( cohist_id, cohist_cust_id, cohist_itemsite_id, cohist_shipto_id,
      cohist_misc_type, cohist_misc_descrip,
      cohist_shipdate, cohist_shipvia,
      cohist_ordernumber, cohist_ponumber, cohist_orderdate,
      cohist_doctype, cohist_invcnumber, cohist_invcdate,
      cohist_qtyshipped, cohist_unitprice, cohist_unitcost,
      cohist_salesrep_id, cohist_commission, cohist_commissionpaid,
      cohist_billtoname, cohist_billtoaddress1,
      cohist_billtoaddress2, cohist_billtoaddress3,
      cohist_billtocity, cohist_billtostate, cohist_billtozip,
      cohist_shiptoname, cohist_shiptoaddress1,
      cohist_shiptoaddress2, cohist_shiptoaddress3,
      cohist_shiptocity, cohist_shiptostate, cohist_shiptozip,
      cohist_curr_id, cohist_sequence, cohist_taxtype_id, cohist_taxzone_id,
      cohist_shipzone_id, cohist_saletype_id )
    VALUES
    ( _cohistid, _p.invchead_cust_id, -1, _p.invchead_shipto_id,
      'T', 'Misc Tax Adjustment',
      _p.invchead_shipdate, _p.invchead_shipvia,
      _p.invchead_ordernumber, _p.invchead_ponumber, _p.invchead_orderdate,
      'I', _p.invchead_invcnumber, _p.invchead_invcdate,
      1, 0.0, 0.0,
      _p.invchead_salesrep_id, 0, FALSE,
      _p.invchead_billto_name, _p.invchead_billto_address1,
      _p.invchead_billto_address2, _p.invchead_billto_address3,
      _p.invchead_billto_city, _p.invchead_billto_state, _p.invchead_billto_zipcode,
      _p.invchead_shipto_name, _p.invchead_shipto_address1,
      _p.invchead_shipto_address2, _p.invchead_shipto_address3,
      _p.invchead_shipto_city, _p.invchead_shipto_state,
      _p.invchead_shipto_zipcode, _p.invchead_curr_id,
      _p.sequence, getAdjustmentTaxtypeId(), _p.invchead_taxzone_id,
      _p.invchead_shipzone_id, _p.invchead_saletype_id );
    INSERT INTO cohisttax
    ( taxhist_parent_id, taxhist_taxtype_id, taxhist_tax_id,
      taxhist_basis, taxhist_basis_tax_id, taxhist_sequence,
      taxhist_percent, taxhist_amount, taxhist_tax,
      taxhist_docdate, taxhist_distdate, taxhist_curr_id, taxhist_curr_rate,
      taxhist_journalnumber )
    SELECT _cohistid, taxhist_taxtype_id, taxhist_tax_id,
           taxhist_basis, taxhist_basis_tax_id, taxhist_sequence,
           taxhist_percent, taxhist_amount, taxhist_tax,
           taxhist_docdate, taxhist_distdate, taxhist_curr_id, taxhist_curr_rate,
           taxhist_journalnumber
    FROM invcheadtax
    WHERE ( (taxhist_parent_id=_p.invchead_id)
      AND   (taxhist_taxtype_id=getAdjustmentTaxtypeId()) );

  END IF;

-- ToDo: handle rounding errors
    _exchGain := currGain(_p.invchead_curr_id, _totalAmount,
                          _firstExchDate, _glDate);
    IF (_exchGain <> 0) THEN
        SELECT insertIntoGLSeries( _p.sequence, 'A/R', 'IN',
                                   _p.invchead_invcnumber, getGainLossAccntId(_p.araccntid),
                                   round(_exchGain, 2) * -1,
                                   _glDate, _p.invchead_billto_name ) INTO _test ;
        IF (_test < 0) THEN
          PERFORM deleteGLSeries(_p.sequence);
          DELETE FROM cohist
           WHERE ((cohist_sequence=_p.sequence)
             AND  (cohist_invcnumber=_p.invchead_invcnumber));
          RETURN _test;
        END IF;
    END IF;

--  Debit A/R for the total Amount
  IF (_totalRoundedBase <> 0) THEN
    IF (_p.araccntid != -1) THEN
      PERFORM insertIntoGLSeries( _p.sequence, 'A/R', 'IN', _p.invchead_invcnumber,
                                  _p.araccntid, round(_totalRoundedBase * -1, 2),
                                  _glDate, _p.invchead_billto_name );
    ELSE
      PERFORM deleteGLSeries(_p.sequence);
      DELETE FROM cohist
       WHERE ((cohist_sequence=_p.sequence)
         AND  (cohist_invcnumber=_p.invchead_invcnumber));
      RETURN -17;
    END IF;
  END IF;

--  Commit the GLSeries;
  SELECT postGLSeries(_p.sequence, pJournalNumber) INTO _test;
  IF (_test < 0) THEN
    PERFORM deleteGLSeries(_p.sequence);
    DELETE FROM cohist
     WHERE ((cohist_sequence=_p.sequence)
       AND  (cohist_invcnumber=_p.invchead_invcnumber));
    RETURN _test;
  END IF;

--  Create the Invoice aropen item
  SELECT nextval('aropen_aropen_id_seq') INTO _aropenid;
  INSERT INTO aropen
  ( aropen_id, aropen_username, aropen_journalnumber,
    aropen_open, aropen_posted,
    aropen_cust_id, aropen_ponumber,
    aropen_docnumber, aropen_applyto, aropen_doctype,
    aropen_docdate, aropen_duedate, aropen_distdate, aropen_terms_id,
    aropen_amount, aropen_paid,
    aropen_salesrep_id, aropen_commission_due, aropen_commission_paid,
    aropen_ordernumber, aropen_notes, aropen_cobmisc_id,
    aropen_curr_id )
  VALUES
  ( _aropenid, getEffectiveXtUser(), pJournalNumber,
    TRUE, FALSE,
    _p.invchead_cust_id, _p.invchead_ponumber,
    _p.invchead_invcnumber, _p.invchead_invcnumber, 'I',
    _p.invchead_invcdate, determineDueDate(_p.invchead_terms_id, _p.invchead_invcdate), _glDate, _p.invchead_terms_id,
    round(_totalAmount, 2), 0,
    _p.invchead_salesrep_id, _commissionDue, FALSE,
    _p.invchead_ordernumber::text, _p.invchead_notes, pInvcheadid,
    _p.invchead_curr_id );

-- Handle the Inventory and G/L Transactions for any billed Inventory where invcitem_updateinv is true
  FOR _r IN SELECT itemsite_id AS itemsite_id, invcitem_id,
                   (invcitem_billed * invcitem_qty_invuomratio) AS qty,
                   invchead_invcnumber, invchead_cust_id AS cust_id, item_number,
                   invchead_saletype_id AS saletype_id, invchead_shipzone_id AS shipzone_id,
                   invchead_prj_id, itemsite_costmethod
            FROM invchead JOIN invcitem ON ( (invcitem_invchead_id=invchead_id) AND
                                             (invcitem_billed <> 0) AND
                                             (invcitem_updateinv) )
                          JOIN itemsite ON ( (itemsite_item_id=invcitem_item_id) AND
                                             (itemsite_warehous_id=invcitem_warehous_id) )
                          JOIN item ON (item_id=invcitem_item_id)
            WHERE (invchead_id=pInvcheadid) LOOP

--  Issue billed stock from inventory
    IF (_itemlocSeries = 0) THEN
      _itemlocSeries := NEXTVAL('itemloc_series_seq');
    END IF;
    IF (_r.itemsite_costmethod != 'J') THEN
      SELECT postInvTrans(itemsite_id, 'SH', _r.qty,
                         'S/O', 'IN', _r.invchead_invcnumber, '',
                         ('Invoice Billed ' || _r.item_number),
                         getPrjAccntId(_r.invchead_prj_id, resolveCOSAccount(itemsite_id, _r.cust_id, _r.saletype_id, _r.shipzone_id)),
                         costcat_asset_accnt_id, _itemlocSeries, _glDate) INTO _invhistid
      FROM itemsite, costcat
      WHERE ( (itemsite_costcat_id=costcat_id)
       AND (itemsite_id=_r.itemsite_id) );
    ELSE
      RAISE DEBUG 'postInvoice(%, %, %) tried to postInvTrans a %-costed item',
                  pInvcheadid, pJournalNumber, pItemlocSeries,
                  _r.itemsite_costmethod;
    END IF;

  END LOOP;

--  Mark the invoice as posted
  UPDATE invchead
  SET invchead_posted=TRUE, invchead_gldistdate=_glDate
  WHERE (invchead_id=pInvcheadid);

  IF (_totalAmount > 0) THEN
    -- get a list of allocated CMs
    FOR _r IN SELECT aropen_id,
		     CASE WHEN((aropen_amount - aropen_paid) >=
                                aropenalloc_amount / (1 / aropen_curr_rate /
                                currRate(aropenalloc_curr_id,_firstExchDate))) THEN
			      aropenalloc_amount / (1 / aropen_curr_rate /
                                currRate(aropenalloc_curr_id,_firstExchDate))
			  ELSE (aropen_amount - aropen_paid)
		     END AS balance,
		     aropen_curr_id, aropen_curr_rate,
		     aropenalloc_doctype, aropenalloc_doc_id
                FROM aropenalloc, aropen
               WHERE ( (aropenalloc_aropen_id=aropen_id)
                 AND   ((aropenalloc_doctype='S' AND aropenalloc_doc_id=(SELECT cohead_id
                                                                           FROM cohead
                                                                          WHERE cohead_number=_p.invchead_ordernumber)) OR
                        (aropenalloc_doctype='I' AND aropenalloc_doc_id=_p.invchead_id)) ) LOOP

      _appliedAmount := _r.balance;
      IF (_totalAmount < _appliedAmount / (1 / currRate(_r.aropen_curr_id,_firstExchDate) /
                        _r.aropen_curr_rate)) THEN
        _appliedAmount := _totalAmount;
	_tmpCurrId := _p.invchead_curr_id;
      ELSE
	_tmpCurrId := _r.aropen_curr_id;
      END IF;

      -- ignore if no appliable balance
      IF (_appliedAmount > 0) THEN
        -- create an arcreditapply record linking the source c/m and the target invoice
        -- for an amount that is equal to the balance on the invoice or the balance on
        -- c/m whichever is greater.
        INSERT INTO arcreditapply
              (arcreditapply_source_aropen_id, arcreditapply_target_aropen_id,
	       arcreditapply_amount, arcreditapply_curr_id, arcreditapply_reftype, arcreditapply_ref_id)
        VALUES(_r.aropen_id, _aropenid, _appliedAmount, _tmpCurrId, 'S',  _r.aropenalloc_doc_id);

        -- call postARCreditMemoApplication(aropen_id of C/M)
        SELECT postARCreditMemoApplication(_r.aropen_id) into _test;

        -- if no error decrement the balance and contiue on
        IF (_test >= 0) THEN
          _totalAmount := _totalAmount - currToCurr(_tmpCurrId, _p.invchead_curr_id,
						    _appliedAmount, _firstExchDate);
        END IF;

        -- delete the allocation
        DELETE FROM aropenalloc
        WHERE (aropenalloc_doctype='I')
          AND (aropenalloc_doc_id=_p.invchead_id);

      END IF;
    END LOOP;
  END IF;

  RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.postinvoice(integer, integer, integer) OWNER TO admin;

--
-- TOC entry 2016 (class 1255 OID 146566839)
-- Dependencies: 4536 8
-- Name: postinvoices(boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postinvoices(boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPostUnprinted ALIAS FOR $1;
BEGIN
  RETURN postInvoices(pPostUnprinted, FALSE);
END;
$_$;


ALTER FUNCTION public.postinvoices(boolean) OWNER TO admin;

--
-- TOC entry 2017 (class 1255 OID 146566840)
-- Dependencies: 4536 8
-- Name: postinvoices(boolean, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postinvoices(boolean, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPostUnprinted ALIAS FOR $1;
  pInclZeros     ALIAS FOR $2;
BEGIN
  RETURN postInvoices(pPostUnprinted, pInclZeros, fetchJournalNumber('AR-IN'));
END;
$_$;


ALTER FUNCTION public.postinvoices(boolean, boolean) OWNER TO admin;

--
-- TOC entry 2018 (class 1255 OID 146566841)
-- Dependencies: 4536 8
-- Name: postinvoices(boolean, boolean, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postinvoices(boolean, boolean, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPostUnprinted ALIAS FOR $1;
  pInclZeros     ALIAS FOR $2;
  pJournalNumber ALIAS FOR $3;
  _invcheadid    INTEGER;
  _itemlocSeries INTEGER;
  _counter INTEGER;
  _r RECORD;

BEGIN

  _itemlocSeries := 0;

  IF (pInclZeros) THEN

    FOR _invcheadid IN
      SELECT invchead_id
      FROM invchead
      WHERE ( (NOT invchead_posted)
       AND (checkInvoiceSitePrivs(invchead_id))
       AND (pPostUnprinted OR invchead_printed) ) LOOP

      SELECT postInvoice(_invcheadid, pJournalNumber, _itemlocSeries) INTO _itemlocSeries;
      IF (_itemlocSeries < 0) THEN
        RETURN _itemlocSeries;
      END IF;
    END LOOP;

  ELSE

    FOR _invcheadid IN
      SELECT invchead_id
      FROM invchead LEFT OUTER JOIN invcitem ON (invchead_id=invcitem_invchead_id)
                    LEFT OUTER JOIN item ON (invcitem_item_id=item_id)
      WHERE((NOT invchead_posted)
        AND (checkInvoiceSitePrivs(invchead_id))
        AND (pPostUnprinted OR invchead_printed))
      GROUP BY invchead_id, invchead_freight, invchead_misc_amount
      HAVING (COALESCE(SUM(round((invcitem_billed * invcitem_qty_invuomratio) * (invcitem_price /
              CASE WHEN (item_id IS NULL) THEN 1
              ELSE invcitem_price_invuomratio END), 2)),0)
             + invchead_freight + invchead_misc_amount) > 0 LOOP

      SELECT postInvoice(_invcheadid, pJournalNumber, _itemlocSeries) INTO _itemlocSeries;
      IF (_itemlocSeries < 0) THEN
        RETURN _itemlocSeries;
      END IF;
    END LOOP;

  END IF;

  RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.postinvoices(boolean, boolean, integer) OWNER TO admin;

--
-- TOC entry 2019 (class 1255 OID 146566842)
-- Dependencies: 4536 8
-- Name: postinvtrans(integer, text, numeric, text, text, text, text, text, integer, integer, integer, timestamp with time zone, numeric, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postinvtrans(pitemsiteid integer, ptranstype text, pqty numeric, pmodule text, pordertype text, pordernumber text, pdocnumber text, pcomments text, pdebitid integer, pcreditid integer, pitemlocseries integer, ptimestamp timestamp with time zone DEFAULT now(), pcostovrld numeric DEFAULT NULL::numeric, pinvhistid integer DEFAULT NULL::integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
-- pInvhistid is the original transaction to be returned, reversed, etc.
DECLARE
  _creditid	     INTEGER;
  _debitid	     INTEGER;
  _glreturn	     INTEGER;
  _invhistid	     INTEGER;
  _itemlocdistid     INTEGER;
  _r		     RECORD;
  _sense	     INTEGER;  -- direction in which to adjust inventory QOH
  _t		     RECORD;
  _timestamp         TIMESTAMP WITH TIME ZONE;
  _xferwhsid	     INTEGER;

BEGIN

  --  Cache item and itemsite info
  SELECT CASE WHEN(itemsite_costmethod IN ('A','J')) THEN COALESCE(abs(pCostOvrld / pQty), avgcost(itemsite_id))
              ELSE stdCost(itemsite_item_id)
         END AS cost,
         itemsite_costmethod,
         itemsite_qtyonhand,
	 itemsite_warehous_id,
         ( (item_type = 'R') OR (itemsite_controlmethod = 'N') ) AS nocontrol,
         (itemsite_controlmethod IN ('L', 'S')) AS lotserial,
         (itemsite_loccntrl) AS loccntrl,
         itemsite_freeze AS frozen INTO _r
  FROM itemsite JOIN item ON (item_id=itemsite_item_id)
  WHERE (itemsite_id=pItemsiteid);

  --Post the Inventory Transactions
  IF (_r.nocontrol) THEN
    RETURN -1; -- non-fatal error so dont throw an exception?
  END IF;

  IF (COALESCE(pItemlocSeries,0) = 0) THEN
    RAISE EXCEPTION 'Transaction series must be provided';
  END IF;

  SELECT NEXTVAL('invhist_invhist_id_seq') INTO _invhistid;

  IF ((pTimestamp IS NULL) OR (CAST(pTimestamp AS date)=CURRENT_DATE)) THEN
    _timestamp := CURRENT_TIMESTAMP;
  ELSE
    _timestamp := pTimestamp;
  END IF;

  IF (pTransType = 'TS' OR pTransType = 'TR') THEN
    SELECT * INTO _t FROM tohead WHERE (tohead_number=pDocNumber);
    IF (pTransType = 'TS') THEN
      _xferwhsid := CASE
          WHEN (_t.tohead_src_warehous_id=_r.itemsite_warehous_id) THEN _t.tohead_trns_warehous_id
          WHEN (_t.tohead_trns_warehous_id=_r.itemsite_warehous_id AND pComments ~* 'recall') THEN _t.tohead_src_warehous_id
          WHEN (_t.tohead_trns_warehous_id=_r.itemsite_warehous_id) THEN _t.tohead_dest_warehous_id
          WHEN (_t.tohead_dest_warehous_id=_r.itemsite_warehous_id) THEN _t.tohead_trns_warehous_id
          ELSE NULL
          END;
    ELSIF (pTransType = 'TR') THEN
      _xferwhsid := CASE
          WHEN (_t.tohead_src_warehous_id=_r.itemsite_warehous_id) THEN _t.tohead_trns_warehous_id
          WHEN (_t.tohead_trns_warehous_id=_r.itemsite_warehous_id AND pComments ~* 'recall') THEN _t.tohead_dest_warehous_id
          WHEN (_t.tohead_trns_warehous_id=_r.itemsite_warehous_id) THEN _t.tohead_src_warehous_id
          WHEN (_t.tohead_dest_warehous_id=_r.itemsite_warehous_id) THEN _t.tohead_trns_warehous_id
          ELSE NULL
          END;
    END IF;
  END IF;


  -- increase inventory: AD RM RT RP RR RS RX RB TR
  -- decrease inventory: IM IB IT SH SI EX RI
  -- TS and TR are special: shipShipment and recallShipment should not change
  -- QOH at the Transfer Order src whs (as this was done by issueToShipping)
  -- but postReceipt should change QOH at the transit whs
  IF (pTransType='TS') THEN
    _sense := CASE WHEN (SELECT tohead_trns_warehous_id=_r.itemsite_warehous_id
                         FROM tohead
                         WHERE (tohead_number=pDocNumber)) THEN -1
                         ELSE 0
                         END;
  ELSIF (pTransType='TR') THEN
    _sense := CASE WHEN (SELECT tohead_src_warehous_id=_r.itemsite_warehous_id
                         FROM tohead
                         WHERE (tohead_number=pDocNumber)) THEN 0
                         ELSE 1
                         END;
  ELSIF (pTransType IN ('IM', 'IB', 'IT', 'SH', 'SI', 'EX', 'RI')) THEN
    _sense := -1;

  ELSE
    _sense := 1;
  END IF;

  IF((_r.itemsite_costmethod='A') AND (_r.itemsite_qtyonhand + round(_sense * pQty, 6)) < 0) THEN
    -- Can not let average costed itemsites go negative
    RAISE EXCEPTION 'This transaction will cause an Average Costed item to go negative which is not allowed [xtuple: postinvtrans, -2]';
  END IF;

  INSERT INTO invhist
  ( invhist_id, invhist_itemsite_id, invhist_transtype, invhist_transdate,
      invhist_invqty, invhist_qoh_before,
      invhist_qoh_after,
      invhist_costmethod, invhist_value_before, invhist_value_after,
      invhist_ordtype, invhist_ordnumber, invhist_docnumber, invhist_comments,
      invhist_invuom, invhist_unitcost, invhist_xfer_warehous_id, invhist_posted,
      invhist_series )
  SELECT
    _invhistid, itemsite_id, pTransType, _timestamp,
    pQty, itemsite_qtyonhand,
    (itemsite_qtyonhand + (_sense * pQty)),
    itemsite_costmethod, itemsite_value, itemsite_value + (_r.cost * _sense * pQty),
    pOrderType, pOrderNumber, pDocNumber, pComments,
    uom_name, _r.cost, _xferwhsid, FALSE, pItemlocSeries
  FROM itemsite, item, uom
  WHERE ( (itemsite_item_id=item_id)
   AND (item_inv_uom_id=uom_id)
   AND (itemsite_id=pItemsiteid) );

  IF (pCreditid IN (SELECT accnt_id FROM accnt)) THEN
    _creditid = pCreditid;
  ELSE
    SELECT warehous_default_accnt_id INTO _creditid
    FROM itemsite, whsinfo
    WHERE ( (itemsite_warehous_id=warehous_id)
      AND  (itemsite_id=pItemsiteid) );
  END IF;

  IF (pDebitid IN (SELECT accnt_id FROM accnt)) THEN
    _debitid = pDebitid;
  ELSE
    SELECT warehous_default_accnt_id INTO _debitid
    FROM itemsite, whsinfo
    WHERE ( (itemsite_warehous_id=warehous_id)
      AND  (itemsite_id=pItemsiteid) );
  END IF;

  --  Post the G/L Transaction
  IF (_creditid <> _debitid) THEN
    SELECT insertGLTransaction(pModule, pOrderType, pOrderNumber, pComments,
                               _creditid, _debitid, _invhistid,
                               (_r.cost * pQty), _timestamp::DATE, FALSE) INTO _glreturn;
  END IF;

  --  Distribute this if this itemsite is controlled
  IF ( _r.lotserial OR _r.loccntrl ) THEN

    _itemlocdistid := nextval('itemlocdist_itemlocdist_id_seq');
    INSERT INTO itemlocdist
    ( itemlocdist_id,
      itemlocdist_itemsite_id,
      itemlocdist_source_type,
      itemlocdist_reqlotserial,
      itemlocdist_distlotserial,
      itemlocdist_expiration,
      itemlocdist_qty,
      itemlocdist_series,
      itemlocdist_invhist_id,
      itemlocdist_order_type,
      itemlocdist_order_id )
    SELECT _itemlocdistid,
           pItemsiteid,
           'O',
           (((pQty * _sense) > 0)  AND _r.lotserial),
           ((pQty * _sense) < 0),
           endOfTime(),
           (_sense * pQty),
           pItemlocSeries,
           _invhistid,
           pOrderType,
           CASE WHEN pOrderType='SO' THEN getSalesLineItemId(pOrderNumber)
                ELSE NULL
           END;

    -- populate distributions if invhist_id parameter passed to undo
    IF (pInvhistid IS NOT NULL) THEN
      INSERT INTO itemlocdist
        ( itemlocdist_itemlocdist_id, itemlocdist_source_type, itemlocdist_source_id,
          itemlocdist_itemsite_id, itemlocdist_ls_id, itemlocdist_expiration,
          itemlocdist_qty, itemlocdist_series, itemlocdist_invhist_id )
      SELECT _itemlocdistid, 'L', COALESCE(invdetail_location_id, -1),
             invhist_itemsite_id, invdetail_ls_id,  COALESCE(invdetail_expiration, endoftime()),
             (invdetail_qty * -1.0), pItemlocSeries, _invhistid
      FROM invhist JOIN invdetail ON (invdetail_invhist_id=invhist_id)
      WHERE (invhist_id=pInvhistid);

      IF ( _r.lotserial)  THEN
        INSERT INTO lsdetail
          ( lsdetail_itemsite_id, lsdetail_ls_id, lsdetail_created,
            lsdetail_source_type, lsdetail_source_id, lsdetail_source_number )
        SELECT invhist_itemsite_id, invdetail_ls_id, CURRENT_TIMESTAMP,
               'I', _itemlocdistid, ''
        FROM invhist JOIN invdetail ON (invdetail_invhist_id=invhist_id)
        WHERE (invhist_id=pInvhistid);
      END IF;

      PERFORM distributeitemlocseries(pItemlocSeries);

    END IF;

  END IF;   -- end of distributions

  -- These records will be used for posting G/L transactions to trial balance after records committed.
  -- If we try to do it now concurrency locking prevents any transactions while
  -- user enters item distribution information.  Cant have that.
  INSERT INTO itemlocpost ( itemlocpost_glseq, itemlocpost_itemlocseries)
  VALUES ( _glreturn, pItemlocSeries );

  RETURN _invhistid;

END;
$$;


ALTER FUNCTION public.postinvtrans(pitemsiteid integer, ptranstype text, pqty numeric, pmodule text, pordertype text, pordernumber text, pdocnumber text, pcomments text, pdebitid integer, pcreditid integer, pitemlocseries integer, ptimestamp timestamp with time zone, pcostovrld numeric, pinvhistid integer) OWNER TO admin;

--
-- TOC entry 2020 (class 1255 OID 146566844)
-- Dependencies: 4536 8
-- Name: postitemlocseries(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postitemlocseries(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemlocseries ALIAS FOR $1;
  _result INTEGER;

BEGIN

  PERFORM postIntoTrialBalance(itemlocpost_glseq)
  FROM (
    SELECT DISTINCT itemlocpost_glseq, gltrans_accnt_id
    FROM itemlocpost
      JOIN gltrans ON (itemlocpost_glseq=gltrans_sequence)
    WHERE (itemlocpost_itemlocseries=pItemlocseries)
    ORDER BY gltrans_accnt_id
  ) AS data;

  PERFORM postInvHist(invhist_id)
  FROM invhist
    JOIN itemsite ON (invhist_itemsite_id=itemsite_id)
  WHERE ( (invhist_series=pItemlocseries)
  AND ( NOT invhist_posted)
  AND ( NOT itemsite_freeze) );

  DELETE FROM itemlocpost WHERE (itemlocpost_itemlocseries=pItemlocseries);

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.postitemlocseries(integer) OWNER TO admin;

--
-- TOC entry 2024 (class 1255 OID 146566845)
-- Dependencies: 4536 8
-- Name: postjournals(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postjournals(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSequence	ALIAS FOR $1;
  _transCount INTEGER := 0;
  _journalnumber INTEGER := fetchJournalNumber('J/P');
  _sequence INTEGER := fetchGLSequence();
  _sltrans RECORD;
BEGIN

--  Make sure that we balance
  IF (SELECT SUM(sltrans_amount) != 0
      FROM sltrans
      WHERE ((NOT sltrans_posted )
       AND (sltrans_sequence=pSequence))) THEN
     RAISE EXCEPTION 'Can not post journals. Transactions do not balance in selected date range.';
  END IF;

--  March through the sltrans members, posting them one at a time
  FOR _sltrans IN SELECT sltrans_source, sltrans_accnt_id,
                          SUM(sltrans_amount) as amount
                     FROM sltrans
                    WHERE ((sltrans_amount<>0.0)
                      AND  (NOT sltrans_posted)
                      AND  (sltrans_sequence=pSequence))
                    GROUP BY sltrans_source, sltrans_accnt_id LOOP

-- refuse to accept postings into closed periods
    IF (SELECT BOOL_AND(COALESCE(period_closed, FALSE))
        FROM accnt LEFT OUTER JOIN
             period ON (CURRENT_DATE BETWEEN period_start AND period_end)
        WHERE (accnt_id = _sltrans.sltrans_accnt_id)) THEN
      RAISE EXCEPTION 'Cannot post to closed period (%).', _sltrans.sltrans_distdate;
      RETURN -4;        -- remove raise exception when all callers check return code
    END IF;

-- refuse to accept postings into frozen periods without proper priv
    IF (SELECT NOT BOOL_AND(checkPrivilege('PostFrozenPeriod')) AND
               BOOL_AND(COALESCE(period_freeze, FALSE))
        FROM accnt LEFT OUTER JOIN
             period ON (CURRENT_DATE BETWEEN period_start AND period_end)
        WHERE (accnt_id = _sltrans.sltrans_accnt_id)) THEN
      RAISE EXCEPTION 'Cannot post to frozen period (%).', _sltrans.sltrans_distdate;
      RETURN -4;        -- remove raise exception when all callers check return code
    END IF;

    IF (_sltrans.amount != 0) THEN
       INSERT INTO gltrans
        ( gltrans_posted, gltrans_exported, gltrans_created, gltrans_date,
          gltrans_sequence, gltrans_accnt_id, gltrans_source, gltrans_notes,
          gltrans_doctype, gltrans_docnumber, gltrans_amount, gltrans_journalnumber, gltrans_rec )
        VALUES
        ( FALSE, FALSE, CURRENT_TIMESTAMP, CURRENT_DATE,
          _sequence, _sltrans.sltrans_accnt_id, _sltrans.sltrans_source, 'Journal Posting',
          'JP', _journalnumber, _sltrans.amount, _journalnumber, TRUE );

      _transCount := _transCount + 1;
    END IF;
  END LOOP;

--  Update all of the posted sltrans members
  UPDATE sltrans SET
    sltrans_posted=true,
    sltrans_gltrans_journalnumber=_journalnumber
  WHERE ((NOT sltrans_posted)
    AND (sltrans_sequence=pSequence));

  PERFORM postIntoTrialBalance(_sequence);

  RETURN _journalnumber;

END;
$_$;


ALTER FUNCTION public.postjournals(integer) OWNER TO admin;

--
-- TOC entry 2025 (class 1255 OID 146566846)
-- Dependencies: 4536 8
-- Name: postjournals(text[], date, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postjournals(text[], date, date, date) RETURNS SETOF integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSources		ALIAS FOR $1;
  pStartDate 		ALIAS FOR $2;
  pEndDate		ALIAS FOR $3;
  pDistDate     	ALIAS FOR $4;
  _i INTEGER;
BEGIN
  FOR _i IN 1..ARRAY_UPPER(pSources,1)
  LOOP
    RETURN NEXT postJournals(pSources[_i], pStartDate, pEndDate, pDistDate);
  END LOOP;
  RETURN;
END;
$_$;


ALTER FUNCTION public.postjournals(text[], date, date, date) OWNER TO admin;

--
-- TOC entry 2026 (class 1255 OID 146566847)
-- Dependencies: 4536 8
-- Name: postjournals(text, date, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postjournals(text, date, date, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSource		ALIAS FOR $1;
  pStartDate 		ALIAS FOR $2;
  pEndDate		ALIAS FOR $3;
  pDistDate     	ALIAS FOR $4;
  _transCount INTEGER := 0;
  _journalnumber INTEGER := fetchJournalNumber('J/P');
  _sequence INTEGER := fetchGLSequence();
  _sltrans RECORD;
BEGIN

--  Make sure that we balance
  IF (SELECT SUM(sltrans_amount) != 0
      FROM sltrans
      WHERE ((NOT sltrans_posted )
       AND (sltrans_source=pSource)
       AND (sltrans_date BETWEEN pStartDate AND pEndDate))) THEN
     RAISE EXCEPTION 'Can not post journals. Transactions do not balance in selected date range.';
  END IF;

--  March through the sltrans members, posting them one at a time
  FOR _sltrans IN SELECT sltrans_source, sltrans_accnt_id,
                          SUM(sltrans_amount) as amount
                     FROM sltrans
                    WHERE ((sltrans_amount<>0.0)
                      AND  (NOT sltrans_posted)
                      AND  (sltrans_source=pSource)
                      AND  (sltrans_date BETWEEN pStartDate AND pEndDate))
                    GROUP BY sltrans_source, sltrans_accnt_id LOOP

-- refuse to accept postings into frozen periods if any of the accounts disallow it
    IF (SELECT NOT BOOL_AND(checkPrivilege('PostFrozenPeriod')) AND
               BOOL_AND(COALESCE(period_freeze, FALSE))
        FROM accnt LEFT OUTER JOIN
             period ON (pDistDate BETWEEN period_start AND period_end)
        WHERE (accnt_id = _sltrans.sltrans_accnt_id)) THEN
      RAISE EXCEPTION 'Cannot post to frozen period (%).', _sltrans.sltrans_distdate;
      RETURN -4;        -- remove raise exception when all callers check return code
    END IF;

    IF (_sltrans.amount != 0) THEN
       INSERT INTO gltrans
        ( gltrans_posted, gltrans_exported, gltrans_created, gltrans_date,
          gltrans_sequence, gltrans_accnt_id, gltrans_source, gltrans_notes,
          gltrans_doctype, gltrans_docnumber, gltrans_amount, gltrans_journalnumber )
        VALUES
        ( FALSE, FALSE, CURRENT_TIMESTAMP, pDistDate,
          _sequence, _sltrans.sltrans_accnt_id, _sltrans.sltrans_source, 'Journal Posting',
          'JP', _journalnumber, _sltrans.amount, _journalnumber );

      _transCount := _transCount + 1;
    END IF;
  END LOOP;

--  Update all of the posted sltrans members
  UPDATE sltrans SET
    sltrans_posted=true,
    sltrans_gltrans_journalnumber=_journalnumber
  WHERE ((NOT sltrans_posted)
    AND (sltrans_source=pSource)
    AND (sltrans_date BETWEEN pStartDate AND pEndDate));

  PERFORM postIntoTrialBalance(_sequence);

  RETURN _journalnumber;

END;
$_$;


ALTER FUNCTION public.postjournals(text, date, date, date) OWNER TO admin;

--
-- TOC entry 2028 (class 1255 OID 146566849)
-- Dependencies: 4536 8
-- Name: postmessage(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postmessage(text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pUsername ALIAS FOR $1;
  pText ALIAS FOR $2;
  _msgid INTEGER;

BEGIN

  SELECT NEXTVAL('msg_msg_id_seq') INTO _msgid;
  INSERT INTO msg
  (msg_id, msg_posted, msg_scheduled, msg_expires, msg_username, msg_text)
  VALUES
  (_msgid, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, endOfTime(), getEffectiveXtUser(), pText);

  INSERT INTO msguser
  ( msguser_msg_id, msguser_username )
  VALUES
  ( _msgid, pUsername );

  NOTIFY "messagePosted";

  RETURN _msgid;

END;
$_$;


ALTER FUNCTION public.postmessage(text, text) OWNER TO admin;

--
-- TOC entry 2027 (class 1255 OID 146566848)
-- Dependencies: 4536 8
-- Name: postmessage(timestamp without time zone, timestamp without time zone, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postmessage(timestamp without time zone, timestamp without time zone, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pScheduled ALIAS FOR $1;
  pExpires ALIAS FOR $2;
  pText ALIAS FOR $3;
  _msgid INTEGER;

BEGIN

  SELECT NEXTVAL('msg_msg_id_seq') INTO _msgid;
  INSERT INTO msg
  (msg_id, msg_posted, msg_scheduled, msg_expires, msg_username, msg_text)
  VALUES
  (_msgid, CURRENT_TIMESTAMP, pScheduled, pExpires, getEffectiveXtUser(), pText);

  INSERT INTO msguser
  ( msguser_msg_id, msguser_username )
  SELECT _msgid, usr_username
  FROM usr
  WHERE (usr_username <> getEffectiveXtUser());

  NOTIFY "messagePosted";

  RETURN _msgid;

END;
$_$;


ALTER FUNCTION public.postmessage(timestamp without time zone, timestamp without time zone, text) OWNER TO admin;

--
-- TOC entry 2029 (class 1255 OID 146566850)
-- Dependencies: 4536 8
-- Name: postmessage(timestamp without time zone, timestamp without time zone, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postmessage(timestamp without time zone, timestamp without time zone, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pScheduled ALIAS FOR $1;
  pExpires ALIAS FOR $2;
  pUsername ALIAS FOR $3;
  pText ALIAS FOR $4;
  _msgid INTEGER;

BEGIN

  SELECT NEXTVAL('msg_msg_id_seq') INTO _msgid;
  INSERT INTO msg
  (msg_id, msg_posted, msg_scheduled, msg_expires, msg_username, msg_text)
  VALUES
  (_msgid, CURRENT_TIMESTAMP, pScheduled, pExpires, getEffectiveXtUser(), pText);

  INSERT INTO msguser
  ( msguser_msg_id, msguser_username )
  VALUES
  ( _msgid, pUsername );

  NOTIFY "messagePosted";

  RETURN _msgid;

END;
$_$;


ALTER FUNCTION public.postmessage(timestamp without time zone, timestamp without time zone, text, text) OWNER TO admin;

--
-- TOC entry 2030 (class 1255 OID 146566851)
-- Dependencies: 4536 8
-- Name: postmisccount(integer, numeric, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postmisccount(pitemsiteid integer, pqty numeric, pcomments text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pQty ALIAS FOR $2;
  pComments ALIAS FOR $3;
  _invcntid INTEGER;
  _result INTEGER;

BEGIN

--  Make sure the passed itemsite points to a real item
  IF ( ( SELECT (item_type IN ('R', 'F') OR itemsite_costmethod = 'J')
         FROM itemsite, item
         WHERE ( (itemsite_item_id=item_id)
          AND (itemsite_id=pItemsiteid) ) ) ) THEN
    RETURN 0;
  END IF;

  SELECT invcnt_id INTO _invcntid
  FROM invcnt
  WHERE ( (NOT invcnt_posted)
   AND (invcnt_itemsite_id=pItemsiteid) );

  IF (_invcntid IS NULL) THEN
    _invcntid := NEXTVAL('invcnt_invcnt_id_seq');

    INSERT INTO invcnt
     ( invcnt_id, invcnt_itemsite_id, invcnt_tagdate,
       invcnt_qoh_before, invcnt_qoh_after,
       invcnt_tag_username, invcnt_cntdate, invcnt_cnt_username,
       invcnt_postdate, invcnt_post_username, invcnt_posted,
       invcnt_priority, invcnt_comments )
    SELECT _invcntid, pItemsiteid, now(),
           itemsite_qtyonhand, pQty,
           getEffectiveXtUser(), now(), getEffectiveXtUser(),
           now(), getEffectiveXtUser(), FALSE,
           FALSE, pComments
    FROM itemsite
    WHERE (itemsite_id=pItemsiteid);

    SELECT postCountTag(_invcntid, FALSE) INTO _result;
    IF (_result < 0) THEN
      DELETE FROM invcnt
      WHERE (invcnt_id=_invcntid);
    END IF;

    RETURN _result;
  ELSE
    RETURN -2;
  END IF;

END;
$_$;


ALTER FUNCTION public.postmisccount(pitemsiteid integer, pqty numeric, pcomments text) OWNER TO admin;

--
-- TOC entry 2011 (class 1255 OID 146566852)
-- Dependencies: 4536 8
-- Name: postpogltransactions(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postpogltransactions() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  UPDATE gltrans
  SET gltrans_exported=TRUE
  WHERE ( (NOT gltrans_exported)
   AND (gltrans_source='A/P')
   AND (gltrans_doctype IN ('VO')) );

  RETURN TRUE;

END;
$$;


ALTER FUNCTION public.postpogltransactions() OWNER TO admin;

--
-- TOC entry 2021 (class 1255 OID 146566853)
-- Dependencies: 4536 8
-- Name: postporeceipt(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postporeceipt(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN postReceipt($1, $2);
END;
$_$;


ALTER FUNCTION public.postporeceipt(integer, integer) OWNER TO admin;

--
-- TOC entry 2022 (class 1255 OID 146566854)
-- Dependencies: 4536 8
-- Name: postporeceipts(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postporeceipts(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN postReceipts('PO', $1, NULL);
END;
$_$;


ALTER FUNCTION public.postporeceipts(integer) OWNER TO admin;

--
-- TOC entry 2023 (class 1255 OID 146566855)
-- Dependencies: 4536 8
-- Name: postporeturncreditmemo(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postporeturncreditmemo(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPorejectId ALIAS FOR $1;

BEGIN
  RETURN postPoReturnCreditMemo(pPorejectId, NULL);
END;
$_$;


ALTER FUNCTION public.postporeturncreditmemo(integer) OWNER TO admin;

--
-- TOC entry 2031 (class 1255 OID 146566856)
-- Dependencies: 4536 8
-- Name: postporeturncreditmemo(integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postporeturncreditmemo(integer, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPorejectId ALIAS FOR $1;
  pAmount ALIAS FOR $2;
  _p RECORD;
  _a RECORD;
  _itemsiteId INTEGER;
  _docNumber TEXT;
  _sequence INTEGER;
  _journalNumber INTEGER;
  _apopenid INTEGER;
  _exchGainItem NUMERIC;
  _itemAmount_base NUMERIC;
  _itemAmount NUMERIC;
  _glseriesTotal NUMERIC;
  _tmpTotal NUMERIC;
  _test INTEGER;
  _exchDate DATE;
  _tax RECORD;
  _taxAmount NUMERIC := 0;
  _taxAmount_base NUMERIC;
  _apaccntid INTEGER;

BEGIN
--Set things up
  SELECT NEXTVAL('apopen_apopen_id_seq') INTO _apopenid;
  SELECT fetchGLSequence() INTO _sequence;
  SELECT fetchJournalNumber('AP-MISC') INTO _journalNumber;
  SELECT fetchapmemonumber() INTO _docNumber;
  _glseriesTotal := 0;

--Get poreject data
  SELECT pohead_vend_id, pohead_number, pohead_curr_id, pohead_orderdate, pohead_taxzone_id,
         poitem_id, poitem_itemsite_id,poitem_expcat_id, poitem_taxtype_id,
        itemsite_costcat_id, poreject_qty, poreject_date,
        ('Return of Item ' || COALESCE(item_number,poitem_vend_item_number)
           || ', qty. ' || formatqty(poreject_qty)) AS notes,
        poreject_value AS value,
        currToBase(pohead_curr_id,(poitem_unitprice * poreject_qty),CURRENT_DATE) AS itemAmount_base,
        (poitem_unitprice * poreject_qty) AS itemAmount
        INTO _p
  FROM pohead, poreject, poitem
        LEFT OUTER JOIN itemsite ON (poitem_itemsite_id=itemsite_id)
        LEFT OUTER JOIN item ON (itemsite_item_id=item_id)
  WHERE ((poreject_poitem_id=poitem_id)
  AND (pohead_id=poitem_pohead_id)
  AND (poreject_id=pPorejectId));

  _itemAmount := _p.itemAmount;
  _itemAmount_base := _p.itemAmount_base;
  IF (pAmount IS NOT NULL) THEN
    _itemAmount := pAmount;
    _itemAmount_base := currToBase(_p.pohead_curr_id, pAmount, CURRENT_DATE);
  END IF;


--  Grab the G/L Accounts
  IF (COALESCE(_p.poitem_itemsite_id, -1) = -1) THEN
    SELECT pp.accnt_id AS pp_accnt_id,
           lb.accnt_id AS lb_accnt_id INTO _a
    FROM expcat, accnt AS pp, accnt AS lb
    WHERE ( (expcat_purchprice_accnt_id=pp.accnt_id)
     AND (expcat_liability_accnt_id=lb.accnt_id)
     AND (expcat_id=_p.poitem_expcat_id) );
    IF (NOT FOUND) THEN
      RAISE EXCEPTION 'Cannot Post Credit Memo due to unassigned G/L Accounts.';
    END IF;
  ELSE
    SELECT pp.accnt_id AS pp_accnt_id,
           lb.accnt_id AS lb_accnt_id INTO _a
    FROM costcat, accnt AS pp, accnt AS lb
    WHERE ( (costcat_purchprice_accnt_id=pp.accnt_id)
     AND (costcat_liability_accnt_id=lb.accnt_id)
     AND (costcat_id=_p.itemsite_costcat_id) );
    IF (NOT FOUND) THEN
      RAISE EXCEPTION 'Cannot Post Credit Memo due to unassigned G/L Accounts.';
    END IF;
  END IF;

--  AP Open Item record
    INSERT INTO apopen
    ( apopen_id, apopen_username, apopen_journalnumber,
      apopen_vend_id, apopen_docnumber, apopen_doctype, apopen_ponumber,
      apopen_docdate, apopen_duedate, apopen_distdate, apopen_terms_id,
      apopen_amount, apopen_paid, apopen_open, apopen_notes, apopen_accnt_id, apopen_curr_id,
      apopen_closedate )
    VALUES
    ( _apopenid, getEffectiveXtUser(), _journalNumber,
      _p.pohead_vend_id, _docNumber, 'C', _p.pohead_number,
      CURRENT_DATE, CURRENT_DATE, CURRENT_DATE, -1,
      round(_itemAmount, 2), 0, (round(_itemAmount, 2) <> 0), _p.notes, -1, _p.pohead_curr_id,
      CASE WHEN (round(_itemAmount, 2) = 0) THEN _p.poreject_date END );

-- Taxes
    FOR _tax IN
      SELECT taxdetail_tax_id, sum(taxdetail_tax) AS taxdetail_tax,
        currToBase(_p.pohead_curr_id, round(sum(taxdetail_tax),2), current_date) AS taxbasevalue
      FROM calculateTaxDetail(_p.pohead_taxzone_id, _p.poitem_taxtype_id,
	  		       current_date, _p.pohead_curr_id,
			       _itemAmount)
      GROUP BY taxdetail_tax_id
    LOOP
      INSERT INTO apopentax (taxhist_basis,taxhist_percent,taxhist_amount,taxhist_docdate, taxhist_tax_id, taxhist_tax,
                             taxhist_taxtype_id, taxhist_parent_id, taxhist_journalnumber )
      VALUES (0, 0, 0, current_date, _tax.taxdetail_tax_id, _tax.taxdetail_tax, getadjustmenttaxtypeid(),
              _apopenid, _journalNumber);

      _taxAmount := _taxAmount + _tax.taxdetail_tax;

    END LOOP;

    _taxAmount_base := addTaxToGLSeries(_sequence,
		       'A/P', 'CM', _docNumber,
		       _p.pohead_curr_id, current_date, current_date,
                      'apopentax', _apopenid,
                      _p.notes);

    UPDATE apopen SET apopen_amount = round(_itemAmount + _taxAmount,2)
    WHERE (apopen_id = _apopenid);

--  Distribute from the clearing account
    PERFORM insertIntoGLSeries( _sequence, 'A/P', 'CM', _docNumber,
                _a.lb_accnt_id,
                round(_p.value, 2),
                current_date, _p.notes );
    _glseriesTotal := _glseriesTotal + round(_p.value, 2);

--  Distribute the remaining variance to the Purchase Price Variance account
    IF (round(_itemAmount_base, 2) <> round(_p.value, 2)) THEN
      _tmpTotal := round(_itemAmount_base, 2) - round(_p.value, 2);
      PERFORM insertIntoGLSeries( _sequence, 'A/P', 'CM', _docNumber,
                                  _a.pp_accnt_id,
                                  _tmpTotal,
                                  current_date, _p.notes );
        _glseriesTotal := _glseriesTotal + _tmpTotal;
    END IF;

--  Post the reject item for this P/O Item as Invoiced
    UPDATE poreject
    SET poreject_invoiced=TRUE
    WHERE poreject_id=pPorejectId;

--  Update the qty vouchered field
    UPDATE poitem
       SET poitem_qty_vouchered = (poitem_qty_vouchered - _p.poreject_qty)
     WHERE (poitem_id=_p.poitem_id);

--  Post to A/P
  SELECT findAPAccount(_p.pohead_vend_id) INTO _apaccntid;
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Cannot Post Credit Memo due to an unassigned A/P Account.';
  END IF;

  SELECT insertIntoGLSeries( _sequence, 'A/P', 'CM', _docNumber,
                             _apaccntid, round(_itemAmount_base + _taxAmount_base, 2) *-1,
                             current_date, _p.notes ) INTO _test;
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Cannot Post Credit Memo.';
  END IF;

-- Clean up loose ends

  _glseriesTotal := _glseriesTotal + round(_itemAmount_base, 2)*-1;

  IF (round(_glseriesTotal, 2) != 0) THEN
        PERFORM insertIntoGLSeries(_sequence, 'A/P', 'CM',
            'Currency Exchange Rounding - ' || _docNumber,
            getGainLossAccntId(_apaccntid), round(_glseriesTotal, 2) * -1,
           current_date, _p.notes);
  END IF;

--  Post it all
  PERFORM postGLSeries(_sequence, _journalNumber);

  RETURN _journalNumber;

END;
$_$;


ALTER FUNCTION public.postporeturncreditmemo(integer, numeric) OWNER TO admin;

--
-- TOC entry 1953 (class 1255 OID 146566858)
-- Dependencies: 4536 8
-- Name: postporeturns(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postporeturns(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPoheadid ALIAS FOR $1;
  _itemlocSeries INTEGER;
  _p RECORD;
  _returnval	INTEGER;

BEGIN

  _itemlocSeries := 0;

  SELECT postPoReturns(pPoheadid,false) INTO _itemlocseries;

  RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.postporeturns(integer) OWNER TO admin;

--
-- TOC entry 1954 (class 1255 OID 146566859)
-- Dependencies: 4536 8
-- Name: postporeturns(integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postporeturns(integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPoheadid ALIAS FOR $1;
  pCreateMemo ALIAS FOR $2;
  _itemlocSeries INTEGER;
  _p RECORD;
  _returnval	INTEGER;
  _tmp        INTEGER;
  _pricevar   NUMERIC := 0.00;
  _invhistid		INTEGER;
  _journalNumber INTEGER := fetchJournalNumber('GL-MISC');

BEGIN

  _itemlocSeries := 0;

  FOR _p IN SELECT pohead_number, pohead_curr_id, poreject_id, poitem_prj_id,
		   poreject_poitem_id, poitem_id, poitem_expcat_id, poitem_linenumber,
		   currToBase(COALESCE(recv_purchcost_curr_id, pohead_curr_id),
                              COALESCE(recv_purchcost, poitem_unitprice),
			      pohead_orderdate) AS poitem_unitprice_base,
                   COALESCE(itemsite_id, -1) AS itemsiteid, poitem_invvenduomratio,
                   SUM(poreject_qty) AS totalqty,
                   itemsite_item_id, itemsite_costmethod, itemsite_controlmethod, recv_date
            FROM pohead JOIN poitem ON (poitem_pohead_id=pohead_id)
                        JOIN poreject ON (poreject_poitem_id=poitem_id AND NOT poreject_posted)
                        LEFT OUTER JOIN itemsite ON (poitem_itemsite_id=itemsite_id)
                        LEFT OUTER JOIN recv ON (recv_id=poreject_recv_id)
            WHERE (pohead_id=pPoheadid)
            GROUP BY poreject_id, pohead_number, poreject_poitem_id, poitem_id, poitem_prj_id,
		     poitem_expcat_id, poitem_linenumber, poitem_unitprice, pohead_curr_id,
		     pohead_orderdate, itemsite_id, poitem_invvenduomratio,
                     itemsite_item_id, itemsite_costmethod, itemsite_controlmethod, recv_date,
                     recv_purchcost_curr_id, recv_purchcost LOOP

    IF (_p.itemsiteid = -1) THEN
        SELECT insertGLTransaction( 'S/R', 'PO', _p.pohead_number, 'Return Non-Inventory to P/O',
                                     expcat_liability_accnt_id,
                                     getPrjAccntId(_p.poitem_prj_id, expcat_exp_accnt_id), -1,
                                     round(_p.poitem_unitprice_base * _p.totalqty * -1, 2),
				     CURRENT_DATE ) INTO _returnval
        FROM expcat
        WHERE (expcat_id=_p.poitem_expcat_id);

        UPDATE poreject
        SET poreject_posted=TRUE, poreject_value= round(_p.poitem_unitprice_base * _p.totalqty, 2)
        WHERE (poreject_id=_p.poreject_id);

    ELSEIF (_p.itemsite_controlmethod='N') THEN
      SELECT insertGLTransaction('S/R', 'PO', _p.pohead_number, 'Return Non-Controlled Inventory from PO',
                                 costcat_liability_accnt_id,
                                 getPrjAccntId(_p.poitem_prj_id, costcat_exp_accnt_id), -1,
                                 round((_p.poitem_unitprice_base * _p.totalqty * -1), 2),
                                 CURRENT_DATE ) INTO _returnval
      FROM itemsite, costcat
      WHERE((itemsite_costcat_id=costcat_id)
        AND (itemsite_id=_p.itemsiteid));
      IF (_returnval = -3) THEN -- zero value transaction
        _returnval := 0;
      END IF;
      UPDATE poreject
      SET poreject_posted=TRUE, poreject_value= round(_p.poitem_unitprice_base * _p.totalqty, 2)
      WHERE (poreject_id=_p.poreject_id);
    ELSE
      IF (_itemlocSeries = 0) THEN
        SELECT NEXTVAL('itemloc_series_seq') INTO _itemlocSeries;
      END IF;

      SELECT postInvTrans( itemsite_id, 'RP', (_p.totalqty * _p.poitem_invvenduomratio * -1),
                           'S/R', 'PO', (_p.pohead_number || '-' || _p.poitem_linenumber::TEXT), '', 'Return Inventory to P/O',
                           costcat_asset_accnt_id, costcat_liability_accnt_id, _itemlocSeries, CURRENT_TIMESTAMP) INTO _returnval
      FROM itemsite, costcat
      WHERE ( (itemsite_costcat_id=costcat_id)
       AND (itemsite_id=_p.itemsiteid) );

      UPDATE poreject
      SET poreject_posted=TRUE, poreject_value=(invhist_unitcost *_p.totalqty * _p.poitem_invvenduomratio)
      FROM invhist
      WHERE ((poreject_id=_p.poreject_id)
      AND (invhist_id=_returnval));

    END IF;

    IF (_returnval < 0) THEN
      RETURN _returnval;
    END IF;


    UPDATE poitem
    SET poitem_qty_returned=(poitem_qty_returned + _p.totalqty),
	poitem_status='O'
    WHERE (poitem_id=_p.poitem_id);

      IF (fetchMetricBool('RecordPPVonReceipt')) THEN -- If the 'Purchase Price Variance on Receipt' option is true
         _invhistid := _returnval;
         -- Find the difference in the purchase price value expected from the P/O and the value of the transaction
         SELECT ((_p.poitem_unitprice_base * poitem_qty_returned) - (invhist_value_before - invhist_value_after)) INTO _pricevar
         FROM invhist, poitem
         WHERE ((invhist_id = _invhistid)
           AND  (poitem_id=_p.poitem_id));

         -- If difference exists then
         IF (_pricevar <> 0.00) THEN
           -- Record an additional GL Transaction for the purchase price variance
           SELECT insertGLTransaction( _journalNumber,
                'S/R', 'PO', _p.pohead_number,
                                       'Purchase price variance adjusted for P/O ' || _p.pohead_number || ' for item ' || _p.poitem_linenumber::TEXT,
                                       costcat_liability_accnt_id,
                                       getPrjAccntId(_p.poitem_prj_id, costcat_purchprice_accnt_id), -1,
                                       _pricevar,
                                       CURRENT_DATE, false ) INTO _tmp
           FROM itemsite, costcat, poitem
           WHERE ((itemsite_costcat_id=costcat_id)
              AND (itemsite_id=poitem_itemsite_id) );
           IF (NOT FOUND) THEN
             RAISE EXCEPTION 'Could not insert G/L transaction: no cost category found for itemsite_id %',
             _p.itemsiteid;
           ELSIF (_tmp < 0 AND _tmp != -3) THEN -- error but not 0-value transaction
             RETURN _tmp;
           ELSE
             -- Posting to trial balance is deferred to prevent locking
             INSERT INTO itemlocpost ( itemlocpost_glseq, itemlocpost_itemlocseries)
             VALUES ( _tmp, _itemlocSeries );
           END IF;
         END IF;
       END IF;

    IF (pCreateMemo) THEN
	SELECT postPoReturnCreditMemo(_p.poreject_id) INTO _returnval;
    END IF;

    IF (_returnval < 0) THEN
      RETURN _returnval;
    END IF;

  END LOOP;

  RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.postporeturns(integer, boolean) OWNER TO admin;

--
-- TOC entry 2032 (class 1255 OID 146566861)
-- Dependencies: 4536 8
-- Name: postproduction(integer, numeric, boolean, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postproduction(integer, numeric, boolean, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RAISE NOTICE 'postProduction(INTEGER, NUMERIC, BOOLEAN, BOOLEAN) is deprecated. please use postProduction(INTEGER, NUMERIC, BOOLEAN, INTEGER, TIMESTAMP WITH TIME ZONE) instead';
  RETURN postProduction($1, $2, $3, 0, now());
END;
$_$;


ALTER FUNCTION public.postproduction(integer, numeric, boolean, boolean) OWNER TO admin;

--
-- TOC entry 2033 (class 1255 OID 146566862)
-- Dependencies: 4536 8
-- Name: postproduction(integer, numeric, boolean, boolean, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postproduction(integer, numeric, boolean, boolean, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RAISE NOTICE 'postProduction(INTEGER, NUMERIC, BOOLEAN, BOOLEAN, INTEGER) is deprecated. please use postProduction(INTEGER, NUMERIC, BOOLEAN, INTEGER, TIMESTAMP WITH TIME ZONE) instead';
  RETURN postProduction($1, $2, $3, $5, now());
END;
$_$;


ALTER FUNCTION public.postproduction(integer, numeric, boolean, boolean, integer) OWNER TO admin;

--
-- TOC entry 2035 (class 1255 OID 146566864)
-- Dependencies: 4536 8
-- Name: postproduction(integer, numeric, boolean, integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postproduction(integer, numeric, boolean, integer, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoid          ALIAS FOR $1;
  pQty           ALIAS FOR $2;
  pBackflush     ALIAS FOR $3;
  pItemlocSeries ALIAS FOR $4;
  pGlDistTS      ALIAS FOR $5;
  _test          INTEGER;
  _invhistid     INTEGER;
  _itemlocSeries INTEGER;
  _parentQty     NUMERIC;
  _r             RECORD;
  _sense         TEXT;
  _wipPost       NUMERIC;
  _woNumber      TEXT;
  _ucost         NUMERIC;

BEGIN

  IF (pQty = 0) THEN
    RETURN 0;
  ELSIF (pQty > 0) THEN
    _sense = 'from';
  ELSE
    _sense = 'to';
  END IF;

  IF ( ( SELECT wo_status
         FROM wo
         WHERE (wo_id=pWoid) ) NOT IN  ('R','E','I') ) THEN
    RETURN -1;
  END IF;

--  Make sure that all Component Item Sites exist
  SELECT bomitem_id INTO _test
  FROM wo, bomitem, itemsite
  WHERE ( (wo_itemsite_id=itemsite_id)
   AND (itemsite_item_id=bomitem_parent_item_id)
   AND (woEffectiveDate(wo_startdate) BETWEEN bomitem_effective AND (bomitem_expires - 1))
   AND (wo_id=pWoid)
   AND (bomitem_rev_id=wo_bom_rev_id)
   AND (bomitem_item_id NOT IN
        ( SELECT component.itemsite_item_id
          FROM itemsite AS component, itemsite AS parent
          WHERE ( (wo_itemsite_id=parent.itemsite_id)
           AND (parent.itemsite_item_id=bomitem_parent_item_id)
           AND (bomitem_item_id=component.itemsite_item_id)
           AND (woEffectiveDate(wo_startdate) BETWEEN bomitem_effective AND (bomitem_expires - 1))
           AND (bomitem_rev_id=wo_bom_rev_id)
           AND (component.itemsite_active)
           AND (component.itemsite_warehous_id=parent.itemsite_warehous_id) ) ) ) )
  LIMIT 1;
  IF (FOUND AND pBackflush) THEN
    RETURN -2;
  END IF;

  SELECT formatWoNumber(pWoid) INTO _woNumber;

  SELECT roundQty(item_fractional, pQty) INTO _parentQty
  FROM wo, itemsite, item
  WHERE ((wo_itemsite_id=itemsite_id)
   AND (itemsite_item_id=item_id)
   AND (wo_id=pWoid));

--  Create the material receipt transaction
  IF (pItemlocSeries = 0) THEN
    SELECT NEXTVAL('itemloc_series_seq') INTO _itemlocSeries;
  ELSE
    _itemlocSeries = pItemlocSeries;
  END IF;

  IF (pBackflush) THEN
    FOR _r IN SELECT womatl_id, womatl_qtyiss +
		     (CASE
		       WHEN (womatl_qtywipscrap >  ((womatl_qtyfxd + (_parentQty + wo_qtyrcv) * womatl_qtyper) * womatl_scrap)) THEN
                         (womatl_qtyfxd + (_parentQty + wo_qtyrcv) * womatl_qtyper) * womatl_scrap
		       ELSE
		         womatl_qtywipscrap
		      END) AS consumed,
		     (womatl_qtyfxd + ((_parentQty + wo_qtyrcv) * womatl_qtyper)) * (1 + womatl_scrap) AS expected
	      FROM womatl, wo, itemsite, item
	      WHERE ((womatl_issuemethod IN ('L', 'M'))
		AND  (womatl_wo_id=pWoid)
		AND  (womatl_wo_id=wo_id)
		AND  (womatl_itemsite_id=itemsite_id)
		AND  (itemsite_item_id=item_id)) LOOP
      -- Don't issue more than should have already been consumed at this point
      IF (pQty > 0) THEN
        IF (noNeg(_r.expected - _r.consumed) > 0) THEN
          SELECT issueWoMaterial(_r.womatl_id, noNeg(_r.expected - _r.consumed), _itemlocSeries, pGlDistTS) INTO _itemlocSeries;
        END IF;
      ELSE
        -- Used by postMiscProduction of disassembly
        SELECT returnWoMaterial(_r.womatl_id, (_r.expected * -1.0), _itemlocSeries, CURRENT_TIMESTAMP, true) INTO _itemlocSeries;
      END IF;

      UPDATE womatl
      SET womatl_issuemethod='L'
      WHERE ( (womatl_issuemethod='M')
       AND (womatl_id=_r.womatl_id) );

    END LOOP;
  END IF;

  SELECT CASE WHEN (pQty < 0 AND itemsite_costmethod='S') THEN stdcost(itemsite_item_id) * pQty
              WHEN (pQty < 0) THEN avgcost(itemsite_id) * pQty
              WHEN (wo_cosmethod = 'D') THEN wo_wipvalue
              ELSE  round((wo_wipvalue - (wo_postedvalue / wo_qtyord * (wo_qtyord -
                    CASE WHEN (wo_qtyord < wo_qtyrcv + pQty) THEN wo_qtyord
                         ELSE wo_qtyrcv + pQty
                    END ))),2)
         END INTO _wipPost
  FROM wo
    JOIN itemsite ON (wo_itemsite_id=itemsite_id)
  WHERE (wo_id=pWoid);

  SELECT postInvTrans( itemsite_id, 'RM', _parentQty,
                       'W/O', 'WO', _woNumber, '', ('Receive Inventory ' || item_number || ' ' || _sense || ' Manufacturing'),
                       costcat_asset_accnt_id, getPrjAccntId(wo_prj_id, costcat_wip_accnt_id), _itemlocSeries, pGlDistTS,
                       -- the following is only actually used when the item is average or job costed
                       _wipPost ) INTO _invhistid
  FROM wo, itemsite, item, costcat
  WHERE ( (wo_itemsite_id=itemsite_id)
   AND (itemsite_item_id=item_id)
   AND (itemsite_costcat_id=costcat_id)
   AND (wo_id=pWoid) );

  IF (pQty < 0 ) THEN
    _wipPost := _wipPost * -1;
  END IF;

--  Increase this W/O's received qty decrease its WIP value
  UPDATE wo
  SET wo_qtyrcv = (wo_qtyrcv + _parentQty),
      wo_wipvalue = (wo_wipvalue - (CASE WHEN (itemsite_costmethod IN ('A','J'))
                                               THEN _wipPost
                                         WHEN (itemsite_costmethod='S')
                                               THEN (stdcost(itemsite_item_id) * _parentQty)
                                         ELSE 0.0  END))
  FROM itemsite, item
  WHERE ((wo_itemsite_id=itemsite_id)
   AND (itemsite_item_id=item_id)
   AND (wo_id=pWoid));

--  ROB Increase this W/O's WIP value for custom costing
  SELECT SUM(itemcost_stdcost * _parentQty) INTO _ucost
  FROM wo JOIN itemsite ON (itemsite_id=wo_itemsite_id)
          JOIN itemcost ON (itemcost_item_id=itemsite_item_id)
          JOIN costelem ON ((costelem_id=itemcost_costelem_id) AND
                            (costelem_exp_accnt_id IS NOT NULL) AND
                            (NOT costelem_sys))
  WHERE (wo_id=pWoid);

  UPDATE wo
  SET wo_wipvalue = (wo_wipvalue + coalesce(_ucost,0))
  WHERE (wo_id=pWoid);

--  ROB Distribute to G/L - create Cost Variance, debit WIP
  PERFORM insertGLTransaction( 'W/O', 'WO', _woNumber,
                               ('Post Other Cost ' || item_number || ' ' || _sense || ' Manufacturing'),
                               getPrjAccntId(wo_prj_id, costelem_exp_accnt_id),
                               getPrjAccntId(wo_prj_id,costcat_wip_accnt_id), _invhistid,
			       (itemcost_stdcost * _parentQty),
                                pGlDistTS::DATE )
FROM wo, costelem, itemcost, costcat, itemsite, item
WHERE
  ((wo_id=pWoid) AND
  (wo_itemsite_id=itemsite_id) AND
  (itemsite_item_id=item_id) AND
  (costelem_id = itemcost_costelem_id) AND
  (itemcost_item_id = itemsite_item_id) AND
  (itemsite_costcat_id = costcat_id) AND
  (costelem_exp_accnt_id) IS NOT NULL  AND
  (costelem_sys = false));
--End


--  Make sure the W/O is at issue status
  UPDATE wo
  SET wo_status='I'
  WHERE (wo_id=pWoid);

  RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.postproduction(integer, numeric, boolean, integer, timestamp with time zone) OWNER TO admin;

--
-- TOC entry 2034 (class 1255 OID 146566863)
-- Dependencies: 4536 8
-- Name: postproduction(integer, numeric, boolean, boolean, integer, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postproduction(integer, numeric, boolean, boolean, integer, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RAISE NOTICE 'postProduction(INTEGER, NUMERIC, BOOLEAN, BOOLEAN, INTEGER, TEXT, TEXT) is deprecated. please use postProduction(INTEGER, NUMERIC, BOOLEAN, INTEGER, TIMESTAMP WITH TIME ZONE) instead';
  RETURN postProduction($1, $2, $3, $5, now());
END;
$_$;


ALTER FUNCTION public.postproduction(integer, numeric, boolean, boolean, integer, text, text) OWNER TO admin;

--
-- TOC entry 2036 (class 1255 OID 146566866)
-- Dependencies: 4536 8
-- Name: postreceipt(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postreceipt(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2011 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  precvid		ALIAS FOR $1;
  _itemlocSeries	INTEGER := COALESCE($2, 0);
  _freightAccnt		INTEGER;
  _glDate		TIMESTAMP WITH TIME ZONE;
  _o			RECORD;
  _ordertypeabbr	TEXT;
  _r			RECORD;
  _ra			RECORD;
  _recvinvqty          NUMERIC := 0.00;
  _recvvalue		NUMERIC := 0.00;
  _pricevar            NUMERIC := 0.00;
  _tmp			INTEGER;
  _toitemitemid		INTEGER;
  _coheadid		INTEGER;
  _coitemid		INTEGER;
  _linenumber          INTEGER;
  _invhistid		INTEGER;
  _shipheadid		INTEGER;
  _ship               	BOOLEAN;
  _i			RECORD;

BEGIN
  SELECT recv_id, recv_order_type, recv_orderitem_id, recv_qty,
	 round(currToBase(recv_freight_curr_id, recv_freight, recv_date::DATE),
	       2) AS recv_freight_base,
	 recv_freight, recv_freight_curr_id, recv_date, recv_gldistdate,
	 itemsite_id, itemsite_item_id, item_inv_uom_id, itemsite_costmethod,
         itemsite_controlmethod, vend_name, item_number, item_fractional
	 INTO _r
  FROM recv LEFT OUTER JOIN itemsite ON (recv_itemsite_id=itemsite_id)
            LEFT OUTER JOIN item ON (itemsite_item_id=item_id)
            LEFT OUTER JOIN vendinfo ON (recv_vend_id=vend_id)
  WHERE ((recv_id=precvid)
    AND  (NOT recv_posted));

  IF (NOT FOUND) THEN
    IF (_itemlocSeries = 0) THEN
      RETURN -10;
    END IF;
    RETURN _itemlocSeries;

  ELSEIF (_r.recv_qty <= 0) THEN
    RETURN -11;

  ELSIF (_r.recv_order_type ='PO') THEN
    _ordertypeabbr := ('P/O for ' || _r.vend_name || ' for item ' || _r.item_number);

    SELECT pohead_number AS orderhead_number, poitem_id AS orderitem_id,
           poitem_linenumber AS orderitem_linenumber,
	   currToBase(pohead_curr_id,
                      COALESCE(recv_purchcost, poitem_unitprice),
		      recv_date::DATE) AS item_unitprice_base,
	   poitem_invvenduomratio AS invvenduomratio,
	   pohead_orderdate AS orderdate, pohead_dropship,
	   poitem_prj_id AS prj_id INTO _o
    FROM recv, pohead, poitem
    WHERE ((recv_orderitem_id=poitem_id)
      AND  (poitem_pohead_id=pohead_id)
      AND  (NOT recv_posted)
      AND  (recv_id=precvid));
  ELSIF (_r.recv_order_type ='RA') THEN
    _ordertypeabbr := 'R/A for item ' || _r.item_number;

    SELECT rahead_id AS orderhead_id, rahead_number AS orderhead_number, raitem_id AS orderitem_id,
           raitem_linenumber AS orderitem_linenumber,
	   currToBase(rahead_curr_id, raitem_unitprice,
		    recv_date::DATE) AS item_unitprice_base,
	   raitem_qty_invuomratio AS invvenduomratio,
	   rahead_authdate AS orderdate,
	   raitem_unitcost AS unitcost,
	   rahead_prj_id AS prj_id INTO _o
    FROM recv, rahead, raitem
    WHERE ((recv_orderitem_id=raitem_id)
      AND  (raitem_rahead_id=rahead_id)
      AND  (NOT recv_posted)
      AND  (recv_id=precvid));
  ELSIF (_r.recv_order_type ='TO') THEN
     _ordertypeabbr := 'T/O for item ' || _r.item_number;

    SELECT tohead_number AS orderhead_number, toitem_id AS orderitem_id,
           toitem_linenumber AS orderitem_linenumber,
	   toitem_stdcost AS item_unitprice_base,
	   1.0 AS invvenduomratio,
	   tohead_orderdate AS orderdate,
	   NULL AS prj_id INTO _o
    FROM recv, tohead, toitem
    WHERE ((recv_orderitem_id=toitem_id)
      AND  (toitem_tohead_id=tohead_id)
      AND  (NOT recv_posted)
      AND  (recv_id=precvid));
  ELSE
    RETURN -13;	-- don't know how to handle this order type
  END IF;

  IF (NOT FOUND) THEN
    IF (_itemlocSeries = 0) THEN
      RETURN -10;
    END IF;
    RETURN _itemlocSeries;
  END IF;

  IF (_itemlocSeries = 0) THEN
    _itemlocSeries := NEXTVAL('itemloc_series_seq');
  ELSEIF (_itemlocSeries < 0) THEN
    RETURN _itemlocSeries;
  END IF;

  _glDate := COALESCE(_r.recv_gldistdate, _r.recv_date);
  _recvinvqty := roundQty(_r.item_fractional, (_r.recv_qty * _o.invvenduomratio));

  IF ( (_r.recv_order_type = 'PO') AND
        (_r.itemsite_id = -1 OR _r.itemsite_id IS NULL OR _r.itemsite_controlmethod = 'N') ) THEN

    IF (_r.itemsite_id IS NOT NULL) THEN
      SELECT insertGLTransaction( fetchJournalNumber('GL-MISC'),
				  'S/R', _r.recv_order_type, _o.orderhead_number,
	  			  'Receive Non-Controlled Inventory from ' || _ordertypeabbr,
				   costcat_liability_accnt_id,
				   getPrjAccntId(_o.prj_id, costcat_exp_accnt_id), -1,
				   round((_o.item_unitprice_base * _r.recv_qty),2),
				   _glDate::DATE, false ) INTO _tmp
      FROM poitem, itemsite, costcat
      WHERE((poitem_itemsite_id=itemsite_id)
        AND (itemsite_costcat_id=costcat_id)
        AND (poitem_id=_o.orderitem_id));
    ELSE
      SELECT insertGLTransaction(fetchJournalNumber('GL-MISC'),
				  'S/R', _r.recv_order_type, _o.orderhead_number,
	  			  'Receive Non-Inventory from ' || 'P/O for ' || _r.vend_name || ' for ' || expcat_code,
				   expcat_liability_accnt_id,
				   getPrjAccntId(_o.prj_id, expcat_exp_accnt_id), -1,
				   round((_o.item_unitprice_base * _r.recv_qty),2),
				   _glDate::DATE, false ) INTO _tmp
      FROM poitem, expcat
      WHERE((poitem_expcat_id=expcat_id)
        AND (poitem_id=_o.orderitem_id));
    END IF;


    IF (_tmp < 0 AND _tmp != -3) THEN -- error but not 0-value transaction
      RETURN _tmp;
    ELSE
      -- Posting to trial balance is deferred to prevent locking
      INSERT INTO itemlocpost ( itemlocpost_glseq, itemlocpost_itemlocseries)
      VALUES ( _tmp, _itemlocSeries );

    END IF;

    SELECT insertGLTransaction( fetchJournalNumber('GL-MISC'),
				'S/R', _r.recv_order_type, _o.orderhead_number,
				'Receive Non-Inventory Freight from ' || _ordertypeabbr,
				 expcat_liability_accnt_id,
				 getPrjAccntId(_o.prj_id, expcat_freight_accnt_id), -1,
				 _r.recv_freight_base,
				 _glDate::DATE, false ),
	   expcat_freight_accnt_id INTO _tmp, _freightAccnt
    FROM poitem, expcat
    WHERE((poitem_expcat_id=expcat_id)
      AND (poitem_id=_o.orderitem_id));

    IF (_tmp < 0 AND _tmp != -3) THEN -- error but not 0-value transaction
      RETURN _tmp;
    ELSE
      -- Posting to trial balance is deferred to prevent locking
      INSERT INTO itemlocpost ( itemlocpost_glseq, itemlocpost_itemlocseries)
      VALUES ( _tmp, _itemlocSeries );
    END IF;

    _recvvalue := ROUND((_o.item_unitprice_base * _r.recv_qty),2);

    UPDATE poitem
    SET poitem_qty_received = (poitem_qty_received + _r.recv_qty),
	poitem_freight_received = (poitem_freight_received + _r.recv_freight_base)
    WHERE (poitem_id=_o.orderitem_id);

  ELSEIF ( (_r.recv_order_type = 'RA') AND
           (_r.itemsite_id = -1 OR _r.itemsite_id IS NULL) ) THEN
    RAISE NOTICE 'itemsite controlmethod is %, cannot post receipt.', _r.itemsite_controlmethod;
    RETURN -14;	-- otherwise how do we get the accounts?

  ELSEIF ( (_r.recv_order_type = 'TO') AND
           (_r.itemsite_id = -1 OR _r.itemsite_id IS NULL) ) THEN
    RAISE NOTICE 'itemsite missing';
    RETURN -14;	-- otherwise how do we get the accounts?

  ELSE	-- not ELSIF: some code is shared between diff order types
    IF (_r.recv_order_type = 'PO') THEN
      SELECT postInvTrans( itemsite_id, 'RP'::TEXT,
			   _recvinvqty,
			   'S/R'::TEXT,
			   _r.recv_order_type::TEXT, _o.orderhead_number::TEXT || '-' || _o.orderitem_linenumber::TEXT,
			   ''::TEXT,
			   'Receive Inventory from ' || _ordertypeabbr,
			   costcat_asset_accnt_id, costcat_liability_accnt_id,
			   _itemlocSeries,
			   _glDate,
                           round((_o.item_unitprice_base * _r.recv_qty),2) -- always passing this in since it is ignored if it is not average costed item
			   ) INTO _tmp
      FROM itemsite, costcat
      WHERE ( (itemsite_costcat_id=costcat_id)
       AND (itemsite_id=_r.itemsite_id) );
      IF (NOT FOUND) THEN
	RAISE EXCEPTION 'Could not post inventory transaction: no cost category found for itemsite_id %',
	  _r.itemsite_id;
      ELSIF (_tmp < -1) THEN -- less than -1 because -1 means it is a none controlled item
	IF(_tmp = -3) THEN
	  RETURN -12; -- The GL trans value was 0 which means we likely do not have a std cost
	END IF;
	RETURN _tmp;
      END IF;

      -- If the 'Purchase Price Variance on Receipt' option is true
      IF (fetchMetricBool('RecordPPVonReceipt')) THEN
        _invhistid := _tmp;
        -- Find the difference in the purchase price value expected from the P/O and the value of the transaction
        SELECT ((_o.item_unitprice_base * _r.recv_qty) - (invhist_value_after - invhist_value_before)) INTO _pricevar
        FROM invhist
        WHERE (invhist_id = _invhistid);

        -- If difference exists then
        IF (_pricevar <> 0.00) THEN
          -- Record an additional GL Transaction for the purchase price variance
          SELECT insertGLTransaction( fetchJournalNumber('GL-MISC'),
				       'S/R', _r.recv_order_type, _o.orderhead_number,
                                      'Purchase price variance adjusted for P/O ' || _o.orderhead_number || ' for item ' || _r.item_number,
                                      costcat_liability_accnt_id,
                                      getPrjAccntId(_o.prj_id, costcat_purchprice_accnt_id), -1,
                                      _pricevar,
                                      _glDate::DATE, false ) INTO _tmp
          FROM itemsite, costcat
          WHERE ((itemsite_costcat_id=costcat_id)
             AND (itemsite_id=_r.itemsite_id) );
          IF (NOT FOUND) THEN
            RAISE EXCEPTION 'Could not insert G/L transaction: no cost category found for itemsite_id %',
            _r.itemsite_id;
          ELSIF (_tmp < 0 AND _tmp != -3) THEN -- error but not 0-value transaction
            RETURN _tmp;
          ELSE
            -- Posting to trial balance is deferred to prevent locking
            INSERT INTO itemlocpost ( itemlocpost_glseq, itemlocpost_itemlocseries)
            VALUES ( _tmp, _itemlocSeries );
          END IF;
        END IF;
      END IF;

      SELECT insertGLTransaction(fetchJournalNumber('GL-MISC'),
				  'S/R', _r.recv_order_type, _o.orderhead_number,
				  'Receive Inventory Freight from ' || _o.orderhead_number || ' for item ' || _r.item_number,
				   costcat_liability_accnt_id,
				   getPrjAccntId(_o.prj_id, costcat_freight_accnt_id), -1,
				   _r.recv_freight_base,
				   _glDate::DATE, false ),
	     costcat_freight_accnt_id INTO _tmp, _freightAccnt
      FROM itemsite, costcat
      WHERE ( (itemsite_costcat_id=costcat_id)
       AND (itemsite_id=_r.itemsite_id) );
      IF (NOT FOUND) THEN
	RAISE EXCEPTION 'Could not insert G/L transaction: no cost category found for itemsite_id %',
	  _r.itemsite_id;
      ELSIF (_tmp < 0 AND _tmp != -3) THEN -- error but not 0-value transaction
	RETURN _tmp;
      ELSE
          -- Posting to trial balance is deferred to prevent locking
          INSERT INTO itemlocpost ( itemlocpost_glseq, itemlocpost_itemlocseries)
          VALUES ( _tmp, _itemlocSeries );
      END IF;

      UPDATE poitem
      SET poitem_qty_received = (poitem_qty_received + _r.recv_qty),
	  poitem_freight_received = (poitem_freight_received + _r.recv_freight_base)
      WHERE (poitem_id=_o.orderitem_id);

    ELSIF (_r.recv_order_type = 'RA') THEN
      SELECT rahead.*, raitem.* INTO _ra
	    FROM rahead, raitem
        WHERE ((rahead_id=raitem_rahead_id)
        AND  (raitem_id=_r.recv_orderitem_id));

      IF (_r.itemsite_controlmethod = 'N') THEN
        SELECT insertGLTransaction( fetchJournalNumber('GL-MISC'),
                                    'S/R', _r.recv_order_type, _o.orderhead_number,
                                    'Receive Non-Controlled Inventory from ' || _ordertypeabbr,
                                    costcat_liability_accnt_id,
                                    getPrjAccntId(_o.prj_id, costcat_exp_accnt_id), -1,
                                    round((_o.item_unitprice_base * _r.recv_qty),2),
                                    _glDate::DATE, false ) INTO _tmp
        FROM itemsite JOIN costcat ON (costcat_id=itemsite_costcat_id)
        WHERE(itemsite_id=_r.itemsite_id);
        IF (NOT FOUND) THEN
          RAISE EXCEPTION 'Could not post inventory transaction: no cost category found for itemsite_id %', _r.itemsite_id;
--        ELSIF (_tmp < -1) THEN
--          RETURN _tmp;
        END IF;
      ELSE
        SELECT postInvTrans(_r.itemsite_id, 'RR',
                            _recvinvqty,
                            'S/R',
                            _r.recv_order_type, _ra.rahead_number::TEXT || '-' || _ra.raitem_linenumber::TEXT,
                            '',
                            'Receive Inventory from ' || _ordertypeabbr,
                            costcat_asset_accnt_id,
                            CASE WHEN(COALESCE(_ra.raitem_cos_accnt_id, -1) != -1) THEN
                                  getPrjAccntId(_o.prj_id, _ra.raitem_cos_accnt_id)
                                 WHEN (_ra.raitem_warranty) THEN
                                  getPrjAccntId(_o.prj_id, resolveCOWAccount(_r.itemsite_id, _ra.rahead_cust_id, _ra.rahead_saletype_id, _ra.rahead_shipzone_id))
                                 ELSE
                                  getPrjAccntId(_o.prj_id, resolveCORAccount(_r.itemsite_id, _ra.rahead_cust_id, _ra.rahead_saletype_id, _ra.rahead_shipzone_id))
                            END,
                            _itemlocSeries, _glDate, COALESCE(_o.unitcost,stdcost(itemsite_item_id)) * _recvinvqty) INTO _tmp
        FROM itemsite, costcat
        WHERE ( (itemsite_costcat_id=costcat_id)
         AND (itemsite_id=_r.itemsite_id) );

        IF (NOT FOUND) THEN
          RAISE EXCEPTION 'Could not post inventory transaction: no cost category found for itemsite_id %', _r.itemsite_id;
        ELSIF (_tmp < -1) THEN -- less than -1 because -1 means it is a none controlled item
          IF(_tmp = -3) THEN
            RAISE NOTICE 'The GL trans value was 0 which means we likely do not have a std cost';
            RETURN -12; -- The GL trans value was 0 which means we likely do not have a std cost
          END IF;
          RETURN _tmp;
        END IF;
      END IF;

      INSERT INTO rahist (rahist_itemsite_id, rahist_date,
			  rahist_descrip,
			  rahist_qty, rahist_uom_id,
			  rahist_source, rahist_source_id, rahist_rahead_id
	  ) VALUES (_r.itemsite_id, _glDate,
		      'Receive Inventory from ' || _ordertypeabbr,
		      _recvinvqty, _r.item_inv_uom_id,
		      'RR', _r.recv_id, _ra.rahead_id
	          );

      SELECT insertGLTransaction(fetchJournalNumber('GL-MISC'),
				  'S/R', _r.recv_order_type, _o.orderhead_number,
				  'Receive Inventory Freight from ' || _o.orderhead_number || ' for item ' || _r.item_number,
				   costcat_liability_accnt_id,
				   getPrjAccntId(_o.prj_id, costcat_freight_accnt_id), -1,
				   _r.recv_freight_base,
				   _glDate::DATE, false ),
	     costcat_freight_accnt_id INTO _tmp, _freightAccnt
      FROM itemsite, costcat
      WHERE ( (itemsite_costcat_id=costcat_id)
       AND (itemsite_id=_r.itemsite_id) );
      IF (_tmp < 0 AND _tmp != -3) THEN -- error but not 0-value transaction
	    RETURN _tmp;
      ELSE
        -- Posting to trial balance is deferred to prevent locking
        INSERT INTO itemlocpost ( itemlocpost_glseq, itemlocpost_itemlocseries)
        VALUES ( _tmp, _itemlocSeries );
      END IF;

      INSERT INTO rahist (rahist_date, rahist_descrip,
			  rahist_source, rahist_source_id,
			  rahist_curr_id, rahist_amount,
			  rahist_rahead_id
	  ) VALUES (_glDate, 'Receive Inventory Freight from ' || _ordertypeabbr,
		  'RR', _r.recv_id, _r.recv_freight_curr_id, _r.recv_freight,
		  _ra.rahead_id
	  );

      UPDATE raitem
      SET raitem_qtyreceived = (raitem_qtyreceived + _r.recv_qty)
      WHERE (raitem_id=_o.orderitem_id);

-- Expire date doesn't mean anything once the RA is received
-- WARNING: INSERTING 'NULL' MIGHT CAUSE PROBLEMS!!
      UPDATE rahead
      SET rahead_expiredate = NULL
      WHERE (rahead_id=_o.orderhead_id);

--  Look for 'ship' lines
    SELECT (count(*) > 0) INTO _ship
    FROM raitem
    WHERE ((raitem_disposition = 'S')
     AND (raitem_new_coitem_id IS NULL)
     AND (raitem_rahead_id=_ra.rahead_id));

--  If receiving a qty on a shippable and upon receipt item, create coitem
      IF ((_ra.rahead_timing='R') AND
          (_ship OR (
          (_ra.raitem_disposition IN ('P','V')) AND
          (_ra.raitem_new_coitem_id IS NULL) AND
          (_ra.raitem_qtyauthorized > 0)))) THEN

          IF (_ra.rahead_new_cohead_id IS NOT NULL) THEN
            _coheadid = _ra.rahead_new_cohead_id;
          ELSE
--  No header, so create a Sales Order header first.
            SELECT nextval('cohead_cohead_id_seq') INTO _coheadid;

            INSERT INTO cohead (
              cohead_id,cohead_number,cohead_cust_id,cohead_custponumber,
              cohead_orderdate,cohead_salesrep_id,cohead_terms_id,
              cohead_shipvia,cohead_shipto_id,cohead_shiptoname,
              cohead_shiptoaddress1,cohead_shiptoaddress2,cohead_shiptoaddress3,
              cohead_shiptocity,cohead_shiptostate,cohead_shiptozipcode,
              cohead_shiptocountry,cohead_freight,cohead_shiptophone,
              cohead_shipto_cntct_id, cohead_shipto_cntct_honorific,
              cohead_shipto_cntct_first_name, cohead_shipto_cntct_middle,
              cohead_shipto_cntct_last_name, cohead_shipto_cntct_suffix,
              cohead_shipto_cntct_phone, cohead_shipto_cntct_title,
              cohead_shipto_cntct_fax, cohead_shipto_cntct_email,
              cohead_shipchrg_id, cohead_shipform_id,cohead_billtoname,
              cohead_billtoaddress1,cohead_billtoaddress2,cohead_billtoaddress3,
              cohead_billtocity,cohead_billtostate,cohead_billtozipcode,
              cohead_billtocountry,cohead_misc_accnt_id,cohead_misc_descrip,
              cohead_commission,cohead_holdtype,cohead_prj_id,cohead_shipcomplete,
              cohead_curr_id,cohead_taxzone_id,cohead_saletype_id,cohead_shipzone_id)
            SELECT _coheadid,fetchsonumber(),rahead_cust_id,rahead_custponumber,
              current_date,rahead_salesrep_id,COALESCE(cohead_terms_id,cust_terms_id),
              COALESCE(cohead_shipvia,cust_shipvia),rahead_shipto_id,rahead_shipto_name,
              rahead_shipto_address1,rahead_shipto_address2,rahead_shipto_address3,
              rahead_shipto_city,rahead_shipto_state,rahead_shipto_zipcode,
              rahead_shipto_country,0,COALESCE(cohead_shiptophone,''),
              cntct_id, cntct_honorific,
              cntct_first_name, cntct_middle,
              cntct_last_name, cntct_suffix,
              cntct_phone, cntct_title,
              cntct_fax, cntct_email,
              COALESCE(cohead_shipchrg_id,cust_shipchrg_id),
              COALESCE(cohead_shipform_id,cust_shipform_id),
              rahead_billtoname,rahead_billtoaddress1,rahead_billtoaddress2,rahead_billtoaddress3,
              rahead_billtocity,rahead_billtostate,rahead_billtozip,
              rahead_billtocountry,NULL,'',rahead_commission, 'N', rahead_prj_id,
              COALESCE(cohead_shipcomplete,
                CASE WHEN cust_partialship THEN
                  false
                ELSE true
                END),rahead_curr_id,rahead_taxzone_id,rahead_saletype_id,rahead_shipzone_id
            FROM rahead
              JOIN custinfo ON (rahead_cust_id=cust_id)
              LEFT OUTER JOIN cohead ON (rahead_orig_cohead_id=cohead_id)
              LEFT OUTER JOIN shiptoinfo ON (rahead_shipto_id=shipto_id)
              LEFT OUTER JOIN cntct ON (shipto_cntct_id=cntct_id)
            WHERE (rahead_id=_ra.rahead_id);

            UPDATE rahead SET rahead_new_cohead_id=_coheadid WHERE rahead_id=_ra.rahead_id;

          END IF;

-- Now enter the line item(s)
        IF (_ra.raitem_disposition IN ('P','V')) AND
           (_ra.raitem_new_coitem_id IS NULL) AND
           (_ra.raitem_qtyauthorized > 0) THEN

          SELECT nextval('coitem_coitem_id_seq') INTO _coitemid;

          SELECT COALESCE(MAX(coitem_linenumber),0)+1 INTO _linenumber
          FROM coitem
          WHERE (coitem_cohead_id=_coheadid);

          INSERT INTO coitem (
            coitem_id,coitem_cohead_id,coitem_linenumber,coitem_itemsite_id,
            coitem_status,coitem_scheddate,coitem_promdate, coitem_qtyord,
            coitem_unitcost,coitem_price,coitem_custprice,coitem_qtyshipped,
            coitem_order_id,coitem_memo,coitem_qtyreturned,
            coitem_taxtype_id,coitem_qty_uom_id,coitem_qty_invuomratio,
            coitem_price_uom_id,coitem_price_invuomratio,coitem_warranty,
            coitem_cos_accnt_id,coitem_order_type, coitem_custpn)
          SELECT _coitemid,_coheadid,_linenumber,_ra.raitem_coitem_itemsite_id,
              'O',_ra.raitem_scheddate,_ra.raitem_scheddate,_ra.raitem_qtyauthorized,
              stdcost(itemsite_item_id),COALESCE(_ra.raitem_saleprice,0),0,0,
              -1,_ra.raitem_notes,0,
              _ra.raitem_taxtype_id,_ra.raitem_qty_uom_id,_ra.raitem_qty_invuomratio,
              _ra.raitem_price_uom_id,_ra.raitem_price_invuomratio,_ra.raitem_warranty,
              _ra.raitem_cos_accnt_id,
              CASE WHEN itemsite_createwo THEN 'W' ELSE NULL END, _ra.raitem_custpn
          FROM itemsite
          WHERE (itemsite_id=_ra.raitem_coitem_itemsite_id);

          UPDATE raitem SET raitem_new_coitem_id=_coitemid WHERE (raitem_id=_ra.raitem_id);
        END IF;

        -- Create items to ship that have no direct relation to receipts.
        IF (_ship) THEN
          FOR _i IN
            SELECT raitem_id FROM raitem
            WHERE ((raitem_rahead_id=_ra.rahead_id)
              AND (raitem_disposition = 'S')
              AND (raitem_new_coitem_id IS NULL))
          LOOP

            SELECT nextval('coitem_coitem_id_seq') INTO _coitemid;

            SELECT COALESCE(MAX(coitem_linenumber),0)+1 INTO _linenumber
              FROM coitem
            WHERE (coitem_cohead_id=_coheadid);

            INSERT INTO coitem (
              coitem_id,coitem_cohead_id,coitem_linenumber,coitem_itemsite_id,
              coitem_status,coitem_scheddate,coitem_promdate, coitem_qtyord,
              coitem_unitcost,coitem_price,coitem_custprice,coitem_qtyshipped,
              coitem_order_id,coitem_memo,coitem_qtyreturned,
              coitem_taxtype_id,coitem_qty_uom_id,coitem_qty_invuomratio,
              coitem_price_uom_id,coitem_price_invuomratio,coitem_warranty,
              coitem_cos_accnt_id,coitem_order_type,coitem_custpn)
            SELECT _coitemid,_coheadid,_linenumber,raitem_coitem_itemsite_id,
              'O',raitem_scheddate,raitem_scheddate,raitem_qtyauthorized,
              stdcost(itemsite_item_id),COALESCE(raitem_saleprice,0),0,0,
              -1,raitem_notes,0,
              raitem_taxtype_id,raitem_qty_uom_id,raitem_qty_invuomratio,
              raitem_price_uom_id,raitem_price_invuomratio,raitem_warranty,
              raitem_cos_accnt_id,
              CASE WHEN itemsite_createwo THEN 'W' ELSE NULL END,raitem_custpn
            FROM raitem
              JOIN itemsite ON (itemsite_id=raitem_itemsite_id)
            WHERE (raitem_id=_i.raitem_id);

            UPDATE raitem SET raitem_new_coitem_id=_coitemid WHERE (raitem_id=_i.raitem_id);

          END LOOP;
        END IF;
      END IF;


    ELSIF (_r.recv_order_type = 'TO' AND fetchMetricBool('MultiWhs')) THEN
      SELECT interWarehouseTransfer(toitem_item_id, tohead_trns_warehous_id,
            tohead_dest_warehous_id, _r.recv_qty,
            'TO', formatToNumber(toitem_id), 'Receive from Transit To Dest Warehouse', _itemlocSeries, _glDate ) INTO _tmp
      FROM tohead, toitem
      WHERE ((tohead_id=toitem_tohead_id)
        AND  (toitem_id=_r.recv_orderitem_id));

      IF (_tmp < 0) THEN
	    RETURN _tmp;
      END IF;

      SELECT insertGLTransaction(fetchJournalNumber('GL-MISC'),
				  'S/R', _r.recv_order_type, _o.orderhead_number,
				  'Receive Inventory Freight from ' || _o.orderhead_number || ' for item ' || _r.item_number,
				   costcat_toliability_accnt_id,
				   costcat_freight_accnt_id, -1,
				   _r.recv_freight_base,
				   _glDate::DATE, false ),
	     costcat_freight_accnt_id INTO _tmp, _freightAccnt
      FROM itemsite, costcat
      WHERE ( (itemsite_costcat_id=costcat_id)
       AND (itemsite_id=_r.itemsite_id) );
      IF (_tmp < 0 AND _tmp != -3) THEN -- error but not 0-value transaction
	    RETURN _tmp;
      ELSE
        -- Posting to trial balance is deferred to prevent locking
        INSERT INTO itemlocpost ( itemlocpost_glseq, itemlocpost_itemlocseries)
        VALUES ( _tmp, _itemlocSeries );
      END IF;

      UPDATE toitem
      SET toitem_qty_received = (toitem_qty_received + _r.recv_qty),
	  toitem_freight_received = (toitem_freight_received +
				      currToCurr(_r.recv_freight_curr_id,
						 toitem_freight_curr_id,
						 _r.recv_freight, _glDate::DATE))
      WHERE (toitem_id=_o.orderitem_id);

    END IF;
    IF(_r.itemsite_costmethod='A') THEN
      _recvvalue := ROUND((_o.item_unitprice_base * _r.recv_qty),2);
    ELSIF (fetchMetricBool('RecordPPVonReceipt')) THEN
      _recvvalue := ROUND((_o.item_unitprice_base * _r.recv_qty), 2);
    ELSE
      _recvvalue := ROUND(stdcost(_r.itemsite_item_id) * _recvinvqty, 2);
    END IF;
  END IF;

  UPDATE recv
  SET recv_value=_recvvalue, recv_recvcost=_recvvalue / recv_qty, recv_posted=TRUE, recv_gldistdate=_glDate::DATE
  WHERE (recv_id=precvid);

  IF (_r.recv_order_type = 'PO') THEN
    -- If this is a drop-shipped PO, then Issue the item to Shipping and Ship the item
    IF (_o.pohead_dropship = TRUE) THEN

      -- Generate the PoItemDropShipped event
      PERFORM postEvent('PoItemDropShipped', 'P', poitem_id,
                        itemsite_warehous_id,
                        (pohead_number || '-' || poitem_linenumber || ': ' || item_number),
                        NULL, NULL, NULL, NULL)
      FROM poitem JOIN itemsite ON (itemsite_id=poitem_itemsite_id)
                  JOIN item ON (item_id=itemsite_item_id)
                  JOIN pohead ON (pohead_id=poitem_pohead_id)
      WHERE (poitem_id=_o.orderitem_id)
        AND (poitem_duedate <= (CURRENT_DATE + itemsite_eventfence));

    END IF;
  END IF;
  RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.postreceipt(integer, integer) OWNER TO admin;

--
-- TOC entry 2037 (class 1255 OID 146566868)
-- Dependencies: 4536 8
-- Name: postreceipts(text, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postreceipts(text, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pordertype		ALIAS FOR $1;
  porderid		ALIAS FOR $2;
  _itemlocSeries	INTEGER	:= $3;
  _qtyToRecv		NUMERIC;
  _r			RECORD;

BEGIN

  SELECT SUM(qtyToReceive(pordertype, recv_orderitem_id)) INTO _qtyToRecv
  FROM recv, orderitem
  WHERE ((recv_orderitem_id=orderitem_id)
    AND  (recv_order_type=pordertype)
    AND  (orderitem_orderhead_type=pordertype)
    AND  (orderitem_orderhead_id=porderid));

  IF (_qtyToRecv <= 0) THEN
    RETURN -11;
  END IF;

  IF (_itemlocSeries IS NULL OR _itemlocSeries <= 0) THEN
    _itemlocSeries := NEXTVAL('itemloc_series_seq');
  END IF;

  FOR _r IN SELECT postReceipt(recv_id, _itemlocSeries) AS postResult
	    FROM recv, orderitem
	    WHERE ((recv_orderitem_id=orderitem_id)
	      AND  (orderitem_orderhead_id=porderid)
	      AND  (orderitem_orderhead_type=pordertype)
	      AND  (NOT recv_posted)
-- Check for multiple users receiving the same order
              AND  (recv_trans_usr_name=getEffectiveXtUser())
	      AND  (recv_order_type=pordertype)) LOOP
    IF (_r.postResult < 0 AND _r.postResult != -11) THEN
      RETURN _r.postResult; -- fail on 1st error but ignore lines with qty == 0
    END IF;
  END LOOP;

  RETURN _itemlocSeries;
END;
$_$;


ALTER FUNCTION public.postreceipts(text, integer, integer) OWNER TO admin;

--
-- TOC entry 2038 (class 1255 OID 146566869)
-- Dependencies: 4536 8
-- Name: postsogltransactions(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postsogltransactions() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  UPDATE gltrans
  SET gltrans_exported=TRUE
  WHERE ( (NOT gltrans_exported)
   AND (gltrans_source='A/R')
   AND (gltrans_doctype IN ('IN', 'CM')) );

  RETURN TRUE;

END;
$$;


ALTER FUNCTION public.postsogltransactions() OWNER TO admin;

--
-- TOC entry 2039 (class 1255 OID 146566870)
-- Dependencies: 4536 8
-- Name: postsoitemproduction(integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postsoitemproduction(integer, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSoitemId      ALIAS FOR $1;
  pGlDistTS      ALIAS FOR $2;
  _qty NUMERIC;

BEGIN
  -- Issuing all, so determine line balance
  SELECT noNeg( coitem_qtyord - coitem_qtyshipped + coitem_qtyreturned -
              ( SELECT COALESCE(SUM(shipitem_qty), 0)
                FROM shipitem, shiphead
                WHERE ((shipitem_orderitem_id=coitem_id)
                  AND  (shipitem_shiphead_id=shiphead_id)
                  AND  (NOT shiphead_shipped) ) ) ) INTO _qty
  FROM coitem
  WHERE (coitem_id=pSoitemId);

  RETURN postSoItemProduction($1, _qty, $2);
END;
$_$;


ALTER FUNCTION public.postsoitemproduction(integer, timestamp with time zone) OWNER TO admin;

--
-- TOC entry 2040 (class 1255 OID 146566871)
-- Dependencies: 4536 8
-- Name: postsoitemproduction(integer, numeric, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postsoitemproduction(integer, numeric, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSoitemId ALIAS FOR $1;
  pQty ALIAS FOR $2;
  pGlDistTS ALIAS FOR $3;
  _itemlocSeries INTEGER := 0;

BEGIN
  --If this cost method is not Job then we are using the wrong function
  IF (NOT EXISTS(SELECT itemsite_costmethod
             FROM coitem,itemsite
             WHERE ((coitem_id=pSoitemId)
                AND (coitem_itemsite_id=itemsite_id)
                AND (itemsite_costmethod = 'J')))) THEN
    RAISE EXCEPTION 'The postSoLineBalanceProduction function may only be used with Job costed item sites';
  END IF;

  IF (pQty > 0) THEN
    SELECT COALESCE(postProduction(wo_id, (pQty * coitem_qty_invuomratio), true, 0, pGlDistTS),-1) INTO _itemlocSeries
    FROM wo, coitem
    WHERE ((wo_ordid=pSoItemid)
     AND (wo_ordtype='S')
     AND (coitem_id=pSoItemid));

    UPDATE wo SET wo_status = 'C'
    WHERE ((wo_ordid=pSoItemid)
     AND (wo_ordtype='S')
     AND (wo_qtyrcv >= wo_qtyord));
  END IF;

  RETURN _itemlocSeries;
END;
$_$;


ALTER FUNCTION public.postsoitemproduction(integer, numeric, timestamp with time zone) OWNER TO admin;

--
-- TOC entry 2041 (class 1255 OID 146566872)
-- Dependencies: 4536 8
-- Name: poststandardjournal(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION poststandardjournal(integer, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pStdjrnlid ALIAS FOR $1;
  pDate ALIAS FOR $2;
  _returnValue INTEGER;

BEGIN

  SELECT postStandardJournal(pStdjrnlid, pDate, FALSE, fetchGLSequence()) INTO _returnValue;

  RETURN _returnValue;

END;
$_$;


ALTER FUNCTION public.poststandardjournal(integer, date) OWNER TO admin;

--
-- TOC entry 2042 (class 1255 OID 146566873)
-- Dependencies: 4536 8
-- Name: poststandardjournal(integer, date, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION poststandardjournal(integer, date, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pStdjrnlid ALIAS FOR $1;
  pDate ALIAS FOR $2;
  pGlSequence ALIAS FOR $3;

BEGIN

  RETURN postStandardJournal(pStdjrnlid, pDate, FALSE, pGLSequence);

END;
$_$;


ALTER FUNCTION public.poststandardjournal(integer, date, integer) OWNER TO admin;

--
-- TOC entry 2043 (class 1255 OID 146566874)
-- Dependencies: 4536 8
-- Name: poststandardjournal(integer, date, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION poststandardjournal(integer, date, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pStdjrnlid ALIAS FOR $1;
  pDate ALIAS FOR $2;
  pReverse ALIAS FOR $3;
  _returnValue INTEGER;

BEGIN

  RETURN postStandardJournal(pStdjrnlid, pDate, pReverse, fetchGLSequence());

END;
$_$;


ALTER FUNCTION public.poststandardjournal(integer, date, boolean) OWNER TO admin;

--
-- TOC entry 2045 (class 1255 OID 146566875)
-- Dependencies: 4536 8
-- Name: poststandardjournal(integer, date, boolean, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION poststandardjournal(integer, date, boolean, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pStdjrnlid ALIAS FOR $1;
  pDate ALIAS FOR $2;
  pReverse ALIAS FOR $3;
  pGlSequence ALIAS FOR $4;

BEGIN

  INSERT INTO glseries
  ( glseries_sequence, glseries_source, glseries_doctype, glseries_docnumber,
    glseries_notes, glseries_accnt_id, glseries_amount, glseries_distdate )
  SELECT pGlSequence, 'G/L', 'ST', stdjrnl_name,
         stdjrnlitem_notes, stdjrnlitem_accnt_id,
         CASE WHEN (pReverse=TRUE) THEN (stdjrnlitem_amount * -1)
              ELSE stdjrnlitem_amount
         END,
         pDate
  FROM stdjrnlitem, stdjrnl
  WHERE ( (stdjrnlitem_stdjrnl_id=stdjrnl_id)
   AND (stdjrnl_id=pStdjrnlid) );

  RETURN pGlSequence;

END;
$_$;


ALTER FUNCTION public.poststandardjournal(integer, date, boolean, integer) OWNER TO admin;

--
-- TOC entry 2046 (class 1255 OID 146566876)
-- Dependencies: 4536 8
-- Name: poststandardjournalgroup(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION poststandardjournalgroup(integer, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pStdjrnlgrpid ALIAS FOR $1;
  pDate ALIAS FOR $2;
BEGIN
  RETURN postStandardJournalGroup(pStdjrnlgrpid, pDate, FALSE);
END;
$_$;


ALTER FUNCTION public.poststandardjournalgroup(integer, date) OWNER TO admin;

--
-- TOC entry 2047 (class 1255 OID 146566877)
-- Dependencies: 4536 8
-- Name: poststandardjournalgroup(integer, date, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION poststandardjournalgroup(integer, date, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pStdjrnlgrpid ALIAS FOR $1;
  pDate ALIAS FOR $2;
  pReverse ALIAS FOR $3;
  _r RECORD;
  _glSequence INTEGER := -1;

BEGIN

  FOR _r IN SELECT stdjrnlgrpitem_id, stdjrnlgrpitem_stdjrnl_id
            FROM stdjrnlgrpitem
            WHERE ( (stdjrnlgrpitem_stdjrnlgrp_id=pStdjrnlgrpid)
             AND (CURRENT_DATE BETWEEN stdjrnlgrpitem_effective AND (stdjrnlgrpitem_expires - 1))
             AND ( (stdjrnlgrpitem_toapply = -1)
              OR (stdjrnlgrpitem_toapply > stdjrnlgrpitem_applied) ) ) LOOP

    IF (_glSequence = -1) THEN
      SELECT fetchGLSequence() INTO _glSequence;
    END IF;

    PERFORM postStandardJournal(_r.stdjrnlgrpitem_stdjrnl_id, pDate, pReverse, _glSequence);

    UPDATE stdjrnlgrpitem
    SET stdjrnlgrpitem_applied=(stdjrnlgrpitem_applied + 1)
    WHERE (stdjrnlgrpitem_id=_r.stdjrnlgrpitem_id);

  END LOOP;

  RETURN _glSequence;

END;
$_$;


ALTER FUNCTION public.poststandardjournalgroup(integer, date, boolean) OWNER TO admin;

--
-- TOC entry 2048 (class 1255 OID 146566878)
-- Dependencies: 4536 8
-- Name: postvalueintoinvbalance(integer, date, numeric, numeric, numeric, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postvalueintoinvbalance(integer, date, numeric, numeric, numeric, numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteId ALIAS FOR $1;
  pDate ALIAS FOR $2;
  pQoh ALIAS FOR $3;
  pNn ALIAS FOR $4;
  pOldCost ALIAS FOR $5;
  pNewCost ALIAS FOR $6;
  _invbalid INTEGER;
  _r RECORD;
  _count INTEGER;
  _valChange NUMERIC;
  _nnvalChange NUMERIC;

BEGIN

--  Grab the costhist record to post
  SELECT period_id INTO _r
  FROM period
  WHERE (pDate BETWEEN period_start AND period_end);

  GET DIAGNOSTICS _count = ROW_COUNT;

--  Find an inventory balance to post into
  IF ( _count > 0 ) THEN
--  Try to find an existing invbal
    SELECT invbal_id INTO _invbalid
    FROM invbal
    WHERE ( (invbal_period_id=_r.period_id)
      AND (invbal_itemsite_id=pItemsiteId) );

    GET DIAGNOSTICS _count = ROW_COUNT;
    IF (_count = 0) THEN
      -- Wasn't there, so forward update
      PERFORM forwardUpdateItemsite(pItemsiteId);

      --  Try to find an existing invbal again
      SELECT invbal_id INTO _invbalid
      FROM invbal
      WHERE ( (invbal_period_id=_r.period_id)
        AND (invbal_itemsite_id=pItemsiteId) );

      GET DIAGNOSTICS _count = ROW_COUNT;
      IF (_count = 0) THEN
        RAISE EXCEPTION 'An inventory balance record was not found for updating standard costs';
      END IF;
    END IF;

    _valChange := round((pNewCost - pOldCost) * pQoh, 2);
    _nnvalChange := round((pNewCost - pOldCost) * pNn, 2);

--  We found an invbal, update it with the change
    IF (_valChange > 0) THEN
      UPDATE invbal SET
        invbal_value_in = (invbal_value_in + _valChange)
      WHERE (invbal_id=_invbalid);
    ELSE
      UPDATE invbal SET
        invbal_value_out = (invbal_value_out - _valChange)
      WHERE (invbal_id=_invbalid);
    END IF;

    IF (_nnvalChange > 0) THEN
      UPDATE invbal SET
        invbal_nnval_in = (invbal_nnval_in + _nnvalChange)
      WHERE (invbal_id=_invbalid);
    ELSE
      UPDATE invbal SET
        invbal_nnval_out = (invbal_nnval_out - _nnvalChange)
      WHERE (invbal_id=_invbalid);
    END IF;

    UPDATE invbal SET
      invbal_value_ending = (invbal_value_beginning + invbal_value_in - invbal_value_out),
      invbal_nnval_ending = (invbal_nnval_beginning + invbal_nnval_in - invbal_nnval_out),
      invbal_dirty=true
    WHERE (invbal_id=_invbalid);

  ELSE
    RAISE EXCEPTION 'No period exists for date %.', pDate;
  END IF;

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.postvalueintoinvbalance(integer, date, numeric, numeric, numeric, numeric) OWNER TO admin;

--
-- TOC entry 2049 (class 1255 OID 146566879)
-- Dependencies: 4536 8
-- Name: postvoucher(integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postvoucher(integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVoheadid ALIAS FOR $1;
  pPostCosts ALIAS FOR $2;

BEGIN
  RETURN postVoucher(pVoheadid, fetchJournalNumber('AP-VO'), pPostCosts);
END;
$_$;


ALTER FUNCTION public.postvoucher(integer, boolean) OWNER TO admin;

--
-- TOC entry 2050 (class 1255 OID 146566880)
-- Dependencies: 4536 8
-- Name: postvoucher(integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postvoucher(integer, integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVoheadid ALIAS FOR $1;
  pJournalNumber ALIAS FOR $2;
  pPostCosts ALIAS FOR $3;
  _sequence INTEGER;
  _totalAmount_base NUMERIC;
  _totalAmount NUMERIC;
  _itemAmount_base NUMERIC;
  _itemAmount NUMERIC;
  _totalDiscountableAmount NUMERIC;
  _test INTEGER;
  _a RECORD;
  _d RECORD;
  _g RECORD;
  _p RECORD;
  _r RECORD;
  _costx RECORD;
  _pPostCosts BOOLEAN;
  _pExplain BOOLEAN;
  _pLowLevel BOOLEAN;
  _exchGainFreight NUMERIC;
  _taxBaseValue NUMERIC;
  _firstExchDateFreight	DATE;
  _tmpTotal		NUMERIC;
  _glDate		DATE;

BEGIN

  RAISE DEBUG 'postVoucher(%, %, %)', pVoheadid, pJournalNumber, pPostCosts;

  _pPostCosts := TRUE;
  _totalAmount_base := 0;
  _totalAmount := 0;
  _totalDiscountableAmount := 0;
  SELECT fetchGLSequence() INTO _sequence;

--  Cache Voucher Infomation
  SELECT vohead.*,
	 vend_number || '-' || vend_name || ' ' || vohead_reference
							  AS glnotes,
	 COALESCE(pohead_orderdate, vohead_docdate) AS pohead_orderdate,
	 COALESCE(pohead_curr_id, vohead_curr_id) AS pohead_curr_id INTO _p
  FROM vendinfo, vohead LEFT OUTER JOIN pohead ON (vohead_pohead_id = pohead_id)
  WHERE ( (vohead_id=pVoheadid)
  AND (vend_id=vohead_vend_id) )
  FOR UPDATE OF vohead;

  IF (_p.vohead_posted) THEN
    RAISE EXCEPTION 'Cannot post Voucher #% as it is already posted [xtuple: postVoucher, -10, %]',
			_p.vohead_number, _p.vohead_number;
  END IF;

  _glDate := COALESCE(_p.vohead_gldistdate, _p.vohead_distdate);

--  If the vohead_distdate is NULL, assume that this is a NULL vohead and quietly delete it
  IF (_p.vohead_distdate IS NULL) THEN
    DELETE FROM vohead WHERE vohead_id = pVoheadid;
    RETURN 0;
  END IF;
  IF (_p.vohead_amount <= 0) THEN
    RAISE EXCEPTION 'Cannot Post Voucher #% for a negative or zero amount (%) [xtuple: postVoucher, -1, %, %]',
			_p.vohead_number, _p.vohead_amount,
			_p.vohead_number, _p.vohead_amount;
  END IF;

-- there is no currency gain/loss on items, see issue 3892,
-- but there might be on freight, which is first encountered at p/o receipt
  SELECT recv_date::DATE INTO _firstExchDateFreight
      FROM recv
      WHERE (recv_vohead_id = pVoheadid);

  SELECT round(SUM(amount),4) INTO _tmpTotal
  FROM (
  SELECT SUM(vodist_amount) AS amount
    FROM vodist
   WHERE ( (vodist_vohead_id=pVoheadid)
     AND   (vodist_tax_id=-1) )
  UNION ALL
  SELECT SUM(voitem_freight) AS amount
    FROM voitem
   WHERE (voitem_vohead_id=pVoheadid)
  UNION ALL
  SELECT SUM(tax*-1)
  FROM
    (SELECT round(sum(taxdetail_tax),2) AS tax,
              currToBase(_p.vohead_curr_id, round(sum(taxdetail_tax),2), _p.vohead_docdate) AS taxbasevalue
     FROM tax
     JOIN calculateTaxDetailSummary('VO', pVoheadid, 'T') ON (taxdetail_tax_id=tax_id)
     GROUP BY tax_id, tax_sales_accnt_id
    ) AS taxdata
  ) AS data;

  IF (_tmpTotal IS NULL OR _tmpTotal <= 0) THEN
    RAISE EXCEPTION 'Cannot Post Voucher #% with negative or zero distributions (%) [xtuple: postVoucher, -2, %, %]',
			_p.vohead_number, _tmpTotal,
			_p.vohead_number, _tmpTotal;
  END IF;

  IF (_tmpTotal > _p.vohead_amount) THEN
    RAISE EXCEPTION 'Cannot Post Voucher #% with distributions greater than the voucher amount (% > %) [xtuple: postVoucher, -3, %, %, %]',
			_p.vohead_number, _tmpTotal, _p.vohead_amount,
			_p.vohead_number, _tmpTotal, _p.vohead_amount;
  END IF;

  IF (_tmpTotal < _p.vohead_amount) THEN
    RAISE EXCEPTION 'Cannot Post Voucher #% with distributions less than the voucher amount (% < %) [xtuple: postVoucher, -4, %, %, %]',
			_p.vohead_number, _tmpTotal, _p.vohead_amount,
			_p.vohead_number, _tmpTotal, _p.vohead_amount;
  END IF;

  SELECT DISTINCT poitem_linenumber INTO _test
    FROM vodist, voitem, poitem
   WHERE ( (vodist_poitem_id=poitem_id)
     AND   (voitem_poitem_id=poitem_id)
     AND   (voitem_vohead_id=vodist_vohead_id)
     AND   ((poitem_qty_received - poitem_qty_vouchered) = 0)
     AND   (vodist_vohead_id=pVoheadid) )
   LIMIT 1;
  IF (FOUND) THEN
    RAISE EXCEPTION 'Cannot Post Voucher #% as one or more of the line items have already been fully vouchered. Check P/O Line #% [postVoucher, -6, %, %]',
         _p.vohead_number, _test,
         _p.vohead_number, _test;
  END IF;

--  Start by handling taxes
  FOR _r IN SELECT tax_sales_accnt_id,
              round(sum(taxdetail_tax),2) AS tax,
              currToBase(_p.vohead_curr_id, round(sum(taxdetail_tax),2), _p.vohead_docdate) AS taxbasevalue
            FROM tax
             JOIN calculateTaxDetailSummary('VO', pVoheadid, 'T') ON (taxdetail_tax_id=tax_id)
	    GROUP BY tax_id, tax_sales_accnt_id LOOP

    PERFORM insertIntoGLSeries( _sequence, 'A/P', 'VO', _p.vohead_number,
                                _r.tax_sales_accnt_id,
                                _r.taxbasevalue,
                                _glDate, _p.glnotes );

    RAISE DEBUG 'postVoucher: _r.tax=%', _r.tax;

    _totalAmount_base := (_totalAmount_base - _r.taxbasevalue);
    _totalAmount := (_totalAmount - _r.tax);

  END LOOP;

-- Update item tax records with posting data
    UPDATE voitemtax SET
      taxhist_docdate=_p.vohead_docdate,
      taxhist_distdate=_glDate,
      taxhist_curr_id=_p.vohead_curr_id,
      taxhist_curr_rate=curr_rate,
      taxhist_journalnumber=pJournalNumber
    FROM vohead
     JOIN voitem ON (vohead_id=voitem_vohead_id),
     curr_rate
    WHERE ((vohead_id=pVoheadId)
      AND (taxhist_parent_id=voitem_id)
      AND (_p.vohead_curr_id=curr_id)
      AND (_p.vohead_docdate BETWEEN curr_effective
                           AND curr_expires) );

-- Update Misc distributions with posting data
    UPDATE voheadtax SET
      taxhist_docdate=_p.vohead_docdate,
      taxhist_distdate=_glDate,
      taxhist_curr_id=_p.vohead_curr_id,
      taxhist_curr_rate=curr_rate,
      taxhist_journalnumber=pJournalNumber
    FROM curr_rate
    WHERE ((taxhist_parent_id=pVoheadid)
      AND (_p.vohead_curr_id=curr_id)
      AND (_p.vohead_docdate BETWEEN curr_effective
                           AND curr_expires) );

--  Loop through the vodist records for the passed vohead that
--  are posted against a P/O Item
  FOR _g IN SELECT DISTINCT poitem_id, voitem_id, voitem_qty, poitem_expcat_id,
                            poitem_invvenduomratio, poitem_prj_id,
                            COALESCE(itemsite_id, -1) AS itemsiteid,
                            COALESCE(itemsite_costcat_id, -1) AS costcatid,
                            COALESCE(itemsite_item_id, -1) AS itemsite_item_id,
                            (SELECT SUM(value)
                             FROM (
                                SELECT SUM(recv_value) AS value
                                FROM recv
                                WHERE (recv_voitem_id=voitem_id)
                             UNION
                                SELECT SUM(poreject_value)*-1 AS value
                                FROM poreject
                                WHERE (poreject_voitem_id=voitem_id)) as data)
                           AS value_base,
			   (poitem_freight_received - poitem_freight_vouchered) /
			       (poitem_qty_received - poitem_qty_vouchered) * voitem_qty AS vouchered_freight,
                            currToBase(_p.pohead_curr_id,
				       (poitem_freight_received - poitem_freight_vouchered) /
				       (poitem_qty_received - poitem_qty_vouchered) * voitem_qty,
				        _firstExchDateFreight ) AS vouchered_freight_base,
			    voitem_freight,
			    currToBase(_p.vohead_curr_id, voitem_freight,
                                       _p.vohead_distdate) AS voitem_freight_base
            FROM vodist, voitem,
                 poitem LEFT OUTER JOIN itemsite ON (poitem_itemsite_id=itemsite_id)
            WHERE ( (vodist_poitem_id=poitem_id)
             AND (voitem_poitem_id=poitem_id)
             AND (voitem_vohead_id=vodist_vohead_id)
             AND (vodist_vohead_id=pVoheadid)) LOOP

--  Grab the G/L Accounts
    IF (_g.costcatid = -1) THEN
      SELECT getPrjAccntId(_g.poitem_prj_id, pp.accnt_id) AS pp_accnt_id,
             lb.accnt_id AS lb_accnt_id,
             fr.accnt_id AS freight_accnt_id INTO _a
      FROM expcat, accnt AS pp, accnt AS lb, accnt AS fr
      WHERE ( (expcat_purchprice_accnt_id=pp.accnt_id)
       AND (expcat_liability_accnt_id=lb.accnt_id)
       AND (expcat_freight_accnt_id=fr.accnt_id)
       AND (expcat_id=_g.poitem_expcat_id) );
      IF (NOT FOUND) THEN
        RAISE EXCEPTION 'Cannot Post Voucher #% due to unassigned G/L Accounts [xtuple: postVoucher, -7, %]',
                        _p.vohead_number, _p.vohead_number;
      END IF;
    ELSE
      SELECT getPrjAccntId(_g.poitem_prj_id, costcat_purchprice_accnt_id) AS pp_accnt_id,
             getPrjAccntId(_g.poitem_prj_id, costcat_liability_accnt_id) AS lb_accnt_id,
             getPrjAccntId(_g.poitem_prj_id, costcat_freight_accnt_id) AS freight_accnt_id
      INTO _a
      FROM costcat
      WHERE (costcat_id=_g.costcatid);
      IF (NOT FOUND) THEN
        RAISE EXCEPTION 'Cannot Post Voucher #% due to unassigned G/L Accounts [xtuple: postVoucher, -8, %]',
                        _p.vohead_number, _p.vohead_number;
      END IF;
    END IF;

--  Clear the Item Amount accumulator
    _itemAmount_base := 0;
    _itemAmount := 0;

--  Figure out the total posted value for this line item
    FOR _d IN SELECT vodist_id, vodist_amount, vodist_discountable,
		     _p.vohead_curr_id, vodist_costelem_id,
		     currToBase(_p.vohead_curr_id, vodist_amount,
				_p.vohead_distdate) AS vodist_amount_base
              FROM vodist
              WHERE ( (vodist_vohead_id=pVoheadid)
               AND (vodist_poitem_id=_g.poitem_id) ) LOOP

       _pExplain := FALSE;
       SELECT * INTO _costx
         FROM itemcost
        WHERE ( (itemcost_item_id = _g.itemsite_item_id)
          AND   (itemcost_costelem_id = _d.vodist_costelem_id) );

       IF (FOUND) THEN
         _pExplain := _costx.itemcost_lowlevel;
       END IF;

--  Post the cost to the Actual if requested
--      IF ( (pPostCosts) AND (_d.vodist_costelem_id <> -1) ) THEN
      IF ( (_d.vodist_costelem_id <> -1) AND (_g.itemsite_item_id <> -1) ) THEN
        PERFORM updateCost( _g.itemsite_item_id, _d.vodist_costelem_id,
                            _pExplain, (_d.vodist_amount / (_g.voitem_qty * _g.poitem_invvenduomratio)),
			    _p.vohead_curr_id );
      END IF;

--  Add the Distribution Amount to the Item Amount
      RAISE DEBUG 'postVoucher: _d.vodist_amount=%', _d.vodist_amount;

      _itemAmount_base := _itemAmount_base + ROUND(_d.vodist_amount_base, 2);
      _itemAmount := _itemAmount + _d.vodist_amount;
      IF (_d.vodist_discountable) THEN
        _totalDiscountableAmount := (_totalDiscountableAmount + _d.vodist_amount);
      END IF;

    END LOOP;

--  Distribute from the clearing account
    PERFORM insertIntoGLSeries( _sequence, 'A/P', 'VO', text(_p.vohead_number),
		_a.lb_accnt_id,
		round(_g.value_base + _g.vouchered_freight_base, 2) * -1,
		_glDate, _p.glnotes );


--  Attribute the correct portion to currency gain/loss
    _exchGainFreight := 0;
    SELECT currGain(_p.pohead_curr_id, _g.vouchered_freight,
		    _firstExchDateFreight, _p.vohead_distdate )
		    INTO _exchGainFreight;
    IF (round(_exchGainFreight, 2) <> 0) THEN
	PERFORM insertIntoGLSeries(_sequence, 'A/P', 'VO',
	    text(_p.vohead_number),
	    getGainLossAccntId(_a.lb_accnt_id), round(_exchGainFreight, 2),
	   _glDate, _p.glnotes);
    END IF;

--  Distribute the remaining variance to the Purchase Price Variance account
    IF (round(_itemAmount_base, 2) <> round(_g.value_base, 2)) THEN
      _tmpTotal := round(_itemAmount_base, 2) - round(_g.value_base, 2);
      PERFORM insertIntoGLSeries( _sequence, 'A/P', 'VO', text(_p.vohead_number),
			          _a.pp_accnt_id,
			          _tmpTotal * -1,
			          _glDate, _p.glnotes );
    END IF;

--  Distribute the remaining freight variance to the Purchase Price Variance account
    IF (round(_g.voitem_freight_base + _exchGainFreight, 2) <> round(_g.vouchered_freight_base, 2)) THEN
      _tmpTotal := round(_g.voitem_freight_base + _exchGainFreight, 2) - round(_g.vouchered_freight_base, 2);
      PERFORM insertIntoGLSeries( _sequence, 'A/P', 'VO', text(_p.vohead_number),
        _a.freight_accnt_id,
	      _tmpTotal * -1,
	      _glDate, _p.glnotes );
    END IF;

--  Add the distribution amount to the total amount to distribute
    RAISE DEBUG 'postVoucher: _itemAmount=%', _itemAmount;

    _totalAmount_base := (_totalAmount_base + _itemAmount_base + _g.voitem_freight_base);
    _totalAmount := (_totalAmount + _itemAmount + _g.voitem_freight);

--  Post all the Tagged Receivings for this P/O Item as Invoiced and
--  record the purchase and receive costs
--  Comment out because recv cost is set at receiving now.
    UPDATE recv
    SET recv_invoiced=TRUE,
	recv_recvcost_curr_id=basecurrid(),
        recv_recvcost=round(_g.value_base / _g.voitem_qty, 2)
    FROM poitem
    WHERE ((recv_orderitem_id=poitem_id)
      AND  (recv_order_type='PO')
      AND  (recv_orderitem_id=_g.poitem_id)
      AND  (recv_vohead_id=pVoheadid) );

--  Post all the Tagged Rejections for this P/O Item as Invoiced
    UPDATE poreject
    SET poreject_invoiced=TRUE
    WHERE ( (poreject_poitem_id=_g.poitem_id)
     AND (poreject_vohead_id=pVoheadid) );

--  Update the qty and freight vouchered fields
    UPDATE poitem
       SET poitem_qty_vouchered = (poitem_qty_vouchered + _g.voitem_qty),
           poitem_freight_vouchered = (poitem_freight_vouchered + _g.vouchered_freight)
     WHERE (poitem_id=_g.poitem_id);

  END LOOP;

--  Loop through the vodist records for the passed vohead that
--  are not posted against a P/O Item
--  Skip the tax distributions
  FOR _d IN SELECT vodist_id, vodist_discountable,
		   currToBase(_p.vohead_curr_id, vodist_amount,
			      _p.vohead_distdate) AS vodist_amount_base,
		   vodist_amount,
		   vodist_accnt_id, vodist_expcat_id
            FROM vodist
            WHERE ( (vodist_vohead_id=pVoheadid)
             AND (vodist_poitem_id=-1)
             AND (vodist_tax_id=-1) ) LOOP

--  Distribute from the misc. account
    IF (_d.vodist_accnt_id = -1) THEN
      PERFORM insertIntoGLSeries( _sequence, 'A/P', 'VO', text(_p.vohead_number),
			  expcat_exp_accnt_id,
			  round(_d.vodist_amount_base, 2) * -1,
			  _glDate, _p.glnotes )
         FROM expcat
        WHERE (expcat_id=_d.vodist_expcat_id);
    ELSE
      PERFORM insertIntoGLSeries( _sequence, 'A/P', 'VO', text(_p.vohead_number),
			  _d.vodist_accnt_id,
			  round(_d.vodist_amount_base, 2) * -1,
			  _glDate, _p.glnotes );
    END IF;

--  Add the Distribution Amount to the Total Amount
    RAISE DEBUG 'postVoucher: _d.vodist_amount=%', _d.vodist_amount;

    _totalAmount_base := _totalAmount_base + ROUND(_d.vodist_amount_base, 2);
    _totalAmount := _totalAmount + _d.vodist_amount;
    IF (_d.vodist_discountable) THEN
      _totalDiscountableAmount := (_totalDiscountableAmount + _d.vodist_amount);
    END IF;

  END LOOP;

  SELECT insertIntoGLSeries( _sequence, 'A/P', 'VO', text(vohead_number),
                             accnt_id, round(_totalAmount_base, 2),
			     _glDate, _p.glnotes ) INTO _test
  FROM vohead LEFT OUTER JOIN accnt ON (accnt_id=findAPAccount(vohead_vend_id))
  WHERE ( (findAPAccount(vohead_vend_id)=0 OR accnt_id > 0) -- G/L interface might be disabled
    AND (vohead_id=pVoheadid) );
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Cannot Post Voucher #% due to an unassigned A/P Account [xtuple: postVoucher, -9, %]',
                    _p.vohead_number, _p.vohead_number;
  END IF;

  PERFORM postGLSeries(_sequence, pJournalNumber);

--  Create the A/P Open Item
  RAISE DEBUG 'postVoucher: _totalAmount=%, _totalDiscountableAmount=%',
                _totalAmount, _totalDiscountableAmount;

  INSERT INTO apopen
  ( apopen_journalnumber, apopen_docdate, apopen_duedate, apopen_distdate, apopen_open,
    apopen_terms_id, apopen_vend_id, apopen_doctype,
    apopen_docnumber, apopen_invcnumber, apopen_ponumber, apopen_reference,
    apopen_amount, apopen_paid, apopen_notes, apopen_username, apopen_posted,
    apopen_curr_id, apopen_discountable_amount )
-- TODO:
  SELECT pJournalNumber, vohead_docdate, vohead_duedate, _glDate, TRUE,
         vohead_terms_id, vohead_vend_id, 'V',
         vohead_number, vohead_invcnumber, COALESCE(TEXT(pohead_number), 'Misc.'), vohead_reference,
         round(_totalAmount, 2), 0, '', getEffectiveXtUser(), FALSE,
         vohead_curr_id, round(_totalDiscountableAmount, 2)
  FROM vohead LEFT OUTER JOIN pohead ON (vohead_pohead_id=pohead_id)
  WHERE (vohead_id=pVoheadid);

--  Close all of the P/O Items that should be closed by this Voucher
  UPDATE poitem
  SET poitem_status='C'
  FROM voitem
  WHERE ( (voitem_poitem_id=poitem_id)
   AND (voitem_close)
   AND (voitem_vohead_id=pVoheadid) );

--  Check the P/O items and if they are all closed go ahead
--  and close the P/O head.
  IF ( (SELECT (count(*) < 1)
          FROM vohead, poitem
         WHERE ((vohead_pohead_id=poitem_pohead_id)
           AND  (poitem_status<>'C')
           AND  (vohead_id=pVoheadid) ) ) ) THEN
    PERFORM closePo(vohead_pohead_id)
       FROM vohead
      WHERE (vohead_id=pVoheadid);
  END IF;

--  Set the vohead as posted
  UPDATE vohead
  SET vohead_posted=TRUE, vohead_gldistdate=_glDate
  WHERE (vohead_id=pVoheadid);

  RETURN pJournalNumber;

END;
$_$;


ALTER FUNCTION public.postvoucher(integer, integer, boolean) OWNER TO admin;

--
-- TOC entry 2051 (class 1255 OID 146566882)
-- Dependencies: 4536 8
-- Name: postvouchers(boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION postvouchers(boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPostCosts ALIAS FOR $1;
  _journalNumber INTEGER;

BEGIN

  SELECT fetchJournalNumber('AP-VO') INTO _journalNumber;

  PERFORM postVoucher(vohead_id, _journalNumber, pPostCosts)
  FROM vohead
  WHERE (NOT vohead_posted);

  RETURN _journalNumber;

END;
$_$;


ALTER FUNCTION public.postvouchers(boolean) OWNER TO admin;

--
-- TOC entry 2052 (class 1255 OID 146566883)
-- Dependencies: 4536 8
-- Name: primarykeyfields(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION primarykeyfields(text, text) RETURNS text[]
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSchema       ALIAS FOR $1;
  pRelation     ALIAS FOR $2;
  _colname      TEXT;
  _counter      INTEGER := 0;
  _result       TEXT[];

BEGIN
  EXECUTE 'SELECT ARRAY(SELECT attname
                         FROM pg_attribute
                         JOIN pg_class idx ON (attrelid         = idx.oid)
                         JOIN pg_namespace ON (idx.relnamespace = pg_namespace.oid)
                         JOIN pg_index     ON (idx.oid          = indexrelid)
                         JOIN pg_class tab ON (indrelid         = tab.oid)
                        WHERE NOT attisdropped
                          AND nspname = ''' || pSchema || '''
                          AND indisprimary
                          AND LOWER(tab.relname) = ''' || pRelation || '''
                       ORDER BY attnum);'
  INTO _result;

  RETURN _result;
END;
$_$;


ALTER FUNCTION public.primarykeyfields(text, text) OWNER TO admin;

--
-- TOC entry 9070 (class 0 OID 0)
-- Dependencies: 2052
-- Name: FUNCTION primarykeyfields(text, text); Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON FUNCTION primarykeyfields(text, text) IS 'Return an array containing the names of the primary key fields of pSchema.pRelation. The first key field is in _result[1].';


--
-- TOC entry 2053 (class 1255 OID 146566884)
-- Dependencies: 2856 4536 8
-- Name: prj(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION prj() RETURNS SETOF prj
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _row prj%ROWTYPE;
  _priv TEXT;
  _grant BOOLEAN;

BEGIN
  -- This query will give us the most permissive privilege the user has been granted
  SELECT privilege, granted INTO _priv, _grant
  FROM privgranted
  WHERE privilege IN ('MaintainAllProjects','ViewAllProjects','MaintainPersonalProjects','ViewPersonalProjects')
  ORDER BY granted DESC, sequence
  LIMIT 1;

  -- If have an 'All' privilege return all results
  IF (_priv ~ 'All' AND _grant) THEN
    FOR _row IN
      SELECT * FROM prj
    LOOP
      RETURN NEXT _row;
    END LOOP;
  -- Otherwise if have any other grant, must be personal privilege.
  ELSIF (_grant) THEN
    FOR _row IN
      SELECT * FROM prj
      WHERE getEffectiveXtUser() IN (prj_owner_username, prj_username)
    LOOP
      RETURN NEXT _row;
    END LOOP;
  END IF;

  RETURN;

END;
$$;


ALTER FUNCTION public.prj() OWNER TO admin;

--
-- TOC entry 9071 (class 0 OID 0)
-- Dependencies: 2053
-- Name: FUNCTION prj(); Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON FUNCTION prj() IS 'A table function that returns Project results according to privilege settings.';


--
-- TOC entry 232 (class 1259 OID 146566885)
-- Dependencies: 6041 8
-- Name: prjtask; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE prjtask (
    prjtask_id integer NOT NULL,
    prjtask_number text NOT NULL,
    prjtask_name text NOT NULL,
    prjtask_descrip text,
    prjtask_prj_id integer NOT NULL,
    prjtask_anyuser boolean,
    prjtask_status character(1) NOT NULL,
    prjtask_hours_budget numeric(18,6) NOT NULL,
    prjtask_hours_actual numeric(18,6) NOT NULL,
    prjtask_exp_budget numeric(16,4) NOT NULL,
    prjtask_exp_actual numeric(16,4) NOT NULL,
    prjtask_owner_username text,
    prjtask_start_date date,
    prjtask_due_date date,
    prjtask_assigned_date date,
    prjtask_completed_date date,
    prjtask_username text,
    CONSTRAINT prjtask_prjtask_status_check CHECK ((prjtask_status = ANY (ARRAY['P'::bpchar, 'O'::bpchar, 'C'::bpchar])))
);


ALTER TABLE public.prjtask OWNER TO admin;


--
-- TOC entry 2056 (class 1255 OID 146566892)
-- Dependencies: 2882 4536 8
-- Name: prjtask(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION prjtask() RETURNS SETOF prjtask
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _row prjtask%ROWTYPE;
  _priv TEXT;
  _grant BOOLEAN;

BEGIN
  -- This query will give us the most permissive privilege the user has been granted
  SELECT privilege, granted INTO _priv, _grant
  FROM privgranted
  WHERE privilege IN ('MaintainAllProjects','ViewAllProjects','MaintainPersonalProjects','ViewPersonalProjects')
  ORDER BY granted DESC, sequence
  LIMIT 1;

  -- If have an 'All' privilege return all results
  IF (_priv ~ 'All' AND _grant) THEN
    FOR _row IN
      SELECT * FROM prjtask
    LOOP
      RETURN NEXT _row;
    END LOOP;
  -- Otherwise if have any other grant, must be personal privilege.
  ELSIF (_grant) THEN
    FOR _row IN
      SELECT prjtask.* FROM prjtask
      JOIN prj ON prj_id=prjtask_prj_id
      WHERE getEffectiveXtUser() IN (prjtask_owner_username,prjtask_username,prj_username,prj_owner_username)
    LOOP
      RETURN NEXT _row;
    END LOOP;
  END IF;

  RETURN;

END;
$$;


ALTER FUNCTION public.prjtask() OWNER TO admin;

--
-- TOC entry 9074 (class 0 OID 0)
-- Dependencies: 2056
-- Name: FUNCTION prjtask(); Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON FUNCTION prjtask() IS 'A table function that returns Project results according to privilege settings.';


--
-- TOC entry 2057 (class 1255 OID 146566893)
-- Dependencies: 4536 8
-- Name: purgecreditmemos(date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION purgecreditmemos(date) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCutoffDate ALIAS FOR $1;

BEGIN

  DELETE FROM cmitem
  WHERE (cmitem_id IN ( SELECT cmitem_id
                        FROM cmitem, cmhead
                        WHERE ( (cmitem_cmhead_id=cmhead_id)
                          AND   (cmhead_posted)
                          AND   (cmhead_printed)
                          AND   (cmhead_docdate<=pCutoffDate)
                          AND   (checkCreditMemoSitePrivs(cmhead_id)) ) ) );

  DELETE FROM cmhead
  WHERE ( (cmhead_posted)
    AND   (cmhead_printed)
    AND   (cmhead_docdate<=pCutoffDate)
    AND   (checkCreditMemoSitePrivs(cmhead_id)) );

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.purgecreditmemos(date) OWNER TO admin;

--
-- TOC entry 2058 (class 1255 OID 146566894)
-- Dependencies: 4536 8
-- Name: purgecrmacctmerge(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION purgecrmacctmerge(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pDestid       ALIAS FOR $1;
  _result       INTEGER := 0;
  _tmpcount     INTEGER := 0;
BEGIN
  IF EXISTS(SELECT 1
              FROM crmacctsel
             WHERE crmacctsel_dest_crmacct_id=pDestid) THEN
    DELETE FROM crmacctsel WHERE crmacctsel_dest_crmacct_id = pDestid;
    GET DIAGNOSTICS _result = ROW_COUNT;

  ELSIF EXISTS(SELECT 1
                 FROM mrgundo
                WHERE mrgundo_base_schema='public'
                  AND mrgundo_base_table='crmacct'
                  AND mrgundo_base_id=pDestid) THEN

    DELETE FROM crmacct
     WHERE crmacct_id IN (
              SELECT mrgundo_pkey_id
                FROM mrgundo
               WHERE mrgundo_schema   = 'public'
                 AND mrgundo_table    = 'crmacct'
                 and mrgundo_pkey_col = 'crmacct_id'
                 AND mrgundo_col IS NULL
                 AND mrgundo_base_schema = 'public'
                 AND mrgundo_base_table  = 'crmacct'
                 AND mrgundo_base_id     = pDestid)
        AND crmacct_id != pDestid;
    GET DIAGNOSTICS _result = ROW_COUNT;

    DELETE FROM mrgundo
     WHERE mrgundo_base_schema ='public'
       AND mrgundo_base_table  ='crmacct'
       AND mrgundo_base_id     = pDestid;
    GET DIAGNOSTICS _tmpcount = ROW_COUNT;

    _result := _result + _tmpcount;
  END IF;

  RETURN _result;
END;
$_$;


ALTER FUNCTION public.purgecrmacctmerge(integer) OWNER TO admin;

--
-- TOC entry 2059 (class 1255 OID 146566895)
-- Dependencies: 4536 8
-- Name: purgeinvoicerecord(date, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION purgeinvoicerecord(date, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCutoffDate ALIAS FOR $1;
  pInvcheadId ALIAS FOR $2;
  _r RECORD;
  _ra RECORD;
  _raheadid INTEGER;
  _result INTEGER;
  _debug BOOLEAN := FALSE;

BEGIN

-- Purge records where the entire Invoice, Billing, Shipper, Sales Order
-- chain of associated documents are closed and complete

  FOR _r IN
  SELECT invchead_id, cobmisc_id, shiphead_id, ordershipped.cohead_id AS ordship_id, orderinvoiced.cohead_id AS ordinv_id
    FROM invchead LEFT OUTER JOIN invcitem ON (invcitem_invchead_id=invchead_id)
                  LEFT OUTER JOIN cobmisc ON (cobmisc_invcnumber::TEXT=invchead_invcnumber)
                  LEFT OUTER JOIN shipitem ON (shipitem_invcitem_id=invcitem_id)
                  LEFT OUTER JOIN shiphead ON (shiphead_id=shipitem_shiphead_id)
                  LEFT OUTER JOIN cohead ordershipped ON (ordershipped.cohead_id=shiphead_order_id)
                  LEFT OUTER JOIN coitem ON (coitem_id=invcitem_coitem_id)
                  LEFT OUTER JOIN cohead orderinvoiced ON (orderinvoiced.cohead_id=coitem_cohead_id)
   WHERE ( (invchead_id = pInvcheadId)
     AND   (invchead_posted)
     AND   (checkInvoiceSitePrivs(invchead_id)) )
  GROUP BY invchead_id, cobmisc_id, shiphead_id, ordship_id, ordinv_id LOOP

-- Check Billing

-- Billing header (cobmisc) must be posted
    SELECT cobmisc_id INTO _result
      FROM cobmisc
     WHERE ( (cobmisc_id=_r.cobmisc_id) AND (NOT cobmisc_posted) );
    IF (FOUND) THEN
      RETURN 'Billing not closed';
    END IF;

-- Billing line items (cobill), associated Invoice line items, and
-- associated Sales Order line items must be closed, posted, and after cutoff date
    SELECT cobill_id INTO _result
      FROM cobill JOIN invcitem ON (invcitem_id=cobill_invcitem_id)
                  JOIN invchead ON ( (invchead_id=invcitem_invchead_id) AND
                                     ((NOT invchead_posted) OR (invchead_invcdate > pCutoffDate)) )
                  JOIN coitem ON ( (coitem_id=cobill_coitem_id) AND
                                   (coitem_status NOT IN ('C', 'X')) )
     WHERE (cobill_cobmisc_id=_r.cobmisc_id);
    IF (FOUND) THEN
      RETURN 'Invoice/Sales Order associated with Billing not closed';
    END IF;

-- Check Shipping

-- Shipping header (shiphead) must be shipped
    SELECT shiphead_id INTO _result
      FROM shiphead
     WHERE ( (shiphead_id=_r.shiphead_id) AND (NOT shiphead_shipped) );
    IF (FOUND) THEN
      RETURN 'Shipper not closed';
    END IF;

-- Shipping line items (shipitem) and associated Sales Order line items
-- must be closed
    SELECT shiphead_id INTO _result
      FROM shiphead, cohead, coitem
     WHERE ( (shiphead_id=_r.shiphead_id)
       AND   ( (shiphead_order_type='SO') AND (shiphead_order_id=cohead_id) )
       AND   (coitem_cohead_id=cohead_id)
       AND   (coitem_status NOT IN ('C', 'X')) );
    IF (FOUND) THEN
      RETURN 'Sales Order associated with Shipper not closed';
    END IF;

-- Shipping line items (shipitem) and associated Invoices must be posted
-- and after cutoff date
    SELECT shiphead_id INTO _result
      FROM shiphead JOIN shipitem ON (shipitem_shiphead_id=shiphead_id)
                    JOIN invcitem ON (invcitem_id=shipitem_invcitem_id)
                    JOIN invchead ON ( (invchead_id=invcitem_invchead_id) AND
                                       ((NOT invchead_posted) OR (invchead_invcdate > pCutoffDate)) )
     WHERE (shiphead_id=_r.shiphead_id);
    IF (FOUND) THEN
      RETURN 'Invoice associated with Shipper not closed';
    END IF;

-- Check Sales Order

-- Sales Order line items (coitem) must be closed
    SELECT cohead_id INTO _result
      FROM cohead JOIN coitem ON ( (coitem_cohead_id=cohead_id) AND
                                   (coitem_status NOT IN ('C', 'X')) )
     WHERE (cohead_id=_r.ordship_id);
    IF (FOUND) THEN
      RETURN 'Shipped Sales Order not closed';
    END IF;
    SELECT cohead_id INTO _result
      FROM cohead JOIN coitem ON ( (coitem_cohead_id=cohead_id) AND
                                   (coitem_status NOT IN ('C', 'X')) )
     WHERE (cohead_id=_r.ordinv_id);
    IF (FOUND) THEN
      RETURN 'Invoiced Sales Order not closed';
    END IF;

    IF (fetchMetricBool('MultiWhs')) THEN
    -- Check Original Return Authorization and cross check to New Sales Order
      SELECT rahead_id INTO _result
        FROM rahead JOIN raitem ON ( (raitem_rahead_id=rahead_id) AND
                                     (raitem_status NOT IN ('C', 'X')) )
                    JOIN coitem ON ( (coitem_id=raitem_new_coitem_id) AND
                                     (coitem_status NOT IN ('C', 'X')) )
                    JOIN invcitem ON (invcitem_coitem_id=coitem_id)
                    JOIN invchead ON ( (invchead_id=invcitem_invchead_id) AND
                                       ((NOT invchead_posted) OR (invchead_invcdate > pCutoffDate)) )
       WHERE (rahead_orig_cohead_id=_r.ordship_id);
      IF (FOUND) THEN
        RETURN 'Shipped Original Return Authorization not closed';
      END IF;
      SELECT rahead_id INTO _result
        FROM rahead JOIN raitem ON ( (raitem_rahead_id=rahead_id) AND
                                     (raitem_status NOT IN ('C', 'X')) )
                    JOIN coitem ON ( (coitem_id=raitem_new_coitem_id) AND
                                     (coitem_status NOT IN ('C', 'X')) )
                    JOIN invcitem ON (invcitem_coitem_id=coitem_id)
                    JOIN invchead ON ( (invchead_id=invcitem_invchead_id) AND
                                       ((NOT invchead_posted) OR (invchead_invcdate > pCutoffDate)) )
       WHERE (rahead_orig_cohead_id=_r.ordinv_id);
      IF (FOUND) THEN
        RETURN 'Invoiced Original Return Authorization not closed';
      END IF;

  -- Check New Return Authorization
      SELECT rahead_id INTO _result
        FROM rahead JOIN raitem ON ( (raitem_rahead_id=rahead_id) AND
                                     (NOT raitem_status IN ('C', 'X')) )
                    JOIN coitem ON ( (coitem_id=raitem_orig_coitem_id) AND
                                     (NOT coitem_status IN ('C', 'X')) )
                    JOIN invcitem ON (invcitem_coitem_id=coitem_id)
                    JOIN invchead ON ( (invchead_id=invcitem_invchead_id) AND
                                       ((NOT invchead_posted) OR (invchead_invcdate > pCutoffDate)) )
       WHERE (rahead_new_cohead_id=_r.ordship_id);
      IF (FOUND) THEN
        RETURN 'Shipped New Return Authorization not closed';
      END IF;
      SELECT rahead_id INTO _result
        FROM rahead JOIN raitem ON ( (raitem_rahead_id=rahead_id) AND
                                     (NOT raitem_status IN ('C', 'X')) )
                    JOIN coitem ON ( (coitem_id=raitem_orig_coitem_id) AND
                                     (NOT coitem_status IN ('C', 'X')) )
                    JOIN invcitem ON (invcitem_coitem_id=coitem_id)
                    JOIN invchead ON ( (invchead_id=invcitem_invchead_id) AND
                                       ((NOT invchead_posted) OR (invchead_invcdate > pCutoffDate)) )
       WHERE (rahead_new_cohead_id=_r.ordinv_id);
      IF (FOUND) THEN
        RETURN 'Invoiced New Return Authorization not closed';
      END IF;
    END IF;

-- Check Lot/Serial Registration

    IF (fetchMetricBool('MultiWhs')) THEN
  -- Registration associated with Sales Order must be expired
      SELECT lsreg_id INTO _result
        FROM lsreg
       WHERE ( (lsreg_cohead_id=_r.ordship_id)
         AND   (lsreg_expiredate > CURRENT_DATE) );
      IF (FOUND) THEN
        RETURN 'Shipped Sales Order Lot/Serial Registration not closed';
      END IF;
      SELECT lsreg_id INTO _result
        FROM lsreg
       WHERE ( (lsreg_cohead_id=_r.ordinv_id)
         AND   (lsreg_expiredate > CURRENT_DATE) );
      IF (FOUND) THEN
        RETURN 'Invoiced Sales Order Lot/Serial Registration not closed';
      END IF;

  -- Registration associated with Shipping must be expired
      SELECT lsreg_id INTO _result
        FROM lsreg
       WHERE ( (lsreg_cohead_id=_r.shiphead_id)
         AND   (lsreg_expiredate > CURRENT_DATE) );
      IF (FOUND) THEN
        RETURN 'Shipper Lot/Serial Registration not closed';
      END IF;
    END IF;

    IF (fetchMetricBool('MultiWhs')) THEN
  -- Registration associated with Original Return Authorization must be expired
      SELECT rahead_id INTO _result
        FROM rahead JOIN raitem ON (raitem_rahead_id=rahead_id)
                    JOIN raitemls ON (raitemls_raitem_id=raitem_id)
                    JOIN lsreg ON ( (lsreg_ls_id=raitemls_ls_id) AND
                                    (lsreg_expiredate > CURRENT_DATE) )
       WHERE (rahead_orig_cohead_id=_r.ordship_id);
      IF (FOUND) THEN
        RETURN 'Shipped Original Return Authorization Lot/Serial Registration not closed';
      END IF;
      SELECT rahead_id INTO _result
        FROM rahead JOIN raitem ON (raitem_rahead_id=rahead_id)
                    JOIN raitemls ON (raitemls_raitem_id=raitem_id)
                    JOIN lsreg ON ( (lsreg_ls_id=raitemls_ls_id) AND
                                    (lsreg_expiredate > CURRENT_DATE) )
       WHERE (rahead_orig_cohead_id=_r.ordinv_id);
      IF (FOUND) THEN
        RETURN 'Invoiced Original Return Authorization Lot/Serial Registration not closed';
      END IF;

  -- Registration associated with New Return Authorization must be expired
      SELECT rahead_id INTO _result
        FROM rahead JOIN raitem ON (raitem_rahead_id=rahead_id)
                    JOIN raitemls ON (raitemls_raitem_id=raitem_id)
                    JOIN lsreg ON ( (lsreg_ls_id=raitemls_ls_id) AND
                                    (lsreg_expiredate > CURRENT_DATE) )
       WHERE (rahead_new_cohead_id=_r.ordship_id);
      IF (FOUND) THEN
        RETURN 'Shipped New Return Authorization Lot/Serial Registration not closed';
      END IF;
      SELECT rahead_id INTO _result
        FROM rahead JOIN raitem ON (raitem_rahead_id=rahead_id)
                    JOIN raitemls ON (raitemls_raitem_id=raitem_id)
                    JOIN lsreg ON ( (lsreg_ls_id=raitemls_ls_id) AND
                                    (lsreg_expiredate > CURRENT_DATE) )
       WHERE (rahead_new_cohead_id=_r.ordinv_id);
      IF (FOUND) THEN
        RETURN 'Invoiced New Return Authorization Lot/Serial Registration not closed';
      END IF;
    END IF;

-- Cash Advances associated with Sales Order cannot exist
    SELECT aropenalloc_doc_id INTO _result
      FROM aropenalloc
     WHERE ((aropenalloc_doctype='S')
       AND  (aropenalloc_doc_id=_r.ordship_id));
    IF (FOUND) THEN
      RETURN 'Shipped Cash Advance not closed';
    END IF;
    SELECT aropenalloc_doc_id INTO _result
      FROM aropenalloc
     WHERE ((aropenalloc_doctype='S')
       AND  (aropenalloc_doc_id=_r.ordinv_id));
    IF (FOUND) THEN
      RETURN 'Invoiced Cash Advance not closed';
    END IF;

  END LOOP;

-- Everything is OK, delete the chain
  FOR _r IN
  SELECT invchead_id, cobmisc_id, shiphead_id, ordershipped.cohead_id AS ordship_id, orderinvoiced.cohead_id AS ordinv_id
    FROM invchead LEFT OUTER JOIN invcitem ON (invcitem_invchead_id=invchead_id)
                  LEFT OUTER JOIN cobmisc ON (cobmisc_invcnumber::TEXT=invchead_invcnumber)
                  LEFT OUTER JOIN shipitem ON (shipitem_invcitem_id=invcitem_id)
                  LEFT OUTER JOIN shiphead ON (shiphead_id=shipitem_shiphead_id)
                  LEFT OUTER JOIN cohead ordershipped ON (ordershipped.cohead_id=shiphead_order_id)
                  LEFT OUTER JOIN coitem ON (coitem_id=invcitem_coitem_id)
                  LEFT OUTER JOIN cohead orderinvoiced ON (orderinvoiced.cohead_id=coitem_cohead_id)
   WHERE ( (invchead_id = pInvcheadId)
     AND   (invchead_posted)
     AND   (checkInvoiceSitePrivs(invchead_id)) )
  GROUP BY invchead_id, cobmisc_id, shiphead_id, ordship_id, ordinv_id LOOP

    IF (fetchMetricBool('MultiWhs')) THEN
      FOR _ra IN
        SELECT rahead_id
        FROM rahead
        WHERE (rahead_orig_cohead_id=_r.ordship_id) LOOP
        IF (_debug) THEN
          RAISE NOTICE 'Deleting Original Return head id %', _ra.rahead_id;
        END IF;
        DELETE FROM raitemls WHERE (raitemls_raitem_id IN (SELECT raitem_id
                                                           FROM raitem
                                                           WHERE (raitem_rahead_id=_ra.rahead_id)));
        DELETE FROM rahist WHERE (rahist_rahead_id=_ra.rahead_id);
        DELETE FROM raitem WHERE (raitem_rahead_id=_ra.rahead_id);
        DELETE FROM rahead WHERE (rahead_id=_ra.rahead_id);
      END LOOP;
      FOR _ra IN
        SELECT rahead_id
        FROM rahead
        WHERE (rahead_orig_cohead_id=_r.ordinv_id) LOOP
        IF (_debug) THEN
          RAISE NOTICE 'Deleting Original Return head id %', _ra.rahead_id;
        END IF;
        DELETE FROM raitemls WHERE (raitemls_raitem_id IN (SELECT raitem_id
                                                           FROM raitem
                                                           WHERE (raitem_rahead_id=_ra.rahead_id)));
        DELETE FROM rahist WHERE (rahist_rahead_id=_ra.rahead_id);
        DELETE FROM raitem WHERE (raitem_rahead_id=_ra.rahead_id);
        DELETE FROM rahead WHERE (rahead_id=_ra.rahead_id);
      END LOOP;

      FOR _ra IN
        SELECT rahead_id
          FROM rahead
         WHERE (rahead_new_cohead_id=_r.ordship_id) LOOP
        IF (_debug) THEN
          RAISE NOTICE 'Deleting New Return head id %', _ra.rahead_id;
        END IF;
        DELETE FROM raitemls WHERE (raitemls_raitem_id IN (SELECT raitem_id
                                                           FROM raitem
                                                           WHERE (raitem_rahead_id=_ra.rahead_id)));
        DELETE FROM rahist WHERE (rahist_rahead_id=_ra.rahead_id);
        DELETE FROM raitem WHERE (raitem_rahead_id=_ra.rahead_id);
        DELETE FROM rahead WHERE (rahead_id=_ra.rahead_id);
      END LOOP;
      FOR _ra IN
        SELECT rahead_id
          FROM rahead
         WHERE (rahead_new_cohead_id=_r.ordinv_id) LOOP
        IF (_debug) THEN
          RAISE NOTICE 'Deleting New Return head id %', _ra.rahead_id;
        END IF;
        DELETE FROM raitemls WHERE (raitemls_raitem_id IN (SELECT raitem_id
                                                           FROM raitem
                                                           WHERE (raitem_rahead_id=_ra.rahead_id)));
        DELETE FROM rahist WHERE (rahist_rahead_id=_ra.rahead_id);
        DELETE FROM raitem WHERE (raitem_rahead_id=_ra.rahead_id);
        DELETE FROM rahead WHERE (rahead_id=_ra.rahead_id);
      END LOOP;
    END IF;

    IF (fetchMetricBool('MultiWhs')) THEN
      IF (_debug) THEN
        RAISE NOTICE 'Deleting Lot/Serial Registrations';
      END IF;
      DELETE FROM lsreg WHERE (lsreg_cohead_id=_r.ordship_id);
      DELETE FROM lsreg WHERE (lsreg_cohead_id=_r.ordinv_id);
      DELETE FROM lsreg WHERE (lsreg_shiphead_id=_r.shiphead_id);
    END IF;

    IF (_debug) THEN
      RAISE NOTICE 'Deleting Shipped Sales Order head id %', _r.ordship_id;
    END IF;
    DELETE FROM payco WHERE (payco_cohead_id=_r.ordship_id);
    -- Delete kit components first
    DELETE FROM coitem WHERE (coitem_cohead_id=_r.ordship_id AND coitem_subnumber > 0);
    DELETE FROM coitem WHERE (coitem_cohead_id=_r.ordship_id);
    DELETE FROM cohead WHERE (cohead_id=_r.ordship_id);

    IF (_debug) THEN
      RAISE NOTICE 'Deleting Sales Order head id %', _r.ordinv_id;
    END IF;
    DELETE FROM payco WHERE (payco_cohead_id=_r.ordinv_id);
    -- Delete kit components first
    DELETE FROM coitem WHERE (coitem_cohead_id=_r.ordinv_id AND coitem_subnumber > 0);
    DELETE FROM coitem WHERE (coitem_cohead_id=_r.ordinv_id);
    DELETE FROM cohead WHERE (cohead_id=_r.ordinv_id);

    IF (_debug) THEN
      RAISE NOTICE 'Deleting Ship head id %', _r.shiphead_id;
    END IF;
    DELETE FROM shipitem WHERE (shipitem_shiphead_id=_r.shiphead_id);
    DELETE FROM pack WHERE (pack_shiphead_id=_r.shiphead_id);
    DELETE FROM shiphead WHERE (shiphead_id=_r.shiphead_id);

    IF (_debug) THEN
      RAISE NOTICE 'Deleting Billing head id %', _r.cobmisc_id;
    END IF;
    DELETE FROM cobill WHERE (cobill_cobmisc_id=_r.cobmisc_id);
    DELETE FROM cobmisc WHERE (cobmisc_id=_r.cobmisc_id);
  END LOOP;

-- Everything is OK, delete the Invoice
  IF (_debug) THEN
    RAISE NOTICE 'Deleting Invoice head id %', _r.invchead_id;
  END IF;
  DELETE FROM invcitem WHERE (invcitem_invchead_id=_r.invchead_id);
  DELETE FROM invchead WHERE (invchead_id=_r.invchead_id);

  RETURN 'Purged';

END;
$_$;


ALTER FUNCTION public.purgeinvoicerecord(date, integer) OWNER TO admin;

--
-- TOC entry 2060 (class 1255 OID 146566897)
-- Dependencies: 4536 8
-- Name: purgeinvoicerecords(date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION purgeinvoicerecords(date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCutoffDate ALIAS FOR $1;

BEGIN

-- Remove the shipitem records
  DELETE FROM shipitem
  WHERE (shipitem_invcitem_id IN (SELECT invcitem_id
                                  FROM invcitem
                                  WHERE invcitem_invchead_id IN ( SELECT invchead_id
                                     FROM invchead
                                     WHERE ( (invchead_invcdate <= pCutoffDate)
                                     AND   (checkInvoiceSitePrivs(invchead_id))
                                     AND   (invchead_posted) ) ) ) );

-- Remove the cobill and cobmisc records
  DELETE FROM cobill
  WHERE (cobill_cobmisc_id IN ( SELECT cobmisc_id
                                FROM cobmisc, invchead
                                WHERE ( (invchead_invcnumber=cobmisc_invcnumber::TEXT)
                                  AND   (checkInvoiceSitePrivs(invchead_id))
                                  AND   (cobmisc_invcdate <= pCutoffDate)
                                  AND   (cobmisc_posted)) ) );

  DELETE FROM cobmisc
  WHERE ( (checkInvoiceSitePrivs(getInvcheadId(cobmisc_invcnumber::TEXT)))
    AND   (cobmisc_invcdate <= pCutoffDate)
    AND   (cobmisc_posted) );

-- Remove the invchead and invcitem records
  DELETE FROM invcitem
  WHERE (invcitem_invchead_id IN ( SELECT invchead_id
                                   FROM invchead
                                   WHERE ( (invchead_invcdate <= pCutoffDate)
                                     AND   (checkInvoiceSitePrivs(invchead_id))
                                     AND   (invchead_posted) ) ) );

  DELETE FROM invchead
  WHERE ( (invchead_invcdate <= pCutoffDate)
    AND   (checkInvoiceSitePrivs(invchead_id))
    AND   (invchead_posted) );

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.purgeinvoicerecords(date) OWNER TO admin;

--
-- TOC entry 2061 (class 1255 OID 146566898)
-- Dependencies: 4536 8
-- Name: purgepostedcountslips(date, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION purgepostedcountslips(date, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCutoffDate ALIAS FOR $1;
  pWarehousid ALIAS FOR $2;

BEGIN

  IF (pWarehousid = -1) THEN
    DELETE FROM cntslip
    WHERE (cntslip_id IN ( SELECT cntslip_id
                           FROM cntslip, invcnt
                           WHERE ( (cntslip_cnttag_id=invcnt_id)
                            AND (invcnt_posted)
                            AND (cntslip_posted)
                            AND (date(invcnt_postdate) <= pCutoffDate) ) ) );

  ELSE
    DELETE FROM cntslip
    WHERE (cntslip_id IN ( SELECT cntslip_id
                           FROM invcnt, itemsite
                           WHERE ( (cntslip_cnttag_id=invcnt_id)
                            AND (invcnt_posted)
                            AND (cntslip_posted)
                            AND (invcnt_itemsite_id=itemsite_id)
                            AND (date(invcnt_postdate) <= pCutoffDate)
                            AND (itemsite_warehous_id=pWarehousid) ) ) );
  END IF;

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.purgepostedcountslips(date, integer) OWNER TO admin;

--
-- TOC entry 2062 (class 1255 OID 146566899)
-- Dependencies: 4536 8
-- Name: purgepostedcounttags(date, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION purgepostedcounttags(date, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCutoffDate ALIAS FOR $1;
  pWarehousid ALIAS FOR $2;

BEGIN

  IF (pWarehousid = -1) THEN
    DELETE FROM cntslip
    WHERE (cntslip_cnttag_id IN ( SELECT invcnt_id
                                  FROM invcnt
                                  WHERE ( (invcnt_posted)
                                   AND (date(invcnt_postdate) <= pCutoffDate) ) ) );

    DELETE FROM invcnt
    WHERE ((invcnt_posted)
     AND (date(invcnt_postdate) <= pCutoffDate));

  ELSE
    DELETE FROM cntslip
    WHERE (cntslip_cnttag_id IN ( SELECT invcnt_id
                                  FROM invcnt, itemsite
                                  WHERE ( (invcnt_posted)
                                   AND (invcnt_itemsite_id=itemsite_id)
                                   AND (date(invcnt_postdate) <= pCutoffDate)
                                   AND (itemsite_warehous_id=pWarehousid) ) ) );

    DELETE FROM invcnt
    WHERE (invcnt_id IN ( SELECT invcnt_id
                          FROM invcnt, itemsite
                          WHERE ( (invcnt_posted)
                           AND (invcnt_itemsite_id=itemsite_id)
                           AND (date(invcnt_postdate) <= pCutoffDate)
                           AND (itemsite_warehous_id=pWarehousid) ) ) );
  END IF;

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.purgepostedcounttags(date, integer) OWNER TO admin;

--
-- TOC entry 2064 (class 1255 OID 146566900)
-- Dependencies: 4536 8
-- Name: purgeshipments(date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION purgeshipments(date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pcutoff ALIAS FOR $1;
  _r RECORD;

BEGIN

  -- Used for transfer orders shipments (which are never invoiced)
  FOR _r IN SELECT shiphead_id
	      FROM shiphead
	     WHERE ( (shiphead_order_type='TO')
               AND   (shiphead_shipped)
               AND   (shiphead_shipdate <= pcutoff) ) LOOP
    DELETE FROM shipitem WHERE (shipitem_shiphead_id=_r.shiphead_id);
    DELETE FROM shiphead WHERE (shiphead_id=_r.shiphead_id);
  END LOOP;

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.purgeshipments(date) OWNER TO admin;

--
-- TOC entry 2065 (class 1255 OID 146566901)
-- Dependencies: 4536 8
-- Name: qtyallocated(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION qtyallocated(integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pLookAheaddays ALIAS FOR $2;

BEGIN

  RETURN qtyAllocated(pItemsiteid, startOfTime(), (CURRENT_DATE + pLookAheadDays));

END;
$_$;


ALTER FUNCTION public.qtyallocated(integer, integer) OWNER TO admin;

--
-- TOC entry 2066 (class 1255 OID 146566902)
-- Dependencies: 4536 8
-- Name: qtyallocated(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION qtyallocated(integer, date) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pDate ALIAS FOR $2;

BEGIN

  RETURN qtyAllocated(pItemsiteid, startOfTime(), pDate);

END;
$_$;


ALTER FUNCTION public.qtyallocated(integer, date) OWNER TO admin;

--
-- TOC entry 2067 (class 1255 OID 146566903)
-- Dependencies: 4536 8
-- Name: qtyallocated(integer, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION qtyallocated(integer, date, date) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pStartDate ALIAS FOR $2;
  pEndDate ALIAS FOR $3;

BEGIN

  IF ( fetchMetricBool('MultiWhs')) THEN
    IF ( SELECT item_sold
         FROM itemsite, item
         WHERE ((itemsite_item_id=item_id)
         AND (itemsite_id=pItemsiteid)) ) THEN
      RETURN (allocatedForTo(pItemsiteid, pStartDate, pEndDate) +
	      allocatedForWo(pItemsiteid, pStartDate, pEndDate) +
	      allocatedForSo(pItemsiteid, pStartDate, pEndDate));
    ELSE
      RETURN (allocatedForTo(pItemsiteid, pStartDate, pEndDate) +
	      allocatedForWo(pItemsiteid, pStartDate, pEndDate));
    END IF;
  ELSE
    IF ( SELECT item_sold
         FROM itemsite, item
         WHERE ((itemsite_item_id=item_id)
         AND (itemsite_id=pItemsiteid)) ) THEN
      RETURN (allocatedForWo(pItemsiteid, pStartDate, pEndDate) +
	      allocatedForSo(pItemsiteid, pStartDate, pEndDate));
    ELSE
      RETURN (allocatedForWo(pItemsiteid, pStartDate, pEndDate));
    END IF;
  END IF;
END;
$_$;


ALTER FUNCTION public.qtyallocated(integer, date, date) OWNER TO admin;

--
-- TOC entry 2068 (class 1255 OID 146566904)
-- Dependencies: 4536 8
-- Name: qtyatshipping(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION qtyatshipping(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN qtyAtShipping('SO', $1);
END;
$_$;


ALTER FUNCTION public.qtyatshipping(integer) OWNER TO admin;

--
-- TOC entry 2069 (class 1255 OID 146566905)
-- Dependencies: 4536 8
-- Name: qtyatshipping(text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION qtyatshipping(text, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN qtyAtShipping($1, $2, 'U');
END;
$_$;


ALTER FUNCTION public.qtyatshipping(text, integer) OWNER TO admin;

--
-- TOC entry 2070 (class 1255 OID 146566906)
-- Dependencies: 4536 8
-- Name: qtyatshipping(text, integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION qtyatshipping(text, integer, text) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pordertype	ALIAS FOR $1;
  plineitemid	ALIAS FOR $2;
  pstatus       ALIAS FOR $3;
  _qty NUMERIC  := 0.0;

BEGIN

-- pstatus U=unshipped
--         S=shipped
--         B=both unshipped and shipped

  IF (pordertype NOT IN ('SO', 'TO')) THEN
    RAISE EXCEPTION '% is not a valid order type', pordertype;
  END IF;

  IF (pstatus NOT IN ('U', 'S', 'B')) THEN
    RAISE EXCEPTION '% is not a valid status', pstatus;
  END IF;

  SELECT COALESCE(SUM(shipitem_qty), 0.0) INTO _qty
  FROM shipitem, shiphead
  WHERE ((shipitem_shiphead_id=shiphead_id)
    AND  (shiphead_order_type=pordertype)
    AND  (shipitem_orderitem_id=plineitemid)
    AND  (((shiphead_shipped) AND (pstatus IN ('S', 'B'))) OR ((NOT shiphead_shipped) AND (pstatus IN ('U', 'B'))))  );

  RETURN _qty;

END;
$_$;


ALTER FUNCTION public.qtyatshipping(text, integer, text) OWNER TO admin;

--
-- TOC entry 2071 (class 1255 OID 146566907)
-- Dependencies: 4536 8
-- Name: qtyavailable(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION qtyavailable(integer, integer) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pLookAheadDays ALIAS FOR $2;

BEGIN

  RETURN ( ( SELECT itemsite_qtyonhand
             FROM itemsite
             WHERE (itemsite_id=pItemsiteid) ) +
           (SELECT qtyOrdered(pItemsiteid, pLookAheadDays)) -
           (SELECT qtyAllocated(pitemsiteid, pLookAheadDays)) );
END;
$_$;


ALTER FUNCTION public.qtyavailable(integer, integer) OWNER TO admin;

--
-- TOC entry 2072 (class 1255 OID 146566908)
-- Dependencies: 4536 8
-- Name: qtyavailable(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION qtyavailable(integer, date) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pDate ALIAS FOR $2;

BEGIN

  RETURN ( ( SELECT itemsite_qtyonhand
             FROM itemsite
             WHERE (itemsite_id=pItemsiteid) ) +
           (SELECT qtyOrdered(pItemsiteid, (pDate - CURRENT_DATE))) -
           (SELECT qtyAllocated(pItemsiteid, (pDate - CURRENT_DATE))) );
END;
$_$;


ALTER FUNCTION public.qtyavailable(integer, date) OWNER TO admin;

--
-- TOC entry 2073 (class 1255 OID 146566909)
-- Dependencies: 4536 8
-- Name: qtyinshipment(text, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION qtyinshipment(text, integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pordertype	ALIAS FOR $1;
  plineitemid	ALIAS FOR $2;
  pshipheadid   ALIAS FOR $3;
  _qty NUMERIC;

BEGIN

  IF (pordertype NOT IN ('SO', 'TO')) THEN
    RAISE EXCEPTION '% is not a valid order type', pordertype;
  END IF;

  IF (pshipheadid IS NULL) THEN
    RAISE EXCEPTION 'Cannot calculate quantity in a shipment with a NULL shipment';
  END IF;

  SELECT SUM(COALESCE(shipitem_qty, 0.0)) INTO _qty
  FROM shipitem, shiphead
  WHERE ((shipitem_shiphead_id=shiphead_id)
      AND (shiphead_order_type=pordertype)
      AND (shipitem_orderitem_id=plineitemid)
      AND (shiphead_id=pshipheadid));

  IF (NOT FOUND) THEN
    RAISE NOTICE 'Quantity of % item % is 0 because shipment % does not exist.',
                  pordertype, plineitemid, pshipheadid;
  END IF;

  RETURN _qty;

END;
$_$;


ALTER FUNCTION public.qtyinshipment(text, integer, integer) OWNER TO admin;

--
-- TOC entry 2076 (class 1255 OID 146566910)
-- Dependencies: 4536 8
-- Name: qtylocation(integer, integer, date, date, integer, text, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION qtylocation(integer, integer, date, date, integer, text, integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pLocationId  ALIAS FOR $1;
  pLsId        ALIAS FOR $2;
  pExpiration  ALIAS FOR $3;
  pWarranty    ALIAS FOR $4;
  pItemsiteId  ALIAS FOR $5;
  pOrderType   ALIAS FOR $6;
  pOrderId     ALIAS FOR $7;
  pItemlocdistId ALIAS FOR $8;
  _qty         NUMERIC = 0.0;
  _qtyDist     NUMERIC = 0.0;
  _qtyReserved NUMERIC = 0.0;

BEGIN
-- Summarize itemloc qty for this location/itemsite
  SELECT COALESCE(SUM(itemloc_qty), 0) INTO _qty
    FROM itemloc
   WHERE ( (itemloc_itemsite_id=pItemsiteId)
     AND (itemloc_location_id=pLocationId)
     AND (COALESCE(itemloc_ls_id, -1)=COALESCE(pLsId, itemloc_ls_id, -1))
     AND (COALESCE(itemloc_expiration, endoftime())=COALESCE(pExpiration, itemloc_expiration, endoftime()))
     AND (COALESCE(itemloc_warrpurc, endoftime())=COALESCE(pWarranty, itemloc_warrpurc, endoftime())) );

-- Summarize qty distributed but not yet committed by previous distributions
  SELECT COALESCE(SUM(loc.itemlocdist_qty), 0) INTO _qtyDist
    FROM itemlocdist loc
      JOIN itemlocdist ls ON ((ls.itemlocdist_source_type='O')
			  AND (ls.itemlocdist_id=loc.itemlocdist_itemlocdist_id))
   WHERE ( (ls.itemlocdist_itemsite_id=pItemsiteId)
     AND (loc.itemlocdist_source_type='L')
     AND (loc.itemlocdist_source_id=pLocationId)
     AND (COALESCE(ls.itemlocdist_ls_id, -1)=COALESCE(pLsId, ls.itemlocdist_ls_id, -1))
     AND (COALESCE(ls.itemlocdist_expiration, endoftime())=COALESCE(pExpiration, ls.itemlocdist_expiration, endoftime()))
     AND (COALESCE(ls.itemlocdist_warranty, endoftime())=COALESCE(pWarranty, ls.itemlocdist_warranty, endoftime()))
     AND (ls.itemlocdist_id != pItemlocdistId ) );

-- Summarize reserved qty for this location/itemsite
-- that is reserved for a different order
  IF (fetchMetricBool('EnableSOReservationsByLocation')) THEN
    SELECT COALESCE(SUM(reserve_qty), 0) INTO _qtyReserved
      FROM itemloc JOIN reserve ON ( (reserve_supply_id=itemloc_id AND reserve_supply_type='I')
                                    AND  ((reserve_demand_type <> COALESCE(pOrderType, '')) OR
                                          (reserve_demand_id <> COALESCE(pOrderId, -1))) )
     WHERE ( (itemloc_itemsite_id=pItemsiteId)
       AND (itemloc_location_id=pLocationId)
       AND (COALESCE(itemloc_ls_id, -1)=COALESCE(pLsId, itemloc_ls_id, -1))
       AND (COALESCE(itemloc_expiration, endoftime())=COALESCE(pExpiration, itemloc_expiration, endoftime()))
       AND (COALESCE(itemloc_warrpurc, endoftime())=COALESCE(pWarranty, itemloc_warrpurc, endoftime())) );
  END IF;

  RETURN (_qty + _qtyDist - _qtyReserved);

END;
$_$;


ALTER FUNCTION public.qtylocation(integer, integer, date, date, integer, text, integer, integer) OWNER TO admin;

--
-- TOC entry 2077 (class 1255 OID 146566911)
-- Dependencies: 4536 8
-- Name: qtyordered(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION qtyordered(integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pLookahead ALIAS FOR $2;
  _itemType TEXT;
  _result NUMERIC;

BEGIN

  RETURN qtyOrdered(pItemsiteid, startOfTime(), (CURRENT_DATE + pLookahead));

END;
$_$;


ALTER FUNCTION public.qtyordered(integer, integer) OWNER TO admin;

--
-- TOC entry 2078 (class 1255 OID 146566912)
-- Dependencies: 4536 8
-- Name: qtyordered(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION qtyordered(integer, date) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pDate ALIAS FOR $2;

BEGIN

  RETURN qtyOrdered(pItemsiteid, startOfTime(), pDate);

END;
$_$;


ALTER FUNCTION public.qtyordered(integer, date) OWNER TO admin;

--
-- TOC entry 2079 (class 1255 OID 146566913)
-- Dependencies: 4536 8
-- Name: qtyordered(integer, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION qtyordered(integer, date, date) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pStartDate ALIAS FOR $2;
  pEndDate ALIAS FOR $3;
  _itemType TEXT;

BEGIN

  SELECT item_type INTO _itemType
  FROM item, itemsite
  WHERE ( (itemsite_item_id=item_id)
   AND (itemsite_id=pItemsiteid) );

  IF ( SELECT metric_value
	FROM metric
	WHERE ((metric_name = 'MultiWhs')
	AND (metric_value = 't'))) THEN
    RETURN orderedByPo(pItemsiteid, pStartDate, pEndDate) +
           orderedByWo(pItemsiteid, pStartDate, pEndDate) +
           orderedByTo(pItemsiteid, pStartDate, pEndDate);
  ELSE
    RETURN orderedByPo(pItemsiteid, pStartDate, pEndDate) +
           orderedByWo(pItemsiteid, pStartDate, pEndDate);

  END IF;

END;
$_$;


ALTER FUNCTION public.qtyordered(integer, date, date) OWNER TO admin;

--
-- TOC entry 2080 (class 1255 OID 146566914)
-- Dependencies: 4536 8
-- Name: qtypr(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION qtypr(integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pLookahead ALIAS FOR $2;

BEGIN
  RETURN qtypr(pItemsiteid, startOfTime(), (CURRENT_DATE + pLookahead));
END;
$_$;


ALTER FUNCTION public.qtypr(integer, integer) OWNER TO admin;

--
-- TOC entry 2081 (class 1255 OID 146566915)
-- Dependencies: 4536 8
-- Name: qtypr(integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION qtypr(integer, date) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pDate ALIAS FOR $2;

BEGIN
  RETURN qtypr(pItemsiteid, startOfTime(), pDate);
END;
$_$;


ALTER FUNCTION public.qtypr(integer, date) OWNER TO admin;

--
-- TOC entry 2082 (class 1255 OID 146566916)
-- Dependencies: 4536 8
-- Name: qtypr(integer, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION qtypr(integer, date, date) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pStartDate ALIAS FOR $2;
  pEndDate ALIAS FOR $3;
  _prtotal NUMERIC;

BEGIN

SELECT SUM(pr_qtyreq) INTO _prtotal
  FROM pr
  WHERE ((pr_status = 'O')
    AND (pr_itemsite_id=pItemsiteid)
    AND (pr_duedate BETWEEN pStartDate AND pEndDate));

 IF (_prtotal IS NULL) THEN
     RETURN 0.0;
 END IF;

 RETURN _prtotal;

END;
$_$;


ALTER FUNCTION public.qtypr(integer, date, date) OWNER TO admin;

--
-- TOC entry 2083 (class 1255 OID 146566917)
-- Dependencies: 4536 8
-- Name: qtyreserved(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION qtyreserved(integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/EULA for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  _qty NUMERIC;

BEGIN

  SELECT COALESCE(SUM(coitem_qtyreserved),0) INTO _qty
    FROM coitem
   WHERE(coitem_itemsite_id=pItemsiteid);

  RETURN _qty;
END;
$_$;


ALTER FUNCTION public.qtyreserved(integer) OWNER TO admin;

--
-- TOC entry 2084 (class 1255 OID 146566918)
-- Dependencies: 4536 8
-- Name: qtytoreceive(text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION qtytoreceive(text, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pordertype	ALIAS FOR $1;
  porderitemid	ALIAS FOR $2;
  _qty		NUMERIC;

BEGIN
  IF (pordertype = 'TO' AND NOT fetchMetricBool('MultiWhs')) THEN
    RETURN 0;
  END IF;

  IF (pordertype = 'RA' AND NOT fetchMetricBool('EnableReturnAuth')) THEN
    RETURN 0;
  END IF;

  SELECT SUM(recv_qty) INTO _qty
  FROM recv
  WHERE ((recv_orderitem_id=porderitemid)
    AND  (NOT recv_posted)
    AND  (recv_order_type=pordertype));

  RETURN COALESCE(_qty, 0.0);

END;
$_$;


ALTER FUNCTION public.qtytoreceive(text, integer) OWNER TO admin;

--
-- TOC entry 2085 (class 1255 OID 146566919)
-- Dependencies: 4536 8
-- Name: recallshipment(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION recallshipment(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN recallShipment($1, CURRENT_TIMESTAMP);
END;
$_$;


ALTER FUNCTION public.recallshipment(integer) OWNER TO admin;

--
-- TOC entry 2086 (class 1255 OID 146566920)
-- Dependencies: 4536 8
-- Name: recallshipment(integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION recallshipment(integer, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pshipheadid		ALIAS FOR $1;
  _timestamp		TIMESTAMP WITH TIME ZONE := $2;
  _allInvoiced		BOOLEAN;
  _invoicePosted	BOOLEAN;
  _in                   RECORD;
  _co			RECORD;
  _cobill		RECORD;
  _h			RECORD;
  _result               INTEGER;
  _invhistid		INTEGER;
  _itemlocSeries	INTEGER;
  _qty			NUMERIC;
  _qtyToBill		NUMERIC;
  _shiphead		RECORD;
  _to			RECORD;
  _ti			RECORD;
  _value                NUMERIC;

BEGIN

  IF (_timestamp IS NULL) THEN
    _timestamp := CURRENT_TIMESTAMP;
  END IF;

  SELECT * INTO _shiphead
  FROM shiphead
  WHERE (shiphead_id=pshipheadid);
  IF (NOT FOUND OR NOT _shiphead.shiphead_shipped) THEN
    RETURN -1;
  END IF;

  IF (_shiphead.shiphead_order_type = 'SO') THEN
    SELECT cohead_number AS head_number, cohead_cust_id AS cust_id, cohead_prj_id AS prj_id,
           cohead_saletype_id AS saletype_id, cohead_shipzone_id AS shipzone_id INTO _h
      FROM cohead
     WHERE (cohead_id=_shiphead.shiphead_order_id);
    IF (NOT FOUND) THEN
      RETURN -1;
    END IF;

    SELECT COALESCE(BOOL_AND(shipitem_invoiced), FALSE) INTO _allInvoiced
     FROM cobill, shipitem
    WHERE ((cobill_coitem_id=shipitem_orderitem_id)
      AND  (shipitem_shiphead_id=pshipheadid));

    IF (_allInvoiced AND NOT checkPrivilege('RecallInvoicedShipment')) THEN
      RETURN -2;
    END IF;

    -- Check for any associated posted Invoices
    SELECT COALESCE(BOOL_AND(invchead_posted), FALSE) INTO _invoicePosted
    FROM shipitem JOIN invcitem ON (invcitem_id=shipitem_invcitem_id)
                  JOIN invchead ON (invchead_id=invcitem_invchead_id)
    WHERE (shipitem_shiphead_id=pshipheadid);

    IF (_invoicePosted) THEN
      RETURN -4;
    END IF;

    -- Delete any associated unposted Invoices
    FOR _in IN SELECT DISTINCT invchead_id
                 FROM shipitem JOIN invcitem ON (invcitem_id=shipitem_invcitem_id)
                               JOIN invchead ON ( (invchead_id=invcitem_invchead_id) AND
                                                  (NOT invchead_posted) )
                WHERE (shipitem_shiphead_id=pshipheadid) LOOP
      SELECT deleteInvoice(_in.invchead_id) INTO _result;
      IF (_result < 0) THEN
        RETURN _result;
      END IF;
    END LOOP;

    FOR _co IN SELECT coitem_id, coitem_itemsite_id, coitem_qty_invuomratio, coitem_warranty, coitem_cos_accnt_id,
                   itemsite_controlmethod
                 FROM coitem
                  JOIN itemsite ON (coitem_itemsite_id=itemsite_id)
                WHERE(coitem_id IN (SELECT shipitem_orderitem_id
                                      FROM shipitem, shiphead
                                     WHERE((shipitem_shiphead_id=shiphead_id)
                                       AND (shiphead_shipped)
                                       AND (shiphead_id=pshipheadid)))) FOR UPDATE LOOP

      SELECT SUM(shipitem_qty),SUM(COALESCE(shipitem_value, 0)) INTO _qty, _value
      FROM shipitem
      WHERE ( (shipitem_orderitem_id=_co.coitem_id)
       AND (shipitem_shiphead_id=pshipheadid) );

      UPDATE coitem
      SET coitem_qtyshipped = (coitem_qtyshipped - _qty)
      WHERE (coitem_id=_co.coitem_id);

      _qtyToBill := _qty;
      FOR _cobill IN SELECT cobill_id, cobill_qty
			 FROM cobill, shipitem
			WHERE ((cobill_coitem_id=shipitem_orderitem_id)
			  AND  (shipitem_shiphead_id=pshipheadid)
			  AND  (cobill_coitem_id=_co.coitem_id)) FOR UPDATE LOOP

        IF (noNeg(_cobill.cobill_qty - _qtyToBill) = 0) THEN
          DELETE FROM cobill WHERE (cobill_id=_cobill.cobill_id);
        ELSE
	  UPDATE cobill
	  SET cobill_qty = noNeg(cobill_qty - _qtyToBill)
	  WHERE (cobill_id=_cobill.cobill_id);
	END IF;

	_qtyToBill = _qtyToBill - _cobill.cobill_qty;
	EXIT WHEN (_qtyToBill <= 0.0);
      END LOOP;

  --  Check to see if all of the cobills have been deleted for this cobmisc
      IF (EXISTS(SELECT cobmisc_id
                 FROM cobmisc JOIN cobill ON (cobill_cobmisc_id=cobmisc_id)
                 WHERE (cobmisc_cohead_id=_shiphead.shiphead_order_id AND NOT cobmisc_posted))) THEN
  --  Lines exist, update the freight
        UPDATE cobmisc SET cobmisc_freight = (cobmisc_freight - _shiphead.shiphead_freight)
        WHERE (cobmisc_cohead_id=_shiphead.shiphead_order_id AND NOT cobmisc_posted);
      ELSE
  --  No lines exist, delete the cobmisc
        DELETE FROM cobmisc
        WHERE (cobmisc_cohead_id=_shiphead.shiphead_order_id AND NOT cobmisc_posted);
      END IF;

  --  Distribute to G/L, debit Shipping Asset, credit COS
      IF (_co.itemsite_controlmethod != 'N') THEN
        PERFORM insertGLTransaction( 'S/R', _shiphead.shiphead_order_type,
	  			   _h.head_number::TEXT, 'Recall Shipment',
                                   CASE WHEN(COALESCE(_co.coitem_cos_accnt_id, -1) != -1)
                                          THEN getPrjAccntId(_h.prj_id, _co.coitem_cos_accnt_id)
                                        WHEN(_co.coitem_warranty = TRUE)
                                          THEN getPrjAccntId(_h.prj_id, resolveCOWAccount(itemsite_id, _h.cust_id, _h.saletype_id, _h.shipzone_id))
				        ELSE getPrjAccntId(_h.prj_id, resolveCOSAccount(itemsite_id, _h.cust_id, _h.saletype_id, _h.shipzone_id))
                                   END,
                                   getPrjAccntId(_h.prj_id,costcat_shipasset_accnt_id), -1,
				   _value,
				   _timestamp::DATE )
        FROM itemsite, costcat
        WHERE ( (itemsite_costcat_id=costcat_id)
         AND (itemsite_id=_co.coitem_itemsite_id) );
       END IF;

    END LOOP;

-- Kit billing selection
-- Set kit billing qty to zero since kits are shipped complete
    FOR _cobill IN SELECT cobill_id, cobill_qty
                   FROM shipitem JOIN coitem sub ON (sub.coitem_id=shipitem_orderitem_id)
                                 JOIN coitem kit ON (kit.coitem_id <> sub.coitem_id AND
                                                     kit.coitem_cohead_id = sub.coitem_cohead_id AND
                                                     kit.coitem_linenumber = sub.coitem_linenumber AND
                                                     kit.coitem_subnumber = 0)
                                 JOIN cobill ON (cobill_coitem_id=kit.coitem_id)
                   WHERE (shipitem_shiphead_id=pshipheadid)
                     AND (sub.coitem_subnumber > 0)
                   GROUP BY cobill_id, cobill_qty
    LOOP
      UPDATE cobill SET cobill_qty = 0.0
      WHERE (cobill_id=_cobill.cobill_id);
    END LOOP;

  ELSEIF (_shiphead.shiphead_order_type = 'TO') THEN
    SELECT * INTO _to
      FROM tohead
     WHERE (tohead_id=_shiphead.shiphead_order_id);
    IF (NOT FOUND) THEN
      RETURN -1;
    END IF;
    IF (_to.tohead_status = 'C') THEN
      RETURN -6;
    END IF;

    FOR _ti IN SELECT toitem_id,
                      sis.itemsite_id AS src_itemsite_id,
                      tis.itemsite_id AS trns_itemsite_id,
                      scc.costcat_shipasset_accnt_id AS src_shipasset_accnt_id,
                      tcc.costcat_asset_accnt_id AS trns_asset_accnt_id,
                      itemcost(tis.itemsite_id) AS trns_cost,
                      SUM(shipitem_qty) AS recall_qty
               FROM shipitem JOIN toitem ON (toitem_id=shipitem_orderitem_id)
                             JOIN itemsite sis ON (sis.itemsite_item_id=toitem_item_id AND sis.itemsite_warehous_id=_to.tohead_src_warehous_id)
                             JOIN itemsite tis ON (tis.itemsite_item_id=toitem_item_id AND tis.itemsite_warehous_id=_to.tohead_trns_warehous_id)
                             JOIN costcat scc ON (scc.costcat_id=sis.itemsite_costcat_id)
                             JOIN costcat tcc ON (tcc.costcat_id=tis.itemsite_costcat_id)
               WHERE (shipitem_shiphead_id=pshipheadid)
               GROUP BY toitem_id, sis.itemsite_id, tis.itemsite_id,
                        scc.costcat_shipasset_accnt_id, tcc.costcat_asset_accnt_id
    LOOP

      _itemlocSeries := NEXTVAL('itemloc_series_seq');

      SELECT postInvTrans(_ti.src_itemsite_id, 'TS', (_ti.recall_qty * -1.0), 'I/M',
			  _shiphead.shiphead_order_type, formatToNumber(_ti.toitem_id),
			  _to.tohead_number,
			  'Recall TO Shipment To Src Warehouse',
			  _ti.trns_asset_accnt_id,
			  _ti.src_shipasset_accnt_id,
			  _itemlocSeries, _timestamp,
                          (_ti.trns_cost * _ti.recall_qty * -1.0)) INTO _invhistid;

      IF (_invhistid < 0) THEN
	RETURN _invhistid;
      END IF;

      -- post the inventory history if lot/serial or location control
      PERFORM postItemlocseries(_itemlocSeries);

      -- record inventory history and qoh changes at transit warehouse but
      -- there is only one g/l account to touch
      SELECT postInvTrans(_ti.trns_itemsite_id, 'TR', (_ti.recall_qty * -1.0), 'I/M',
			  _shiphead.shiphead_order_type, formatToNumber(_ti.toitem_id),
			  _to.tohead_number,
			  'Recall TO Shipment From Transit Warehouse',
			  _ti.trns_asset_accnt_id,
			  _ti.trns_asset_accnt_id,
			  _itemlocSeries, _timestamp,
                          (_ti.trns_cost * _ti.recall_qty * -1.0)) INTO _invhistid;

      IF (_invhistid < 0) THEN
	RETURN _invhistid;
      END IF;

      -- post the inventory history if lot/serial or location control
      PERFORM postItemlocseries(_itemlocSeries);

      UPDATE toitem
      SET toitem_qty_shipped = (toitem_qty_shipped - _ti.recall_qty)
      WHERE (toitem_id=_ti.toitem_id);

      UPDATE shipitem SET shipitem_shipdate=NULL,
                          shipitem_shipped=FALSE,
                          shipitem_value=(shipitem_qty * _ti.trns_cost)
      WHERE ((shipitem_orderitem_id=_ti.toitem_id)
        AND  (shipitem_shiphead_id=pshipheadid));

      DELETE FROM recv
	WHERE ((recv_orderitem_id=_ti.toitem_id)
	  AND  (recv_order_type='TO')
	  AND  (NOT recv_posted));

    END LOOP;

  END IF;

  UPDATE shiphead
  SET shiphead_shipped=FALSE
  WHERE (shiphead_id=pshipheadid);

  RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.recallshipment(integer, timestamp with time zone) OWNER TO admin;

--
-- TOC entry 2087 (class 1255 OID 146566922)
-- Dependencies: 4536 8
-- Name: recallwo(integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION recallwo(integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoid ALIAS FOR $1;
  recallChildren ALIAS FOR $2;
  returnCode INTEGER;

BEGIN

  UPDATE wo
  SET wo_status='E'
  WHERE ((wo_status='R')
   AND (wo_id=pWoid));

  IF (recallChildren) THEN
    returnCode := (SELECT MAX(recallWo(wo_id, TRUE))
                   FROM wo
                   WHERE ((wo_ordtype='W')
                    AND (wo_ordid=pWoid)));
  END IF;

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.recallwo(integer, boolean) OWNER TO admin;

--
-- TOC entry 2088 (class 1255 OID 146566923)
-- Dependencies: 4536 8
-- Name: receipts(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION receipts(text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTransType ALIAS FOR $1;

BEGIN
  IF (pTransType IN ('RM', 'RB', 'RT', 'RP', 'RR', 'RX', 'TR')) THEN
    RETURN TRUE;
  ELSE
    RETURN FALSE;
  END IF;

END;
$_$;


ALTER FUNCTION public.receipts(text) OWNER TO admin;

--
-- TOC entry 2089 (class 1255 OID 146566924)
-- Dependencies: 8
-- Name: releaseapmemonumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION releaseapmemonumber(integer) RETURNS boolean
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT releaseNumber('APMemoNumber', $1::INTEGER) > 0;
$_$;


ALTER FUNCTION public.releaseapmemonumber(integer) OWNER TO admin;

--
-- TOC entry 1980 (class 1255 OID 146566925)
-- Dependencies: 8
-- Name: releasearmemonumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION releasearmemonumber(integer) RETURNS boolean
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  select releaseNumber('ARMemoNumber', $1::INTEGER) > 0;
$_$;


ALTER FUNCTION public.releasearmemonumber(integer) OWNER TO admin;

--
-- TOC entry 2044 (class 1255 OID 146566926)
-- Dependencies: 8
-- Name: releasecashrcptnumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION releasecashrcptnumber(integer) RETURNS boolean
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT releaseNumber('CashRcptNumber', $1) > 0;
$_$;


ALTER FUNCTION public.releasecashrcptnumber(integer) OWNER TO admin;

--
-- TOC entry 2054 (class 1255 OID 146566927)
-- Dependencies: 8
-- Name: releasecmnumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION releasecmnumber(integer) RETURNS boolean
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT releaseNumber('CmNumber', $1) > 0;
$_$;


ALTER FUNCTION public.releasecmnumber(integer) OWNER TO admin;

--
-- TOC entry 2055 (class 1255 OID 146566928)
-- Dependencies: 8
-- Name: releasecmnumber(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION releasecmnumber(text) RETURNS boolean
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT releaseNumber('CmNumber', $1::INTEGER) > 0;
$_$;


ALTER FUNCTION public.releasecmnumber(text) OWNER TO admin;

--
-- TOC entry 2063 (class 1255 OID 146566929)
-- Dependencies: 8
-- Name: releasecrmaccountnumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION releasecrmaccountnumber(integer) RETURNS boolean
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT releaseNumber('CRMAccountNumber', $1::INTEGER) > 0;
$_$;


ALTER FUNCTION public.releasecrmaccountnumber(integer) OWNER TO admin;

--
-- TOC entry 2074 (class 1255 OID 146566930)
-- Dependencies: 8
-- Name: releaseincidentnumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION releaseincidentnumber(integer) RETURNS boolean
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT releaseNumber('IncidentNumber', $1) = 1;
$_$;


ALTER FUNCTION public.releaseincidentnumber(integer) OWNER TO admin;

--
-- TOC entry 2075 (class 1255 OID 146566931)
-- Dependencies: 8
-- Name: releaseinvcnumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION releaseinvcnumber(integer) RETURNS boolean
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT releaseNumber('InvcNumber', $1) > 0;
$_$;


ALTER FUNCTION public.releaseinvcnumber(integer) OWNER TO admin;

--
-- TOC entry 905 (class 1255 OID 146566932)
-- Dependencies: 8
-- Name: releaseinvcnumber(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION releaseinvcnumber(text) RETURNS boolean
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT releaseNumber('InvcNumber', $1::INTEGER) > 0;
$_$;


ALTER FUNCTION public.releaseinvcnumber(text) OWNER TO admin;

--
-- TOC entry 2090 (class 1255 OID 146566933)
-- Dependencies: 4536 8
-- Name: releasenumber(text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION releasenumber(text, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  psequence	ALIAS FOR $1;
  pnumber 	ALIAS FOR $2;
BEGIN
  IF (fetchMetricBool('EnableGaplessNumbering')) THEN
    -- drop the number back into the pool if it was not committed
    PERFORM clearNumberIssue(psequence, pnumber);
  END IF;

  UPDATE orderseq SET
    orderseq_number = LEAST(pnumber, orderseq_number)
  WHERE (orderseq_name=psequence);

  RETURN 1;
END;
$_$;


ALTER FUNCTION public.releasenumber(text, integer) OWNER TO admin;

--
-- TOC entry 2091 (class 1255 OID 146566934)
-- Dependencies: 8
-- Name: releaseponumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION releaseponumber(integer) RETURNS boolean
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT releaseNumber('PoNumber', $1) > 0;
$_$;


ALTER FUNCTION public.releaseponumber(integer) OWNER TO admin;

--
-- TOC entry 2092 (class 1255 OID 146566935)
-- Dependencies: 8
-- Name: releaseponumber(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION releaseponumber(text) RETURNS boolean
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT releaseNumber('PoNumber', $1::INTEGER) > 0;
$_$;


ALTER FUNCTION public.releaseponumber(text) OWNER TO admin;

--
-- TOC entry 2093 (class 1255 OID 146566936)
-- Dependencies: 8
-- Name: releaseprnumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION releaseprnumber(integer) RETURNS boolean
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT releaseNumber('PrNumber', $1) > 0;
$_$;


ALTER FUNCTION public.releaseprnumber(integer) OWNER TO admin;

--
-- TOC entry 2094 (class 1255 OID 146566937)
-- Dependencies: 4536 8
-- Name: releasepurchaseorder(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION releasepurchaseorder(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPoheadid ALIAS FOR $1;

BEGIN

  IF ( ( SELECT (COUNT(*) = 0)
         FROM poitem
         WHERE ( (poitem_pohead_id=pPoheadid)
           AND   (poitem_status='U') ) ) ) THEN
    RETURN -1;
  END IF;

  IF ( ( SELECT (pohead_status='U')
         FROM pohead
         WHERE (pohead_id=pPoheadid) ) ) THEN

    --update status and store the date that the order was released on
    UPDATE pohead
    SET pohead_status='O', pohead_released = current_date
    WHERE (pohead_id=pPoheadid);

  END IF;

  --update status and store the duedates at release
  UPDATE poitem
  SET poitem_status='O', poitem_rlsd_duedate = poitem_duedate
  WHERE (poitem_pohead_id=pPoheadid);

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.releasepurchaseorder(integer) OWNER TO admin;

--
-- TOC entry 2095 (class 1255 OID 146566938)
-- Dependencies: 8
-- Name: releasequnumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION releasequnumber(integer) RETURNS integer
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT releaseNumber('QuNumber', $1);
$_$;


ALTER FUNCTION public.releasequnumber(integer) OWNER TO admin;

--
-- TOC entry 2096 (class 1255 OID 146566939)
-- Dependencies: 8
-- Name: releasequnumber(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION releasequnumber(text) RETURNS integer
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT releaseNumber('QuNumber', $1::INTEGER);
$_$;


ALTER FUNCTION public.releasequnumber(text) OWNER TO admin;

--
-- TOC entry 2097 (class 1255 OID 146566940)
-- Dependencies: 4536 8
-- Name: releaseshipmentnumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION releaseshipmentnumber(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pNumber ALIAS FOR $1;
  _test INTEGER;

BEGIN

--  Check to see if a Shipment exists with the passed number
  SELECT shiphead_id INTO _test
  FROM shiphead
  WHERE (shiphead_number=pNumber);

  IF (FOUND) THEN
    RETURN FALSE;
  END IF;

--  Check to see if ShipmentNumber orderseq has been incremented past the passed number
  SELECT orderseq_number INTO _test
  FROM orderseq
  WHERE (orderseq_name='ShipmentNumber');

  IF ((_test - 1) <> pNumber) THEN
    RETURN FALSE;
  END IF;

--  Decrement the orderseq, releasing the passed number
  UPDATE orderseq
  SET orderseq_number = (orderseq_number - 1)
  WHERE (orderseq_name='ShipmentNumber');

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.releaseshipmentnumber(integer) OWNER TO admin;

--
-- TOC entry 2098 (class 1255 OID 146566941)
-- Dependencies: 4536 8
-- Name: releasesohead(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION releasesohead(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSoheadid ALIAS FOR $1;

BEGIN

  DELETE FROM soheadlock
   WHERE ( (soheadlock_sohead_id=pSoheadid)
     AND   (soheadlock_username=getEffectiveXtUser())
     AND   (soheadlock_procpid=pg_backend_pid()) );

  RETURN TRUE;
END;
$_$;


ALTER FUNCTION public.releasesohead(integer) OWNER TO admin;

--
-- TOC entry 2099 (class 1255 OID 146566942)
-- Dependencies: 8
-- Name: releasesonumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION releasesonumber(integer) RETURNS integer
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT releaseNumber('SoNumber', $1);
$_$;


ALTER FUNCTION public.releasesonumber(integer) OWNER TO admin;

--
-- TOC entry 2100 (class 1255 OID 146566943)
-- Dependencies: 4536 8
-- Name: releasesonumber(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION releasesonumber(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
	IF (COALESCE($1, '') = '' OR $1 ~ '[^0-9]')
	THEN
	--do nothing;
	RETURN 1;
	ELSE
	RETURN releaseNumber('SoNumber', $1::INTEGER);

	END IF;
END;
$_$;


ALTER FUNCTION public.releasesonumber(text) OWNER TO admin;

--
-- TOC entry 2101 (class 1255 OID 146566944)
-- Dependencies: 4536 8
-- Name: releaseunusedbillingheader(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION releaseunusedbillingheader(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCobmiscid ALIAS FOR $1;
  _p RECORD;

BEGIN

  IF ( ( SELECT cobmisc_posted
         FROM cobmisc
         WHERE (cobmisc_id=pCobmiscid) ) ) THEN
    RETURN -1;
  END IF;

  SELECT cobill_id INTO _p
    FROM cobill
   WHERE (cobill_cobmisc_id=pCobmiscid)
   LIMIT 1;
  IF (FOUND) THEN
    RETURN -2;
  END IF;

  DELETE FROM cobmisc
  WHERE (cobmisc_id=pCobmiscid);

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.releaseunusedbillingheader(integer) OWNER TO admin;

--
-- TOC entry 2102 (class 1255 OID 146566945)
-- Dependencies: 8
-- Name: releasevonumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION releasevonumber(integer) RETURNS boolean
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT releaseNumber('VcNumber', $1) > 0;
$_$;


ALTER FUNCTION public.releasevonumber(integer) OWNER TO admin;

--
-- TOC entry 2103 (class 1255 OID 146566946)
-- Dependencies: 4536 8
-- Name: releasewo(integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION releasewo(integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoid ALIAS FOR $1;
  releaseChildren ALIAS FOR $2;
  returnCode INTEGER;
BEGIN
  UPDATE wo
  SET wo_status='R'
  WHERE ((wo_status='E')
   AND (wo_id=pWoid));

  IF (releaseChildren) THEN
    returnCode := (SELECT MAX(releaseWo(wo_id, TRUE))
                   FROM wo
                   WHERE ((wo_ordtype='W')
                    AND (wo_ordid=pWoid)));
  END IF;

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.releasewo(integer, boolean) OWNER TO admin;

--
-- TOC entry 2104 (class 1255 OID 146566947)
-- Dependencies: 8
-- Name: releasewonumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION releasewonumber(integer) RETURNS boolean
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT releaseNumber('WoNumber', $1) > 0;
$_$;


ALTER FUNCTION public.releasewonumber(integer) OWNER TO admin;

--
-- TOC entry 930 (class 1255 OID 146566948)
-- Dependencies: 4536 8
-- Name: relocateinventory(integer, integer, integer, numeric, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION relocateinventory(integer, integer, integer, numeric, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN relocateInventory($1, $2, $3, $4, $5, CURRENT_TIMESTAMP);
END;
$_$;


ALTER FUNCTION public.relocateinventory(integer, integer, integer, numeric, text) OWNER TO admin;

--
-- TOC entry 946 (class 1255 OID 146566949)
-- Dependencies: 4536 8
-- Name: relocateinventory(integer, integer, integer, numeric, text, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION relocateinventory(integer, integer, integer, numeric, text, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSourceItemlocid      ALIAS FOR $1;
  pTargetLocationid     ALIAS FOR $2;
  pItemsiteid           ALIAS FOR $3;
  pQty                  ALIAS FOR $4;
  pComments             ALIAS FOR $5;
  _GlDistTS             TIMESTAMP WITH TIME ZONE := $6;
  _targetItemlocid      INTEGER;
  _invhistid            INTEGER;
  _p                    RECORD;
  _rsrv                 RECORD;
  _qty                  NUMERIC;
  _qtyunreserved        NUMERIC := 0.0;
  _qtytomove            NUMERIC := 0.0;
  _result               INTEGER := -1;
  _itemlocSeries        INTEGER := NEXTVAL('itemloc_series_seq');

BEGIN

    IF ((_GlDistTS IS NULL) OR (CAST(_GlDistTS AS date)=CURRENT_DATE)) THEN
      _GlDistTS := CURRENT_TIMESTAMP;
    END IF;

--  Make sure the passed itemsite points to a real item
  IF ( ( SELECT (item_type IN ('R', 'F') OR itemsite_costmethod = 'J')
         FROM itemsite, item
         WHERE ( (itemsite_item_id=item_id)
          AND (itemsite_id=pItemsiteid) ) ) ) THEN
    RETURN 0;
  END IF;

--  Cache some parameters
  SELECT itemloc_ls_id,
         itemloc_itemsite_id AS itemsiteid,
         itemloc_expiration,
         itemloc_warrpurc,
         itemloc_qty,
         sourceloc.location_netable AS sourcenet,
         targetloc.location_netable AS targetnet INTO _p
  FROM itemloc, location AS sourceloc, location AS targetloc
  WHERE ( (itemloc_location_id=sourceloc.location_id)
   AND (targetloc.location_id=pTargetLocationid)
   AND (itemloc_id=pSourceItemlocid) );

--  Check to make sure the qty being transfered exists
  IF (_p.itemloc_qty < pQty) THEN
    RETURN -1;
  END IF;

--  Create the RL transaction
  SELECT NEXTVAL('invhist_invhist_id_seq') INTO _invhistid;
  INSERT INTO invhist
  ( invhist_id, invhist_itemsite_id,
    invhist_transtype, invhist_invqty,
    invhist_qoh_before, invhist_qoh_after,
    invhist_comments,   invhist_transdate,
    invhist_invuom, invhist_unitcost, invhist_costmethod,
    invhist_value_before, invhist_value_after, invhist_series)
  SELECT _invhistid, itemsite_id,
         'RL', 0,
         itemsite_qtyonhand, itemsite_qtyonhand,
         pComments, _GlDistTS,
         uom_name,
         CASE WHEN (itemsite_costmethod='A') THEN avgcost(itemsite_id)
              ELSE stdCost(item_id)
         END, itemsite_costmethod,
         itemsite_value, itemsite_value, _itemlocSeries
  FROM item, itemsite, uom
  WHERE ((itemsite_item_id=item_id)
   AND (item_inv_uom_id=uom_id)
   AND (itemsite_controlmethod <> 'N')
   AND (itemsite_id=pItemsiteid));

--  Relocate the inventory from the source and record the transactions
  INSERT INTO invdetail
  ( invdetail_invhist_id, invdetail_location_id, invdetail_ls_id,
    invdetail_qty, invdetail_qty_before, invdetail_qty_after,
    invdetail_expiration, invdetail_warrpurc )
  SELECT _invhistid, itemloc_location_id, itemloc_ls_id,
         (pQty * -1), itemloc_qty, (itemloc_qty - pQty),
         itemloc_expiration, itemloc_warrpurc
  FROM itemloc
  WHERE (itemloc_id=pSourceItemlocid);

  UPDATE itemloc
  SET itemloc_qty=(itemloc_qty - pQty)
  FROM itemsite
  WHERE ( (itemloc_itemsite_id=itemsite_id)
   AND (NOT itemsite_freeze)
   AND (itemloc_id=pSourceItemlocid) );

--  Check to see if any of the current Lot/Serial #/Expiration exists at the target location
  SELECT itemloc_id INTO _targetItemlocid
  FROM itemloc
  WHERE ( (COALESCE(itemloc_ls_id, -1)=COALESCE(_p.itemloc_ls_id,-1))
   AND (COALESCE(itemloc_expiration,endOfTime())=COALESCE(_p.itemloc_expiration,endOfTime()))
   AND (COALESCE(itemloc_warrpurc,endOfTime())=COALESCE(_p.itemloc_warrpurc,endOfTime()))
   AND (itemloc_itemsite_id=pItemsiteid)
   AND (itemloc_location_id=pTargetLocationid) );

  IF (NOT FOUND) THEN
    SELECT NEXTVAL('itemloc_itemloc_id_seq') INTO _targetItemlocid;
    INSERT INTO itemloc
    ( itemloc_id, itemloc_itemsite_id, itemloc_location_id,
      itemloc_ls_id, itemloc_expiration, itemloc_warrpurc, itemloc_qty )
    VALUES
    ( _targetItemlocid, pItemsiteid, pTargetLocationid,
      _p.itemloc_ls_id, _p.itemloc_expiration, _p.itemloc_warrpurc, 0 );
  END IF;

--  Relocate the inventory to the resultant target and record the transactions
  INSERT INTO invdetail
  ( invdetail_invhist_id, invdetail_location_id, invdetail_ls_id,
    invdetail_qty, invdetail_qty_before, invdetail_qty_after,
    invdetail_expiration, invdetail_warrpurc )
  SELECT _invhistid, pTargetLocationid, _p.itemloc_ls_id,
         pQty, itemloc_qty, (itemloc_qty + pQty),
         _p.itemloc_expiration, _p.itemloc_warrpurc
  FROM itemloc
  WHERE (itemloc_id=_targetItemlocid);

  UPDATE itemloc
  SET itemloc_qty=(itemloc_qty + pQty)
  FROM itemsite
  WHERE ( (itemloc_itemsite_id=itemsite_id)
   AND (NOT itemsite_freeze)
   AND (itemloc_id=_targetItemlocid) );

  UPDATE invhist
  SET invhist_hasdetail=TRUE
  WHERE (invhist_id=_invhistid);

--  Post in incomming or outgoing NN transaction if required
  IF (_p.sourcenet <> _p.targetnet) THEN
    IF (_p.targetnet) THEN
      _qty = (pQty * -1);
    ELSE
      _qty = pQty;
    END IF;

    INSERT INTO invhist
    ( invhist_itemsite_id,
      invhist_transtype, invhist_invqty,
      invhist_qoh_before, invhist_qoh_after,
      invhist_docnumber, invhist_comments, invhist_transdate,
      invhist_invuom, invhist_unitcost, invhist_costmethod,
      invhist_value_before, invhist_value_after, invhist_series)
    SELECT itemsite_id,
           'NN', (_qty * -1),
           itemsite_qtyonhand, (itemsite_qtyonhand - _qty),
           '', '', _GlDistTS,
           uom_name,
           CASE WHEN (itemsite_costmethod='A') THEN avgcost(itemsite_id)
                ELSE stdCost(item_id)
           END, itemsite_costmethod,
           itemsite_value, itemsite_value, _itemlocSeries
    FROM item, itemsite, uom
    WHERE ( (itemsite_item_id=item_id)
     ANd (item_inv_uom_id=uom_id)
     AND (itemsite_controlmethod <> 'N')
     AND (itemsite_id=_p.itemsiteid) );

    UPDATE itemsite
    SET itemsite_qtyonhand = (itemsite_qtyonhand - _qty),
        itemsite_nnqoh = (itemsite_nnqoh + _qty)
    WHERE (itemsite_id=_p.itemsiteid);
  END IF;

--  Check to see if there is anything left at the target Itemloc and delete if not
--  Could be zero if relocate increased a negative quantity to zero
  DELETE FROM itemloc
  WHERE ( (itemloc_qty=0)
   AND (itemloc_id=_targetItemlocid) );

--  Handle Reservations
  IF (fetchMetricBool('EnableSOReservationsByLocation')) THEN
    SELECT CASE WHEN (qtyReservedLocation(itemloc_id) > itemloc_qty)
                THEN (qtyReservedLocation(itemloc_id) - itemloc_qty)
                ELSE 0.0
                END INTO _qtyunreserved
    FROM itemloc
    WHERE (itemloc_id=pSourceItemlocid);
    -- Move reservations as necessary
    WHILE (_qtyunreserved > 0.0) LOOP
      SELECT * INTO _rsrv
      FROM reserve
      WHERE ((reserve_supply_type='I')
        AND  (reserve_supply_id=pSourceItemlocid))
      ORDER BY reserve_qty;
      IF (NOT FOUND) THEN
        RAISE EXCEPTION 'Cannot find reservation to unreserve.';
      END IF;
      IF (_rsrv.reserve_qty > _qtyunreserved) THEN
        _qtytomove := _qtyunreserved;
      ELSE
        _qtytomove := _rsrv.reserve_qty;
      END IF;
      -- Unreserve Source Location
      SELECT unreserveSOLineQty(_rsrv.reserve_demand_id,
                                _qtytomove,
                                pSourceItemlocid) INTO _result;
      IF (_result < 0) THEN
        RAISE EXCEPTION 'unreserveSOLineQty failed with result=%, reserve_id=%, qty=%',
                        _result, _rsrv.reserve_id, _qtytomove;
      END IF;
      -- Reserve to new Location
      SELECT reserveSOLineQty(_rsrv.reserve_demand_id,
                              TRUE,
                              _qtytomove,
                              _targetItemlocid) INTO _result;
      IF (_result < 0) THEN
        RAISE EXCEPTION 'reserveSOLineQty failed with result=%, reserve_id=%, qty=%',
                        _result, _rsrv.reserve_id, _qtytomove;
      END IF;
      -- Calculate running total
      _qtyunreserved := _qtyunreserved - _qtytomove;
    END LOOP;
  END IF;

--  Check to see if there is anything left at the source Itemloc and delete if not
  DELETE FROM itemloc
  WHERE ( (itemloc_qty=0)
   AND (itemloc_id=pSourceItemlocid) );

--  Return the invhist_id
  RETURN _invhistid;

END;
$_$;


ALTER FUNCTION public.relocateinventory(integer, integer, integer, numeric, text, timestamp with time zone) OWNER TO admin;

--
-- TOC entry 2105 (class 1255 OID 146566951)
-- Dependencies: 4536 8
-- Name: reopenbankreconciliation(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION reopenbankreconciliation(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pBankrecid ALIAS FOR $1;
  _bankrecid INTEGER;
  _accntid INTEGER;
  _sequence INTEGER;
  _gltransid INTEGER;
  _r RECORD;

BEGIN

-- Check the accnt information to make sure it is valid
  SELECT accnt_id INTO _accntid
    FROM bankrec, bankaccnt, accnt
   WHERE ( (bankaccnt_accnt_id=accnt_id)
     AND   (bankrec_bankaccnt_id=bankaccnt_id)
     AND   (bankrec_id=pBankrecid) );
  IF ( NOT FOUND ) THEN
    RETURN -1;
  END IF;

  SELECT bankrec_id INTO _bankrecid
    FROM bankrec
   WHERE (NOT bankrec_posted);
  IF (FOUND) THEN
  -- Delete any bankrecitem records for unposted periods
    DELETE FROM bankrecitem
     WHERE (bankrecitem_bankrec_id=_bankrecid);
  -- Delete any bankrec records for unposted period
    DELETE FROM bankrec
     WHERE (bankrec_id=_bankrecid);
  END IF;

-- Mark all the gltrans items that have been cleared as unreconciled.
  UPDATE gltrans
     SET gltrans_rec = FALSE
   WHERE ( (gltrans_id IN (SELECT bankrecitem_source_id
                             FROM bankrecitem
                            WHERE ((bankrecitem_source = 'GL')
                              AND  (bankrecitem_cleared)
                              AND  (bankrecitem_bankrec_id=pBankrecid) ) ) )
     AND   (gltrans_accnt_id=_accntid) ) ;

-- Mark all the sltrans items that have been cleared as unreconciled.
  UPDATE sltrans
     SET sltrans_rec = FALSE
   WHERE ( (sltrans_id IN (SELECT bankrecitem_source_id
                             FROM bankrecitem
                            WHERE ((bankrecitem_source = 'SL')
                              AND  (bankrecitem_cleared)
                              AND  (bankrecitem_bankrec_id=pBankrecid) ) ) )
     AND   (sltrans_accnt_id=_accntid) ) ;

-- Mark the bankrec record as unposted
  UPDATE bankrec SET
    bankrec_posted = FALSE,
    bankrec_postdate = NULL
   WHERE (bankrec_id=pBankrecid);

  RETURN pBankrecid;
END;
$_$;


ALTER FUNCTION public.reopenbankreconciliation(integer) OWNER TO admin;

--
-- TOC entry 2106 (class 1255 OID 146566952)
-- Dependencies: 4536 8
-- Name: reorderdate(integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION reorderdate(integer, integer, boolean) RETURNS date
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pLookAhead ALIAS FOR $2;
  pIncludePlanned ALIAS FOR $3;
  _runningAvailability NUMERIC;
  _reorderLevel NUMERIC;
  _availability RECORD;

BEGIN

--  Make sure that we know how to handle the passed part
  IF ( SELECT (NOT (item_type IN ('M', 'P')))
       FROM item, itemsite
       WHERE ( (itemsite_item_id=item_id)
        AND (itemsite_id=pItemsiteid) ) ) THEN
    RETURN NULL;
  END IF;

--  Load the initial QOH
  SELECT itemsite_qtyonhand INTO _runningAvailability
  FROM itemsite
  WHERE (itemsite_id=pItemsiteid);

--  Grab the Reorder Level, if any
  IF ( ( SELECT itemsite_useparams
         FROM itemsite
         WHERE (itemsite_id=pItemsiteid) ) ) THEN
    SELECT itemsite_reorderlevel INTO _reorderLevel
    FROM itemsite
    WHERE (itemsite_id=pItemsiteid);
  ELSE
    _reorderLevel := 0;
  END IF;

--  If we are already below the Reorder Level then we should order ASAP
  IF (_runningAvailability <= _reorderLevel) THEN
    RETURN CURRENT_DATE;
  END IF;

--  Grab all of the availability trigger points
  FOR _availability IN SELECT 1 AS seq,
                              wo_duedate AS orderdate,
                              (noNeg(wo_qtyord - wo_qtyrcv)) AS balance
                       FROM wo
                       WHERE ((wo_status IN ('O', 'E', 'R', 'I'))
                        AND (wo_duedate <= (CURRENT_DATE + pLookAhead))
                        AND (wo_itemsite_id=pItemsiteid))

                      UNION SELECT 2 AS seq,
                                   womatl_duedate AS orderdate,
                                   (noNeg(itemuomtouom(itemsite_item_id, womatl_uom_id, NULL, womatl_qtyreq - womatl_qtyiss)) * -1) AS balance
                      FROM womatl, wo, itemsite
                      WHERE ((wo_status IN ('O', 'E', 'R', 'I'))
                       AND (womatl_wo_id=wo_id)
                       AND (womatl_itemsite_id=itemsite_id)
                       AND (womatl_duedate <= (CURRENT_DATE + pLookahead))
                       AND (womatl_itemsite_id=pItemsiteid))

                      UNION SELECT 1 AS seq,
                                   poitem_duedate AS orderdate,
                                   (noNeg(poitem_qty_ordered - poitem_qty_received) * poitem_invvenduomratio) AS balance
                      FROM pohead, poitem
                      WHERE ((poitem_pohead_id=pohead_id)
                       AND (poitem_status = 'O')
                       AND (poitem_duedate <= (CURRENT_DATE + pLookAhead))
                       AND (poitem_itemsite_id=pItemsiteid))

                      UNION SELECT 2 AS seq,
                                   coitem_scheddate AS orderdate,
                                   (noNeg(coitem_qtyord - coitem_qtyshipped + coitem_qtyreturned) * -1) AS balance
                      FROM coitem, cohead
                      WHERE ((coitem_status = 'O')
                       AND (coitem_cohead_id=cohead_id)
                       AND (coitem_scheddate <= (CURRENT_DATE + pLookAhead))
                       AND (coitem_itemsite_id=pItemsiteid))

                      UNION SELECT 2 AS seq,
                                   planord_startdate AS orderdate,
                                   (planreq_qty * -1) AS balance
                      FROM planreq, planord
                      WHERE ( (pIncludePlanned)
                       AND (planreq_source='P')
                       AND (planreq_source_id=planord_id)
                       AND (planord_startdate <= (CURRENT_DATE + pLookAhead))
                       AND (planord_itemsite_id=pItemsiteid) )

                      UNION SELECT 1 AS seq,
                                   planord_duedate AS orderdate,
                                   planord_qty AS balance
                      FROM planord
                      WHERE ( (pIncludePlanned)
                       AND (planord_duedate <= (CURRENT_DATE + pLookAhead))
                       AND (planord_itemsite_id=pItemsiteid) )

                      ORDER BY orderdate, seq LOOP

--  Calculate the new projected availability
    _runningAvailability := (_runningAvailability + _availability.balance);

--  Check to see if the project availability drop below the reorder level
    IF (_runningAvailability < _reorderLevel) THEN
      RETURN _availability.orderdate;
    END IF;

  END LOOP;

--  The reorder level was not reached within the look ahead period
  RETURN NULL;

END;
$_$;


ALTER FUNCTION public.reorderdate(integer, integer, boolean) OWNER TO admin;

--
-- TOC entry 2107 (class 1255 OID 146566953)
-- Dependencies: 4536 8
-- Name: replaceallvoidedapchecks(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION replaceallvoidedapchecks(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RAISE NOTICE 'replaceAllVoidedAPChecks() is deprecated - use replaceAllVoidedChecks() instead';
  RETURN replaceAllVoidedChecks($1);
END;
$_$;


ALTER FUNCTION public.replaceallvoidedapchecks(integer) OWNER TO admin;

--
-- TOC entry 2108 (class 1255 OID 146566954)
-- Dependencies: 4536 8
-- Name: replaceallvoidedchecks(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION replaceallvoidedchecks(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pBankaccntid	ALIAS FOR $1;
  _returnValue	INTEGER := 0;

BEGIN

  SELECT MIN(replaceVoidedCheck(checkhead_id)) INTO _returnValue
    FROM checkhead
    WHERE ( (checkhead_void)
     AND (NOT checkhead_posted)
     AND (NOT checkhead_replaced)
     AND (NOT checkhead_deleted)
     AND (checkhead_bankaccnt_id=pBankaccntid) );

  RETURN _returnValue;

END;
$_$;


ALTER FUNCTION public.replaceallvoidedchecks(integer) OWNER TO admin;

--
-- TOC entry 2109 (class 1255 OID 146566955)
-- Dependencies: 4536 8
-- Name: replacevoidedapcheck(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION replacevoidedapcheck(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RAISE NOTICE 'replaceVoidedAPCheck() is deprecated - use replaceVoidedCheck()';
  RETURN replaceVoidedCheck($1);
END;
$_$;


ALTER FUNCTION public.replacevoidedapcheck(integer) OWNER TO admin;

--
-- TOC entry 2110 (class 1255 OID 146566956)
-- Dependencies: 4536 8
-- Name: replacevoidedcheck(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION replacevoidedcheck(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCheckid	ALIAS FOR $1;
  _newCheckid	INTEGER;

BEGIN
  IF ( ( SELECT ( (NOT checkhead_void) OR checkhead_posted OR checkhead_replaced )
         FROM checkhead
         WHERE (checkhead_id=pCheckid) ) ) THEN
    RETURN -1;
  END IF;

  -- has someone created a new check for one of the items while this was void?
  IF EXISTS (SELECT dup.checkitem_id
             FROM checkitem orig, checkitem dup, checkhead AS duphead
             WHERE ((COALESCE(orig.checkitem_aropen_id,-1)=COALESCE(dup.checkitem_aropen_id,-1))
                AND (COALESCE(orig.checkitem_apopen_id,-1)=COALESCE(dup.checkitem_apopen_id,-1))
                AND (orig.checkitem_checkhead_id!=dup.checkitem_checkhead_id)
                AND (dup.checkitem_checkhead_id=duphead.checkhead_id)
                AND (NOT duphead.checkhead_void)
                AND (orig.checkitem_checkhead_id=pCheckid))) THEN
    RETURN -2;
  END IF;

  SELECT NEXTVAL('checkhead_checkhead_id_seq') INTO _newCheckid;

  INSERT INTO checkhead
  ( checkhead_id, checkhead_recip_id, checkhead_recip_type,
    checkhead_bankaccnt_id, checkhead_checkdate,
    checkhead_number, checkhead_amount,
    checkhead_for, checkhead_journalnumber,
    checkhead_notes,
    checkhead_misc, checkhead_expcat_id, checkhead_curr_id )
  SELECT _newCheckid, checkhead_recip_id, checkhead_recip_type,
	 checkhead_bankaccnt_id, checkhead_checkdate,
	 -1, -- fetchNextCheckNumber(checkhead_bankaccnt_id),
         checkhead_amount,
	 checkhead_for, checkhead_journalnumber,
         checkhead_notes || '
Replaces voided check ' || checkhead_number,
	 checkhead_misc, checkhead_expcat_id, checkhead_curr_id
  FROM checkhead
  WHERE (checkhead_id=pCheckid);

  INSERT INTO checkitem
  ( checkitem_checkhead_id, checkitem_amount, checkitem_discount,
    checkitem_ponumber, checkitem_vouchernumber, checkitem_invcnumber,
    checkitem_apopen_id, checkitem_aropen_id,
    checkitem_docdate, checkitem_curr_id, checkitem_curr_rate )
  SELECT _newCheckid, checkitem_amount, checkitem_discount,
         checkitem_ponumber, checkitem_vouchernumber, checkitem_invcnumber,
	 checkitem_apopen_id, checkitem_aropen_id,
	 checkitem_docdate, checkitem_curr_id, checkitem_curr_rate
  FROM checkitem
  WHERE (checkitem_checkhead_id=pCheckid);

  UPDATE checkhead
  SET checkhead_replaced=TRUE
  WHERE (checkhead_id=pCheckid);

  RETURN _newCheckid;

END;
$_$;


ALTER FUNCTION public.replacevoidedcheck(integer) OWNER TO admin;

--
-- TOC entry 2111 (class 1255 OID 146566957)
-- Dependencies: 4536 8
-- Name: reprioritizewo(integer, integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION reprioritizewo(integer, integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoid ALIAS FOR $1;
  pPriority ALIAS FOR $2;
  pChangeChildren ALIAS FOR $3;
  _status CHAR(1);
  _result INTEGER;

BEGIN

  SELECT wo_status INTO _status
  FROM wo
  WHERE (wo_id=pWoid);

  IF (NOT (_status IN ('O', 'E','R','I'))) THEN
    return -1;
  END IF;

  UPDATE wo
  SET wo_priority=pPriority
  WHERE (wo_id=pWoid);

  IF ( (_status IN ('E','R','I')) AND (pChangeChildren) ) THEN
    SELECT COALESCE(MIN(reprioritizeWo(wo_id, pPriority, TRUE)), 1) INTO _result
    FROM wo
    WHERE ( (wo_ordtype='W')
     AND (wo_ordid=pWoid) );
  ELSE
    _result = 1;
  END IF;

  RETURN _result;

END;
$_$;


ALTER FUNCTION public.reprioritizewo(integer, integer, boolean) OWNER TO admin;

--
-- TOC entry 2113 (class 1255 OID 146566959)
-- Dependencies: 4536 8
-- Name: resetdbobjperms(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION resetdbobjperms() RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _count        INTEGER := 0;
BEGIN
  SELECT SUM(resetDBObjPerms(nspname || '.' || relname)) INTO _count
  FROM pg_catalog.pg_class, pg_catalog.pg_namespace
  WHERE (relkind IN ('r', 'S', 'v')
    AND  (relnamespace=pg_namespace.oid)
    AND  (nspname IN ('public', 'api')));

  RETURN _count;
END;
$$;


ALTER FUNCTION public.resetdbobjperms() OWNER TO admin;

--
-- TOC entry 2112 (class 1255 OID 146566958)
-- Dependencies: 4536 8
-- Name: resetdbobjperms(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION resetdbobjperms(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pObjname      ALIAS FOR $1;
BEGIN
  EXECUTE 'ALTER TABLE '   || pObjname || ' OWNER TO ' || getEffectiveXtUser() || ';';
  EXECUTE 'REVOKE ALL ON ' || pObjname || ' FROM PUBLIC;';
  EXECUTE 'GRANT  ALL ON ' || pObjname || ' TO GROUP xtrole;';
  RETURN 1;
END;
$_$;


ALTER FUNCTION public.resetdbobjperms(text) OWNER TO admin;

--
-- TOC entry 2115 (class 1255 OID 146566960)
-- Dependencies: 4536 8
-- Name: resetlowlevelcode(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION resetlowlevelcode(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE

    pItemId ALIAS FOR $1;
    _result	INTEGER;
    _counterNum	INTEGER	:= 1;
    _feedBackNum INTEGER := 1;
    _r                  RECORD;

BEGIN
    DELETE FROM costUpdate;

    IF pItemId = -1 THEN 	-- -1 is an invalid item_id => do them all
	INSERT INTO costUpdate ( costUpdate_item_id, costUpdate_item_type )
			SELECT item_id, item_type
			FROM   item;

        -- Recalculate the Item Lowlevel codes
        WHILE _feedBackNum > 0 LOOP
            SELECT updateLowlevel(_counterNum) INTO _feedBackNum;
            _counterNum := _counterNum + 1;
        END LOOP;

    ELSE
	INSERT INTO costUpdate ( costUpdate_item_id, costUpdate_item_type )
			SELECT item_id, item_type
			FROM   item
                        WHERE (item_id=pItemId);
      FOR _r IN SELECT item_id, bomdata_bomwork_level, item_type
                FROM item,
                     indentedBOM(pItemId, getActiveRevId('BOM',pItemId),0,0)
                WHERE (bomdata_item_id=item_id)
                ORDER BY bomdata_bomwork_level LOOP

        -- this only works because of the ORDER BY in the loop SELECT
        UPDATE costUpdate
        SET costupdate_lowlevel_code = _r.bomdata_bomwork_level
        WHERE (costupdate_item_id=_r.item_id);

        IF (NOT FOUND) THEN
          INSERT INTO costUpdate (
            costUpdate_item_id, costUpdate_lowlevel_code, costUpdate_item_type
          ) VALUES (
            _r.item_id, _r.bomdata_bomwork_level, _r.item_type
          );
        END IF;
      END LOOP;

    END IF;

    SELECT count(*) INTO _result
    FROM costUpdate;

    RETURN _result;

END;
$_$;


ALTER FUNCTION public.resetlowlevelcode(integer) OWNER TO admin;

--
-- TOC entry 2116 (class 1255 OID 146566961)
-- Dependencies: 4536 8
-- Name: resetqohbalance(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION resetqohbalance(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN resetQOHBalance($1, CURRENT_TIMESTAMP);
END;
$_$;


ALTER FUNCTION public.resetqohbalance(integer) OWNER TO admin;

--
-- TOC entry 2117 (class 1255 OID 146566962)
-- Dependencies: 4536 8
-- Name: resetqohbalance(integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION resetqohbalance(integer, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid   ALIAS FOR $1;
  pGlDistTS     ALIAS FOR $2;
  _invhistid    INTEGER;
  _itemlocSeries INTEGER;

BEGIN

  IF ( ( SELECT ( (itemsite_controlmethod IN ('L', 'S')) OR
                  (item_type = 'R') OR
                  (itemsite_costmethod = 'J') OR
                  (itemsite_loccntrl) OR
                  (itemsite_qtyonhand > 0) )
         FROM itemsite, item
         WHERE ( (itemsite_item_id=item_id)
          AND (itemsite_id=pItemsiteid) ) ) ) THEN
    RETURN 0;
  END IF;

  _itemlocSeries := NEXTVAL('itemloc_series_seq');

  SELECT postInvTrans( itemsite_id, 'AD', (itemsite_qtyonhand * -1),
                       'I/M', '', '', 'RESET',
                       'Reset QOH Balance to 0',
                       costcat_asset_accnt_id, costcat_adjustment_accnt_id,
                       _itemlocSeries, pGlDistTS ) INTO _invhistid
  FROM itemsite, costcat
  WHERE ( (itemsite_costcat_id=costcat_id)
   AND (itemsite_id=pItemsiteid) );

  PERFORM postItemLocSeries(_itemlocSeries);

  RETURN _invhistid;

END;
$_$;


ALTER FUNCTION public.resetqohbalance(integer, timestamp with time zone) OWNER TO admin;

--
-- TOC entry 2118 (class 1255 OID 146566963)
-- Dependencies: 4536 8
-- Name: resolvecosaccount(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION resolvecosaccount(integer, integer) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  RETURN resolveCOSAccount($1, $2, -1, -1);

END;
$_$;


ALTER FUNCTION public.resolvecosaccount(integer, integer) OWNER TO admin;

--
-- TOC entry 2119 (class 1255 OID 146566964)
-- Dependencies: 4536 8
-- Name: resolvecosaccount(integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION resolvecosaccount(pitemsiteid integer, pcustid integer, psaletypeid integer, pshipzoneid integer) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _salesaccntid INTEGER;
  _accntid INTEGER;

BEGIN

  SELECT findSalesAccnt(pItemsiteid, 'IS', pCustid, pSaletypeid, pShipzoneid) INTO _salesaccntid;
  IF (_salesaccntid = -1) THEN
    SELECT getUnassignedAccntId() INTO _accntid;
  ELSE
    SELECT salesaccnt_cos_accnt_id INTO _accntid
    FROM salesaccnt
    WHERE (salesaccnt_id=_salesaccntid);
  END IF;

  RETURN _accntid;

END;
$$;


ALTER FUNCTION public.resolvecosaccount(pitemsiteid integer, pcustid integer, psaletypeid integer, pshipzoneid integer) OWNER TO admin;

--
-- TOC entry 2120 (class 1255 OID 146566965)
-- Dependencies: 4536 8
-- Name: resolvecowaccount(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION resolvecowaccount(integer, integer) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  RETURN resolveCOWAccount($1, $2, -1, -1);

END;
$_$;


ALTER FUNCTION public.resolvecowaccount(integer, integer) OWNER TO admin;

--
-- TOC entry 2121 (class 1255 OID 146566966)
-- Dependencies: 4536 8
-- Name: resolvecowaccount(integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION resolvecowaccount(pitemsiteid integer, pcustid integer, psaletypeid integer, pshipzoneid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _salesaccntid INTEGER;
  _accntid INTEGER;

BEGIN

  SELECT findSalesAccnt(pItemsiteid, 'IS', pCustid, pSaletypeid, pShipzoneid) INTO _salesaccntid;
  IF (_salesaccntid = -1) THEN
    SELECT getUnassignedAccntId() INTO _accntid;
  ELSE
    SELECT salesaccnt_cow_accnt_id INTO _accntid
    FROM salesaccnt
    WHERE (salesaccnt_id=_salesaccntid);
  END IF;

  RETURN _accntid;

END;
$$;


ALTER FUNCTION public.resolvecowaccount(pitemsiteid integer, pcustid integer, psaletypeid integer, pshipzoneid integer) OWNER TO admin;

--
-- TOC entry 2122 (class 1255 OID 146566967)
-- Dependencies: 4536 8
-- Name: resolvecreditaccount(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION resolvecreditaccount(integer, integer) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  RETURN resolveCreditAccount($1, $2, -1, -1);

END;
$_$;


ALTER FUNCTION public.resolvecreditaccount(integer, integer) OWNER TO admin;

--
-- TOC entry 2123 (class 1255 OID 146566968)
-- Dependencies: 4536 8
-- Name: resolvecreditaccount(integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION resolvecreditaccount(pitemsiteid integer, pcustid integer, psaletypeid integer, pshipzoneid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _salesaccntid INTEGER;
  _accntid INTEGER;

BEGIN

  SELECT findSalesAccnt(pItemsiteid, 'IS', pCustid, pSaletypeid, pShipzoneid) INTO _salesaccntid;
  IF (_salesaccntid = -1) THEN
    SELECT getUnassignedAccntId() INTO _accntid;
  ELSE
    SELECT salesaccnt_credit_accnt_id INTO _accntid
    FROM salesaccnt
    WHERE (salesaccnt_id=_salesaccntid);
  END IF;

  RETURN _accntid;

END;
$$;


ALTER FUNCTION public.resolvecreditaccount(pitemsiteid integer, pcustid integer, psaletypeid integer, pshipzoneid integer) OWNER TO admin;

--
-- TOC entry 2124 (class 1255 OID 146566969)
-- Dependencies: 4536 8
-- Name: resolvesalesaccount(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION resolvesalesaccount(integer, integer) RETURNS integer
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  RETURN resolveSalesAccount($1, $2, -1, -1);

END;
$_$;


ALTER FUNCTION public.resolvesalesaccount(integer, integer) OWNER TO admin;

--
-- TOC entry 2126 (class 1255 OID 146566970)
-- Dependencies: 4536 8
-- Name: resolvesalesaccount(integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION resolvesalesaccount(pitemsiteid integer, pcustid integer, psaletypeid integer, pshipzoneid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _salesaccntid INTEGER;
  _accntid INTEGER;

BEGIN

  SELECT findSalesAccnt(pItemsiteid, 'IS', pCustid, pSaletypeid, pShipzoneid) INTO _salesaccntid;
  IF (_salesaccntid = -1) THEN
    SELECT getUnassignedAccntId() INTO _accntid;
  ELSE
    SELECT salesaccnt_sales_accnt_id INTO _accntid
    FROM salesaccnt
    WHERE (salesaccnt_id=_salesaccntid);
  END IF;

  RETURN _accntid;

END;
$$;


ALTER FUNCTION public.resolvesalesaccount(pitemsiteid integer, pcustid integer, psaletypeid integer, pshipzoneid integer) OWNER TO admin;

--
-- TOC entry 2127 (class 1255 OID 146566971)
-- Dependencies: 4536 8
-- Name: restoresaleshistory(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION restoresaleshistory(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pAsohistid ALIAS FOR $1;

BEGIN

  INSERT INTO cohist ( cohist_id,
                       cohist_cust_id,
                       cohist_itemsite_id,
                       cohist_shipdate,
                       cohist_invcdate,
                       cohist_duedate,
                       cohist_promisedate,
                       cohist_ordernumber,
                       cohist_invcnumber,
                       cohist_qtyshipped,
                       cohist_unitprice,
                       cohist_unitcost,
                       cohist_billtoname,
                       cohist_billtoaddress1,
                       cohist_billtoaddress2,
                       cohist_billtoaddress3,
                       cohist_billtocity,
                       cohist_billtostate,
                       cohist_billtozip,
                       cohist_shiptoname,
                       cohist_shiptoaddress1,
                       cohist_shiptoaddress2,
                       cohist_shiptoaddress3,
                       cohist_shiptocity,
                       cohist_shiptostate,
                       cohist_shiptozip,
                       cohist_shipto_id,
                       cohist_shipvia,
                       cohist_salesrep_id,
                       cohist_misc_type,
                       cohist_misc_descrip,
                       cohist_misc_id,
                       cohist_commission,
                       cohist_commissionpaid,
                       cohist_doctype,
                       cohist_orderdate,
                       cohist_imported,
                       cohist_ponumber,
                       cohist_curr_id,
                       cohist_taxtype_id,
                       cohist_taxzone_id )
  SELECT asohist_id,
         CASE asohist_cust_id WHEN -1 THEN NULL ELSE asohist_cust_id END,
         asohist_itemsite_id,
         asohist_shipdate,
         asohist_invcdate,
         asohist_duedate,
         asohist_promisedate,
         asohist_ordernumber,
         asohist_invcnumber,
         asohist_qtyshipped,
         asohist_unitprice,
         asohist_unitcost,
         asohist_billtoname,
         asohist_billtoaddress1,
         asohist_billtoaddress2,
         asohist_billtoaddress3,
         asohist_billtocity,
         asohist_billtostate,
         asohist_billtozip,
         asohist_shiptoname,
         asohist_shiptoaddress1,
         asohist_shiptoaddress2,
         asohist_shiptoaddress3,
         asohist_shiptocity,
         asohist_shiptostate,
         asohist_shiptozip,
         asohist_shipto_id,
         asohist_shipvia,
         CASE asohist_salesrep_id WHEN -1 THEN NULL ELSE asohist_salesrep_id END,
         asohist_misc_type,
         asohist_misc_descrip,
         asohist_misc_id,
         asohist_commission,
         asohist_commissionpaid,
         asohist_doctype,
         asohist_orderdate,
         asohist_imported,
         asohist_ponumber,
	 asohist_curr_id,
         asohist_taxtype_id,
         asohist_taxzone_id
  FROM asohist
  WHERE (asohist_id=pAsohistid);

  INSERT INTO cohisttax ( taxhist_id,
                          taxhist_parent_id,
                          taxhist_taxtype_id,
                          taxhist_tax_id,
                          taxhist_basis,
                          taxhist_basis_tax_id,
                          taxhist_sequence,
                          taxhist_percent,
                          taxhist_amount,
                          taxhist_tax,
                          taxhist_docdate,
                          taxhist_distdate,
                          taxhist_curr_id,
                          taxhist_curr_rate,
                          taxhist_journalnumber )
  SELECT taxhist_id,
         taxhist_parent_id,
         taxhist_taxtype_id,
         taxhist_tax_id,
         taxhist_basis,
         taxhist_basis_tax_id,
         taxhist_sequence,
         taxhist_percent,
         taxhist_amount,
         taxhist_tax,
         taxhist_docdate,
         taxhist_distdate,
         taxhist_curr_id,
         taxhist_curr_rate,
         taxhist_journalnumber
  FROM asohisttax
  WHERE (taxhist_parent_id=pAsohistid);

  DELETE FROM asohisttax
  WHERE (taxhist_parent_id=pAsohistid);

  DELETE FROM asohist
  WHERE (asohist_id=pAsohistid);

  RETURN pAsohistid;

END;
$_$;


ALTER FUNCTION public.restoresaleshistory(integer) OWNER TO admin;

--
-- TOC entry 2128 (class 1255 OID 146566972)
-- Dependencies: 4536 8
-- Name: returncompleteshipment(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION returncompleteshipment(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN returnCompleteShipment($1, 0, CURRENT_TIMESTAMP);
END;
$_$;


ALTER FUNCTION public.returncompleteshipment(integer) OWNER TO admin;

--
-- TOC entry 2129 (class 1255 OID 146566973)
-- Dependencies: 4536 8
-- Name: returncompleteshipment(integer, integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION returncompleteshipment(integer, integer, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pshipheadid		ALIAS FOR $1;
  _itemlocSeries	INTEGER := $2;
  _timestamp		TIMESTAMP WITH TIME ZONE := $3;
  _r RECORD;
  _result 		RECORD;
  _shiphead_number	TEXT := '';
  _count		INTEGER := 0;
  _countsum		INTEGER := 0;

BEGIN
  FOR _r IN SELECT shipitem_id
            FROM shipitem, shiphead
            WHERE ( (shipitem_shiphead_id=shiphead_id)
             AND (NOT shiphead_shipped)
             AND (shiphead_id=pshipheadid) ) LOOP
    _itemlocSeries := returnShipmentTransaction(_r.shipitem_id, _itemlocSeries, _timestamp);
  END LOOP;

  FOR _result IN SELECT shiphead_number
                   FROM shiphead
                  WHERE ( (shiphead_id=pshipheadid) ) LOOP
    _shiphead_number := _result.shiphead_number;
  END LOOP;

  SELECT COUNT(*) INTO _count
    FROM shipdata
   WHERE(shipdata_shiphead_number=_shiphead_number);

  SELECT COUNT(*) INTO _countsum
    FROM shipdatasum
   WHERE(shipdatasum_shiphead_number=_shiphead_number);

  IF (_count > 0) THEN
    DELETE FROM shipdata
     WHERE(shipdata_shiphead_number=_shiphead_number);
  END IF;
  IF (_countsum > 0) THEN
    DELETE FROM shipdatasum
     WHERE(shipdatasum_shiphead_number=_shiphead_number);
  END IF;

  DELETE FROM pack
   WHERE(pack_shiphead_id=pshipheadid);
  DELETE FROM shiphead
  WHERE (shiphead_id=pshipheadid);

  RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.returncompleteshipment(integer, integer, timestamp with time zone) OWNER TO admin;

--
-- TOC entry 2131 (class 1255 OID 146566975)
-- Dependencies: 4536 8
-- Name: returnitemshipments(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION returnitemshipments(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN returnItemShipments('SO', $1, 0, CURRENT_TIMESTAMP);
END;
$_$;


ALTER FUNCTION public.returnitemshipments(integer) OWNER TO admin;

--
-- TOC entry 2130 (class 1255 OID 146566974)
-- Dependencies: 4536 8
-- Name: returnitemshipments(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION returnitemshipments(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN returnItemShipments('SO', $1, $2, CURRENT_TIMESTAMP);
END;
$_$;


ALTER FUNCTION public.returnitemshipments(integer, integer) OWNER TO admin;

--
-- TOC entry 2132 (class 1255 OID 146566976)
-- Dependencies: 4536 8
-- Name: returnitemshipments(text, integer, integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION returnitemshipments(text, integer, integer, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pordertype		ALIAS FOR $1;
  pitemid		ALIAS FOR $2;
  _itemlocSeries	INTEGER				:= $3;
  _timestamp		TIMESTAMP WITH TIME ZONE	:= $4;
  _invhistid INTEGER;
  _r RECORD;

BEGIN

  IF (COALESCE(_itemlocSeries,0) = 0 ) THEN
    _itemlocSeries := NEXTVAL('itemloc_series_seq');
  END IF;

  FOR _r IN
    SELECT shipitem_id
    FROM shipitem
      JOIN shiphead ON (shiphead_id=shipitem_shiphead_id)
    WHERE ((NOT shiphead_shipped)
      AND  (shiphead_order_type=pordertype)
      AND  (shipitem_orderitem_id=pitemid))
  LOOP

    SELECT returnShipmentTransaction(_r.shipitem_id, _itemlocSeries, _timestamp) INTO _itemlocSeries;

    IF (_itemlocSeries < 0) THEN
      RETURN _itemlocSeries;
    END IF;

  END LOOP;

  RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.returnitemshipments(text, integer, integer, timestamp with time zone) OWNER TO admin;

--
-- TOC entry 2133 (class 1255 OID 146566977)
-- Dependencies: 4536 8
-- Name: returnshipmenttransaction(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION returnshipmenttransaction(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN returnShipmentTransaction($1, 0, CURRENT_TIMESTAMP);
END;
$_$;


ALTER FUNCTION public.returnshipmenttransaction(integer) OWNER TO admin;

--
-- TOC entry 2134 (class 1255 OID 146566978)
-- Dependencies: 4536 8
-- Name: returnshipmenttransaction(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION returnshipmenttransaction(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN returnShipmentTransaction($1, $2, CURRENT_TIMESTAMP);
END;
$_$;


ALTER FUNCTION public.returnshipmenttransaction(integer, integer) OWNER TO admin;

--
-- TOC entry 2135 (class 1255 OID 146566979)
-- Dependencies: 4536 8
-- Name: returnshipmenttransaction(integer, integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION returnshipmenttransaction(integer, integer, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pShipitemId           ALIAS FOR $1;
  pItemlocSeries        ALIAS FOR $2;
  pTimestamp            ALIAS FOR $3;
  _itemlocSeries        INTEGER;
  _invhistid            INTEGER;
  _reserveid            INTEGER;
  _coheadid             INTEGER;
  _rows                 INTEGER;
  _r                    RECORD;
  _rsrv                 RECORD;

BEGIN

    IF (COALESCE(pItemlocSeries, 0) = 0 ) THEN
      _itemlocSeries := NEXTVAL('itemloc_series_seq');
    ELSE
      _itemlocSeries := pItemlocSeries;
    END IF;

    -- Find the shipment transaction record
    SELECT shipitem.*,
           shiphead_id, shiphead_number, shiphead_order_type, invhist_series,
           itemsite_loccntrl, itemsite_costmethod, itemsite_controlmethod,
           cohead_prj_id AS prj_id
      INTO _r
    FROM shipitem
      JOIN shiphead ON (shiphead_id=shipitem_shiphead_id)
      JOIN invhist ON (invhist_id=shipitem_invhist_id)
      JOIN itemsite ON (itemsite_id=invhist_itemsite_id)
      LEFT OUTER JOIN cohead ON ((shiphead_order_type = 'SO') AND (shiphead_order_id = cohead_id))
    WHERE ((NOT shiphead_shipped)
      AND  (shipitem_id=pShipitemId));

    GET DIAGNOSTICS _rows = ROW_COUNT;
    IF (_rows = 0 ) THEN
      -- Was it a non-controlled sales order item?
      SELECT shipitem.*,
             shiphead_id, shiphead_number, shiphead_order_type,
             itemsite_loccntrl, itemsite_costmethod, itemsite_controlmethod,
             cohead_prj_id AS prj_id
      INTO _r
      FROM shipitem
        JOIN shiphead ON (shiphead_id=shipitem_shiphead_id)
        JOIN coitem ON (shipitem_orderitem_id=coitem_id)
        JOIN cohead ON (cohead_id=coitem_cohead_id)
        JOIN itemsite ON (itemsite_id=coitem_itemsite_id)
      WHERE ((NOT shiphead_shipped)
        AND  (shipitem_id=pShipitemId)
        AND  (shiphead_order_type = 'SO'));
    END IF;

    GET DIAGNOSTICS _rows = ROW_COUNT;
    IF (_rows = 0 AND fetchmetricbool('MultiWhs') ) THEN
      -- Was it a non-controlled transfer order item?
      SELECT shipitem.*,
             shiphead_id, shiphead_number, shiphead_order_type,
             itemsite_loccntrl, itemsite_costmethod, itemsite_controlmethod,
             NULL AS prj_id
      INTO _r
      FROM shipitem
        JOIN shiphead ON (shiphead_id=shipitem_shiphead_id)
        JOIN toitem ON (shipitem_orderitem_id=toitem_id)
        JOIN itemsite ON (itemsite_id=coitem_itemsite_id)
      WHERE ((NOT shiphead_shipped)
        AND  (shipitem_id=pShipitemId)
        AND  (shiphead_order_type = 'TO'));
    END IF;

    IF (_rows > 0 ) THEN
      IF (_r.shiphead_order_type = 'SO') THEN
        -- Handle inventory transaction
        IF (_r.itemsite_controlmethod != 'N' OR _r.itemsite_costmethod = 'J') THEN
          SELECT postInvTrans( itemsite_id, 'RS', (_r.shipitem_qty * coitem_qty_invuomratio),
                               'S/R', _r.shiphead_order_type, formatSoNumber(_r.shipitem_orderitem_id),
                               shiphead_number, 'Return from Shipping',
                               costcat_asset_accnt_id, getPrjAccntId(_r.prj_id, costcat_shipasset_accnt_id),
                               _itemlocSeries, pTimestamp, _r.shipitem_value, _r.shipitem_invhist_id ) INTO _invhistid
          FROM coitem, itemsite, costcat, shiphead, shipitem
          WHERE ((coitem_itemsite_id=itemsite_id)
            AND  (itemsite_costcat_id=costcat_id)
            AND  (coitem_id=_r.shipitem_orderitem_id)
            AND  (shiphead_order_type=_r.shiphead_order_type)
            AND  (shiphead_id=shipitem_shiphead_id)
            AND  (shipitem_orderitem_id=_r.shipitem_orderitem_id));

          -- We know the distribution so post this through so the any w/o activity knows about it
          PERFORM postItemlocseries(_itemlocSeries);
        END IF;

        IF (_r.itemsite_costmethod = 'J') THEN
          -- Reopen the work order
          UPDATE wo SET wo_status = 'I' WHERE ((wo_ordtype='S') AND (wo_ordid=_r.shipitem_orderitem_id));

          --  Job cost, so correct Production Posting referencing original receipt for reverse info.
          PERFORM correctProduction(wo_id, invhist_invqty, false, _itemlocSeries, pTimestamp, invhist_id)
          FROM wo, invhist
          WHERE ((wo_ordtype = 'S')
            AND  (wo_ordid = _r.shipitem_orderitem_id)
            AND  (invhist_series=_r.invhist_series)
            AND  (invhist_transtype='RM'));

          --  Return eligble material
          PERFORM returnWoMaterial(womatlpost_womatl_id, _itemlocSeries, pTimestamp, womatlpost_invhist_id)
          FROM womatlpost, invhist m, invhist s
          WHERE ((womatlpost_invhist_id=m.invhist_id)
            AND  (m.invhist_series=s.invhist_series)
            AND  (m.invhist_transtype='IM')
            AND  (s.invhist_id=_r.shipitem_invhist_id));

        END IF; -- end Job Costing

      ELSIF (_r.shiphead_order_type = 'TO') THEN
        SELECT postInvTrans(itemsite_id, 'RS', _r.shipitem_qty,
                            'S/R', _r.shiphead_order_type, formatToNumber(toitem_id),
                            tohead_number, 'Return from Shipping',
                            costcat_asset_accnt_id, costcat_shipasset_accnt_id,
                            _itemlocSeries, pTimestamp, _r.shipitem_value, _r.shipitem_invhist_id ) INTO _invhistid
        FROM toitem, tohead, itemsite, costcat
        WHERE ((toitem_item_id=itemsite_item_id)
          AND  (toitem_tohead_id=tohead_id)
  	  AND  (tohead_src_warehous_id=itemsite_warehous_id)
          AND  (itemsite_costcat_id=costcat_id)
          AND  (toitem_id=_r.shipitem_orderitem_id));

      ELSE
        -- Don't know what kind of order this is
        RETURN -11;
      END IF;

      UPDATE shiphead
      SET shiphead_sfstatus='D'
      WHERE ((shiphead_id=_r.shiphead_id)
        AND  (shiphead_sfstatus='P'));

       -- Handle reservation if applicable
      IF (fetchmetricbool('EnableSOReservations')) THEN
        UPDATE coitem
          SET coitem_qtyreserved = (coitem_qtyreserved + shipitemrsrv_qty)
        FROM shipitemrsrv
        WHERE ((coitem_id=_r.shipitem_orderitem_id)
          AND  (shipitemrsrv_shipitem_id=_r.shipitem_id));

        -- Handle location reservations if applicable
        FOR _rsrv IN
          SELECT *
          FROM shipitemlocrsrv
          WHERE (shipitemlocrsrv_shipitem_id=_r.shipitem_id)
        LOOP
          -- See if a reservation record still exists
          SELECT reserve_id INTO _reserveid
          FROM reserve JOIN itemloc ON (reserve_supply_id=itemloc_id)
          WHERE ((reserve_supply_type='I')
            AND  (reserve_demand_type = 'SO')
            AND  (reserve_demand_id = _r.shipitem_orderitem_id )
            AND  (itemloc_itemsite_id=_rsrv.shipitemlocrsrv_itemsite_id)
            AND  (itemloc_location_id=_rsrv.shipitemlocrsrv_location_id)
            AND  (COALESCE(itemloc_ls_id, -1)=COALESCE(_rsrv.shipitemlocrsrv_ls_id, -1))
            AND  (COALESCE(itemloc_expiration, endOfTime())=COALESCE(_rsrv.shipitemlocrsrv_expiration, endOfTime()))
            AND  (COALESCE(itemloc_warrpurc, endoftime())=COALESCE(_rsrv.shipitemlocrsrv_warrpurc, endoftime())) );

          GET DIAGNOSTICS _rows = ROW_COUNT;
          IF (_rows > 0 ) THEN
            -- Update existing
            UPDATE reserve
            SET reserve_qty = (reserve_qty + _rsrv.shipitemlocrsrv_qty)
            WHERE (reserve_id=_reserveid);
          ELSE
            -- Recreate record
            INSERT INTO reserve
            SELECT nextval('reserve_reserve_id_seq'), 'SO', _r.shipitem_orderitem_id,
                   'I', itemloc_id, _rsrv.shipitemlocrsrv_qty, 'R'
            FROM itemloc
            WHERE ((itemloc_itemsite_id=_rsrv.shipitemlocrsrv_itemsite_id)
              AND  (itemloc_location_id=_rsrv.shipitemlocrsrv_location_id)
              AND  (COALESCE(itemloc_ls_id, -1)=COALESCE(_rsrv.shipitemlocrsrv_ls_id, -1))
              AND  (COALESCE(itemloc_expiration, endOfTime())=COALESCE(_rsrv.shipitemlocrsrv_expiration, endOfTime()))
              AND  (COALESCE(itemloc_warrpurc, endoftime())=COALESCE(_rsrv.shipitemlocrsrv_warrpurc, endoftime())) );
          END IF;
        END LOOP;
      END IF;

      DELETE FROM shipitem WHERE (shipitem_id = _r.shipitem_id );

      -- Clean up if this is the last shipitem on the shipment
      IF (NOT EXISTS(SELECT shipitem_shiphead_id
                     FROM shipitem
                     WHERE (shipitem_shiphead_id=_r.shiphead_id))) THEN
        DELETE FROM shipdata
         WHERE(shipdata_shiphead_number=_r.shiphead_number);
        DELETE FROM shipdatasum
         WHERE(shipdatasum_shiphead_number=_r.shiphead_number);
        DELETE FROM pack
         WHERE(pack_shiphead_id=_r.shiphead_id);
        DELETE FROM shiphead
         WHERE (shiphead_id=_r.shiphead_id);
      END IF;

    END IF;

    RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.returnshipmenttransaction(integer, integer, timestamp with time zone) OWNER TO admin;

--
-- TOC entry 2136 (class 1255 OID 146566981)
-- Dependencies: 4536 8
-- Name: returnwomaterial(integer, numeric, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION returnwomaterial(integer, numeric, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWomatlid ALIAS FOR $1;
  pQty ALIAS FOR $2;
  pGlDistTS ALIAS FOR $3;
  _itemlocSeries INTEGER;

BEGIN

  SELECT NEXTVAL('itemloc_series_seq') INTO _itemlocSeries;
  RETURN returnWoMaterial(pWomatlid, pQty, _itemlocSeries, pGlDistTS);

END;
$_$;


ALTER FUNCTION public.returnwomaterial(integer, numeric, timestamp with time zone) OWNER TO admin;

--
-- TOC entry 2138 (class 1255 OID 146566982)
-- Dependencies: 4536 8
-- Name: returnwomaterial(integer, integer, timestamp with time zone, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION returnwomaterial(integer, integer, timestamp with time zone, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWomatlid ALIAS FOR $1;
  pItemlocSeries ALIAS FOR $2;
  pGlDistTS ALIAS FOR $3;
  pInvhistId ALIAS FOR $4;
  _woNumber TEXT;
  _invhistid INTEGER;
  _itemlocSeries INTEGER;
  _invqty NUMERIC;
  _womatlqty NUMERIC;
  _cost NUMERIC := 0;
  _rows INTEGER;

BEGIN

  _itemlocSeries := 0;

  SELECT invhist_invqty, invhist_invqty * invhist_unitcost INTO _invqty, _cost
  FROM invhist
  WHERE (invhist_id=pInvhistId);

  GET DIAGNOSTICS _rows = ROW_COUNT;

  IF (_rows = 0) THEN
    RAISE EXCEPTION 'No transaction found for invhist_id %', pInvhistId;
  END IF;

  SELECT itemuomtouom(itemsite_item_id, NULL, womatl_uom_id, _invqty)
    INTO _womatlqty
    FROM womatl, itemsite
    WHERE((womatl_itemsite_id=itemsite_id)
     AND (womatl_id=pWomatlid));

  GET DIAGNOSTICS _rows = ROW_COUNT;

  IF (_rows = 0) THEN
    _womatlqty := _invqty;
  END IF;

  IF ( SELECT (
         CASE WHEN (womatl_qtyreq >= 0) THEN
           womatl_qtyiss < _womatlqty
         ELSE
           womatl_qtyiss > _womatlqty
         END )
       FROM womatl
       WHERE ( womatl_id=pWomatlid ) ) THEN
    RETURN pItemlocSeries;
  END IF;

  SELECT formatWoNumber(womatl_wo_id) INTO _woNumber
  FROM womatl
  WHERE (womatl_id=pWomatlid);

  IF (pItemlocSeries = 0) THEN
    SELECT NEXTVAL('itemloc_series_seq') INTO _itemlocSeries;
  ELSE
    _itemlocSeries = pItemlocSeries;
  END IF;

  -- Post the transaction
  SELECT postInvTrans( ci.itemsite_id, 'IM', (_invqty * -1),
                       'W/O', 'WO', _woNumber, '',
                       ('Return ' || item_number || ' from Work Order'),
                       getPrjAccntId(wo_prj_id, pc.costcat_wip_accnt_id), cc.costcat_asset_accnt_id, _itemlocSeries, pGlDistTS,
                       -- Cost will be ignored by Standard Cost items sites
                       _cost, pInvhistId) INTO _invhistid
    FROM womatl, wo,
         itemsite AS ci, costcat AS cc,
         itemsite AS pi, costcat AS pc,
         item
   WHERE((womatl_itemsite_id=ci.itemsite_id)
     AND (ci.itemsite_costcat_id=cc.costcat_id)
     AND (womatl_wo_id=wo_id)
     AND (wo_itemsite_id=pi.itemsite_id)
     AND (pi.itemsite_costcat_id=pc.costcat_id)
     AND (ci.itemsite_item_id=item_id)
     AND (womatl_id=pWomatlid) );

--  Create linkage to the transaction created
  INSERT INTO womatlpost (womatlpost_womatl_id,womatlpost_invhist_id)
              VALUES (pWomatlid,_invhistid);

--  Decrease the parent W/O's WIP value by the value of the returned components
  UPDATE wo
  SET wo_wipvalue = (wo_wipvalue - (CASE WHEN(itemsite_costmethod IN ('A','J'))
                                              THEN _cost
                                         WHEN(itemsite_costmethod='S')
                                              THEN stdcost(itemsite_item_id) * _invqty
                                         ELSE 0.0 END )),
      wo_postedvalue = (wo_postedvalue - (CASE WHEN(itemsite_costmethod IN ('A','J'))
                                                    THEN _cost
                                               WHEN(itemsite_costmethod='S')
                                                    THEN stdcost(itemsite_item_id) * _invqty
                                               ELSE 0.0 END ))
  FROM womatl, itemsite
  WHERE ( (wo_id=womatl_wo_id)
   AND (womatl_itemsite_id=itemsite_id)
   AND (womatl_id=pWomatlid) );

  UPDATE womatl
  SET womatl_qtyiss = (womatl_qtyiss - _womatlqty),
      womatl_lastreturn = CURRENT_DATE
  WHERE (womatl_id=pWomatlid);

  RETURN _itemlocSeries;
END;
$_$;


ALTER FUNCTION public.returnwomaterial(integer, integer, timestamp with time zone, integer) OWNER TO admin;

--
-- TOC entry 9075 (class 0 OID 0)
-- Dependencies: 2138
-- Name: FUNCTION returnwomaterial(integer, integer, timestamp with time zone, integer); Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON FUNCTION returnwomaterial(integer, integer, timestamp with time zone, integer) IS 'Returns material by reversing a specific historical transaction';


--
-- TOC entry 2139 (class 1255 OID 146566983)
-- Dependencies: 4536 8
-- Name: returnwomaterial(integer, numeric, integer, timestamp with time zone, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION returnwomaterial(integer, numeric, integer, timestamp with time zone, boolean DEFAULT false) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWomatlid ALIAS FOR $1;
  pQty ALIAS FOR $2;
  pItemlocSeries ALIAS FOR $3;
  pGlDistTS ALIAS FOR $4;
  pReqStdCost ALIAS FOR $5;
  _woNumber TEXT;
  _invhistid INTEGER;
  _itemlocSeries INTEGER;
  _qty NUMERIC;
  _cost NUMERIC := 0;

BEGIN

  _itemlocSeries := 0;

  IF ( SELECT (
         CASE WHEN (womatl_qtyreq >= 0) THEN
           womatl_qtyiss < pQty
         ELSE
           womatl_qtyiss > pQty
         END )
       FROM womatl
       WHERE ( womatl_id=pWomatlid ) ) THEN
    RETURN pItemlocSeries;
  END IF;

  SELECT itemuomtouom(itemsite_item_id, womatl_uom_id, NULL, pQty)
    INTO _qty
    FROM womatl, itemsite
   WHERE((womatl_itemsite_id=itemsite_id)
     AND (womatl_id=pWomatlid));
  IF (NOT FOUND) THEN
    _qty := pQty;
  END IF;

  SELECT formatWoNumber(womatl_wo_id) INTO _woNumber
  FROM womatl
  WHERE (womatl_id=pWomatlid);

  IF (pItemlocSeries = 0) THEN
    SELECT NEXTVAL('itemloc_series_seq') INTO _itemlocSeries;
  ELSE
    _itemlocSeries = pItemlocSeries;
  END IF;

  -- Get the cost average
  IF (pReqStdCost) THEN
    SELECT stdcost(itemsite_item_id) * _qty INTO _cost
    FROM womatl, itemsite
    WHERE((womatl_itemsite_id=itemsite_id)
      AND (womatl_id=pWomatlid));
  ELSE
    SELECT SUM(invhist_value_before - invhist_value_after) / SUM(invhist_qoh_before - invhist_qoh_after)  * _qty INTO _cost
    FROM invhist, womatlpost, womatl
    WHERE((womatlpost_womatl_id=womatl_id)
     AND (womatlpost_invhist_id=invhist_id)
     AND (invhist_qoh_before > invhist_qoh_after)
     AND (womatl_id=pWomatlId));
  END IF;

  _cost := COALESCE(_cost, 0); -- make sure it's not a null value

  -- Post the transaction
  SELECT postInvTrans( ci.itemsite_id, 'IM', (_qty * -1),
                       'W/O', 'WO', _woNumber, '',
                       ('Return ' || item_number || ' from Work Order'),
                       getPrjAccntId(wo_prj_id, pc.costcat_wip_accnt_id), cc.costcat_asset_accnt_id, _itemlocSeries, pGlDistTS,
                       -- Cost will be ignored by Standard Cost items sites
                       _cost) INTO _invhistid
    FROM womatl, wo,
         itemsite AS ci, costcat AS cc,
         itemsite AS pi, costcat AS pc,
         item
   WHERE((womatl_itemsite_id=ci.itemsite_id)
     AND (ci.itemsite_costcat_id=cc.costcat_id)
     AND (womatl_wo_id=wo_id)
     AND (wo_itemsite_id=pi.itemsite_id)
     AND (pi.itemsite_costcat_id=pc.costcat_id)
     AND (ci.itemsite_item_id=item_id)
     AND (womatl_id=pWomatlid) );

--  Create linkage to the transaction created
  IF (_invhistid != -1) THEN
    INSERT INTO womatlpost (womatlpost_womatl_id,womatlpost_invhist_id)
                VALUES (pWomatlid,_invhistid);
  END IF;

--  Decrease the parent W/O's WIP value by the value of the returned components
  UPDATE wo
  SET wo_wipvalue = (wo_wipvalue - (CASE WHEN(itemsite_costmethod IN ('A','J'))
                                              THEN _cost
                                         WHEN(itemsite_costmethod='S')
                                              THEN stdcost(itemsite_item_id) * _qty
                                         ELSE 0.0 END )),
      wo_postedvalue = (wo_postedvalue - (CASE WHEN(itemsite_costmethod IN ('A','J'))
                                                    THEN _cost
                                               WHEN(itemsite_costmethod='S')
                                                    THEN stdcost(itemsite_item_id) * _qty
                                               ELSE 0.0 END ))
  FROM womatl, itemsite
  WHERE ( (wo_id=womatl_wo_id)
   AND (womatl_itemsite_id=itemsite_id)
   AND (womatl_id=pWomatlid) );

  UPDATE womatl
  SET womatl_qtyiss = (womatl_qtyiss - pQty),
      womatl_lastreturn = CURRENT_DATE
  WHERE (womatl_id=pWomatlid);

  RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.returnwomaterial(integer, numeric, integer, timestamp with time zone, boolean) OWNER TO admin;

--
-- TOC entry 2140 (class 1255 OID 146566984)
-- Dependencies: 4536 8
-- Name: returnwomaterialbatch(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION returnwomaterialbatch(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoid ALIAS FOR $1;
  _itemlocSeries INTEGER;
  _woid INTEGER;
  _r RECORD;

BEGIN

  SELECT wo_id INTO _woid
  FROM wo
  WHERE ( (wo_status IN ('E','I'))
   AND (wo_id=pWoid) );

  IF (FOUND) THEN
    SELECT NEXTVAL('itemloc_series_seq') INTO _itemlocSeries;

    FOR _r IN SELECT womatl_id,
                CASE WHEN wo_qtyord >= 0 THEN
                  womatl_qtyiss
                ELSE
                  ((womatl_qtyreq - womatl_qtyiss) * -1)
                END AS qty
              FROM wo, womatl, itemsite
              WHERE ((wo_id=womatl_wo_id)
              AND (womatl_itemsite_id=itemsite_id)
              AND ( (wo_qtyord < 0) OR (womatl_issuemethod IN ('S','M')) )
              AND (womatl_wo_id=pWoid)) LOOP

      IF (_r.qty != 0) THEN
        PERFORM returnWoMaterial(_r.womatl_id, _r.qty, _itemlocSeries, now());
      END IF;

    END LOOP;

--  Reset the W/O Status to E
    UPDATE wo
    SET wo_status='E'
    WHERE (wo_id=pWoid);

    RETURN _itemlocSeries;

  ELSE
    RETURN -1;
  END IF;

END;
$_$;


ALTER FUNCTION public.returnwomaterialbatch(integer) OWNER TO admin;

--
-- TOC entry 2141 (class 1255 OID 146566985)
-- Dependencies: 4536 8
-- Name: reversecashreceipt(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION reversecashreceipt(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCashrcptid ALIAS FOR $1;
  pJournalNumber ALIAS FOR $2;
  _p RECORD;
  _r RECORD;
  _postToAR NUMERIC;
  _postToMisc NUMERIC;
  _posted_base NUMERIC := 0;
  _posted NUMERIC := 0;
  _sequence INTEGER;
  _aropenid INTEGER;
  _arMemoNumber TEXT;
  _arAccntid INTEGER;
  _closed BOOLEAN;
  _debitAccntid INTEGER;
  _exchGain NUMERIC;
  _comment      TEXT;

BEGIN
  _posted := 0;
  _posted_base := 0;

  SELECT fetchGLSequence() INTO _sequence;

  SELECT accnt_id INTO _arAccntid
  FROM cashrcpt, accnt, salescat
  WHERE ((cashrcpt_salescat_id=salescat_id)
    AND  (salescat_ar_accnt_id=accnt_id)
    AND  (cashrcpt_id=pCashrcptid));
  IF (NOT FOUND) THEN
    SELECT accnt_id INTO _arAccntid
    FROM cashrcpt, accnt
    WHERE ( (findARAccount(cashrcpt_cust_id)=accnt_id)
     AND (cashrcpt_id=pCashrcptid) );
    IF (NOT FOUND) THEN
      RETURN -5;
    END IF;
  END IF;

  SELECT cashrcpt_cust_id, ('Reverse Cash Receipt posting for ' || cust_number||'-'||cust_name) AS custnote,
         cashrcpt_fundstype, cashrcpt_number, cashrcpt_docnumber,
         cashrcpt_distdate, cashrcpt_amount, cashrcpt_discount,
         (cashrcpt_amount / cashrcpt_curr_rate) AS cashrcpt_amount_base,
         (cashrcpt_discount / cashrcpt_curr_rate) AS cashrcpt_discount_base,
         cashrcpt_notes,
         cashrcpt_bankaccnt_id AS bankaccnt_id,
         accnt_id AS prepaid_accnt_id,
         cashrcpt_usecustdeposit,
         cashrcpt_curr_id, cashrcpt_curr_rate INTO _p
  FROM accnt, cashrcpt LEFT OUTER JOIN custinfo ON (cashrcpt_cust_id=cust_id)
  WHERE ( (findPrepaidAccount(cashrcpt_cust_id)=accnt_id)
   AND (cashrcpt_id=pCashrcptid) );
  IF (NOT FOUND) THEN
    RETURN -7;
  END IF;

  IF (_p.cashrcpt_fundstype IN ('A', 'D', 'M', 'V')) THEN
    IF NOT EXISTS(SELECT ccpay_id
                  FROM ccpay
                  WHERE ((ccpay_order_number=CAST(pCashrcptid AS TEXT))
                     AND (ccpay_status IN ('C', 'A')))) THEN
      RETURN -8;
    END IF;
    _debitAccntid := findPrepaidAccount(_p.cashrcpt_cust_id);
  ELSE
    SELECT accnt_id INTO _debitAccntid
    FROM cashrcpt, bankaccnt, accnt
    WHERE ( (cashrcpt_bankaccnt_id=bankaccnt_id)
     AND (bankaccnt_accnt_id=accnt_id)
     AND (cashrcpt_id=pCashrcptid) );
    IF (NOT FOUND) THEN
      RETURN -6;
    END IF;
  END IF;

--  Determine the amount to post to A/R Open Items
  SELECT COALESCE(SUM(cashrcptitem_amount),0) INTO _postToAR
  FROM cashrcptitem JOIN aropen ON (aropen_id=cashrcptitem_aropen_id)
  WHERE ((cashrcptitem_cashrcpt_id=pCashrcptid)
   AND (cashrcptitem_applied));
  IF (NOT FOUND) THEN
    _postToAR := 0;
  END IF;

--  Determine the amount to post to Misc. Distributions
  SELECT COALESCE(SUM(cashrcptmisc_amount),0) INTO _postToMisc
  FROM cashrcptmisc
  WHERE (cashrcptmisc_cashrcpt_id=pCashrcptid);
  IF (NOT FOUND) THEN
    _postToMisc := 0;
  END IF;

--  Check to see if the C/R is over applied
  IF ((_postToAR + _postToMisc) > _p.cashrcpt_amount) THEN
    RETURN -1;
  END IF;

--  Check to see if the C/R is positive amount
  IF (_p.cashrcpt_amount <= 0) THEN
    RETURN -2;
  END IF;

--  Distribute A/R Applications
  FOR _r IN SELECT aropen_id, aropen_doctype, aropen_docnumber, aropen_docdate,
                   aropen_duedate, aropen_curr_id, aropen_curr_rate,
                   round(aropen_amount - aropen_paid, 2) <=
                      round(aropen_paid +
                      currToCurr(_p.cashrcpt_curr_id, aropen_curr_id,abs(cashrcptitem_amount + cashrcptitem_discount),_p.cashrcpt_distdate),2)
                               AS closed,
                   cashrcptitem_id, cashrcptitem_amount, cashrcptitem_discount,
                   (cashrcptitem_amount / _p.cashrcpt_curr_rate) AS cashrcptitem_amount_base,
                   (cashrcptitem_discount / _p.cashrcpt_curr_rate) AS cashrcptitem_discount_base,
                   round(aropen_paid -
                      currToCurr(_p.cashrcpt_curr_id, aropen_curr_id,abs(cashrcptitem_amount),_p.cashrcpt_distdate),2) AS new_paid,
                   round(currToCurr(_p.cashrcpt_curr_id, aropen_curr_id,abs(cashrcptitem_discount),_p.cashrcpt_distdate),2) AS new_discount
            FROM cashrcptitem JOIN aropen ON (cashrcptitem_aropen_id=aropen_id)
            WHERE ((cashrcptitem_cashrcpt_id=pCashrcptid)
              AND (cashrcptitem_applied)) LOOP

--  Handle discount
    IF (_r.cashrcptitem_discount_base > 0) THEN
      PERFORM reverseCashReceiptDisc(_r.cashrcptitem_id, pJournalNumber);
    END IF;

--  Update the aropen item to post the paid amount
    UPDATE aropen
    SET aropen_paid = _r.new_paid - _r.new_discount,
        aropen_open = TRUE,
        aropen_closedate = NULL
    WHERE (aropen_id=_r.aropen_id);

--  Cache the running amount posted
    _posted_base := _posted_base + _r.cashrcptitem_amount_base;
    _posted := _posted + _r.cashrcptitem_amount;

--  Record the cashrcpt application
    IF (_r.aropen_doctype IN ('I','D')) THEN
      INSERT INTO arapply
      ( arapply_cust_id,
        arapply_source_aropen_id, arapply_source_doctype, arapply_source_docnumber,
        arapply_target_aropen_id, arapply_target_doctype, arapply_target_docnumber,
        arapply_fundstype, arapply_refnumber, arapply_reftype, arapply_ref_id,
        arapply_applied, arapply_closed,
        arapply_postdate, arapply_distdate, arapply_journalnumber, arapply_username,
        arapply_curr_id
       )
      VALUES
      ( _p.cashrcpt_cust_id,
        -1, 'K', _p.cashrcpt_number,
        _r.aropen_id, _r.aropen_doctype, _r.aropen_docnumber,
        _p.cashrcpt_fundstype, _p.cashrcpt_docnumber, 'CRA', _r.cashrcptitem_id,
        (round(_r.cashrcptitem_amount, 2) * -1.0), _r.closed,
        CURRENT_DATE, _p.cashrcpt_distdate, pJournalNumber, getEffectiveXtUser(), _p.cashrcpt_curr_id );
    ELSE
      INSERT INTO arapply
      ( arapply_cust_id,
        arapply_source_aropen_id, arapply_source_doctype, arapply_source_docnumber,
        arapply_target_aropen_id, arapply_target_doctype, arapply_target_docnumber,
        arapply_fundstype, arapply_refnumber, arapply_reftype, arapply_ref_id,
        arapply_applied, arapply_closed, arapply_postdate, arapply_distdate,
        arapply_journalnumber, arapply_username, arapply_curr_id )
      VALUES
      ( _p.cashrcpt_cust_id,
        _r.aropen_id, _r.aropen_doctype, _r.aropen_docnumber,
        -1, 'R', _p.cashrcpt_number,
        '', '', 'CRA', _r.cashrcptitem_id,
        (round(abs(_r.cashrcptitem_amount), 2) * -1.0), _r.closed,
        CURRENT_DATE, _p.cashrcpt_distdate, pJournalNumber, getEffectiveXtUser(), _p.cashrcpt_curr_id );
    END IF;

    _exchGain := arCurrGain(_r.aropen_id,_p.cashrcpt_curr_id, abs(_r.cashrcptitem_amount),
                           _p.cashrcpt_distdate);

    PERFORM insertIntoGLSeries( _sequence, 'A/R', 'CR',
                        (_r.aropen_doctype || '-' || _r.aropen_docnumber),
                        CASE WHEN _r.aropen_doctype != 'R' THEN _arAccntid
                        ELSE findDeferredAccount(_p.cashrcpt_cust_id) END,
                        (round(_r.cashrcptitem_amount_base + _exchGain, 2) * -1.0),
                        _p.cashrcpt_distdate, _p.custnote );

    IF (_exchGain <> 0) THEN
        PERFORM insertIntoGLSeries(_sequence, 'A/R', 'CR',
               _r.aropen_doctype || '-' || _r.aropen_docnumber,
               getGainLossAccntId(
               CASE WHEN _r.aropen_doctype != 'R' THEN _arAccntid
               ELSE findDeferredAccount(_p.cashrcpt_cust_id) END
               ), round(_exchGain, 2),
               _p.cashrcpt_distdate, _p.custnote);

    END IF;

  END LOOP;

--  Distribute Misc. Applications
  FOR _r IN SELECT cashrcptmisc_id, cashrcptmisc_accnt_id, cashrcptmisc_amount,
                   (cashrcptmisc_amount / _p.cashrcpt_curr_rate) AS cashrcptmisc_amount_base,
                   cashrcptmisc_notes
            FROM cashrcptmisc
            WHERE (cashrcptmisc_cashrcpt_id=pCashrcptid)  LOOP

--  Cache the running amount posted
    _posted_base := (_posted_base + _r.cashrcptmisc_amount_base);
    _posted := (_posted + _r.cashrcptmisc_amount);

--  Record the cashrcpt application
    INSERT INTO arapply
    ( arapply_cust_id,
      arapply_source_aropen_id, arapply_source_doctype, arapply_source_docnumber,
      arapply_target_aropen_id, arapply_target_doctype, arapply_target_docnumber,
      arapply_fundstype, arapply_refnumber,
      arapply_applied, arapply_closed,
      arapply_postdate, arapply_distdate, arapply_journalnumber, arapply_username,
      arapply_curr_id, arapply_reftype, arapply_ref_id )
    VALUES
    ( _p.cashrcpt_cust_id,
      -1, 'K', '',
      -1, 'Misc.', '',
      _p.cashrcpt_fundstype, _p.cashrcpt_docnumber,
      (round(_r.cashrcptmisc_amount, 2) * -1.0), TRUE,
      CURRENT_DATE, _p.cashrcpt_distdate, pJournalNumber, getEffectiveXtUser(),
      _p.cashrcpt_curr_id, 'CRD', _r.cashrcptmisc_id );

    PERFORM insertIntoGLSeries( _sequence, 'A/R', 'CR', _r.cashrcptmisc_notes,
                                _r.cashrcptmisc_accnt_id,
                                (round(_r.cashrcptmisc_amount_base, 2) * -1.0),
                                _p.cashrcpt_distdate, _p.custnote );

  END LOOP;

--  Post any remaining Cash to an A/R Debit Memo
--  this credit memo may absorb an occasional currency exchange rounding error
  IF (round(_posted_base, 2) < round(_p.cashrcpt_amount_base, 2)) THEN
    _comment := ('Unapplied from ' || _p.cashrcpt_fundstype || '-' || _p.cashrcpt_docnumber);
    PERFORM insertIntoGLSeries( _sequence, 'A/R', 'CR',
                                _comment,
                                _p.prepaid_accnt_id,
                                ((round(_p.cashrcpt_amount_base, 2) - round(_posted_base, 2)) * -1.0),
                                _p.cashrcpt_distdate, _p.custnote );
    SELECT fetchArMemoNumber() INTO _arMemoNumber;
    -- Post A/R Debit Memo
    SELECT createARDebitMemo(NULL, _p.cashrcpt_cust_id, pJournalNumber, _arMemoNumber, '',
                              _p.cashrcpt_distdate, (_p.cashrcpt_amount - _posted),
                              _comment, -1, -1, -1, _p.cashrcpt_distdate, -1, NULL, 0,
                              _p.cashrcpt_curr_id) INTO _aropenid;
    -- Create Cash Receipt Item to capture posting
    INSERT INTO cashrcptitem
      ( cashrcptitem_cashrcpt_id, cashrcptitem_aropen_id, cashrcptitem_amount )
    VALUES
      ( pCashrcptid, _aropenid, ((_p.cashrcpt_amount - _posted) * 1.0) );

  ELSIF (round(_posted_base, 2) > round(_p.cashrcpt_amount_base, 2)) THEN
    PERFORM insertIntoGLSeries(_sequence, 'A/R', 'CR',
                   'Currency Exchange Rounding - ' || _p.cashrcpt_docnumber,
                   getGainLossAccntId(_debitAccntid),
                   ((round(_posted_base, 2) - round((_p.cashrcpt_amount_base + _p.cashrcpt_discount_base), 2)) * 1.0),
                   _p.cashrcpt_distdate, _p.custnote);
  END IF;

--  Debit Cash
  PERFORM insertIntoGLSeries( _sequence, 'A/R', 'CR',
                    (_p.cashrcpt_fundstype || '-' || _p.cashrcpt_docnumber),
                     _debitAccntid, round(_p.cashrcpt_amount_base, 2),
                     _p.cashrcpt_distdate,
                     _p.custnote );

  PERFORM postGLSeries(_sequence, pJournalNumber);

--  Update and void the posted cashrcpt
  UPDATE cashrcpt SET cashrcpt_posted=FALSE,
                      cashrcpt_posteddate=NULL,
                      cashrcpt_postedby=NULL,
                      cashrcpt_void=TRUE
  WHERE (cashrcpt_id=pCashrcptid);

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.reversecashreceipt(integer, integer) OWNER TO admin;

--
-- TOC entry 2142 (class 1255 OID 146566987)
-- Dependencies: 4536 8
-- Name: reversecashreceiptdisc(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION reversecashreceiptdisc(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCashrcptItemId ALIAS FOR $1;
  pJournalNumber ALIAS FOR $2;
  _r RECORD;
  _t RECORD;
  _v RECORD;
  _ardiscountid INTEGER;
  _arMemoNumber TEXT;
  _arAccntid INTEGER;
  _discountAccntid INTEGER;
  _comment      TEXT;
  _discprcnt NUMERIC;
  _check INTEGER;

BEGIN

    -- Fetch base records for processing
    SELECT aropen_id, aropen_doctype, aropen_amount,
           cashrcptitem_discount,
           cashrcpt_cust_id, cashrcpt_distdate, cashrcpt_applydate,
           cashrcpt_curr_id, cashrcpt_fundstype, cashrcpt_docnumber,
           round(currToCurr(cashrcpt_curr_id, aropen_curr_id, cashrcptitem_discount, cashrcpt_distdate),2) AS aropen_discount
      INTO _r
    FROM cashrcptitem
      JOIN cashrcpt ON (cashrcptitem_cashrcpt_id=cashrcpt_id)
      JOIN aropen ON ( (aropen_id=cashrcptitem_aropen_id) AND (aropen_doctype IN ('I', 'D')) )
    WHERE (cashrcptitem_id=pCashrcptItemId);

    -- Get discount account
    _discountAccntid := findardiscountaccount(_r.cashrcpt_cust_id);

    IF (_r.cashrcptitem_discount > 0) THEN
      --  Determine discount percentage
      _discprcnt := _r.aropen_discount / _r.aropen_amount;

      SELECT fetchArMemoNumber() INTO _arMemoNumber;
      _comment := 'Discount Credit Reversal from ' || _r.cashrcpt_fundstype || '-' || _r.cashrcpt_docnumber;

      -- Create misc debit memo record
      _ardiscountid := nextval('aropen_aropen_id_seq');
      INSERT INTO aropen (
        aropen_id, aropen_docdate, aropen_duedate, aropen_doctype,
        aropen_docnumber, aropen_curr_id, aropen_posted, aropen_amount )
      VALUES (
        _ardiscountid, _r.cashrcpt_distdate, _r.cashrcpt_distdate, 'D',
        _arMemoNumber, _r.cashrcpt_curr_id, false,_r.cashrcptitem_discount);

      IF (fetchMetricBool('CreditTaxDiscount')) THEN
        --  proportional tax credits calculated and implemented for the debit memo generated by the discount
        IF (_r.aropen_doctype  = 'I') THEN
          -- Tax for invoices
          SELECT aropen_cobmisc_id AS invcheadid,
                 invchead_curr_id,
                 invchead_invcdate INTO _t
          FROM aropen
            LEFT OUTER JOIN invchead ON (aropen_cobmisc_id = invchead_id)
            LEFT OUTER JOIN invcitem ON (invchead_id = invcitem_invchead_id)
          WHERE aropen_id = _r.aropen_id;

          FOR _v IN SELECT tax_sales_accnt_id,
                           tax_id,
                           round(sum(taxdetail_tax), 2) AS tax,
                           currToBase(_t.invchead_curr_id, round(sum(taxdetail_tax), 2), _t.invchead_invcdate) AS taxbasevalue
          FROM tax
            JOIN calculateTaxDetailSummary('I', _t.invcheadid, 'T') ON (taxdetail_tax_id=tax_id)
            GROUP BY tax_id, tax_sales_accnt_id
          LOOP
            INSERT INTO aropentax(
              taxhist_parent_id, taxhist_taxtype_id, taxhist_tax_id,
              taxhist_percent, taxhist_amount, taxhist_tax,
              taxhist_docdate, taxhist_basis)
            VALUES (
              _ardiscountid, getadjustmenttaxtypeid(), _v.tax_id,
              0.00, 0.00, (round((_v.tax * _discprcnt), 2)),
              _r.cashrcpt_distdate, 0.00);
          END LOOP;

        ELSIF (_r.aropen_doctype  = 'D') THEN
          -- Tax for debit memos
          INSERT INTO aropentax(
            taxhist_parent_id, taxhist_taxtype_id, taxhist_tax_id,
            taxhist_percent, taxhist_amount, taxhist_tax,
            taxhist_docdate, taxhist_basis)
          SELECT
            _ardiscountid, taxhist_taxtype_id, taxhist_tax_id,
            0.00, 0.00, (round((taxhist_tax * _discprcnt), 2)),
            _r.cashrcpt_distdate, 0.00
          FROM aropentax
          WHERE (taxhist_parent_id=_r.aropen_id);

        END IF;
      END IF; -- End taxes

      -- Create debit memo for discount
      SELECT createARDebitMemo(_ardiscountid, _r.cashrcpt_cust_id, pJournalNumber, _arMemoNumber, '',
                                _r.cashrcpt_distdate, _r.cashrcptitem_discount,
                                _comment, -1, -1, _discountAccntid, _r.cashrcpt_distdate,
                                -1, NULL, 0, _r.cashrcpt_curr_id) INTO _ardiscountid;

    END IF; -- End handle Discount

    RETURN 1;

END;
$_$;


ALTER FUNCTION public.reversecashreceiptdisc(integer, integer) OWNER TO admin;

--
-- TOC entry 2143 (class 1255 OID 146566988)
-- Dependencies: 4536 8
-- Name: reverseglseries(integer, date, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION reverseglseries(integer, date, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSequence ALIAS FOR $1;
  pDistDate ALIAS FOR $2;
  pNotes ALIAS FOR $3;
  _sequence INTEGER := fetchGLSequence();
  _journal INTEGER;

BEGIN

  IF (SELECT COUNT(gltrans_sequence) > 0 FROM gltrans WHERE gltrans_sequence = pSequence) THEN
    SELECT fetchJournalNumber(jrnluse_use) INTO _journal
    FROM gltrans
      JOIN jrnluse ON (gltrans_journalnumber=jrnluse_number)
    WHERE (gltrans_sequence=pSequence)
    LIMIT 1;

    INSERT INTO gltrans (gltrans_created, gltrans_posted, gltrans_exported,
                         gltrans_date, gltrans_sequence, gltrans_accnt_id,
                         gltrans_source, gltrans_docnumber, gltrans_misc_id,
                         gltrans_amount, gltrans_notes, gltrans_journalnumber,
                         gltrans_doctype)
                 SELECT  CURRENT_TIMESTAMP, FALSE, FALSE,
                         pDistDate, _sequence, gltrans_accnt_id,
                         gltrans_source, gltrans_docnumber, gltrans_misc_id,
                         (gltrans_amount * -1), pNotes, _journal,
                         gltrans_doctype
                    FROM gltrans
                   WHERE (gltrans_sequence=pSequence);

    PERFORM postIntoTrialBalance(_sequence);
  ELSE
    SELECT fetchJournalNumber(jrnluse_use) INTO _journal
    FROM sltrans
      JOIN jrnluse ON (sltrans_journalnumber=jrnluse_number)
    WHERE (sltrans_sequence=pSequence)
    LIMIT 1;

    INSERT INTO sltrans (sltrans_created, sltrans_posted,
                         sltrans_date, sltrans_sequence, sltrans_accnt_id,
                         sltrans_source, sltrans_docnumber, sltrans_misc_id,
                         sltrans_amount, sltrans_notes, sltrans_journalnumber,
                         sltrans_doctype)
                 SELECT  CURRENT_TIMESTAMP, FALSE,
                         pDistDate, _sequence, sltrans_accnt_id,
                         sltrans_source, sltrans_docnumber, sltrans_misc_id,
                         (sltrans_amount * -1), pNotes, _journal,
                         sltrans_doctype
                    FROM sltrans
                   WHERE (sltrans_sequence=pSequence);
  END IF;

  RETURN _journal;
END;
$_$;


ALTER FUNCTION public.reverseglseries(integer, date, text) OWNER TO admin;

--
-- TOC entry 2137 (class 1255 OID 146566989)
-- Dependencies: 4536 8
-- Name: revokeallmodulecmnttypesource(integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION revokeallmodulecmnttypesource(integer, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCmnttypeid ALIAS FOR $1;
  pModuleName ALIAS FOR $2;

BEGIN

  DELETE FROM cmnttypesource
  WHERE (cmnttypesource_id IN ( SELECT cmnttypesource_id
                                FROM cmnttypesource, source
                                WHERE ( (cmnttypesource_source_id=source_id)
                                  AND (cmnttypesource_cmnttype_id=pCmnttypeid)
                                  AND (source_module=pModuleName) ) ) );

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.revokeallmodulecmnttypesource(integer, text) OWNER TO admin;

--
-- TOC entry 2114 (class 1255 OID 146566990)
-- Dependencies: 4536 8
-- Name: revokeallmodulepriv(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION revokeallmodulepriv(text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pUsername ALIAS FOR $1;
  pModuleName ALIAS FOR $2;

BEGIN

  DELETE FROM usrpriv
  WHERE (usrpriv_id IN ( SELECT usrpriv_id
                         FROM usrpriv, priv
                         WHERE ( (usrpriv_priv_id=priv_id)
                          AND (usrpriv_username=pUsername)
                          AND (priv_module=pModuleName) ) ) );

  NOTIFY "usrprivUpdated";

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.revokeallmodulepriv(text, text) OWNER TO admin;

--
-- TOC entry 2125 (class 1255 OID 146566991)
-- Dependencies: 4536 8
-- Name: revokeallmoduleprivgroup(integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION revokeallmoduleprivgroup(integer, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pGrpid ALIAS FOR $1;
  pModuleName ALIAS FOR $2;

BEGIN

  DELETE FROM grppriv
  WHERE (grppriv_id IN ( SELECT grppriv_id
                         FROM grppriv, priv
                         WHERE ( (grppriv_priv_id=priv_id)
                          AND (grppriv_grp_id=pGrpid)
                          AND (priv_module=pModuleName) ) ) );

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.revokeallmoduleprivgroup(integer, text) OWNER TO admin;

--
-- TOC entry 2144 (class 1255 OID 146566992)
-- Dependencies: 4536 8
-- Name: revokecmnttypesource(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION revokecmnttypesource(integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCmnttypeid ALIAS FOR $1;
  pSourceid ALIAS FOR $2;

BEGIN

  DELETE FROM cmnttypesource
  WHERE ( (cmnttypesource_cmnttype_id=pCmnttypeid)
    AND (cmnttypesource_source_id=pSourceid) );

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.revokecmnttypesource(integer, integer) OWNER TO admin;

--
-- TOC entry 2145 (class 1255 OID 146566993)
-- Dependencies: 4536 8
-- Name: revokegroup(text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION revokegroup(text, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pUsername ALIAS FOR $1;
  pGrpid ALIAS FOR $2;

BEGIN

  DELETE FROM usrgrp
  WHERE ( (usrgrp_username=pUsername)
   AND (usrgrp_grp_id=pGrpid) );

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.revokegroup(text, integer) OWNER TO admin;

--
-- TOC entry 2146 (class 1255 OID 146566994)
-- Dependencies: 4536 8
-- Name: revokepriv(text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION revokepriv(text, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pUsername ALIAS FOR $1;
  pPrivid ALIAS FOR $2;

BEGIN

  DELETE FROM usrpriv
  WHERE ( (usrpriv_username=pUsername)
   AND (usrpriv_priv_id=pPrivid) );

  NOTIFY "usrprivUpdated";

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.revokepriv(text, integer) OWNER TO admin;

--
-- TOC entry 2147 (class 1255 OID 146566995)
-- Dependencies: 4536 8
-- Name: revokepriv(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION revokepriv(text, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pUsername ALIAS FOR $1;
  pPrivname ALIAS FOR $2;

BEGIN

  DELETE FROM usrpriv
  WHERE ( (usrpriv_username=pUsername)
   AND (usrpriv_priv_id IN (SELECT priv_id
                              FROM priv
                             WHERE priv_name=pPrivname) ));

  NOTIFY "usrprivUpdated";

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.revokepriv(text, text) OWNER TO admin;

--
-- TOC entry 2148 (class 1255 OID 146566996)
-- Dependencies: 4536 8
-- Name: revokeprivgroup(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION revokeprivgroup(integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pGrpid ALIAS FOR $1;
  pPrivid ALIAS FOR $2;

BEGIN

  DELETE FROM grppriv
  WHERE ( (grppriv_grp_id=pGrpid)
   AND (grppriv_priv_id=pPrivid) );

  NOTIFY "usrprivUpdated";

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.revokeprivgroup(integer, integer) OWNER TO admin;

--
-- TOC entry 2149 (class 1255 OID 146566997)
-- Dependencies: 4536 8
-- Name: rollupactualcost(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION rollupactualcost(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
    pItemid ALIAS FOR $1;

BEGIN
    RETURN rollUpSorACost(pitemid, TRUE);
END;
$_$;


ALTER FUNCTION public.rollupactualcost(integer) OWNER TO admin;

--
-- TOC entry 2150 (class 1255 OID 146566998)
-- Dependencies: 4536 8
-- Name: rollupsoracost(integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION rollupsoracost(integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid	ALIAS FOR $1;
  pActual	ALIAS FOR $2;
  _counter INTEGER;
  _setid INTEGER;
  _consumers RECORD;

BEGIN

  _counter := 0;

  SELECT indentedWhereUsed(pItemid) INTO _setid;

  FOR _consumers IN SELECT bomwork_item_id
                    FROM bomwork
                    WHERE (bomwork_set_id=_setid)
                    ORDER BY bomwork_level LOOP
    PERFORM updateSorACost( _consumers.bomwork_item_id, costelem_type, TRUE,
			    lowerCost(_consumers.bomwork_item_id,
				      costelem_type, pActual),
			    pActual )
    FROM costelem
    WHERE (costelem_sys);

    PERFORM updateLowerUserCosts(_consumers.bomwork_item_id, pActual);

    _counter := _counter + 1;

  END LOOP;

  PERFORM deleteBOMWorkset(_setid);

  RETURN _counter;

END;
$_$;


ALTER FUNCTION public.rollupsoracost(integer, boolean) OWNER TO admin;

--
-- TOC entry 2151 (class 1255 OID 146566999)
-- Dependencies: 4536 8
-- Name: rollupstandardcost(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION rollupstandardcost(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
    pItemid ALIAS FOR $1;

BEGIN
    RETURN rollUpSorACost(pItemid, FALSE);
END;
$_$;


ALTER FUNCTION public.rollupstandardcost(integer) OWNER TO admin;

--
-- TOC entry 2152 (class 1255 OID 146567000)
-- Dependencies: 4536 8
-- Name: roundcost(numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION roundcost(pcost numeric) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _scale INTEGER;

BEGIN
  IF (pCost IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT locale_cost_scale INTO _scale
  FROM locale
  WHERE (locale_id=getUsrLocaleId());

  RETURN ROUND(pCost, _scale);

END;
$$;


ALTER FUNCTION public.roundcost(pcost numeric) OWNER TO admin;

--
-- TOC entry 2153 (class 1255 OID 146567001)
-- Dependencies: 4536 8
-- Name: roundlocale(boolean, numeric, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION roundlocale(pfractional boolean, pqty numeric, plocale text) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _r RECORD;
  _scale INTEGER;

BEGIN
  IF (pFractional) THEN
    SELECT * INTO _r
    FROM locale
    WHERE (locale_id=getUsrLocaleId());

    _scale := CASE pLocale WHEN 'qtyper' THEN _r.locale_qtyper_scale
                           WHEN 'cost' THEN _r.locale_cost_scale
                           ELSE _r.locale_qty_scale
              END;

    RETURN ROUND(pQty, _scale);
  ELSE
    IF (TRUNC(pQty) < pQty) THEN
      RETURN (TRUNC(pQty) + 1);
    ELSE
      RETURN TRUNC(pQty);
    END IF;
  END IF;
END;
$$;


ALTER FUNCTION public.roundlocale(pfractional boolean, pqty numeric, plocale text) OWNER TO admin;

--
-- TOC entry 2154 (class 1255 OID 146567002)
-- Dependencies: 4536 8
-- Name: roundqty(boolean, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION roundqty(pfractional boolean, pqty numeric) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _scale INTEGER;

BEGIN
  SELECT locale_qty_scale INTO _scale
  FROM locale
  WHERE (locale_id=getUsrLocaleId());

  IF (pFractional) THEN
    RETURN ROUND(pQty, _scale);
  ELSE
    IF (TRUNC(pQty) < ROUND(pQty, _scale)) THEN
      RETURN (TRUNC(pQty) + 1);
    ELSE
      RETURN TRUNC(pQty);
    END IF;
  END IF;
END;
$$;


ALTER FUNCTION public.roundqty(pfractional boolean, pqty numeric) OWNER TO admin;

--
-- TOC entry 2155 (class 1255 OID 146567003)
-- Dependencies: 4536 8
-- Name: roundsale(numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION roundsale(psale numeric) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _scale INTEGER;

BEGIN
  IF (pSale IS NULL) THEN
    RETURN NULL;
  END IF;

  SELECT locale_salesprice_scale INTO _scale
  FROM locale
  WHERE (locale_id=getUsrLocaleId());

  RETURN ROUND(pSale, _scale);

END;
$$;


ALTER FUNCTION public.roundsale(psale numeric) OWNER TO admin;

--
-- TOC entry 2156 (class 1255 OID 146567004)
-- Dependencies: 4536 8
-- Name: roundup(numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION roundup(numeric) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE

  pValue ALIAS FOR $1;
  _checkValue integer;

BEGIN

  _checkValue := pValue::integer;

  IF (_checkValue::numeric < pValue) THEN
    RETURN (_checkValue + 1)::numeric;
  ELSE
    RETURN _checkValue::numeric;
  END IF;

END;
$_$;


ALTER FUNCTION public.roundup(numeric) OWNER TO admin;

--
-- TOC entry 2158 (class 1255 OID 146567006)
-- Dependencies: 4536 8
-- Name: saveaddr(integer, text, text, text, text, text, text, text, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION saveaddr(integer, text, text, text, text, text, text, text, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pAddrId ALIAS FOR $1;
  pNumber ALIAS FOR $2;
  pAddr1 ALIAS FOR $3;
  pAddr2 ALIAS FOR $4;
  pAddr3 ALIAS FOR $5;
  pCity ALIAS FOR $6;
  pState ALIAS FOR $7;
  pPostalCode ALIAS FOR $8;
  pCountry ALIAS FOR $9;
  pFlag ALIAS FOR $10;
  _returnVal INTEGER;

BEGIN

  SELECT saveAddr(pAddrId,pNumber, pAddr1,pAddr2,pAddr3,pCity,pState,pPostalCode,pCountry,true,'',pFlag) INTO _returnVal;

  RETURN _returnVal;

END;
$_$;


ALTER FUNCTION public.saveaddr(integer, text, text, text, text, text, text, text, text, text) OWNER TO admin;

--
-- TOC entry 2157 (class 1255 OID 146567005)
-- Dependencies: 4536 8
-- Name: saveaddr(integer, text, text, text, text, text, text, text, text, boolean, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION saveaddr(integer, text, text, text, text, text, text, text, text, boolean, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pAddrId ALIAS FOR $1;
  pNumber ALIAS FOR $2;
  pAddr1 ALIAS FOR $3;
  pAddr2 ALIAS FOR $4;
  pAddr3 ALIAS FOR $5;
  pCity ALIAS FOR $6;
  pState ALIAS FOR $7;
  pPostalCode ALIAS FOR $8;
  pCountry ALIAS FOR $9;
  pActive ALIAS FOR $10;
  pNotes ALIAS FOR $11;
  pFlag ALIAS FOR $12;
  _addrId INTEGER;
  _addrNumber INTEGER;
  _flag TEXT;
  _p RECORD;
  _cnt INTEGER;
  _notes TEXT;

BEGIN
  --Validate
  IF ((pFlag IS NULL) OR (pFlag = '') OR (pFlag = 'CHECK') OR (pFlag = 'CHANGEONE') OR (pFlag = 'CHANGEALL')) THEN
    IF (pFlag='') THEN
      _flag := 'CHECK';
    ELSE
      _flag := COALESCE(pFlag,'CHECK');
    END IF;
  ELSE
	RAISE EXCEPTION 'Invalid Flag (%). Valid flags are CHECK, CHANGEONE or CHANGEALL', pFlag;
  END IF;

  _notes := COALESCE(pNotes,'');

  --If there is nothing here, get out
  IF ( (pNumber = '' OR pNumber IS NULL)
    AND (pAddr1 = '' OR pAddr1 IS NULL)
    AND (pAddr2 = '' OR pAddr2 IS NULL)
    AND (pAddr3 = '' OR pAddr3 IS NULL)
    AND (pCity = '' OR pCity IS NULL)
    AND (pState = '' OR pState IS NULL)
    AND (pPostalCode = '' OR pPostalCode IS NULL)
    AND (pCountry = '' OR pCountry IS NULL) ) THEN
    RETURN NULL;

  END IF;

  _addrId := COALESCE(pAddrId,-1);

  --If we have an ID see if anything has changed, if not get out
  IF (_addrId >= 0) THEN
    SELECT * FROM addr INTO _p
    WHERE ((pAddrId=addr_id)
    AND (COALESCE(pNumber,addr_number)=addr_number)
    AND (COALESCE(pAddr1, '')=COALESCE(addr_line1, ''))
    AND (COALESCE(pAddr2, '')=COALESCE(addr_line2, ''))
    AND (COALESCE(pAddr3, '')=COALESCE(addr_line3, ''))
    AND (COALESCE(pCity, '')=COALESCE(addr_city, ''))
    AND (COALESCE(pState, '')=COALESCE(addr_state, ''))
    AND (COALESCE(pPostalCode, '')=COALESCE(addr_postalcode, ''))
    AND (COALESCE(pCountry, '')=COALESCE(addr_country, ''))
    AND (pActive=addr_active)
    AND (_notes=COALESCE(addr_notes,'')));
    IF (FOUND) THEN
      RETURN _addrId;
    END IF;
  END IF;

  --Check to see if duplicate address exists

    SELECT addr_id, addr_notes INTO _p
    FROM addr
    WHERE ((_addrId <> addr_id)
    AND  (COALESCE(UPPER(addr_line1),'') = COALESCE(UPPER(pAddr1),''))
    AND  (COALESCE(UPPER(addr_line2),'') = COALESCE(UPPER(pAddr2),''))
    AND  (COALESCE(UPPER(addr_line3),'') = COALESCE(UPPER(pAddr3),''))
    AND  (COALESCE(UPPER(addr_city),'') = COALESCE(UPPER(pCity),''))
    AND  (COALESCE(UPPER(addr_state),'') = COALESCE(UPPER(pState),''))
    AND  (COALESCE(UPPER(addr_postalcode),'') = COALESCE(UPPER(pPostalcode),''))
    AND  (COALESCE(UPPER(addr_country),'') = COALESCE(UPPER(pCountry),'')));
    IF (FOUND) THEN
	--Note:  To prevent overwriting of existing notes, the application
	--needs to load any existing notes for a matching address before altering them.
	IF (_notes <> _p.addr_notes) THEN
		UPDATE addr
		SET addr_notes=addr_notes || '
' || _notes
		WHERE addr_id=_p.addr_id;
	END IF;
        RETURN _p.addr_id;  --A matching address exits
    END IF;

  IF (_addrId < 0) THEN
    _flag := 'CHANGEONE';
  END IF;

  IF (_flag = 'CHECK') THEN
    IF addrUseCount(_addrId) > 1 THEN
      RETURN -2;
    ELSIF (SELECT COUNT(addr_id)=0 FROM addr WHERE (addr_id=_addrId)) THEN
      _flag := 'CHANGEONE';
    ELSE
      _flag := 'CHANGEALL';
    END IF;
  END IF;

  IF (_flag = 'CHANGEALL') THEN
    _addrNumber := pNumber;
    IF (_addrNumber IS NULL) THEN
      SELECT addr_number INTO _addrNumber
        FROM addr
       WHERE(addr_id = _addrId);
      IF (_addrNumber IS NULL) THEN
        _addrNumber := fetchNextNumber('AddressNumber');
      END IF;
    END IF;

    UPDATE addr SET
      addr_line1 = pAddr1, addr_line2 = pAddr2, addr_line3 = pAddr3,
      addr_city = pCity, addr_state = pState,
      addr_postalcode = pPostalcode, addr_country = pCountry,
      addr_active = pActive, addr_notes = pNotes
    WHERE addr_id = _addrId;
    RETURN _addrId;

  ELSE
    SELECT NEXTVAL('addr_addr_id_seq') INTO _addrId;

    IF (_flag = 'CHANGEONE') THEN
      _addrNumber := fetchNextNumber('AddressNumber');
    ELSE
      _addrNumber := COALESCE(pNumber::text,fetchNextNumber('AddressNumber'));
    END IF;

    INSERT INTO addr ( addr_id, addr_number,
    addr_line1, addr_line2, addr_line3,
    addr_city, addr_state, addr_postalcode, addr_country,
    addr_active, addr_notes
    ) VALUES ( _addrId, _addrNumber,
    pAddr1, pAddr2, pAddr3,
    pCity, pState, pPostalcode, pCountry,
    pActive, _notes);
    RETURN _addrId;

  END IF;
END;
$_$;


ALTER FUNCTION public.saveaddr(integer, text, text, text, text, text, text, text, text, boolean, text, text) OWNER TO admin;

--
-- TOC entry 2159 (class 1255 OID 146567007)
-- Dependencies: 4536 8
-- Name: savealarm(integer, text, date, time without time zone, integer, text, boolean, text, boolean, text, boolean, text, text, integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION savealarm(integer, text, date, time without time zone, integer, text, boolean, text, boolean, text, boolean, text, text, integer, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pAlarmId ALIAS FOR $1;
  pAlarmNumber ALIAS FOR $2;
  pDate ALIAS FOR $3;
  pTime ALIAS FOR $4;
  pOffset ALIAS FOR $5;
  pQualifier ALIAS FOR $6;
  pEvent ALIAS FOR $7;
  pEventRecipient ALIAS FOR $8;
  pEmail ALIAS FOR $9;
  pEmailRecipient ALIAS FOR $10;
  pSysmsg ALIAS FOR $11;
  pSysmsgRecipient ALIAS FOR $12;
  pSource ALIAS FOR $13;
  pSourceId ALIAS FOR $14;
  pFlag ALIAS FOR $15;
  _alarmId INTEGER;
  _alarmNumber TEXT;
  _alarmTime TIMESTAMP;
  _alarmInterval INTERVAL;
  _alarmTrigger TIMESTAMP;
  _isNew BOOLEAN;
  _flag TEXT;
  _alarmCount INTEGER := 0;
  _debug BOOLEAN := false;

BEGIN
  IF (_debug) THEN
    RAISE NOTICE 'pAlarmId = %', pAlarmId;
    RAISE NOTICE 'pAlarmNumber = %', pAlarmNumber;
    RAISE NOTICE 'pDate = %', pDate;
    RAISE NOTICE 'pTime = %', pTime;
    RAISE NOTICE 'pOffset = %', pOffset;
    RAISE NOTICE 'pQualifier = %', pQualifier;
    RAISE NOTICE 'pEvent = %', pEvent;
    RAISE NOTICE 'pEventRecipient = %', pEventRecipient;
    RAISE NOTICE 'pEmail = %', pEmail;
    RAISE NOTICE 'pEmailRecipient = %', pEmailRecipient;
    RAISE NOTICE 'pSysmsg = %', pSysmsg;
    RAISE NOTICE 'pSysmsgRecipient = %', pSysmsgRecipient;
    RAISE NOTICE 'pSource = %', pSource;
    RAISE NOTICE 'pSourceId = %', pSourceId;
    RAISE NOTICE 'pFlag = %', pFlag;
  END IF;
  --Validate
  IF ((pFlag IS NULL) OR (pFlag = '') OR (pFlag = 'CHECK') OR (pFlag = 'CHANGEONE') OR (pFlag = 'CHANGEALL')) THEN
    IF (pFlag='') THEN
      _flag := 'CHECK';
    ELSE
      _flag := COALESCE(pFlag,'CHECK');
    END IF;
  ELSE
	RAISE EXCEPTION 'Invalid Flag (%). Valid flags are CHECK, CHANGEONE or CHANGEALL', pFlag;
  END IF;

  --If there is nothing here get out
  IF ( (pAlarmId IS NULL OR pAlarmId = -1)
	AND (pOffset IS NULL)
        AND (pSourceId IS NULL)
	AND (COALESCE(pQualifier, '') = '')
	AND (COALESCE(pEventRecipient, '') = '')
	AND (COALESCE(pEmailRecipient, '') = '')
	AND (COALESCE(pSysmsgRecipient, '') = '')
	AND (COALESCE(pSource, '') = '') ) THEN

	RETURN NULL;

  END IF;

  IF (pAlarmId IS NULL OR pAlarmId = -1) THEN
    _isNew := true;
    _alarmId := nextval('alarm_alarm_id_seq');
    _alarmNumber := fetchNextNumber('AlarmNumber');
  ELSE
    SELECT COUNT(alarm_id) INTO _alarmCount
      FROM alarm
      WHERE ((alarm_id=pAlarmId)
      AND (alarm_source=pSource)
      AND (alarm_source_id=pSourceId));

    -- ask whether new or update if name changes
    -- but only if this isn't a new record with a pre-allocated id
    IF (_alarmCount < 1 AND _flag = 'CHECK') THEN
      IF (EXISTS(SELECT alarm_id
                 FROM alarm
                 WHERE (alarm_id=pAlarmId))) THEN
        RETURN -10;
      ELSE
        _isNew := true;
        _alarmNumber := fetchNextNumber('AlarmNumber');
      END IF;
    ELSIF (_flag = 'CHANGEONE') THEN
      _isNew := true;
      _alarmId := nextval('alarm_alarm_id_seq');
      _alarmNumber := fetchNextNumber('AlarmNumber');
    END IF;
  END IF;

  _alarmNumber := COALESCE(_alarmNumber,pAlarmNumber,fetchNextNumber('AlarmNumber'));

  _alarmTime := COALESCE(pDate, CURRENT_DATE) + COALESCE(pTime, CURRENT_TIME);
  IF (COALESCE(pOffset, 0) > 0) THEN
    _alarmInterval := CASE WHEN (pQualifier IN ('MB', 'MA')) THEN CAST(pOffset AS TEXT) || ' minutes'
                           WHEN (pQualifier IN ('HB', 'HA')) THEN CAST(pOffset AS TEXT) || ' hours'
                           WHEN (pQualifier IN ('DB', 'DA')) THEN CAST(pOffset AS TEXT) || ' days'
                           ELSE ''
                     END;
    _alarmTrigger := CASE WHEN (pQualifier IN ('MB', 'HB', 'DB')) THEN _alarmTime - _alarmInterval
                          WHEN (pQualifier IN ('MA', 'HA', 'DA')) THEN _alarmTime + _alarmInterval
                          ELSE _alarmTime
                     END;
  ELSE
    _alarmTrigger := _alarmTime;
  END IF;

  IF (_isNew) THEN
    _alarmId := COALESCE(_alarmId,pAlarmId,nextval('alarm_alarm_id_seq'));

    INSERT INTO alarm (
      alarm_id,alarm_number,
      alarm_event, alarm_email, alarm_sysmsg, alarm_trigger,
      alarm_time, alarm_time_offset, alarm_time_qualifier,
      alarm_creator, alarm_event_recipient, alarm_email_recipient, alarm_sysmsg_recipient,
      alarm_source, alarm_source_id )
    VALUES (
      _alarmId, _alarmNumber,
      pEvent, pEmail, pSysmsg, _alarmTrigger,
      _alarmTime, pOffset, pQualifier,
      getEffectiveXtUser(), pEventRecipient, pEmailRecipient, pSysmsgRecipient,
      pSource, pSourceId );

    RETURN _alarmId;

  ELSE
    UPDATE alarm SET
      alarm_number=_alarmNumber,
      alarm_event=COALESCE(pEvent, alarm_event),
      alarm_email=COALESCE(pEmail, alarm_event),
      alarm_sysmsg=COALESCE(pSysmsg, alarm_event),
      alarm_trigger=_alarmTrigger,
      alarm_time=_alarmTime,
      alarm_time_offset=COALESCE(pOffset, alarm_time_offset),
      alarm_time_qualifier=COALESCE(pQualifier, alarm_time_qualifier),
      alarm_event_recipient=COALESCE(pEventRecipient, alarm_event_recipient),
      alarm_email_recipient=COALESCE(pEmailRecipient, alarm_email_recipient),
      alarm_sysmsg_recipient=COALESCE(pSysmsgRecipient, alarm_sysmsg_recipient)
    WHERE (alarm_id=pAlarmId);

    RETURN pAlarmId;

  END IF;
END;
$_$;


ALTER FUNCTION public.savealarm(integer, text, date, time without time zone, integer, text, boolean, text, boolean, text, boolean, text, text, integer, text) OWNER TO admin;

--
-- TOC entry 2160 (class 1255 OID 146567009)
-- Dependencies: 4536 8
-- Name: savebomhead(integer, text, date, text, numeric, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION savebomhead(integer, text, date, text, numeric, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pRevision ALIAS FOR $2;
  pRevisionDate ALIAS FOR $3;
  pDocumentNumber ALIAS FOR $4;
  pBatchSize ALIAS FOR $5;
  pRequiredQtyPer ALIAS FOR $6;
  _seq INTEGER;
  _p RECORD;
  _revid INTEGER;

BEGIN

  IF (NOT fetchMetricBool('RevControl')) THEN -- Deal with BOM if Rev Control Turned off
    SELECT bomhead_id INTO _seq
    FROM bomhead
    WHERE (bomhead_item_id=pItemid);

    IF (NOT FOUND) THEN  -- No bomhead exists
      _seq := NEXTVAL('bomhead_bomhead_id_seq');

      INSERT INTO bomhead
        (bomhead_id,bomhead_item_id,bomhead_docnum,bomhead_revision,
        bomhead_revisiondate,bomhead_batchsize,bomhead_requiredqtyper,bomhead_rev_id)
        VALUES
        (_seq,pItemid, pDocumentNumber, pRevision, pRevisionDate, pBatchSize, pRequiredQtyPer,-1);
    ELSE
      UPDATE bomhead SET
        bomhead_revision	= pRevision,
        bomhead_revisiondate	= pRevisionDate,
        bomhead_docnum		= pDocumentNumber,
        bomhead_batchsize	= pBatchSize,
        bomhead_requiredqtyper = pRequiredQtyPer
      WHERE (bomhead_id=_seq);
    END IF;

    RETURN _seq;
  ELSE  -- Deal with Revision Control
    IF (COALESCE(pRevision,'') = '' AND getActiveRevId('BOM',pItemid) != -1) THEN
        RAISE EXCEPTION 'Revision Control records exist for item.  You must provide a new or existing revision number.';
    END IF;

    SELECT * INTO _p
    FROM bomhead
      LEFT OUTER JOIN rev ON (bomhead_rev_id=rev_id),
      item
    WHERE ((bomhead_item_id=pItemid)
    AND (COALESCE(bomhead_revision,'')=COALESCE(pRevision,''))
    AND (bomhead_item_id=item_id));

    IF (NOT FOUND) THEN  -- This is a new bomhead record
      IF LENGTH(pRevision) > 0 THEN  -- We need to create a revision record
        SELECT createbomrev(pItemid, pRevision) INTO _revid;

        UPDATE bomhead SET
          bomhead_revisiondate		= pRevisiondate,
          bomhead_docnum		= pDocumentNumber,
          bomhead_batchsize		= pBatchsize,
          bomhead_requiredqtyper	= pRequiredqtyper
        WHERE (bomhead_rev_id=_revid);

        SELECT bomhead_id INTO _seq
        FROM bomhead
        WHERE (bomhead_rev_id=_revid);

        RETURN _seq;
      ELSE  -- Just create a regular bom header record
       _seq := NEXTVAL('bomhead_bomhead_id_seq');

       INSERT INTO bomhead
        (bomhead_id,bomhead_item_id,bomhead_docnum,bomhead_revision,
        bomhead_revisiondate,bomhead_batchsize,bomhead_requiredqtyper,bomhead_rev_id)
        VALUES
        (_seq,pItemid, pDocumentNumber, pRevision, pRevisionDate, pBatchSize, pRequiredQtyPer,-1);

        RETURN _seq;

      END IF;
    ELSE  -- We need to update a record
      IF (_p.rev_status = 'I') THEN
        RAISE EXCEPTION 'Revision % for % is inactive.  Update not allowed.', _p.rev_number, _p.item_number;

      ELSIF (COALESCE(pRevision,'') = COALESCE(_p.bomhead_revision,'')) THEN  -- No change, just update
        UPDATE bomhead SET
          bomhead_revisiondate		= pRevisiondate,
          bomhead_docnum		= pDocumentNumber,
          bomhead_batchsize		= pBatchSize,
          bomhead_requiredqtyper	= pRequiredqtyper
        WHERE (bomhead_id=_p.bomhead_id);

        RETURN _p.bomhead_id;

      ELSE -- Need a new revision
        SELECT createbomrev(pItemid, pRevision) INTO _revid;

        UPDATE bomhead SET
          bomhead_revisiondate		= pRevisiondate,
          bomhead_docnum		= pDocumentNumber,
          bomhead_batchsize		= pBatchSize,
          bomhead_requiredqtyper	= pRequiredqtyper
        WHERE (bomhead_rev_id=_revid);

        SELECT bomhead_id INTO _seq
        FROM bomhead
        WHERE (bomhead_rev_id=_revid);

        RETURN _seq;
      END IF;
    END IF;
  END IF;

  RETURN _seq;

END;
$_$;


ALTER FUNCTION public.savebomhead(integer, text, date, text, numeric, numeric) OWNER TO admin;

--
-- TOC entry 2162 (class 1255 OID 146567011)
-- Dependencies: 4536 8
-- Name: savecntct(integer, text, integer, text, text, text, text, text, text, text, text, text, text, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION savecntct(pcntctid integer, pcontactnumber text, paddrid integer, phonorific text, pfirstname text, pmiddlename text, plastname text, psuffix text, pphone text, pphone2 text, pfax text, pemail text, pwebaddr text, ptitle text, pflag text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;

BEGIN

  SELECT saveCntct(pCntctId,pContactNumber,NULL,pAddrId,pHonorific,pFirstName,pMiddleName,pLastName,pSuffix,NULL,
        NULL,pPhone,pPhone2,pFax,pEmail,pWebAddr,NULL,pTitle,pFlag, NULL) INTO _returnVal;

  RETURN _returnVal;

END;
$$;


ALTER FUNCTION public.savecntct(pcntctid integer, pcontactnumber text, paddrid integer, phonorific text, pfirstname text, pmiddlename text, plastname text, psuffix text, pphone text, pphone2 text, pfax text, pemail text, pwebaddr text, ptitle text, pflag text) OWNER TO admin;

--
-- TOC entry 2161 (class 1255 OID 146567010)
-- Dependencies: 4536 8
-- Name: savecntct(integer, text, integer, integer, text, text, text, text, text, text, boolean, text, text, text, text, text, text, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION savecntct(pcntctid integer, pcontactnumber text, pcrmacctid integer, paddrid integer, phonorific text, pfirstname text, pmiddlename text, plastname text, psuffix text, pinitials text, pactive boolean, pphone text, pphone2 text, pfax text, pemail text, pwebaddr text, pnotes text, ptitle text, pflag text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _returnVal INTEGER;

BEGIN

  SELECT saveCntct( pCntctId, pContactNumber, pCrmAcctId, pAddrId, pHonorific, pFirstName, pMiddleName, pLastName, pSuffix, pInitials,
	pActive, pPhone, pPhone2, pFax, pEmail, pWebAddr, pNotes, pTitle, pFlag, NULL) INTO _returnVal;
  RETURN _returnVal;

END;
$$;


ALTER FUNCTION public.savecntct(pcntctid integer, pcontactnumber text, pcrmacctid integer, paddrid integer, phonorific text, pfirstname text, pmiddlename text, plastname text, psuffix text, pinitials text, pactive boolean, pphone text, pphone2 text, pfax text, pemail text, pwebaddr text, pnotes text, ptitle text, pflag text) OWNER TO admin;

--
-- TOC entry 2163 (class 1255 OID 146567012)
-- Dependencies: 4536 8
-- Name: savecntct(integer, text, integer, integer, text, text, text, text, text, text, boolean, text, text, text, text, text, text, text, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION savecntct(pcntctid integer, pcontactnumber text, pcrmacctid integer, paddrid integer, phonorific text, pfirstname text, pmiddlename text, plastname text, psuffix text, pinitials text, pactive boolean, pphone text, pphone2 text, pfax text, pemail text, pwebaddr text, pnotes text, ptitle text, pflag text, pownerusername text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _cntctId INTEGER;
  _cntctNumber TEXT;
  _isNew BOOLEAN;
  _flag TEXT;
  _contactCount INTEGER := 0;

BEGIN
  --Validate
  IF ((pFlag IS NULL) OR (pFlag = '') OR (pFlag = 'CHECK') OR (pFlag = 'CHANGEONE') OR (pFlag = 'CHANGEALL')) THEN
    IF (pFlag='') THEN
      _flag := 'CHECK';
    ELSE
      _flag := COALESCE(pFlag,'CHECK');
    END IF;
  ELSE
	RAISE EXCEPTION 'Invalid Flag (%). Valid flags are CHECK, CHANGEONE or CHANGEALL', pFlag;
  END IF;

  --If there is nothing here get out
  IF ( (pCntctId IS NULL OR pCntctId = -1)
	AND (pAddrId IS NULL)
	AND (COALESCE(pFirstName, '') = '')
	AND (COALESCE(pMiddleName, '') = '')
	AND (COALESCE(pLastName, '') = '')
	AND (COALESCE(pSuffix, '') = '')
	AND (COALESCE(pHonorific, '') = '')
	AND (COALESCE(pInitials, '') = '')
	AND (COALESCE(pPhone, '') = '')
	AND (COALESCE(pPhone2, '') = '')
	AND (COALESCE(pFax, '') = '')
	AND (COALESCE(pEmail, '') = '')
	AND (COALESCE(pWebAddr, '') = '')
	AND (COALESCE(pNotes, '') = '')
	AND (COALESCE(pTitle, '') = '') ) THEN

	RETURN NULL;

  END IF;

  IF (pCntctId IS NULL OR pCntctId = -1) THEN
    _isNew := true;
    _cntctId := nextval('cntct_cntct_id_seq');
    _cntctNumber := COALESCE(pContactNumber,fetchNextNumber('ContactNumber'));
  ELSE
    SELECT COUNT(cntct_id) INTO _contactCount
      FROM cntct
      WHERE ((cntct_id=pCntctId)
      AND (cntct_first_name=pFirstName)
      AND (cntct_last_name=pLastName));

    -- ask whether new or update if name changes
    -- but only if this isn't a new record with a pre-allocated id
    IF (_contactCount < 1 AND _flag = 'CHECK') THEN
      IF (EXISTS(SELECT cntct_id
                 FROM cntct
                 WHERE (cntct_id=pCntctId))) THEN
        RETURN -10;
      ELSE
        _isNew := true;
        _cntctNumber := fetchNextNumber('ContactNumber');
      END IF;
    ELSIF (_flag = 'CHANGEONE') THEN
      _isNew := true;
      _cntctId := nextval('cntct_cntct_id_seq');
      _cntctNumber := fetchNextNumber('ContactNumber');
    ELSIF (_flag = 'CHANGEALL') THEN
      _isNew := false;
    END IF;
  END IF;

  IF (pContactNumber = '') THEN
    _cntctNumber := fetchNextNumber('ContactNumber');
  ELSE
    _cntctNumber := COALESCE(_cntctNumber,pContactNumber,fetchNextNumber('ContactNumber'));
  END IF;

  IF (_isNew) THEN
    _cntctId := COALESCE(_cntctId,pCntctId,nextval('cntct_cntct_id_seq'));

    INSERT INTO cntct (
      cntct_id,cntct_number,
      cntct_crmacct_id,cntct_addr_id,cntct_first_name,
      cntct_last_name,cntct_honorific,cntct_initials,
      cntct_active,cntct_phone,cntct_phone2,
      cntct_fax,cntct_email,cntct_webaddr,
      cntct_notes,cntct_title,cntct_middle,cntct_suffix, cntct_owner_username )
    VALUES (
      _cntctId, COALESCE(_cntctNumber,fetchNextNumber('ContactNumber')) ,pCrmAcctId,pAddrId,
      pFirstName,pLastName,pHonorific,
      pInitials,COALESCE(pActive,true),pPhone,pPhone2,pFax,
      pEmail,pWebAddr,pNotes,pTitle,pMiddleName,pSuffix,pOwnerUsername );

    RETURN _cntctId;

  ELSE
    UPDATE cntct SET
      cntct_number=COALESCE(_cntctNumber,fetchNextNumber('ContactNumber')),
      cntct_crmacct_id=COALESCE(pCrmAcctId,cntct_crmacct_id),
      cntct_addr_id=COALESCE(pAddrId,cntct_addr_id),
      cntct_first_name=COALESCE(pFirstName,cntct_first_name),
      cntct_last_name=COALESCE(pLastName,cntct_last_name),
      cntct_honorific=COALESCE(pHonorific,cntct_honorific),
      cntct_initials=COALESCE(pInitials,cntct_initials),
      cntct_active=COALESCE(pActive,cntct_active),
      cntct_phone=COALESCE(pPhone,cntct_phone),
      cntct_phone2=COALESCE(pPhone2,cntct_phone2),
      cntct_fax=COALESCE(pFax,cntct_fax),
      cntct_email=COALESCE(pEmail,cntct_email),
      cntct_webaddr=COALESCE(pWebAddr,cntct_webaddr),
      cntct_notes=COALESCE(pNotes,cntct_notes),
      cntct_title=COALESCE(pTitle,cntct_title),
      cntct_middle=COALESCE(pMiddleName,cntct_middle),
      cntct_suffix=COALESCE(pSuffix,cntct_suffix),
      cntct_owner_username=COALESCE(pOwnerUsername, cntct_owner_username)
    WHERE (cntct_id=pCntctId);

    RETURN pCntctId;

  END IF;
END;
$$;


ALTER FUNCTION public.savecntct(pcntctid integer, pcontactnumber text, pcrmacctid integer, paddrid integer, phonorific text, pfirstname text, pmiddlename text, plastname text, psuffix text, pinitials text, pactive boolean, pphone text, pphone2 text, pfax text, pemail text, pwebaddr text, pnotes text, ptitle text, pflag text, pownerusername text) OWNER TO admin;

--
-- TOC entry 2165 (class 1255 OID 146567014)
-- Dependencies: 4536 8
-- Name: saveimageass(text, integer, character, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION saveimageass(text, integer, character, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSource 	ALIAS FOR $1;
  pSourceId 	ALIAS FOR $2;
  pPurpose 	ALIAS FOR $3;
  pImageid 	ALIAS FOR $4;
  _imageassId INTEGER = 0;

BEGIN

--  See if this link already exists
  SELECT imageass_id INTO _imageassId
  FROM imageass
  WHERE ((imageass_source_id=pSourceId)
  AND (imageass_source=pSource)
  AND (imageass_image_id=pImageId)
  AND (imageass_purpose=pPurpose));

  IF (FOUND) THEN
    RETURN _imageassId;
  END IF;

-- See if a record with this purpose already exists (item only)
  IF (pSource = 'I' AND pPurpose != 'M') THEN
    SELECT imageass_id INTO _imageassId
    FROM imageass
    WHERE ((imageass_source_id=pSourceId)
    AND (imageass_source=pSource)
    AND (imageass_purpose=pPurpose));
  END IF;

  IF (_imageassId > 0) THEN
    UPDATE imageass SET
      imageass_image_id=pImageId
    WHERE (imageass_id=_imageassId);
  ELSE
    _imageassId := NEXTVAL('imageass_imageass_id_seq');
    INSERT INTO imageass VALUES (_imageassId,pSourceId,pSource,pImageid,CASE WHEN pSource='I' THEN pPurpose ELSE 'M' END);
  END IF;

  RETURN _imageassId;
END;
$_$;


ALTER FUNCTION public.saveimageass(text, integer, character, integer) OWNER TO admin;

--
-- TOC entry 2166 (class 1255 OID 146567015)
-- Dependencies: 4536 8
-- Name: saveipsitem(integer, integer, integer, numeric, numeric, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION saveipsitem(integer, integer, integer, numeric, numeric, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2012 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pIpsItemId	ALIAS FOR $1;
  pIpsHeadId	ALIAS FOR $2;
  pItemId	ALIAS FOR $3;
  pQtyBreak	ALIAS FOR $4;
  pPrice	ALIAS FOR $5;
  pQtyUomId	ALIAS FOR $6;
  pPriceUomId	ALIAS FOR $7;
  _ipsitemid	INTEGER;
  _new		BOOLEAN;
BEGIN

  -- Validation
  IF (SELECT COUNT(item_id)=0 FROM item WHERE (item_id=pItemId)) THEN
    RAISE EXCEPTION 'You must provide a valid Item';
  ELSIF (COALESCE(pQtyBreak,0) < 0) THEN
    RAISE EXCEPTION 'Quantity can not be a negative value';
  ELSIF (COALESCE(pPrice,0) < 0) THEN
    RAISE EXCEPTION 'Price must be a negative value';
  ELSIF ((pQtyUomId IS NOT NULL) AND (SELECT COUNT(item_id)=0 FROM
        (SELECT item_id
         FROM item
         WHERE ((item_id=pItemId)
           AND (item_inv_uom_id=pQtyUomId))
         UNION
         SELECT item_id
         FROM item,itemuomconv,itemuom,uomtype
         WHERE ((item_id=pItemId)
           AND (itemuomconv_item_id=item_id)
           AND (itemuomconv_from_uom_id=pQtyUomId)
           AND (itemuom_itemuomconv_id=itemuomconv_id)
           AND (itemuom_uomtype_id=uomtype_id)
           AND (uomtype_name='Selling'))
         UNION
         SELECT item_id
         FROM item,itemuomconv,itemuom,uomtype
         WHERE ((item_id=pItemId)
           AND (itemuomconv_item_id=item_id)
           AND (itemuomconv_to_uom_id=pQtyUomId)
           AND (itemuom_itemuomconv_id=itemuomconv_id)
           AND (itemuom_uomtype_id=uomtype_id)
           AND (uomtype_name='Selling'))) AS data)) THEN
    RAISE EXCEPTION 'Qty UOM Must be a valid Selling UOM for the Item';
  ELSIF ((pPriceUomId IS NOT NULL) AND (SELECT COUNT(item_id)=0 FROM
        (SELECT item_id
         FROM item
         WHERE ((item_id=pItemId)
           AND (item_inv_uom_id=pPriceUomId))
         UNION
         SELECT item_id
         FROM item,itemuomconv,itemuom,uomtype
         WHERE ((item_id=pItemId)
           AND (itemuomconv_item_id=item_id)
           AND (itemuomconv_from_uom_id=pPriceUomId)
           AND (itemuom_itemuomconv_id=itemuomconv_id)
           AND (itemuom_uomtype_id=uomtype_id)
           AND (uomtype_name='Selling'))
         UNION
         SELECT item_id
         FROM item,itemuomconv,itemuom,uomtype
         WHERE ((item_id=pItemId)
           AND (itemuomconv_item_id=item_id)
           AND (itemuomconv_to_uom_id=pPriceUomId)
           AND (itemuom_itemuomconv_id=itemuomconv_id)
           AND (itemuom_uomtype_id=uomtype_id)
           AND (uomtype_name='Selling'))) AS data)) THEN
    RAISE EXCEPTION 'Price UOM Must be a valid Selling UOM for the Item';
  END IF;

  _new := TRUE;

  IF (pIpsItemId IS NOT NULL) THEN
    SELECT ipsitem_id INTO _ipsitemid
    FROM ipsitem
    WHERE (ipsitem_id=pIpsItemId);

    IF (FOUND) THEN
      _new := FALSE;
    ELSE
      RAISE EXCEPTION 'Pricing Schedule Item not found.';
    END IF;
  ELSE
    SELECT ipsitem_id INTO _ipsitemid
    FROM ipsitem
    WHERE ((ipsitem_ipshead_id	= pIpsheadId)
      AND (ipsitem_item_id 	= pItemId)
      AND (ipsitem_qtybreak 	= pQtyBreak)
      AND (ipsitem_qty_uom_id = COALESCE(pQtyUomId,(SELECT item_inv_uom_id FROM item WHERE item_id = pItemId)))
      AND (ipsitem_price_uom_id =
           CASE
             WHEN (pQtyUomId = (SELECT item_inv_uom_id FROM item WHERE item_id = pItemId)) THEN
               COALESCE(pPriceUomId,pQtyUomId,(SELECT item_inv_uom_id FROM item WHERE item_id = pItemId))
             ELSE
               COALESCE(pQtyUomId,(SELECT item_inv_uom_id FROM item WHERE item_id = pItemId))
           END));
  END IF;

  IF (FOUND) THEN
    _new := false;
  ELSE
    _ipsitemid := nextval('ipsitem_ipsitem_id_seq');
  END IF;

  IF (_new) THEN
    INSERT INTO ipsitem (
      ipsitem_id,
      ipsitem_ipshead_id,
      ipsitem_item_id,
      ipsitem_qtybreak,
      ipsitem_price,
      ipsitem_qty_uom_id,
      ipsitem_price_uom_id,
      ipsitem_discntprcnt,
      ipsitem_fixedamtdiscount)
    VALUES (
      _ipsitemid,
      pIpsheadId,
      pItemId,
      pQtyBreak,
      pPrice,
      COALESCE(pQtyUomId,(SELECT item_inv_uom_id FROM item WHERE item_id = pItemId)),
      CASE
        WHEN (pQtyUomId = (SELECT item_inv_uom_id FROM item WHERE item_id = pItemId)) THEN
          COALESCE(pPriceUomId,pQtyUomId,(SELECT item_inv_uom_id FROM item WHERE item_id = pItemId))
        ELSE
          COALESCE(pQtyUomId,(SELECT item_inv_uom_id FROM item WHERE item_id = pItemId))
      END,
      0.0,
      0.0);
  ELSE
    UPDATE ipsitem SET
      ipsitem_qtybreak = pQtyBreak,
      ipsitem_price = pPrice,
      ipsitem_qty_uom_id = COALESCE(pQtyUomId,(SELECT item_inv_uom_id FROM item WHERE item_id = pItemId)),
      ipsitem_price_uom_id =
      CASE
        WHEN (pQtyUomId = (SELECT item_inv_uom_id FROM item WHERE item_id = pItemId)) THEN
          COALESCE(pPriceUomId,pQtyUomId,(SELECT item_inv_uom_id FROM item WHERE item_id = pItemId))
        ELSE
          COALESCE(pQtyUomId,(SELECT item_inv_uom_id FROM item WHERE item_id = pItemId))
      END
    WHERE (ipsitem_id=_ipsitemid);
   END IF;

   RETURN _ipsitemid;

END;
$_$;


ALTER FUNCTION public.saveipsitem(integer, integer, integer, numeric, numeric, integer, integer) OWNER TO admin;

--
-- TOC entry 2167 (class 1255 OID 146567016)
-- Dependencies: 4536 8
-- Name: saveipsitem(integer, integer, integer, numeric, numeric, integer, integer, numeric, numeric, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION saveipsitem(pipsitemid integer, pipsheadid integer, pitemid integer, pqtybreak numeric, pprice numeric, pqtyuomid integer, ppriceuomid integer, ppercent numeric, pfixedamt numeric, ptype text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _ipsitemid	INTEGER;
  _new		BOOLEAN;
BEGIN

  -- Validation
  IF (SELECT COUNT(item_id)=0 FROM item WHERE (item_id=pItemId)) THEN
    RAISE EXCEPTION 'You must provide a valid Item';
  ELSIF (COALESCE(pQtyBreak,0) < 0) THEN
    RAISE EXCEPTION 'Quantity can not be a negative value';
  ELSIF (COALESCE(pPrice,0) < 0) THEN
    RAISE EXCEPTION 'Price must be a negative value';
  ELSIF ((pQtyUomId IS NOT NULL) AND (SELECT COUNT(item_id)=0 FROM
        (SELECT item_id
         FROM item
         WHERE ((item_id=pItemId)
           AND (item_inv_uom_id=pQtyUomId))
         UNION
         SELECT item_id
         FROM item,itemuomconv,itemuom,uomtype
         WHERE ((item_id=pItemId)
           AND (itemuomconv_item_id=item_id)
           AND (itemuomconv_from_uom_id=pQtyUomId)
           AND (itemuom_itemuomconv_id=itemuomconv_id)
           AND (itemuom_uomtype_id=uomtype_id)
           AND (uomtype_name='Selling'))
         UNION
         SELECT item_id
         FROM item,itemuomconv,itemuom,uomtype
         WHERE ((item_id=pItemId)
           AND (itemuomconv_item_id=item_id)
           AND (itemuomconv_to_uom_id=pQtyUomId)
           AND (itemuom_itemuomconv_id=itemuomconv_id)
           AND (itemuom_uomtype_id=uomtype_id)
           AND (uomtype_name='Selling'))) AS data)) THEN
    RAISE EXCEPTION 'Qty UOM Must be a valid Selling UOM for the Item';
  ELSIF ((pPriceUomId IS NOT NULL) AND (SELECT COUNT(item_id)=0 FROM
        (SELECT item_id
         FROM item
         WHERE ((item_id=pItemId)
           AND (item_inv_uom_id=pPriceUomId))
         UNION
         SELECT item_id
         FROM item,itemuomconv,itemuom,uomtype
         WHERE ((item_id=pItemId)
           AND (itemuomconv_item_id=item_id)
           AND (itemuomconv_from_uom_id=pPriceUomId)
           AND (itemuom_itemuomconv_id=itemuomconv_id)
           AND (itemuom_uomtype_id=uomtype_id)
           AND (uomtype_name='Selling'))
         UNION
         SELECT item_id
         FROM item,itemuomconv,itemuom,uomtype
         WHERE ((item_id=pItemId)
           AND (itemuomconv_item_id=item_id)
           AND (itemuomconv_to_uom_id=pPriceUomId)
           AND (itemuom_itemuomconv_id=itemuomconv_id)
           AND (itemuom_uomtype_id=uomtype_id)
           AND (uomtype_name='Selling'))) AS data)) THEN
    RAISE EXCEPTION 'Price UOM Must be a valid Selling UOM for the Item';
  END IF;

  _new := TRUE;

  IF (pIpsItemId IS NOT NULL) THEN
    SELECT ipsitem_id INTO _ipsitemid
    FROM ipsiteminfo
    WHERE (ipsitem_id=pIpsItemId);

    IF (FOUND) THEN
      _new := FALSE;
    ELSE
      RAISE EXCEPTION 'Pricing Schedule Item not found.';
    END IF;
  ELSE
    SELECT ipsitem_id INTO _ipsitemid
    FROM ipsiteminfo
    WHERE ((ipsitem_ipshead_id	= pIpsheadId)
      AND (ipsitem_item_id 	= pItemId)
      AND (ipsitem_qtybreak 	= pQtyBreak)
      AND (ipsitem_qty_uom_id = COALESCE(pQtyUomId,(SELECT item_inv_uom_id FROM item WHERE item_id = pItemId)))
      AND (ipsitem_price_uom_id =
           CASE
             WHEN (pQtyUomId = (SELECT item_inv_uom_id FROM item WHERE item_id = pItemId)) THEN
               COALESCE(pPriceUomId,pQtyUomId,(SELECT item_inv_uom_id FROM item WHERE item_id = pItemId))
             ELSE
               COALESCE(pQtyUomId,(SELECT item_inv_uom_id FROM item WHERE item_id = pItemId))
           END));
  END IF;

  IF (FOUND) THEN
    _new := false;
  END IF;

  IF (_new) THEN
    INSERT INTO ipsiteminfo (
      ipsitem_ipshead_id,
      ipsitem_item_id,
      ipsitem_qtybreak,
      ipsitem_price,
      ipsitem_qty_uom_id,
      ipsitem_price_uom_id,
      ipsitem_discntprcnt,
      ipsitem_fixedamtdiscount,
      ipsitem_type)
    VALUES (
      pIpsheadId,
      pItemId,
      pQtyBreak,
      pPrice,
      COALESCE(pQtyUomId,(SELECT item_inv_uom_id FROM item WHERE item_id = pItemId)),
      CASE
        WHEN (pQtyUomId = (SELECT item_inv_uom_id FROM item WHERE item_id = pItemId)) THEN
          COALESCE(pPriceUomId,pQtyUomId,(SELECT item_inv_uom_id FROM item WHERE item_id = pItemId))
        ELSE
          COALESCE(pQtyUomId,(SELECT item_inv_uom_id FROM item WHERE item_id = pItemId))
      END,
      pPercent,
      pFixedAmt,
      pType)
    RETURNING ipsitem_id INTO _ipsitemid;
  ELSE
    UPDATE ipsiteminfo SET
      ipsitem_qtybreak = pQtyBreak,
      ipsitem_price = pPrice,
      ipsitem_qty_uom_id = COALESCE(pQtyUomId,(SELECT item_inv_uom_id FROM item WHERE item_id = pItemId)),
      ipsitem_price_uom_id =
      CASE
        WHEN (pQtyUomId = (SELECT item_inv_uom_id FROM item WHERE item_id = pItemId)) THEN
          COALESCE(pPriceUomId,pQtyUomId,(SELECT item_inv_uom_id FROM item WHERE item_id = pItemId))
        ELSE
          COALESCE(pQtyUomId,(SELECT item_inv_uom_id FROM item WHERE item_id = pItemId))
      END,
      ipsitem_discntprcnt=pPercent,
      ipsitem_fixedamtdiscount=pFixedAmt,
      ipsitem_type=pType
    WHERE (ipsitem_id=_ipsitemid);
   END IF;

   RETURN _ipsitemid;

END;
$$;


ALTER FUNCTION public.saveipsitem(pipsitemid integer, pipsheadid integer, pitemid integer, pqtybreak numeric, pprice numeric, pqtyuomid integer, ppriceuomid integer, ppercent numeric, pfixedamt numeric, ptype text) OWNER TO admin;

--
-- TOC entry 2168 (class 1255 OID 146567017)
-- Dependencies: 4536 8
-- Name: saveipsprodcat(integer, integer, integer, numeric, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION saveipsprodcat(integer, integer, integer, numeric, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
DECLARE
  pIpsProdcatId	ALIAS FOR $1;
  pIpsHeadId	ALIAS FOR $2;
  pProdCatId	ALIAS FOR $3;
  pQtyBreak	ALIAS FOR $4;
  pDiscount	ALIAS FOR $5;
  _ipsprodcatid	INTEGER;
  _new		BOOLEAN;

BEGIN

  -- Validation
  IF (SELECT COUNT(*)=0 FROM prodcat WHERE (prodcat_id=pProdcatId)) THEN
    RAISE EXCEPTION 'You must provide a valid Product Category';
  ELSIF (COALESCE(pQtyBreak,0) < 0) THEN
    RAISE EXCEPTION 'Quantity can not be a negative value';
  ELSIF (COALESCE(pDiscount,0) < 0) THEN
    RAISE EXCEPTION 'Discount must be a negative value';
  END IF;

  _new := TRUE;

  IF (pIpsProdcatId IS NOT NULL) THEN
    SELECT ipsprodcat_id INTO _ipsprodcatid
    FROM ipsprodcat
    WHERE (ipsprodcat_id=pIpsprodcatId);

    IF (FOUND) THEN
      _new := FALSE;
    ELSE
      RAISE EXCEPTION 'Pricing Schedule Product Category not found';
    END IF;
  ELSE
    SELECT ipsprodcat_id INTO _ipsprodcatid
    FROM ipsprodcat
    WHERE ((ipsprodcat_ipshead_id=pIpsheadId)
      AND (ipsprodcat_prodcat_id=pProdcatId)
      AND (ipsprodcat_qtybreak=pQtyBreak));

    IF (FOUND) THEN
      _new := false;
    ELSE
      _ipsprodcatid := nextval('ipsprodcat_ipsprodcat_id_seq');
    END IF;
  END IF;

  IF (_new) THEN
    INSERT INTO ipsprodcat (
      ipsprodcat_id,
      ipsprodcat_ipshead_id,
      ipsprodcat_prodcat_id,
      ipsprodcat_qtybreak,
      ipsprodcat_discntprcnt)
    VALUES (
      _ipsprodcatid,
      pIpsheadId,
      pProdcatId,
      pQtyBreak,
      pDiscount * .01);
  ELSE
    UPDATE ipsprodcat SET
      ipsprodcat_qtybreak = pQtyBreak,
      ipsprodcat_discntprcnt = pDiscount * .01
    WHERE (ipsprodcat_id=_ipsprodcatid);
  END IF;

  RETURN _ipsprodcatid;
END;
$_$;


ALTER FUNCTION public.saveipsprodcat(integer, integer, integer, numeric, numeric) OWNER TO admin;

--
-- TOC entry 2169 (class 1255 OID 146567018)
-- Dependencies: 4536 8
-- Name: saveipsprodcat(integer, integer, integer, numeric, numeric, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION saveipsprodcat(integer, integer, integer, numeric, numeric, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2012 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pIpsProdcatId	    ALIAS FOR $1;
  pIpsHeadId	    ALIAS FOR $2;
  pProdCatId	    ALIAS FOR $3;
  pQtyBreak	    ALIAS FOR $4;
  pDiscount	    ALIAS FOR $5;
  pFixedAmtDiscount ALIAS FOR $6;
  _ipsprodcatid	INTEGER;
  _new		BOOLEAN;

BEGIN

  -- Validation
  IF (SELECT COUNT(*)=0 FROM prodcat WHERE (prodcat_id=pProdcatId)) THEN
    RAISE EXCEPTION 'You must provide a valid Product Category';
  ELSIF (COALESCE(pQtyBreak,0) < 0) THEN
    RAISE EXCEPTION 'Quantity can not be a negative value';
  ELSIF (COALESCE(pDiscount,0) < 0) THEN
    RAISE EXCEPTION 'Discount must be a negative value';
  END IF;

  _new := TRUE;

  IF (pIpsProdcatId IS NOT NULL) THEN
    SELECT ipsprodcat_id INTO _ipsprodcatid
    FROM ipsprodcat
    WHERE (ipsprodcat_id=pIpsprodcatId);

    IF (FOUND) THEN
      _new := FALSE;
    ELSE
      RAISE EXCEPTION 'Pricing Schedule Product Category not found';
    END IF;
  ELSE
    SELECT ipsprodcat_id INTO _ipsprodcatid
    FROM ipsprodcat
    WHERE ((ipsprodcat_ipshead_id=pIpsheadId)
      AND (ipsprodcat_prodcat_id=pProdcatId)
      AND (ipsprodcat_qtybreak=pQtyBreak));

    IF (FOUND) THEN
      _new := false;
    ELSE
      _ipsprodcatid := nextval('ipsprodcat_ipsprodcat_id_seq');
    END IF;
  END IF;

  IF (_new) THEN
    INSERT INTO ipsprodcat (
      ipsprodcat_id,
      ipsprodcat_ipshead_id,
      ipsprodcat_prodcat_id,
      ipsprodcat_qtybreak,
      ipsprodcat_discntprcnt,
      ipsprodcat_fixedamtdiscount)
    VALUES (
      _ipsprodcatid,
      pIpsheadId,
      pProdcatId,
      pQtyBreak,
      pDiscount * .01,
      pFixedAmtDiscount);
  ELSE
    UPDATE ipsprodcat SET
      ipsprodcat_qtybreak = pQtyBreak,
      ipsprodcat_discntprcnt = pDiscount * .01,
      ipsprodcat_fixedamtdiscount = pFixedAmtDiscount
    WHERE (ipsprodcat_id=_ipsprodcatid);
  END IF;

  RETURN _ipsprodcatid;
END;
$_$;


ALTER FUNCTION public.saveipsprodcat(integer, integer, integer, numeric, numeric, numeric) OWNER TO admin;

--
-- TOC entry 2164 (class 1255 OID 146567019)
-- Dependencies: 4536 8
-- Name: saveipsprodcat(integer, integer, integer, numeric, numeric, numeric, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION saveipsprodcat(pipsprodcatid integer, pipsheadid integer, pprodcatid integer, pqtybreak numeric, pdiscount numeric, pfixedamtdiscount numeric, ptype text) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _ipsitemid	INTEGER;
  _new		BOOLEAN;

BEGIN

  -- Validation
  IF (SELECT COUNT(*)=0 FROM prodcat WHERE (prodcat_id=pProdcatId)) THEN
    RAISE EXCEPTION 'You must provide a valid Product Category';
  ELSIF (COALESCE(pQtyBreak,0) < 0) THEN
    RAISE EXCEPTION 'Quantity can not be a negative value';
  ELSIF (COALESCE(pDiscount,0) < 0) THEN
    RAISE EXCEPTION 'Discount must be a negative value';
  END IF;

  _new := TRUE;

  IF (pIpsProdcatId IS NOT NULL) THEN
    SELECT ipsitem_id INTO _ipsitemid
    FROM ipsiteminfo
    WHERE (ipsprodcat_id=pIpsprodcatId);

    IF (FOUND) THEN
      _new := FALSE;
    ELSE
      RAISE EXCEPTION 'Pricing Schedule Product Category not found';
    END IF;
  ELSE
    SELECT ipsitem_id INTO _ipsitemid
    FROM ipsiteminfo
    WHERE ((ipsitem_ipshead_id=pIpsheadId)
      AND (ipsitem_prodcat_id=pProdcatId)
      AND (ipsitem_qtybreak=pQtyBreak));

    IF (FOUND) THEN
      _new := false;
    ELSE
      _ipsitemid := nextval('ipsitem_ipsitem_id_seq');
    END IF;
  END IF;

  IF (_new) THEN
    INSERT INTO ipsiteminfo (
      ipsitem_id,
      ipsitem_ipshead_id,
      ipsitem_prodcat_id,
      ipsitem_qtybreak,
      ipsitem_price,
      ipsitem_discntprcnt,
      ipsitem_fixedamtdiscount,
      ipsitem_type)
    VALUES (
      _ipsitemid,
      pIpsheadId,
      pProdcatId,
      pQtyBreak,
      0.0,
      pDiscount * .01,
      pFixedAmtDiscount,
      pType);
  ELSE
    UPDATE ipsiteminfo SET
      ipsitem_qtybreak = pQtyBreak,
      ipsitem_discntprcnt = pDiscount * .01,
      ipsitem_fixedamtdiscount = pFixedAmtDiscount,
      ipsitem_type = pType
    WHERE (ipsitem_id=_ipsitemid);
  END IF;

  RETURN _ipsitemid;
END;
$$;


ALTER FUNCTION public.saveipsprodcat(pipsprodcatid integer, pipsheadid integer, pprodcatid integer, pqtybreak numeric, pdiscount numeric, pfixedamtdiscount numeric, ptype text) OWNER TO admin;

--
-- TOC entry 2171 (class 1255 OID 146567020)
-- Dependencies: 4536 8
-- Name: saveitemimage(integer, character, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION saveitemimage(integer, character, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pPurpose ALIAS FOR $2;
  pImageid ALIAS FOR $3;
  _itemimageId INTEGER;

BEGIN
-- See if a record with this purpose already exists
  SELECT imageass_id INTO _itemimageId
  FROM imageass
  WHERE ( (imageass_source='I')
    AND   (imageass_source_id=pItemid)
    AND   (imageass_purpose=pPurpose) );

  IF (FOUND) THEN
    UPDATE imageass SET imageass_image_id=pImageId
    WHERE (imageass_id=_itemimageId);
  ELSE
    _itemimageId := NEXTVAL('imageass_imageass_id_seq');
    INSERT INTO imageass VALUES (_itemimageId,pItemid,'I',pImageid,pPurpose);
  END IF;

  RETURN _itemimageId;
END;
$_$;


ALTER FUNCTION public.saveitemimage(integer, character, integer) OWNER TO admin;

--
-- TOC entry 2172 (class 1255 OID 146567021)
-- Dependencies: 4536 8
-- Name: saveitemuomconv(integer, integer, numeric, integer, numeric, boolean, integer[]); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION saveitemuomconv(integer, integer, numeric, integer, numeric, boolean, integer[]) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemId ALIAS FOR $1;
  pFromUomId ALIAS FOR $2;
  pFromValue ALIAS FOR $3;
  pToUomId ALIAS FOR $4;
  pToValue ALIAS FOR $5;
  pFractional ALIAS FOR $6;
  pUomTypes ALIAS FOR $7;
  _p RECORD;
  _fromUomId INTEGER;
  _fromValue NUMERIC;
  _toUomId INTEGER;
  _toValue NUMERIC;
  _fractional BOOLEAN;
  _seq INTEGER;
  _i INTEGER;
  _uomtype TEXT;

BEGIN
-- Make sure we have some itemtypes
  IF (pUomTypes IS NULL) OR (ARRAY_UPPER(pUomTypes,1) = 0) THEN
	RAISE EXCEPTION 'You must include at least one item type.';
  END IF;

-- If this is a global UOM, over-ride with global data.
  SELECT * INTO _p
  FROM uomconv
  WHERE ((((uomconv_from_uom_id=pFromUomId)
  AND (uomconv_to_uom_id=pToUomId))
  OR ((uomconv_from_uom_id=pToUomId)
  AND (uomconv_to_uom_id=pFromUomId))));

  IF (FOUND) THEN
    _fromUomId := _p.uomconv_from_uom_id;
    _toUomId := _p.uomconv_to_uom_id;
    _fromValue := _p.uomconv_from_value;
    _toValue := _p.uomconv_to_value;
    _fractional := _p.uomconv_fractional;
    RAISE NOTICE 'Defaulted to global Unit of Measure conversion ratios.';
  ELSE
    _fromUomId := pFromUomId;
    _fromValue := pFromValue;
    _toUomId := pToUomId;
    _toValue := pToValue;
    _fractional := pFractional;
  END IF;

-- See if an item conversion exists going the other way
  SELECT f.uom_name AS f_uom, t.uom_name as t_uom INTO _p
  FROM itemuomconv,uom f, uom t
  WHERE ((itemuomconv_item_id=pItemId)
  AND (itemuomconv_from_uom_id=_toUomId)
  AND (itemuomconv_to_uom_id=_fromUomId)
  AND (f.uom_id=itemuomconv_from_uom_id)
  AND (t.uom_id=itemuomconv_to_uom_id));
  IF (FOUND) THEN
    RAISE EXCEPTION 'Unit of measure conversion already exists going from % to %.',_p.f_uom,_p.t_uom;
  END IF;

-- See if an item conversion record exists
  SELECT * INTO _p
  FROM itemuomconv
  WHERE ((itemuomconv_item_id=pItemId)
  AND (itemuomconv_from_uom_id=_fromUomId)
  AND (itemuomconv_to_uom_id=_toUomId));

-- Update if found
  IF (FOUND) THEN
    UPDATE itemuomconv SET
      itemuomconv_from_value=_fromValue,
      itemuomconv_to_value=_toValue,
      itemuomconv_fractional=_fractional
    WHERE (itemuomconv_id=_p.itemuomconv_id);
    _seq := _p.itemuomconv_id;

    --Delete old type list
    DELETE FROM itemuom WHERE itemuom_itemuomconv_id=_p.itemuomconv_id;
  ELSE

-- Otherwise create a new one
    SELECT NEXTVAL('itemuomconv_itemuomconv_id_seq') INTO _seq;
    INSERT INTO itemuomconv VALUES
      (_seq, pItemId,_fromUomId,_fromValue,_toUomId,_toValue,_fractional);
  END IF;

-- Build new type list
  FOR _i IN 1..ARRAY_UPPER(pUomTypes,1)
  LOOP
    SELECT uomtype_name INTO _uomtype
    FROM itemuomconv, itemuom, uomtype
    WHERE ((itemuom_uomtype_id=uomtype_id)
    AND (itemuomconv_id=itemuom_itemuomconv_id)
    AND (itemuomconv_item_id=pItemId)
    AND (uomtype_name != 'Selling')
    AND (itemuom_uomtype_id=pUomTypes[_i]));
    IF (FOUND) THEN
      RAISE EXCEPTION 'Unit of Measure Type % is already used on this item',_uomtype;
    ELSE
      INSERT INTO itemuom (itemuom_itemuomconv_id,itemuom_uomtype_id)
      VALUES (_seq,pUomTypes[_i]);
    END IF;
  END LOOP;

  RETURN _seq;
END;
$_$;


ALTER FUNCTION public.saveitemuomconv(integer, integer, numeric, integer, numeric, boolean, integer[]) OWNER TO admin;

--
-- TOC entry 2173 (class 1255 OID 146567022)
-- Dependencies: 4536 8
-- Name: savemetasql(text, text, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION savemetasql(text, text, text, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN saveMetasql($1, $2, $3, $4, true, NULL, 0);
END;
$_$;


ALTER FUNCTION public.savemetasql(text, text, text, text) OWNER TO admin;

--
-- TOC entry 2174 (class 1255 OID 146567023)
-- Dependencies: 4536 8
-- Name: savemetasql(text, text, text, text, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION savemetasql(text, text, text, text, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN saveMetasql($1, $2, $3, $4, $5, NULL, 0);
END;
$_$;


ALTER FUNCTION public.savemetasql(text, text, text, text, boolean) OWNER TO admin;

--
-- TOC entry 2175 (class 1255 OID 146567024)
-- Dependencies: 4536 8
-- Name: savemetasql(text, text, text, text, boolean, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION savemetasql(text, text, text, text, boolean, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN saveMetasql($1, $2, $3, $4, $5, $6, 0);
END;
$_$;


ALTER FUNCTION public.savemetasql(text, text, text, text, boolean, text) OWNER TO admin;

--
-- TOC entry 2176 (class 1255 OID 146567025)
-- Dependencies: 4536 8
-- Name: savemetasql(text, text, text, text, boolean, text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION savemetasql(text, text, text, text, boolean, text, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pGroup	ALIAS FOR $1;
  pName 	ALIAS FOR $2;
  pNotes	ALIAS FOR $3;
  pQuery	ALIAS FOR $4;
  pSystem       ALIAS FOR $5;
  pSchema       ALIAS FOR $6;
  pGrade        ALIAS FOR $7;
  _metasqlid	INTEGER;
  _debug        BOOL    := false;
  _grade        INTEGER;
  _insertstr    TEXT;
  _table        TEXT;

BEGIN

  --See if Query already exists
  SELECT metasql_id INTO _metasqlid
  FROM metasql
  WHERE ((metasql_group=pGroup)
     AND (metasql_name=pName)
     AND (metasql_grade=pGrade));

  IF (FOUND) THEN
    IF (_debug) THEN RAISE NOTICE 'update metasql'; END IF;
    UPDATE metasql SET
      metasql_group=pGroup,
      metasql_name=pName,
      metasql_notes=pNotes,
      metasql_query=pQuery
    WHERE (metasql_id=_metasqlid);
  ELSE
    IF (COALESCE(pSchema, 'public') = 'public' OR
        TRIM(pSchema) = '') THEN
      _table := 'metasql';
    ELSE
      _table := pSchema || '.pkgmetasql';
    END IF;

    IF (pGrade IS NULL) THEN
      SELECT MAX(metasql_grade) + 1 INTO _grade
      FROM metasql
      WHERE ((metasql_group=pGroup)
         AND (metasql_name=pName));
    ELSE
      _grade := pGrade;
    END IF;

    _insertstr := 'INSERT INTO ' || _table ||
                  ' (metasql_group, metasql_name, metasql_notes, ' ||
                  '  metasql_query, metasql_grade) VALUES (' ||
                  COALESCE(quote_literal(pGroup),'NULL') || ',' || COALESCE(quote_literal(pName), 'NULL') || ',' ||
                  COALESCE(quote_literal(pNotes), 'NULL') || ',' || COALESCE(quote_literal(pQuery), 'NULL') ||',' ||
                  COALESCE(quote_literal(_grade), 'NULL') || ') RETURNING metasql_id;' ;

    IF (_debug) THEN RAISE NOTICE '%', _insertstr; END IF;
    EXECUTE _insertstr INTO _metasqlid;
  END IF;

  RETURN _metasqlid;
END;
$_$;


ALTER FUNCTION public.savemetasql(text, text, text, text, boolean, text, integer) OWNER TO admin;

--
-- TOC entry 2177 (class 1255 OID 146567026)
-- Dependencies: 4536 8
-- Name: scraps(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION scraps(text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTransType ALIAS FOR $1;

BEGIN
  IF (pTransType IN ('SI', 'SM', 'EX')) THEN
    RETURN TRUE;
  ELSE
    RETURN FALSE;
  END IF;

END;
$_$;


ALTER FUNCTION public.scraps(text) OWNER TO admin;

--
-- TOC entry 2178 (class 1255 OID 146567027)
-- Dependencies: 4536 8
-- Name: scrapwomaterial(integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION scrapwomaterial(integer, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN scrapWoMaterial($1, $2, CURRENT_TIMESTAMP);
END;
$_$;


ALTER FUNCTION public.scrapwomaterial(integer, numeric) OWNER TO admin;

--
-- TOC entry 2179 (class 1255 OID 146567028)
-- Dependencies: 4536 8
-- Name: scrapwomaterial(integer, numeric, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION scrapwomaterial(integer, numeric, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWomatlid	ALIAS FOR $1;
  pQty		ALIAS FOR $2;
  pGlDistTS     ALIAS FOR $3;
  _costmethod         	CHAR(1);
  _scrapValue		NUMERIC;
  _r                   	RECORD;

BEGIN
  -- Validate
  IF (pQty <= 0) THEN
    RAISE EXCEPTION 'Scrap quantity must be a positive number';
  ELSIF ( ( SELECT (womatl_qtyiss < pQty)
	     FROM womatl
	     WHERE (womatl_id=pWomatlid) ) ) THEN
    RAISE EXCEPTION 'You may not scrap more material than has been issued';
  END IF;

  -- Get the wip G/L account
  SELECT costcat_wip_accnt_id
    INTO _r
    FROM womatl, wo, itemsite, costcat
   WHERE((womatl_wo_id=wo_id)
     AND (wo_itemsite_id=itemsite_id)
     AND (itemsite_costcat_id=costcat_id)
     AND (womatl_id=pWomatlid));

  -- Calculate scrap value
  SELECT itemsite_costmethod INTO _costmethod
  FROM womatl
    JOIN itemsite ON (womatl_itemsite_id=itemsite_id)
  WHERE (womatl_id=pWomatlid);

  IF (_costmethod = 'S') THEN
    SELECT ROUND((stdCost(itemsite_item_id) * itemuomtouom(itemsite_item_id, womatl_uom_id, NULL, pQty)),2)
    INTO _scrapValue
    FROM womatl
      JOIN itemsite ON (womatl_itemsite_id=itemsite_id)
    WHERE (womatl_id=pWomatlid);

  ELSIF (_costmethod = 'A') THEN
    SELECT ROUND((SUM(invhist_invqty * invhist_unitcost)-womatl_scrapvalue)/
            (CASE WHEN (SUM(invhist_invqty)-itemuomtouom(itemsite_item_id, womatl_uom_id, NULL, womatl_qtywipscrap) = 0) THEN
              1
            ELSE
              SUM(invhist_invqty)-itemuomtouom(itemsite_item_id, womatl_uom_id, NULL, womatl_qtywipscrap)
            END),2) * itemuomtouom(itemsite_item_id, womatl_uom_id, NULL, pQty)
      INTO _scrapValue
    FROM womatl
        JOIN womatlpost ON (womatl_id=womatlpost_womatl_id)
        JOIN invhist ON (womatlpost_invhist_id=invhist_id)
        JOIN itemsite ON (womatl_itemsite_id=itemsite_id)
    WHERE (womatl_id=pWomatlid)
    GROUP BY itemsite_item_id,womatl_uom_id,womatl_qtywipscrap,womatl_scrapvalue;
  ELSE
    RAISE EXCEPTION 'Cost method not supported to scrap this item';
  END IF;

  --  Distribute to G/L
  PERFORM insertGLTransaction( 'W/O', 'WO', formatWoNumber(womatl_wo_id),
		 ('Scrap ' || item_number || ' from Work Order'),
		 getPrjAccntId(wo_prj_id, _r.costcat_wip_accnt_id), getPrjAccntId(wo_prj_id, costcat_mfgscrap_accnt_id), -1,
		 _scrapValue, date(pGlDistTS) )
  FROM wo, womatl, itemsite, item, costcat
  WHERE ( (wo_id=womatl_wo_id)
   AND (womatl_itemsite_id=itemsite_id)
   AND (itemsite_item_id=item_id)
   AND (itemsite_costcat_id=costcat_id)
   AND (womatl_id=pWomatlid) );

  UPDATE womatl
  SET womatl_qtywipscrap=(womatl_qtywipscrap + pQty),
    womatl_scrapvalue = womatl_scrapvalue + _scrapValue,
    womatl_qtyiss=(womatl_qtyiss - pQty)
  WHERE (womatl_id=pWomatlid);

  UPDATE wo
  SET wo_wipvalue = wo_wipvalue-_scrapValue,
    wo_postedvalue = wo_postedvalue-_scrapValue
  FROM womatl
  WHERE ((womatl_id=pWomatlid)
   AND (wo_id=womatl_wo_id));

  RETURN pWomatlid;

END;
$_$;


ALTER FUNCTION public.scrapwomaterial(integer, numeric, timestamp with time zone) OWNER TO admin;

--
-- TOC entry 2181 (class 1255 OID 146567029)
-- Dependencies: 4536 8
-- Name: selectbalanceforbilling(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION selectbalanceforbilling(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSoheadid ALIAS FOR $1;
  _returnval	BOOLEAN := TRUE;
  _doSelect BOOLEAN;
  _result INTEGER;
  _soitem RECORD;

BEGIN

  FOR _soitem IN
    -- Get the shipments for this SO.  Kits are not shipped
    SELECT cust_partialship, coitem_id,
           coitem_linenumber, 'NOTK' AS item_type,
           SUM(shipitem_qty) AS qty,
           ( (SUM(shipitem_qty) >= (coitem_qtyord - coitem_qtyshipped + coitem_qtyreturned + SUM(shipitem_qty))) OR
             (NOT cust_partialship) ) AS toclose
    FROM cohead JOIN custinfo ON (cust_id=cohead_cust_id)
                JOIN coitem ON (coitem_cohead_id=cohead_id)
                JOIN shipitem ON ( (shipitem_orderitem_id=coitem_id) AND (NOT shipitem_invoiced) )
                JOIN shiphead ON ( (shiphead_id=shipitem_shiphead_id) AND (shiphead_order_type='SO') AND (shiphead_shipped) )
    WHERE (cohead_id=pSoheadid)
    GROUP BY cust_partialship, coitem_id, item_type,
             coitem_linenumber, coitem_qtyord,
             coitem_qtyshipped, coitem_qtyreturned
    UNION
    -- Get the Kits for this SO
    SELECT cust_partialship, coitem_id,
           coitem_linenumber, 'K' AS item_type,
           coitem_qtyord AS qty,
           TRUE AS toclose
    FROM cohead JOIN custinfo ON (cust_id=cohead_cust_id)
                JOIN coitem ON (coitem_cohead_id=cohead_id AND coitem_status='O')
                JOIN itemsite ON (itemsite_id=coitem_itemsite_id)
                JOIN item ON ( (item_id=itemsite_item_id) AND (item_type='K') )
    WHERE (cohead_id=pSoheadid)
  LOOP

    _doSelect := true;
    IF(_soitem.item_type = 'K') THEN
      -- see if all the sub items are shipped
      SELECT coitem_id
        INTO _result
        FROM coitem
       WHERE((coitem_cohead_id=pSoheadid)
         AND (coitem_linenumber=_soitem.coitem_linenumber)
         AND (coitem_subnumber > 0)
         AND ((coitem_qtyord - coitem_qtyshipped + coitem_qtyreturned) > 0))
       LIMIT 1;
      IF( FOUND ) THEN
        _doSelect := false;
      END IF;
    END IF;

    IF (_doSelect) THEN
      -- do as much as we can but still report errors if they occur
      IF (selectForBilling(_soitem.coitem_id, _soitem.qty, _soitem.toclose) < 0) THEN
        _returnval := FALSE;
      END IF;
    END IF;

  END LOOP;

  RETURN _returnval;

END;
$_$;


ALTER FUNCTION public.selectbalanceforbilling(integer) OWNER TO admin;

--
-- TOC entry 2182 (class 1255 OID 146567030)
-- Dependencies: 4536 8
-- Name: selectdiscountitemsforpayment(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION selectdiscountitemsforpayment(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVendid ALIAS FOR $1;
  pBankaccntid ALIAS FOR $2;
  _currid INTEGER;
  _r RECORD;

BEGIN

  SELECT bankaccnt_curr_id INTO _currid
  FROM bankaccnt
  WHERE (bankaccnt_id=pBankaccntid);

  FOR _r IN SELECT apopen_id
              FROM apopen, terms
             WHERE((CURRENT_DATE <= determineDiscountDate(apopen_terms_id, apopen_docdate))
               AND (terms_discprcnt > 0.0)
               AND (apopen_terms_id=terms_id)
               AND (apopen_open)
               AND (apopen_status = 'O')
               AND (apopen_doctype IN ('V', 'D'))
               AND (apopen_vend_id=pVendid)
               AND (apopen_curr_id=_currid) ) LOOP
    PERFORM selectPayment(_r.apopen_id, pBankaccntid);
  END LOOP;

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.selectdiscountitemsforpayment(integer, integer) OWNER TO admin;

--
-- TOC entry 2183 (class 1255 OID 146567031)
-- Dependencies: 4536 8
-- Name: selectdueitemsforpayment(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION selectdueitemsforpayment(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pVendid ALIAS FOR $1;
  pBankaccntid ALIAS FOR $2;
  _currid INTEGER;

BEGIN

  SELECT bankaccnt_curr_id INTO _currid
  FROM bankaccnt
  WHERE (bankaccnt_id=pBankaccntid);

  PERFORM selectPayment(apopen_id, pBankaccntid)
     FROM apopen
    WHERE((apopen_open)
      AND (apopen_vend_id=pVendid)
      AND (apopen_duedate <= CURRENT_DATE)
      AND (apopen_status = 'O')
      AND (apopen_doctype IN ('V', 'D'))
      AND (apopen_curr_id=_currid) );

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.selectdueitemsforpayment(integer, integer) OWNER TO admin;

--
-- TOC entry 2184 (class 1255 OID 146567032)
-- Dependencies: 4536 8
-- Name: selectforbilling(integer, numeric, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION selectforbilling(integer, numeric, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSoitemid	ALIAS FOR $1;
  pQty	ALIAS FOR $2;
  pClose	ALIAS FOR $3;
  _itemid	INTEGER := NULL;
  _taxzoneid	INTEGER := NULL;
  _taxid	INTEGER := NULL;
  _taxtypeid	INTEGER := NULL;

BEGIN
  SELECT cobmisc_taxzone_id,  item_id, coitem_taxtype_id
  INTO _taxzoneid,  _itemid, _taxtypeid
  FROM cobmisc, coitem, itemsite, item
  WHERE ((cobmisc_cohead_id = coitem_cohead_id)
  AND   (NOT cobmisc_posted)
  AND   (coitem_itemsite_id = itemsite_id)
  AND   (itemsite_item_id = item_id)
  AND   (coitem_id = pSoitemid) )
  LIMIT 1;

   RETURN selectforbilling(pSoitemid, pQty, pClose, _taxtypeid);
END;
$_$;


ALTER FUNCTION public.selectforbilling(integer, numeric, boolean) OWNER TO admin;

--
-- TOC entry 2185 (class 1255 OID 146567033)
-- Dependencies: 4536 8
-- Name: selectforbilling(integer, numeric, boolean, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION selectforbilling(integer, numeric, boolean, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSoitemid	ALIAS FOR $1;
  pQty		ALIAS FOR $2;
  pClose	ALIAS FOR $3;
  ptaxtypeid	ALIAS FOR $4;
  _cobillid INTEGER;
  _r RECORD;

BEGIN

-- Get some information
  SELECT cobmisc_id, cobmisc_taxzone_id, coitem_id, coitem_price,
    coitem_price_invuomratio AS invpricerat, coitem_qty_invuomratio, item_id
  INTO _r
  FROM cobmisc, coitem, itemsite, item, site()
  WHERE ((cobmisc_cohead_id = coitem_cohead_id)
  AND   (NOT cobmisc_posted)
  AND   (coitem_itemsite_id = itemsite_id)
  AND   (itemsite_item_id = item_id)
  AND   (coitem_id = pSoitemid)
  AND   (itemsite_warehous_id = warehous_id) )
  LIMIT 1;

-- check to make sure the qty to bill for is not less than
-- the total un-invoiced shipped amount
  IF ((SELECT (pQty < SUM(shipitem_qty))
       FROM shipitem, shiphead, coitem
       WHERE ( (shipitem_shiphead_id=shiphead_id)
       AND (shiphead_order_type='SO')
       AND (shiphead_order_id=coitem_cohead_id)
       AND (shipitem_orderitem_id=coitem_id)
       AND (shiphead_shipped)
       AND (NOT shipitem_invoiced)
       AND (coitem_id=pSoitemid) ) ) ) THEN
    RETURN -1;
  END IF;

  SELECT cobill_id INTO _cobillid
  FROM cobill, cobmisc, coitem
  WHERE ((cobill_cobmisc_id = cobmisc_id)
  AND (cobmisc_cohead_id = coitem_cohead_id)
  AND (cobill_coitem_id = coitem_id)
  AND (NOT cobmisc_posted)
  AND (coitem_id = pSoitemid));

  IF (FOUND) THEN
    UPDATE cobill
    SET cobill_selectdate = CURRENT_DATE,
        cobill_select_username = getEffectiveXtUser(),
        cobill_qty = pQty,
        cobill_toclose = pClose,
	cobill_taxtype_id = ptaxtypeid
    WHERE (cobill_id=_cobillid);

  ELSE
    SELECT NEXTVAL('cobill_cobill_id_seq') INTO _cobillid;
    INSERT INTO cobill
    (cobill_id, cobill_coitem_id, cobill_cobmisc_id,
     cobill_selectdate, cobill_select_username,
     cobill_qty, cobill_toclose,
     cobill_taxtype_id)
    VALUES
    (_cobillid, _r.coitem_id, _r.cobmisc_id,
      CURRENT_DATE, getEffectiveXtUser(),
      pQty, pClose,
      ptaxtypeid);
  END IF;

  RETURN _cobillid;

END;
$_$;


ALTER FUNCTION public.selectforbilling(integer, numeric, boolean, integer) OWNER TO admin;

--
-- TOC entry 2186 (class 1255 OID 146567034)
-- Dependencies: 4536 8
-- Name: selectpayment(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION selectpayment(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pApopenid ALIAS FOR $1;
  pBankaccntid ALIAS FOR $2;
  _p RECORD;
  _apselectid INTEGER;
  _amount NUMERIC;
  _discount NUMERIC;
BEGIN

  SELECT apopen_amount, apopen_paid,
         apopen_doctype, apopen_docdate,
         apopen_curr_id,
         apopen_amount - apopen_paid - apCheckPending(apopen_id) AS balance,
         noNeg(COALESCE(apopen_discountable_amount, 0) *
               CASE WHEN (CURRENT_DATE <= determineDiscountDate(apopen_terms_id, apopen_docdate)) THEN terms_discprcnt
                    ELSE 0.0 END - discount_applied) AS discount_available
    INTO _p
    FROM apopen LEFT OUTER JOIN terms ON (apopen_terms_id=terms_id),
         (SELECT COALESCE(SUM(apapply_amount),0) AS discount_applied
            FROM apapply, apopen
           WHERE((apapply_target_apopen_id=pApopenid)
             AND (apapply_source_apopen_id=apopen_id)
             AND (apopen_discount)) ) AS data
   WHERE(apopen_id=pApopenid);
  IF(NOT FOUND OR (NOT _p.apopen_doctype IN ('V','D','C'))) THEN
    RETURN -1;
  END IF;

  _discount := round(_p.discount_available, 2);
  _amount := noNeg(round(_p.balance, 2) - _discount);

  IF (round(_p.balance,2) < (_discount + _amount)) THEN
    RETURN -2;
  END IF;

  IF (_amount > 0) THEN
    SELECT apselect_id INTO _apselectid
    FROM apselect
    WHERE (apselect_apopen_id=pApopenid);

    IF (FOUND) THEN
      UPDATE apselect
         SET apselect_amount=_amount,
             apselect_discount=_discount,
             apselect_curr_id = _p.apopen_curr_id
       WHERE(apselect_id=_apselectid);
    ELSE
      SELECT NEXTVAL('apselect_apselect_id_seq') INTO _apselectid;

      INSERT INTO apselect
      ( apselect_id, apselect_apopen_id,
        apselect_amount, apselect_discount,
        apselect_bankaccnt_id,
        apselect_curr_id, apselect_date )
      VALUES
      ( _apselectid, pApopenid,
        _amount, _discount,
        pBankaccntid,
        _p.apopen_curr_id, _p.apopen_docdate );
    END IF;
  ELSE
    _apselectid := 0;
  END IF;

  RETURN _apselectid;

END;
$_$;


ALTER FUNCTION public.selectpayment(integer, integer) OWNER TO admin;

--
-- TOC entry 2187 (class 1255 OID 146567035)
-- Dependencies: 4536 8
-- Name: selectuninvoicedshipment(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION selectuninvoicedshipment(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pShipheadid ALIAS FOR $1;
  _cobmiscid INTEGER;
  _coheadid  INTEGER;
  _r RECORD;
  _cobillid INTEGER;

BEGIN

  -- make a cobmisc head if it doesn't already exist for this cohead
  SELECT shiphead_order_id, createBillingHeader(shiphead_order_id)
    INTO _coheadid, _cobmiscid
    FROM shiphead
    JOIN shipitem ON (shipitem_shiphead_id=shiphead_id)
   WHERE (shiphead_shipped
      AND NOT shipitem_invoiced
      AND (shiphead_id=pShipheadid));

  --  Grab all of the uninvoiced shipitem records
  FOR _r IN SELECT cohead_id, coitem_id, SUM(shipitem_qty) AS qty,
                   coitem_price, coitem_price_invuomratio AS invpricerat, coitem_qty_invuomratio, item_id,
                   ( ((coitem_qtyord - coitem_qtyshipped + coitem_qtyreturned) <= 0)
                    OR (NOT cust_partialship) ) AS toclose, coitem_taxtype_id
            FROM shiphead, shipitem, coitem, cohead, custinfo, itemsite, item
            WHERE ( (shipitem_shiphead_id=shiphead_id)
             AND (shipitem_orderitem_id=coitem_id)
             AND (coitem_cohead_id=cohead_id)
             AND (shiphead_shipped)
             AND (NOT shipitem_invoiced)
             AND (coitem_itemsite_id=itemsite_id)
             AND (itemsite_item_id=item_id)
             AND (cohead_cust_id=cust_id)
             AND (item_type != 'K')
             AND (cohead_id=_coheadid)
             AND (shiphead_id=pShipheadid) )
            GROUP BY cohead_id, coitem_id, cust_partialship, coitem_taxtype_id,
                     coitem_qtyord, coitem_qtyshipped, coitem_qtyreturned,
                     coitem_price, invpricerat, coitem_qty_invuomratio, item_id
            UNION
            SELECT cohead_id, coitem_id, coitem_qtyord AS qty,
                   coitem_price, coitem_price_invuomratio AS invpricerat, coitem_qty_invuomratio, item_id,
                   true AS toclose, coitem_taxtype_id
              FROM shiphead, cohead, custinfo, itemsite, item, coitem AS kit
             WHERE((shiphead_order_id=cohead_id)
               AND (coitem_cohead_id=cohead_id)
               AND (coitem_status='O')
               AND (shiphead_shipped)
               AND (coitem_itemsite_id=itemsite_id)
               AND (itemsite_item_id=item_id)
               AND (cohead_cust_id=cust_id)
               AND (item_type = 'K')
               AND (cohead_id=_coheadid)
               AND (shiphead_id=pShipheadid)
               AND (coitem_linenumber NOT IN
                      (SELECT sub.coitem_linenumber
                       FROM coitem AS sub
                       WHERE sub.coitem_cohead_id=cohead_id     -- cohead for kit
                        AND sub.coitem_linenumber=kit.coitem_linenumber
                        AND sub.coitem_subnumber > 0
                        AND ((sub.coitem_qtyord - sub.coitem_qtyshipped + sub.coitem_qtyreturned) > 0)
                        LIMIT 1)
               ))
             GROUP BY cohead_id, coitem_id, cust_partialship, coitem_taxtype_id,
                      coitem_qtyord, coitem_qtyshipped, coitem_qtyreturned,
                      coitem_price, invpricerat, coitem_qty_invuomratio, item_id, coitem_linenumber
  LOOP

    SELECT cobill_id INTO _cobillid
      FROM cobill, cobmisc, coitem
     WHERE ((cobill_cobmisc_id=cobmisc_id)
       AND  (cobmisc_cohead_id=coitem_cohead_id)
       AND  (cobill_coitem_id=coitem_id)
       AND  (NOT cobmisc_posted)
       AND  (cobill_cobmisc_id=_cobmiscid)
       AND  (coitem_id=_r.coitem_id))
     LIMIT 1;

    IF (FOUND) THEN
      UPDATE cobill
         SET cobill_selectdate = CURRENT_DATE,
             cobill_select_username = getEffectiveXtUser(),
             cobill_qty = cobill_qty + _r.qty,
             cobill_toclose = _r.toclose,
             cobill_taxtype_id = _r.coitem_taxtype_id
      WHERE (cobill_id=_cobillid);
    ELSE
--  Now insert the cobill line
      INSERT INTO cobill
      ( cobill_cobmisc_id, cobill_coitem_id,
        cobill_selectdate, cobill_select_username,
        cobill_qty, cobill_toclose,
        cobill_taxtype_id )
      VALUES
      ( _cobmiscid, _r.coitem_id,
        CURRENT_DATE, getEffectiveXtUser(),
        _r.qty, _r.toclose,
         _r.coitem_taxtype_id );
     END IF;

  END LOOP;

  RETURN _cobmiscid;

END;
$_$;


ALTER FUNCTION public.selectuninvoicedshipment(integer) OWNER TO admin;

--
-- TOC entry 2189 (class 1255 OID 146567037)
-- Dependencies: 4536 8
-- Name: selectuninvoicedshipments(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION selectuninvoicedshipments(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWarehousid ALIAS FOR $1;
  _r RECORD;
  _recordCounter INTEGER := 0;

BEGIN

--  Grab all of the uninvoiced shipitem records
  FOR _r IN SELECT DISTINCT shiphead_id
            FROM shiphead, shipitem, coitem, itemsite
            WHERE ( (shiphead_order_type='SO')
             AND (shipitem_shiphead_id=shiphead_id)
             AND (shipitem_orderitem_id=coitem_id)
             AND (coitem_itemsite_id=itemsite_id)
             AND (coitem_status <> 'C')
             AND ( (pWarehousid = -1) OR (itemsite_warehous_id=pWarehousid) )
             AND (shiphead_shipped)
             AND (NOT shipitem_invoiced)
             AND (coitem_id NOT IN ( SELECT cobill_coitem_id
                                     FROM cobmisc, cobill
                                     WHERE ((cobill_cobmisc_id=cobmisc_id)
                                      AND (NOT cobmisc_posted) ) ) ) ) LOOP

      PERFORM selectUninvoicedShipment(_r.shiphead_id);

    _recordCounter := _recordCounter + 1;

  END LOOP;

  RETURN _recordCounter;

END;
$_$;


ALTER FUNCTION public.selectuninvoicedshipments(integer) OWNER TO admin;

--
-- TOC entry 2188 (class 1255 OID 146567036)
-- Dependencies: 4536 8
-- Name: selectuninvoicedshipments(integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION selectuninvoicedshipments(integer, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWarehousid ALIAS FOR $1;
  pCusttype ALIAS FOR $2;
  _r RECORD;
  _recordCounter INTEGER := 0;

BEGIN

--  Grab all of the uninvoiced shipitem records
  FOR _r IN SELECT DISTINCT shiphead_id
            FROM shiphead, shipitem, coitem, itemsite, cohead, custinfo, custtype
            WHERE ( (shiphead_order_type='SO')
             AND (shipitem_shiphead_id=shiphead_id)
             AND (shipitem_orderitem_id=coitem_id)
             AND (coitem_itemsite_id=itemsite_id)
             AND (coitem_status <> 'C')
             AND (coitem_cohead_id=cohead_id)
             AND (cohead_cust_id=cust_id)
             AND (cust_custtype_id=custtype_id)
             AND ( (pWarehousid = -1) OR (itemsite_warehous_id=pWarehousid) )
             AND (custtype_code ~ pCusttype)
             AND (shiphead_shipped)
             AND (NOT shipitem_invoiced)
             AND (coitem_id NOT IN ( SELECT cobill_coitem_id
                                     FROM cobmisc, cobill
                                     WHERE ((cobill_cobmisc_id=cobmisc_id)
                                      AND (NOT cobmisc_posted) ) ) ) ) LOOP

      PERFORM selectUninvoicedShipment(_r.shiphead_id);

    _recordCounter := _recordCounter + 1;

  END LOOP;

  RETURN _recordCounter;

END;
$_$;


ALTER FUNCTION public.selectuninvoicedshipments(integer, text) OWNER TO admin;

--
-- TOC entry 2190 (class 1255 OID 146567038)
-- Dependencies: 4536 8
-- Name: selectuninvoicedshipments(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION selectuninvoicedshipments(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWarehousid ALIAS FOR $1;
  pCusttypeid ALIAS FOR $2;
  _r RECORD;
  _recordCounter INTEGER := 0;

BEGIN

--  Grab all of the uninvoiced shipitem records
  FOR _r IN SELECT DISTINCT shiphead_id
            FROM shiphead, shipitem, coitem, itemsite, cohead, custinfo
            WHERE ( (shiphead_order_type='SO')
             AND (shipitem_shiphead_id=shiphead_id)
             AND (shipitem_orderitem_id=coitem_id)
             AND (coitem_itemsite_id=itemsite_id)
             AND (coitem_status <> 'C')
             AND (coitem_cohead_id=cohead_id)
             AND (cohead_cust_id=cust_id)
             AND (cust_custtype_id=pCusttypeid)
             AND ( (pWarehousid = -1) OR (itemsite_warehous_id=pWarehousid) )
             AND (shiphead_shipped)
             AND (NOT shipitem_invoiced)
             AND (coitem_id NOT IN ( SELECT cobill_coitem_id
                                     FROM cobmisc, cobill
                                     WHERE ((cobill_cobmisc_id=cobmisc_id)
                                      AND (NOT cobmisc_posted) ) ) ) ) LOOP

      PERFORM selectUninvoicedShipment(_r.shiphead_id);

    _recordCounter := _recordCounter + 1;

  END LOOP;

  RETURN _recordCounter;

END;
$_$;


ALTER FUNCTION public.selectuninvoicedshipments(integer, integer) OWNER TO admin;

--
-- TOC entry 2191 (class 1255 OID 146567039)
-- Dependencies: 4536 8
-- Name: setapjournalnumber(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setapjournalnumber() RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _journalNumber INTEGER;
  _r RECORD;

BEGIN

--  Fetch the next Journal Number
  SELECT fetchJournalNumber('A/P') INTO _journalNumber;

--  Walk through all of the A/P Open Items
  FOR _r IN SELECT apopen_id, apopen_docnumber
            FROM apopen
            WHERE (NOT apopen_posted) LOOP

--  Set the Journal Number for all of the G/L Transactions
--  for the A/P Open Item
    UPDATE gltrans
    SET gltrans_journalnumber=_journalNumber
    WHERE ( (gltrans_source='P/O')
     AND (gltrans_doctype IN ('VO'))
     AND (gltrans_docnumber=_r.apopen_docnumber)
     AND (NOT gltrans_exported) );

--  Set the Journal Number for the A/P Open Item
    UPDATE apopen
    SET apopen_journalnumber=_journalNumber
    WHERE (apopen_id=_r.apopen_id);

  END LOOP;

  RETURN _journalNumber;

END;
$$;


ALTER FUNCTION public.setapjournalnumber() OWNER TO admin;

--
-- TOC entry 2192 (class 1255 OID 146567040)
-- Dependencies: 4536 8
-- Name: setarjournalnumber(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setarjournalnumber() RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _journalNumber INTEGER;
  _r RECORD;

BEGIN

--  Fetch the next Journal Number
  SELECT fetchJournalNumber('A/R') INTO _journalNumber;

--  Walk through all of the A/R Open Items
  FOR _r IN SELECT aropen_id, aropen_docnumber
            FROM aropen
            WHERE (NOT aropen_posted) LOOP

--  Set the Journal Number for all of the G/L Transactions
--  for the A/R Open Item
    UPDATE gltrans
    SET gltrans_journalnumber=_journalNumber
    WHERE ( (gltrans_source='S/O')
     AND (gltrans_doctype IN ('CM', 'IN'))
     AND (gltrans_docnumber=_r.aropen_docnumber)
     AND (NOT gltrans_exported) );

--  Set the Journal Number for the A/R Open Item
    UPDATE aropen
    SET aropen_journalnumber=_journalNumber
    WHERE (aropen_id=_r.aropen_id);

  END LOOP;

  RETURN _journalNumber;

END;
$$;


ALTER FUNCTION public.setarjournalnumber() OWNER TO admin;

--
-- TOC entry 2193 (class 1255 OID 146567041)
-- Dependencies: 4536 8
-- Name: setbudget(integer, integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setbudget(integer, integer, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPeriodid ALIAS FOR $1;
  pAccntid ALIAS FOR $2;
  pAmount ALIAS FOR $3;

BEGIN
  RETURN setBudget(1, pPeriodid, pAccntid, pAmount);
END;
$_$;


ALTER FUNCTION public.setbudget(integer, integer, numeric) OWNER TO admin;

--
-- TOC entry 2195 (class 1255 OID 146567042)
-- Dependencies: 4536 8
-- Name: setbudget(integer, integer, integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setbudget(integer, integer, integer, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pBudgheadid ALIAS FOR $1;
  pPeriodid ALIAS FOR $2;
  pAccntid ALIAS FOR $3;
  pAmount ALIAS FOR $4;
  _budgetid INTEGER;

BEGIN

  SELECT budgitem_id INTO _budgetid
    FROM budgitem
   WHERE ((budgitem_period_id=pPeriodid)
     AND  (budgitem_budghead_id=pBudgheadid)
     AND  (budgitem_accnt_id=pAccntid));
  IF (FOUND) THEN
    UPDATE budgitem
       SET budgitem_amount = pAmount
     WHERE (budgitem_id=_budgetid);
  ELSE
    SELECT nextval('budgitem_budgitem_id_seq') INTO _budgetid;

    INSERT INTO budgitem
          (budgitem_id, budgitem_budghead_id, budgitem_period_id, budgitem_accnt_id, budgitem_amount)
    VALUES(_budgetid, pBudgheadid, pPeriodid, pAccntid, pAmount);
  END IF;

  RETURN _budgetid;

END;
$_$;


ALTER FUNCTION public.setbudget(integer, integer, integer, numeric) OWNER TO admin;

--
-- TOC entry 2196 (class 1255 OID 146567043)
-- Dependencies: 4536 8
-- Name: setbytea(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setbytea(text) RETURNS bytea
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pMetricName ALIAS FOR $1;
  _value bytea;

BEGIN

  _value := decode(pMetricName, 'escape');

  RETURN _value;

END;
$_$;


ALTER FUNCTION public.setbytea(text) OWNER TO admin;

--
-- TOC entry 2197 (class 1255 OID 146567044)
-- Dependencies: 4536 8
-- Name: setbytea(bytea); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setbytea(bytea) RETURNS bytea
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pMetricName ALIAS FOR $1;
  _value bytea;

BEGIN

  _value := pMetricName;

  RETURN _value;

END;
$_$;


ALTER FUNCTION public.setbytea(bytea) OWNER TO admin;

--
-- TOC entry 2198 (class 1255 OID 146567045)
-- Dependencies: 4536 8
-- Name: setccbankaccnt(text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setccbankaccnt(text, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pccardtype   ALIAS FOR $1;
  pbankaccntid ALIAS FOR $2;

  _ccbankid    INTEGER;
  _numfound    INTEGER;

BEGIN
  RAISE DEBUG 'setCCBankAccount(%, %) entered', pccardtype, pbankaccntid;
  UPDATE ccbank SET ccbank_bankaccnt_id=pbankaccntid
  WHERE ccbank_ccard_type=pccardtype
  RETURNING ccbank_id INTO _ccbankid;

  GET DIAGNOSTICS _numfound = ROW_COUNT;

  IF (_numfound <= 0) THEN
    INSERT INTO ccbank (ccbank_ccard_type, ccbank_bankaccnt_id)
                VALUES (pccardtype,        pbankaccntid)
    RETURNING _ccbankid;
  END IF;

  RETURN _ccbankid;
END;
$_$;


ALTER FUNCTION public.setccbankaccnt(text, integer) OWNER TO admin;

--
-- TOC entry 2199 (class 1255 OID 146567046)
-- Dependencies: 4536 8
-- Name: seteffectivextuser(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION seteffectivextuser(text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pUsername ALIAS FOR $1;
BEGIN
  PERFORM initEffectiveXtUser();

  PERFORM *
     FROM effective_user
    WHERE effective_key = 'username';

  IF FOUND THEN
    UPDATE effective_user
       SET effective_value = pUsername
     WHERE effective_key = 'username';
  ELSE
    INSERT INTO effective_user (effective_key, effective_value)
         VALUES('username', pUsername);
  END IF;

  RETURN true;
END;
$_$;


ALTER FUNCTION public.seteffectivextuser(text) OWNER TO admin;

--
-- TOC entry 2200 (class 1255 OID 146567047)
-- Dependencies: 4536 8
-- Name: setgljournalnumber(date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setgljournalnumber(date, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pStartDate ALIAS FOR $1;
  pEndDate ALIAS FOR $2;
  _journalNumber INTEGER;

BEGIN

--  Fetch the next Journal Number
  SELECT fetchJournalNumber('G/L') INTO _journalNumber;

--  Set the Journal Number for all of the unposted G/L Transactions
--  in the passed date range.
  UPDATE gltrans
  SET gltrans_journalnumber=_journalNumber
  WHERE ( (NOT gltrans_exported)
    AND (gltrans_date BETWEEN pStartDate and pEndDate) );

  RETURN _journalNumber;

END;
$_$;


ALTER FUNCTION public.setgljournalnumber(date, date) OWNER TO admin;

--
-- TOC entry 2201 (class 1255 OID 146567048)
-- Dependencies: 4536 8
-- Name: setmetric(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setmetric(text, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pMetricName ALIAS FOR $1;
  pMetricValue ALIAS FOR $2;
  _metricid INTEGER;

BEGIN

  SELECT metric_id INTO _metricid
  FROM metric
  WHERE (metric_name=pMetricName);

  IF (FOUND) THEN
    UPDATE metric
    SET metric_value=pMetricValue
    WHERE (metric_id=_metricid);

  ELSE
    INSERT INTO metric
    (metric_name, metric_value)
    VALUES (pMetricName, pMetricValue);
  END IF;

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.setmetric(text, text) OWNER TO admin;

--
-- TOC entry 2202 (class 1255 OID 146567049)
-- Dependencies: 4536 8
-- Name: setmetricenc(text, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setmetricenc(text, text, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pMetricName ALIAS FOR $1;
  pMetricValue ALIAS FOR $2;
  pMetricEnc ALIAS FOR $3;
  _metricid INTEGER;
  _value bytea;
  _key bytea;

BEGIN

  _value = decode(pMetricValue, 'escape');
  _key = decode(pMetricEnc, 'escape');

  SELECT metricenc_id INTO _metricid
  FROM metricenc
  WHERE (metricenc_name=pMetricName);

  IF (FOUND) THEN
    UPDATE metricenc
    SET metricenc_value=encrypt(_value, _key, 'bf')
    WHERE (metricenc_id=_metricid);

  ELSE
    INSERT INTO metricenc
    (metricenc_name, metricenc_value)
    VALUES (pMetricName, encrypt(_value, _key, 'bf'));
  END IF;

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.setmetricenc(text, text, text) OWNER TO admin;

--
-- TOC entry 2203 (class 1255 OID 146567050)
-- Dependencies: 4536 8
-- Name: setnextapmemonumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setnextapmemonumber(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pNumber ALIAS FOR $1;
  _orderseqid INTEGER;

BEGIN

  SELECT orderseq_id INTO _orderseqid
  FROM orderseq
  WHERE (orderseq_name='APMemoNumber');
  IF (FOUND) THEN
    UPDATE orderseq
    SET orderseq_number=pNumber
    WHERE (orderseq_id=_orderseqid);

  ELSE
    INSERT INTO orderseq
    (orderseq_name, orderseq_number)
    VALUES
    ('APMemoNumber', pNumber);
  END IF;

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.setnextapmemonumber(integer) OWNER TO admin;

--
-- TOC entry 2204 (class 1255 OID 146567051)
-- Dependencies: 4536 8
-- Name: setnextarmemonumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setnextarmemonumber(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pNumber ALIAS FOR $1;
  _orderseqid INTEGER;

BEGIN

  SELECT orderseq_id INTO _orderseqid
  FROM orderseq
  WHERE (orderseq_name='ARMemoNumber');
  IF (FOUND) THEN
    UPDATE orderseq
    SET orderseq_number=pNumber
    WHERE (orderseq_id=_orderseqid);

  ELSE
    INSERT INTO orderseq
    (orderseq_name, orderseq_number)
    VALUES
    ('ARMemoNumber', pNumber);
  END IF;

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.setnextarmemonumber(integer) OWNER TO admin;

--
-- TOC entry 2205 (class 1255 OID 146567052)
-- Dependencies: 4536 8
-- Name: setnextcashrcptnumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setnextcashrcptnumber(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pNumber ALIAS FOR $1;
  _orderseqid INTEGER;

BEGIN

  SELECT orderseq_id INTO _orderseqid
  FROM orderseq
  WHERE (orderseq_name='CashRcptNumber');
  IF (FOUND) THEN
    UPDATE orderseq
    SET orderseq_number=pNumber
    WHERE (orderseq_id=_orderseqid);

  ELSE
    INSERT INTO orderseq
    (orderseq_name, orderseq_number)
    VALUES
    ('CashRcptNumber', pNumber);
  END IF;

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.setnextcashrcptnumber(integer) OWNER TO admin;

--
-- TOC entry 2170 (class 1255 OID 146567053)
-- Dependencies: 4536 8
-- Name: setnextchecknumber(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setnextchecknumber(integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pBankaccntid ALIAS FOR $1;
  pNextCheckNumber ALIAS FOR $2;

BEGIN

  UPDATE bankaccnt
  SET bankaccnt_nextchknum=pNextCheckNumber
  WHERE (bankaccnt_id=pBankaccntid);

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.setnextchecknumber(integer, integer) OWNER TO admin;

--
-- TOC entry 2180 (class 1255 OID 146567054)
-- Dependencies: 4536 8
-- Name: setnextcmnumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setnextcmnumber(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pNumber ALIAS FOR $1;
  _orderseqid INTEGER;

BEGIN

  SELECT orderseq_id INTO _orderseqid
  FROM orderseq
  WHERE (orderseq_name='CmNumber');

  IF (NOT FOUND) THEN
    SELECT NEXTVAL('orderseq_orderseq_id_seq') INTO _orderseqid;

    INSERT INTO orderseq (orderseq_id, orderseq_name, orderseq_number)
    VALUES (_orderseqid, 'CmNumber', pNumber);

  ELSE
    UPDATE orderseq
    SET orderseq_number=pNumber
    WHERE (orderseq_name='CmNumber');
  END IF;

  RETURN _orderseqid;

END;
$_$;


ALTER FUNCTION public.setnextcmnumber(integer) OWNER TO admin;

--
-- TOC entry 2194 (class 1255 OID 146567055)
-- Dependencies: 4536 8
-- Name: setnextcrmaccountnumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setnextcrmaccountnumber(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pNumber ALIAS FOR $1;
  _orderseqid INTEGER;

BEGIN

  SELECT orderseq_id INTO _orderseqid
  FROM orderseq
  WHERE (orderseq_name='CRMAccountNumber');

  IF (NOT FOUND) THEN
    SELECT NEXTVAL('orderseq_orderseq_id_seq') INTO _orderseqid;

    INSERT INTO orderseq (orderseq_id, orderseq_name, orderseq_number)
    VALUES (_orderseqid, 'CRMAccountNumber', pNumber);

  ELSE
    UPDATE orderseq
    SET orderseq_number=pNumber
    WHERE (orderseq_name='CRMAccountNumber');
  END IF;

  RETURN _orderseqid;

END;
$_$;


ALTER FUNCTION public.setnextcrmaccountnumber(integer) OWNER TO admin;

--
-- TOC entry 2206 (class 1255 OID 146567056)
-- Dependencies: 4536 8
-- Name: setnextincidentnumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setnextincidentnumber(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pNumber ALIAS FOR $1;
  _orderseqid INTEGER;

BEGIN

  SELECT orderseq_id INTO _orderseqid
  FROM orderseq
  WHERE (orderseq_name='IncidentNumber');

  IF (NOT FOUND) THEN
    SELECT NEXTVAL('orderseq_orderseq_id_seq') INTO _orderseqid;

    INSERT INTO orderseq (orderseq_id, orderseq_name, orderseq_number)
    VALUES (_orderseqid, 'IncidentNumber', pNumber);

  ELSE
    UPDATE orderseq
    SET orderseq_number=pNumber
    WHERE (orderseq_name='IncidentNumber');
  END IF;

  RETURN _orderseqid;

END;
$_$;


ALTER FUNCTION public.setnextincidentnumber(integer) OWNER TO admin;

--
-- TOC entry 2207 (class 1255 OID 146567057)
-- Dependencies: 4536 8
-- Name: setnextinvcnumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setnextinvcnumber(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pNumber ALIAS FOR $1;
  _orderseqid INTEGER;

BEGIN

  SELECT orderseq_id INTO _orderseqid
  FROM orderseq
  WHERE (orderseq_name='InvcNumber');

  IF (NOT FOUND) THEN
    SELECT NEXTVAL('orderseq_orderseq_id_seq') INTO _orderseqid;

    INSERT INTO orderseq (orderseq_id, orderseq_name, orderseq_number)
    VALUES (_orderseqid, 'InvcNumber', pNumber);

  ELSE
    UPDATE orderseq
    SET orderseq_number=pNumber
    WHERE (orderseq_name='InvcNumber');
  END IF;

  RETURN _orderseqid;

END;
$_$;


ALTER FUNCTION public.setnextinvcnumber(integer) OWNER TO admin;

--
-- TOC entry 2208 (class 1255 OID 146567058)
-- Dependencies: 4536 8
-- Name: setnextnumber(text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setnextnumber(text, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  psequence	ALIAS FOR $1;
  pnumber	ALIAS FOR $2;
  _orderseqid	INTEGER;

BEGIN
  SELECT orderseq_id INTO _orderseqid
  FROM orderseq
  WHERE (orderseq_name=psequence);

  IF (NOT FOUND) THEN
    INSERT INTO orderseq (orderseq_name, orderseq_number,
			  orderseq_table, orderseq_numcol)
		  VALUES (psequence,     pnumber,
			  CASE WHEN (psequence='APMemoNumber') THEN 'apopen'
			       WHEN (psequence='ARMemoNumber') THEN 'aropen'
			       WHEN (psequence='CmNumber') THEN 'cmhead'
			       WHEN (psequence='IncidentNumber') THEN 'incdt'
			       WHEN (psequence='InvcNumber') THEN 'invchead'
			       WHEN (psequence='JournalNumber') THEN 'gltrans'
			       WHEN (psequence='PlanNumber') THEN 'planord'
			       WHEN (psequence='PoNumber') THEN 'pohead'
			       WHEN (psequence='PrNumber') THEN 'pr'
			       WHEN (psequence='QuNumber') THEN 'quhead'
			       WHEN (psequence='ShipmentNumber') THEN 'shiphead'
			       WHEN (psequence='SoNumber') THEN 'cohead'
			       WHEN (psequence='ToNumber') THEN 'tohead'
			       WHEN (psequence='VcNumber') THEN 'vohead'
			       WHEN (psequence='WoNumber') THEN 'wo'
			       ELSE ''
			  END,
			  CASE WHEN (psequence='APMemoNumber') THEN 'apopen_docnumber'
			       WHEN (psequence='ARMemoNumber') THEN 'aropen_docnumber'
			       WHEN (psequence='CmNumber') THEN 'cmhead_number'
			       WHEN (psequence='IncidentNumber') THEN 'incdt_number'
			       WHEN (psequence='InvcNumber') THEN 'invchead_invcnumber'
			       WHEN (psequence='JournalNumber') THEN 'gltrans_journalnumber'
			       WHEN (psequence='PlanNumber') THEN 'planord_number'
			       WHEN (psequence='PoNumber') THEN 'pohead_number'
			       WHEN (psequence='PrNumber') THEN 'pr_number'
			       WHEN (psequence='QuNumber') THEN 'quhead_number'
			       WHEN (psequence='ShipmentNumber') THEN 'shiphead_number'
			       WHEN (psequence='SoNumber') THEN 'cohead_number'
			       WHEN (psequence='ToNumber') THEN 'tohead_number'
			       WHEN (psequence='VcNumber') THEN 'vohead_number'
			       WHEN (psequence='WoNumber') THEN 'wo_number'
			       ELSE ''
			  END
			  );
  ELSE
    UPDATE orderseq
    SET orderseq_number=pnumber
    WHERE (orderseq_name=psequence);
  END IF;

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.setnextnumber(text, integer) OWNER TO admin;

--
-- TOC entry 2209 (class 1255 OID 146567059)
-- Dependencies: 4536 8
-- Name: setnextponumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setnextponumber(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pNumber ALIAS FOR $1;
  _orderseqid INTEGER;

BEGIN

  SELECT orderseq_id INTO _orderseqid
  FROM orderseq
  WHERE (orderseq_name='PoNumber');

  IF (NOT FOUND) THEN
    SELECT NEXTVAL('orderseq_orderseq_id_seq') INTO _orderseqid;
    INSERT INTO orderseq (orderseq_id, orderseq_name, orderseq_number)
    VALUES (_orderseqid, 'PoNumber', pNumber);

  ELSE
    UPDATE orderseq
    SET orderseq_number=pNumber
    WHERE (orderseq_name='PoNumber');
  END IF;

  RETURN _orderseqid;

END;
$_$;


ALTER FUNCTION public.setnextponumber(integer) OWNER TO admin;

--
-- TOC entry 2210 (class 1255 OID 146567060)
-- Dependencies: 4536 8
-- Name: setnextprnumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setnextprnumber(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pNumber ALIAS FOR $1;
  _orderseqid INTEGER;

BEGIN

  SELECT orderseq_id INTO _orderseqid
  FROM orderseq
  WHERE (orderseq_name='PrNumber');

  IF (NOT FOUND) THEN
    SELECT NEXTVAL('orderseq_orderseq_id_seq') INTO _orderseqid;
    INSERT INTO orderseq (orderseq_id, orderseq_name, orderseq_number)
    VALUES (_orderseqid, 'PrNumber', pNumber);

  ELSE
    UPDATE orderseq
    SET orderseq_number=pNumber
    WHERE (orderseq_name='PrNumber');
  END IF;

  RETURN _orderseqid;

END;
$_$;


ALTER FUNCTION public.setnextprnumber(integer) OWNER TO admin;

--
-- TOC entry 2211 (class 1255 OID 146567061)
-- Dependencies: 4536 8
-- Name: setnextqunumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setnextqunumber(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pQuNumber ALIAS FOR $1;
  _orderseqid INTEGER;

BEGIN

  SELECT orderseq_id INTO _orderseqid
  FROM orderseq
  WHERE (orderseq_name='QuNumber');

  IF (NOT FOUND) THEN
    SELECT NEXTVAL('orderseq_orderseq_id_seq') INTO _orderseqid;

    INSERT INTO orderseq (orderseq_id, orderseq_name, orderseq_number)
    VALUES (_orderseqid, 'QuNumber', pQuNumber);

  ELSE
    UPDATE orderseq
    SET orderseq_number=pQuNumber
    WHERE (orderseq_name='QuNumber');
  END IF;

  RETURN _orderseqid;

END;
$_$;


ALTER FUNCTION public.setnextqunumber(integer) OWNER TO admin;

--
-- TOC entry 2212 (class 1255 OID 146567062)
-- Dependencies: 4536 8
-- Name: setnextshipmentnumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setnextshipmentnumber(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pShipmentNumber ALIAS FOR $1;
  _orderseqid INTEGER;

BEGIN

  SELECT orderseq_id INTO _orderseqid
  FROM orderseq
  WHERE (orderseq_name='ShipmentNumber');

  IF (NOT FOUND) THEN
    SELECT NEXTVAL('orderseq_orderseq_id_seq') INTO _orderseqid;

    INSERT INTO orderseq (orderseq_id, orderseq_name, orderseq_number)
    VALUES (_orderseqid, 'ShipmentNumber', pShipmentNumber);

  ELSE
    UPDATE orderseq
    SET orderseq_number=pShipmentNumber
    WHERE (orderseq_name='ShipmentNumber');
  END IF;

  RETURN _orderseqid;

END;
$_$;


ALTER FUNCTION public.setnextshipmentnumber(integer) OWNER TO admin;

--
-- TOC entry 2213 (class 1255 OID 146567063)
-- Dependencies: 4536 8
-- Name: setnextsonumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setnextsonumber(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSoNumber ALIAS FOR $1;
  _orderseqid INTEGER;

BEGIN

  SELECT orderseq_id INTO _orderseqid
  FROM orderseq
  WHERE (orderseq_name='SoNumber');

  IF (NOT FOUND) THEN
    SELECT NEXTVAL('orderseq_orderseq_id_seq') INTO _orderseqid;

    INSERT INTO orderseq (orderseq_id, orderseq_name, orderseq_number)
    VALUES (_orderseqid, 'SoNumber', pSoNumber);

  ELSE
    UPDATE orderseq
    SET orderseq_number=pSoNumber
    WHERE (orderseq_name='SoNumber');
  END IF;

  RETURN _orderseqid;

END;
$_$;


ALTER FUNCTION public.setnextsonumber(integer) OWNER TO admin;

--
-- TOC entry 2214 (class 1255 OID 146567064)
-- Dependencies: 4536 8
-- Name: setnextvcnumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setnextvcnumber(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pNumber ALIAS FOR $1;
  _orderseqid INTEGER;

BEGIN

  SELECT orderseq_id INTO _orderseqid
  FROM orderseq
  WHERE (orderseq_name='VcNumber');

  IF (NOT FOUND) THEN
    SELECT NEXTVAL('orderseq_orderseq_id_seq') INTO _orderseqid;
    INSERT INTO orderseq (orderseq_id, orderseq_name, orderseq_number)
    VALUES (_orderseqid, 'VcNumber', pNumber);

  ELSE
    UPDATE orderseq
    SET orderseq_number=pNumber
    WHERE (orderseq_name='VcNumber');
  END IF;

  RETURN _orderseqid;

END;
$_$;


ALTER FUNCTION public.setnextvcnumber(integer) OWNER TO admin;

--
-- TOC entry 2216 (class 1255 OID 146567065)
-- Dependencies: 4536 8
-- Name: setnextwonumber(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setnextwonumber(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pWoNumber ALIAS FOR $1;
  _orderseqid INTEGER;

BEGIN

  SELECT orderseq_id INTO _orderseqid
  FROM orderseq
  WHERE (orderseq_name='WoNumber');

  IF (NOT FOUND) THEN
    SELECT NEXTVAL('orderseq_orderseq_id_seq') INTO _orderseqid;

    INSERT INTO orderseq (orderseq_id, orderseq_name, orderseq_number)
    VALUES (_orderseqid, 'WoNumber', pWoNumber);

  ELSE
    UPDATE orderseq
    SET orderseq_number=pWoNumber
    WHERE (orderseq_name='WoNumber');
  END IF;

  RETURN _orderseqid;

END;
$_$;


ALTER FUNCTION public.setnextwonumber(integer) OWNER TO admin;

--
-- TOC entry 2217 (class 1255 OID 146567066)
-- Dependencies: 4536 8
-- Name: setusercancreateusers(text, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setusercancreateusers(pusername text, pcreateuser boolean) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  IF (pCreateUser) THEN
    EXECUTE 'ALTER USER "' || pUsername || '" CREATEROLE;';
  ELSE
    EXECUTE 'ALTER USER "' || pUsername || '" NOCREATEROLE;';
  END IF;
  RETURN TRUE;
END;
$$;


ALTER FUNCTION public.setusercancreateusers(pusername text, pcreateuser boolean) OWNER TO admin;

--
-- TOC entry 2218 (class 1255 OID 146567067)
-- Dependencies: 4536 8
-- Name: setuserpreference(text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setuserpreference(text, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPrefName ALIAS FOR $1;
  pPrefValue ALIAS FOR $2;

BEGIN
  RETURN setUserPreferences(getEffectiveXtUser(), pPrefName, pPrefValue);
END;
$_$;


ALTER FUNCTION public.setuserpreference(text, text) OWNER TO admin;

--
-- TOC entry 2219 (class 1255 OID 146567068)
-- Dependencies: 4536 8
-- Name: setuserpreference(text, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION setuserpreference(text, text, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pUsername ALIAS FOR $1;
  pPrefName ALIAS FOR $2;
  pPrefValue ALIAS FOR $3;
  _usrprefid INTEGER;

BEGIN

  SELECT usrpref_id INTO _usrprefid
  FROM usrpref
  WHERE ( (usrpref_username=pUsername)
   AND (usrpref_name=pPrefName) );

  IF (FOUND) THEN
    UPDATE usrpref
    SET usrpref_value=pPrefValue
    WHERE (usrpref_id=_usrprefid);

  ELSE
    INSERT INTO usrpref
    (usrpref_username, usrpref_name, usrpref_value)
    VALUES
    (pUsername, pPrefName, pPrefValue);
  END IF;

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.setuserpreference(text, text, text) OWNER TO admin;

--
-- TOC entry 2220 (class 1255 OID 146567069)
-- Dependencies: 4536 8
-- Name: shipments(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION shipments(text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTransType ALIAS FOR $1;

BEGIN
  IF (pTransType IN ('SC', 'SV', 'SH', 'RS', 'TS')) THEN
    RETURN TRUE;
  ELSE
    RETURN FALSE;
  END IF;

END;
$_$;


ALTER FUNCTION public.shipments(text) OWNER TO admin;

--
-- TOC entry 2221 (class 1255 OID 146567070)
-- Dependencies: 8
-- Name: shipshipment(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION shipshipment(integer) RETURNS integer
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
  SELECT shipShipment($1, CURRENT_TIMESTAMP);
$_$;


ALTER FUNCTION public.shipshipment(integer) OWNER TO admin;

--
-- TOC entry 2222 (class 1255 OID 146567071)
-- Dependencies: 4536 8
-- Name: shipshipment(integer, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION shipshipment(integer, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pshipheadid		ALIAS FOR $1;
  _timestamp		TIMESTAMP WITH TIME ZONE := $2;

  _billedQty		NUMERIC;
  _c			RECORD;
  _coholdtype		TEXT;
  _gldate		DATE;
  _invhistid		INTEGER;
  _itemlocSeries	INTEGER;
  _lineitemsToClose     INTEGER[];
  _newQty		NUMERIC;
  _result		INTEGER;
  _s			RECORD;
  _shipcomplete		BOOLEAN;
  _shiphead		RECORD;
  _ti			RECORD;
  _to			RECORD;
  _variance           	NUMERIC;
  _k                    RECORD;

BEGIN

  IF (_timestamp IS NULL) THEN
    _timestamp := CURRENT_TIMESTAMP;
  END IF;
  _gldate := _timestamp::DATE;

  SELECT * INTO _shiphead
  FROM shiphead WHERE (shiphead_id=pshipheadid);
  IF (NOT FOUND) THEN
    RETURN -50;
  END IF;

  IF (_shiphead.shiphead_order_type = 'SO') THEN

    SELECT cohead_shipcomplete, cohead_holdtype INTO _shipcomplete, _coholdtype
      FROM cohead, shiphead
     WHERE ((shiphead_order_id=cohead_id)
       AND  (NOT shiphead_shipped)
       AND  (shiphead_order_type=_shiphead.shiphead_order_type)
       AND  (shiphead_id=pshipheadid));

    IF (_coholdtype = 'C') THEN
      RETURN -12;
    ELSIF (_coholdtype = 'P') THEN
      RETURN -13;
    ELSIF (_coholdtype = 'R') THEN
      RETURN -14;
    ELSIF (_coholdtype = 'S') THEN
      RETURN -15;
    END IF;

---Must Ship Kit components (coitem_subnumber <> 0 complete---------------
    IF ((
         --  Test to see if order's customer accepts backorders and partials
         --  If not then test for shipping kit components complete
        SELECT cohead_number
        FROM shiphead, cohead, custinfo
        WHERE
          (shiphead_order_id = cohead_id) AND
          (cohead_cust_id = cust_id) AND
          (shiphead_order_type = 'SO') AND
          (cust_partialship) AND
          (cust_backorder) AND
          (shiphead_id = pshipheadid)
         ) IS NULL) THEN
      FOR _k IN SELECT (coitem_qtyord -
			(COALESCE(SUM(shipitem_qty),0) +
			 (coitem_qtyshipped - coitem_qtyreturned))) AS remain
		  FROM (coitem LEFT OUTER JOIN (itemsite JOIN item ON (itemsite_item_id=item_id)) ON (coitem_itemsite_id=itemsite_id)) LEFT OUTER JOIN
		       shipitem ON (shipitem_orderitem_id=coitem_id
		                AND shipitem_shiphead_id=pshipheadid)
		 WHERE ((coitem_status NOT IN ('C','X'))
                   AND  (item_type != 'K')
		   AND  (coitem_cohead_id=_shiphead.shiphead_order_id)
                   AND  (coitem_subnumber <> 0)
		   )
	      GROUP BY coitem_id, coitem_qtyshipped, coitem_qtyord,
		       coitem_qtyreturned LOOP
	IF (_k.remain > 0) THEN
	  RAISE EXCEPTION 'Kit component item not shipped complete.  Kits must be shipped and shipped complete or closed on the order.';
	END IF;
      END LOOP;
    END IF;
---End--------------------------------------------------------------------

    IF ( _shipcomplete ) THEN
      FOR _c IN SELECT (coitem_qtyord -
			(COALESCE(SUM(shipitem_qty),0) +
			 (coitem_qtyshipped - coitem_qtyreturned))) AS remain
		  FROM (coitem LEFT OUTER JOIN (itemsite JOIN item ON (itemsite_item_id=item_id)) ON (coitem_itemsite_id=itemsite_id)) LEFT OUTER JOIN
		       shipitem ON (shipitem_orderitem_id=coitem_id
		                AND shipitem_shiphead_id=pshipheadid)
		 WHERE ((coitem_status<>'X')
                   AND  (item_type != 'K')
		   AND  (coitem_cohead_id=_shiphead.shiphead_order_id))
	      GROUP BY coitem_id, coitem_qtyshipped, coitem_qtyord,
		       coitem_qtyreturned LOOP
	IF (_c.remain > 0) THEN
	  RETURN -99;
	END IF;
      END LOOP;
    END IF;

    FOR _c IN SELECT coitem_id, cohead_number, cohead_cust_id, cohead_billtoname, cohead_prj_id,
                     cohead_saletype_id, cohead_shipzone_id,
		     itemsite_id, itemsite_item_id,
                     coitem_qty_invuomratio,
                     coitem_warranty, coitem_cos_accnt_id,
		     SUM(shipitem_qty) AS _qty,
                     SUM(shipitem_value) AS _value
	      FROM coitem, cohead, shiphead, shipitem, itemsite
	      WHERE ( (coitem_cohead_id=cohead_id)
	       AND (coitem_itemsite_id=itemsite_id)
	       AND (shiphead_order_id=cohead_id)
	       AND (shipitem_shiphead_id=shiphead_id)
	       AND (shipitem_orderitem_id=coitem_id)
	       AND (NOT shiphead_shipped)
	       AND (shiphead_id=pshipheadid) )
	      GROUP BY coitem_id, coitem_qty_invuomratio, cohead_number, cohead_cust_id, cohead_billtoname,
           itemsite_id, itemsite_item_id, coitem_warranty, coitem_cos_accnt_id, cohead_prj_id, cohead_saletype_id, cohead_shipzone_id
    LOOP

      IF _c._value > 0 THEN
  --    Distribute to G/L, credit Shipping Asset, debit COS
	SELECT MIN(insertGLTransaction( 'S/R', 'SH', _shiphead.shiphead_number,
                                        ('Ship Order ' || _c.cohead_number || ' for Customer ' || _c.cohead_billtoname),
                                        getPrjAccntId(_c.cohead_prj_id, costcat_shipasset_accnt_id),
                                        CASE WHEN (COALESCE(_c.coitem_cos_accnt_id, -1) != -1)
                                               THEN getPrjAccntId(_c.cohead_prj_id, _c.coitem_cos_accnt_id)
                                             WHEN (_c.coitem_warranty=TRUE)
                                               THEN getPrjAccntId(_c.cohead_prj_id, resolveCOWAccount(itemsite_id, _c.cohead_cust_id, _c.cohead_saletype_id, _c.cohead_shipzone_id))
                                             ELSE getPrjAccntId(_c.cohead_prj_id, resolveCOSAccount(itemsite_id, _c.cohead_cust_id, _c.cohead_saletype_id, _c.cohead_shipzone_id))
                                        END,
                                        -1, _c._value, _gldate )) INTO _result
	FROM itemsite, costcat
	WHERE ( (itemsite_costcat_id=costcat_id)
	AND (itemsite_id=_c.itemsite_id) );

	IF (_result < 0 AND _result != -3) THEN -- ignore -3 as it just means it's not posting a 0 value
	  RETURN _result;
	END IF;

      END IF;

      UPDATE coitem
      SET coitem_qtyshipped = (coitem_qtyshipped + _c._qty)
      WHERE (coitem_id=_c.coitem_id);

      -- check to see if we have more invoiced than shipped items
      -- if we do we will need to mark some of these records as invoiced
      SELECT noNeg(( SELECT COALESCE(SUM(cobill_qty), 0.0)
		     FROM cobill, cobmisc, coitem
		     WHERE ( (cobill_cobmisc_id=cobmisc_id)
		      AND (cobmisc_cohead_id=coitem_cohead_id)
		      AND (cobill_coitem_id=coitem_id)
		      AND (cobmisc_posted)
		      AND (coitem_id=_c.coitem_id) )
		   ) - ( SELECT COALESCE(SUM(shipitem_qty), 0.0)
			 FROM shipitem, shiphead, coitem
			 WHERE ( (shipitem_shiphead_id=shiphead_id)
			  AND (shiphead_order_id=coitem_cohead_id)
			  AND (shipitem_orderitem_id=coitem_id)
			  AND (shiphead_order_type=_shiphead.shiphead_order_type)
			  AND (shiphead_shipped)
			  AND (coitem_id=_c.coitem_id) )
		       ) ) INTO _billedQty;

      IF (_billedQty > 0.0) THEN
	FOR _s IN SELECT shipitem_id, shipitem_qty
		  FROM shipitem, shiphead
		  WHERE ( (shipitem_shiphead_id=shiphead_id)
		   AND (shipitem_orderitem_id=_c.coitem_id)
		   AND (shiphead_order_type=_shiphead.shiphead_order_type)
		   AND (NOT shiphead_shipped)
		   AND (shiphead_id=pshipheadid) )
		  ORDER BY shipitem_qty LOOP

	  IF (_billedQty > 0.0) THEN

	    IF (_billedQty >= _s.shipitem_qty) THEN
	      UPDATE shipitem SET shipitem_invoiced=TRUE WHERE shipitem_id=_s.shipitem_id;
              -- must wait to close coitems until after shiphead_shipped -> true
              _lineitemsToClose := _lineitemsToClose || _c.coitem_id;
	    ELSE
	      _newQty := _s.shipitem_qty - _billedQty;
	      UPDATE shipitem SET shipitem_invoiced=TRUE, shipitem_qty=_billedQty WHERE shipitem_id=_s.shipitem_id;
	      INSERT INTO shipitem ( shipitem_orderitem_id, shipitem_shipdate,
		shipitem_qty, shipitem_transdate, shipitem_invoiced,
		shipitem_shiphead_id, shipitem_trans_username)
	      SELECT shipitem_orderitem_id, shipitem_shipdate,
		_newQty, shipitem_transdate, FALSE,
		shipitem_shiphead_id, shipitem_trans_username
	      FROM shipitem
	      WHERE (shipitem_id=_s.shipitem_id);
	    END IF;

	    _billedQty := _billedQty - _s.shipitem_qty;
	  END IF;
	END LOOP;

      END IF;
    END LOOP;

  ELSEIF (_shiphead.shiphead_order_type = 'TO') THEN
    IF (_shiphead.shiphead_shipped) THEN
      RETURN -8;
    END IF;

    SELECT tohead.* INTO _to
      FROM tohead
     WHERE (tohead_id=_shiphead.shiphead_order_id);

    IF ( _to.tohead_shipcomplete ) THEN
      -- use sufficientInventory...()?
      FOR _ti IN SELECT (toitem_qty_ordered -
			 (COALESCE(SUM(shipitem_qty),0) + toitem_qty_shipped)) AS remain
		  FROM toitem LEFT OUTER JOIN
		       shipitem ON (shipitem_orderitem_id=toitem_id)
		 WHERE ((toitem_status<>'X')
		   AND  (toitem_tohead_id=_shiphead.shiphead_order_id))
	      GROUP BY toitem_qty_shipped, toitem_qty_ordered LOOP
	IF (_ti.remain > 0) THEN
	  RETURN -99;
	END IF;
      END LOOP;
    END IF;

    FOR _ti IN SELECT toitem_id, toitem_item_id, SUM(shipitem_qty) AS qty, SUM(shipitem_value) AS value
		FROM toitem, shipitem
		WHERE ((toitem_tohead_id=_to.tohead_id)
		  AND  (shipitem_orderitem_id=toitem_id)
		  AND  (shipitem_shiphead_id=pshipheadid))
		GROUP BY toitem_id, toitem_item_id LOOP

      IF (NOT EXISTS(SELECT itemsite_id
		     FROM itemsite
		     WHERE ((itemsite_item_id=_ti.toitem_item_id)
		     AND  (itemsite_warehous_id = _to.tohead_trns_warehous_id))
		     )) THEN
	RETURN -6;
      END IF;

      _itemlocSeries := NEXTVAL('itemloc_series_seq');

      SELECT postInvTrans(si.itemsite_id, 'TS', _ti.qty,
                          'I/M', _shiphead.shiphead_order_type,
                          formatToNumber(_ti.toitem_id), _to.tohead_number,
			  'Ship from Src to Transit Warehouse',
			  tc.costcat_asset_accnt_id,
			  sc.costcat_shipasset_accnt_id,
			  _itemlocSeries, _timestamp, _ti.value) INTO _invhistid
      FROM itemsite AS ti, costcat AS tc,
	   itemsite AS si, costcat AS sc
      WHERE ( (ti.itemsite_costcat_id=tc.costcat_id)
        AND  (si.itemsite_costcat_id=sc.costcat_id)
        AND  (ti.itemsite_item_id=_ti.toitem_item_id)
        AND  (si.itemsite_item_id=_ti.toitem_item_id)
        AND  (ti.itemsite_warehous_id=_to.tohead_trns_warehous_id)
        AND  (si.itemsite_warehous_id=_to.tohead_src_warehous_id) );

      --We do not need to distribute lot/serial info for transit, post trans and discard dist detail
      PERFORM postIntoTrialBalance(itemlocpost_glseq) FROM itemlocpost WHERE (itemlocpost_itemlocseries=_itemlocSeries);
      IF (_invhistid > 0) THEN
        PERFORM postInvHist(_invhistid);
      END IF;
      DELETE FROM itemlocdist WHERE (itemlocdist_series=_itemlocSeries);
      DELETE FROM itemlocpost WHERE (itemlocpost_itemlocSeries=_itemlocSeries);

      IF (_result < 0) THEN
	RETURN _result;
      END IF;

      -- record inventory history and qoh changes at transit warehouse but
      -- there is only one g/l account to touch
      SELECT postInvTrans(ti.itemsite_id, 'TR', _ti.qty,
                          'I/M', _shiphead.shiphead_order_type,
                          formatToNumber(_ti.toitem_id), _to.tohead_number,
			  'Receive into Transit from Src Warehouse',
			  tc.costcat_asset_accnt_id,
			  tc.costcat_asset_accnt_id,
			  _itemlocSeries, _timestamp,
			  _ti.value) INTO _invhistid
      FROM itemsite AS ti, costcat AS tc
      WHERE ((ti.itemsite_costcat_id=tc.costcat_id)
        AND  (ti.itemsite_item_id=_ti.toitem_item_id)
        AND  (ti.itemsite_warehous_id=_to.tohead_trns_warehous_id));
      --We do not need to distribute lot/serial info for transit, post trans and discard dist detail
      PERFORM postIntoTrialBalance(itemlocpost_glseq) FROM itemlocpost WHERE (itemlocpost_itemlocseries=_itemlocSeries);
      IF (_invhistid > 0) THEN
        PERFORM postInvHist(_invhistid);
      END IF;
      DELETE FROM itemlocdist WHERE (itemlocdist_series=_itemlocSeries);
      DELETE FROM itemlocpost WHERE (itemlocpost_itemlocSeries=_itemlocSeries);

      --See if there was a change in values during the transfer, if so record the variance
      SELECT (invhist_invqty * invhist_unitcost - _ti.value) INTO _variance
      FROM invhist
      WHERE (invhist_id=_invhistid);

      IF (_variance > 0) THEN
        PERFORM insertGLTransaction( 'S/R', _shiphead.shiphead_order_type, _to.tohead_number,
                                     'Transfer Order - Transfer Variance',
                                     tc.costcat_invcost_accnt_id, tc.costcat_asset_accnt_id, _invhistid,
                                     _variance,
                                     CAST(_timestamp AS DATE) )
        FROM itemsite AS ti, costcat AS tc
        WHERE ( (ti.itemsite_costcat_id=tc.costcat_id)
        AND  (ti.itemsite_item_id=_ti.toitem_item_id)
        AND  (ti.itemsite_warehous_id=_to.tohead_trns_warehous_id) );
      END IF;

      IF (_result < 0) THEN
	RETURN _result;
      END IF;

      UPDATE shipitem SET shipitem_shipdate=_timestamp, shipitem_shipped=TRUE
      WHERE ((shipitem_orderitem_id=_ti.toitem_id)
        AND  (shipitem_shiphead_id=pshipheadid));

      UPDATE toitem
      SET toitem_qty_shipped = (toitem_qty_shipped + _ti.qty)
      WHERE (toitem_id=_ti.toitem_id);
    END LOOP;
  END IF;

  UPDATE shiphead
  SET shiphead_shipped=TRUE, shiphead_shipdate=_gldate
  WHERE (shiphead_id=pshipheadid);

  -- now try to close line items that are fully shipped and invoiced
  IF (_shiphead.shiphead_order_type = 'SO') THEN
    UPDATE coitem SET coitem_status='C'
    WHERE ((coitem_id = ANY (_lineitemsToClose))
      AND  (coitem_qtyshipped >= coitem_qtyord));
  END IF;

  RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.shipshipment(integer, timestamp with time zone) OWNER TO admin;

--
-- TOC entry 2223 (class 1255 OID 146567073)
-- Dependencies: 4536 8
-- Name: singlecharacteristicstostring(text, integer, text, text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION singlecharacteristicstostring(text, integer, text, text, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTargetType ALIAS FOR $1;
  pTargetId ALIAS FOR $2;
  pValKeySep ALIAS FOR $3;
  pPairSep ALIAS FOR $4;
  pCharId ALIAS FOR $5;
  _string TEXT := '';
  _extra BOOLEAN := false;
  _r RECORD;
BEGIN
  FOR _r IN SELECT char_name, charass_value
              FROM charass, char
             WHERE ((charass_char_id=char_id)
               AND  (charass_char_id=pCharId)
               AND  (charass_target_type=pTargetType)
               AND  (charass_target_id=pTargetId)) LOOP
    IF(_extra) THEN
      _string := _string || pPairSep;
    END IF;
    _extra := true;

    _string := _string || _r.char_name || pValKeySep || _r.charass_value;
  END LOOP;

  RETURN _string;
END;
$_$;


ALTER FUNCTION public.singlecharacteristicstostring(text, integer, text, text, integer) OWNER TO admin;

--
-- TOC entry 2224 (class 1255 OID 146567074)
-- Dependencies: 2657 4536 8
-- Name: singlelevelbom(integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION singlelevelbom(integer, integer, integer, integer) RETURNS SETOF bomdata
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pRevisionid ALIAS FOR $2;
  pExpiredDays ALIAS FOR $3;
  pFutureDays ALIAS FOR $4;
  _row bomdata%ROWTYPE;
  _bomworksetid INTEGER;
  _x RECORD;
  _check CHAR(1);
  _inactive BOOLEAN;
  _batchsize NUMERIC;

BEGIN

  _inactive := FALSE;

  IF (pRevisionid != -1) THEN
    --Is this a deactivated revision?
    SELECT rev_status INTO _check
    FROM rev
    WHERE ((rev_id=pRevisionid)
    AND (rev_status='I'));
    IF (FOUND) THEN
      _inactive := TRUE;
    END IF;
  END IF;

  -- Get the batch quantity
  SELECT COALESCE( (
    SELECT bomhead_batchsize
    FROM bomhead
    WHERE ((bomhead_item_id=pItemId)
    AND (bomhead_rev_id=pRevisionid))),1) INTO _batchsize;

  IF NOT (_inactive) THEN
    FOR _x IN
        SELECT bomitem_id, bomitem_seqnumber, bomitem_seqnumber AS f_bomitem_seqnumber,
               item_id, item_number, uom_name,
               item_descrip1, item_descrip2,
               (item_descrip1 || ' ' || item_descrip2) AS itemdescription,
               (itemuomtouomratio(bomitem_item_id, bomitem_uom_id, NULL) * bomitem_qtyfxd) AS qtyfxd,
               (itemuomtouomratio(bomitem_item_id, bomitem_uom_id, NULL) * bomitem_qtyper) AS qtyper,
               bomitem_scrap, bomitem_createwo,
               CASE WHEN (bomitem_issuemethod='S') THEN 'Push'
                 WHEN (bomitem_issuemethod='L') THEN 'Pull'
                 WHEN (bomitem_issuemethod='M') THEN 'Mixed'
                 ELSE 'Special'
               END AS issuemethod,
               bomitem_effective, bomitem_expires,
               CASE WHEN (bomitem_expires <= CURRENT_DATE) THEN TRUE
                 ELSE FALSE
               END AS expired,
               CASE WHEN (bomitem_effective > CURRENT_DATE) THEN TRUE
                 ELSE FALSE
               END AS future,
               actcost(bomitem_item_id, bomitem_id) AS actunitcost,
               stdcost(bomitem_item_id, bomitem_id) AS stdunitcost,
               CASE WHEN item_type NOT IN ('R','T') THEN
                 itemuomtouom(bomitem_item_id, bomitem_uom_id, NULL,
                              (bomitem_qtyfxd/_batchsize + bomitem_qtyper) * (1 + bomitem_scrap), 'qtyper') * actcost(bomitem_item_id, bomitem_id)
               ELSE 0.0 END AS actextendedcost,
               CASE WHEN item_type NOT IN ('R','T') THEN
                 itemuomtouom(bomitem_item_id, bomitem_uom_id, NULL,
                              (bomitem_qtyfxd/_batchsize + bomitem_qtyper) * (1 + bomitem_scrap), 'qtyper') * stdcost(bomitem_item_id, bomitem_id)
               ELSE 0.0 END AS stdextendedcost,
               bomitem_char_id, bomitem_value, bomitem_notes, bomitem_ref
       FROM bomitem(pItemid,pRevisionid), item, uom
       WHERE ( (item_inv_uom_id=uom_id)
       AND (bomitem_item_id=item_id)
       AND (bomitem_expires > (CURRENT_DATE - pExpiredDays))
       AND (bomitem_effective <= (CURRENT_DATE + pFutureDays)) )
       UNION
       SELECT -1, -1, NULL, -1, costelem_type AS bomdata_item_number, '',
              '', '',
              '',
              NULL,
              NULL,
              NULL, NULL,
              NULL,
              NULL, NULL,
              false,false,
              currToBase(itemcost_curr_id, itemcost_actcost, CURRENT_DATE) AS actunitcost,
              itemcost_stdcost AS stdunitcost,
              currToBase(itemcost_curr_id, itemcost_actcost, CURRENT_DATE) AS actextendedcost,
              itemcost_stdcost AS stdextendedcost,
              NULL, NULL, NULL, NULL
       FROM itemcost, costelem
       WHERE ( (itemcost_costelem_id=costelem_id)
       AND (NOT itemcost_lowlevel)
       AND (itemcost_item_id=pItemid) )
       ORDER BY bomitem_seqnumber, bomitem_effective, item_number
    LOOP
        _row.bomdata_bomitem_id := _x.bomitem_id;
        _row.bomdata_bomwork_seqnumber := _x.f_bomitem_seqnumber;
        _row.bomdata_item_id := _x.item_id;
        _row.bomdata_item_number := _x.item_number;
        _row.bomdata_uom_name := _x.uom_name;
        _row.bomdata_item_descrip1 := _x.item_descrip1;
        _row.bomdata_item_descrip2 := _x.item_descrip2;
        _row.bomdata_itemdescription := _x.itemdescription;
        _row.bomdata_batchsize := _batchsize;
        _row.bomdata_qtyfxd := _x.qtyfxd;
        _row.bomdata_qtyper := _x.qtyper;
        _row.bomdata_scrap := _x.bomitem_scrap;
        _row.bomdata_createchild := _x.bomitem_createwo;
        _row.bomdata_issuemethod := _x.issuemethod;
        _row.bomdata_effective := _x.bomitem_effective;
        _row.bomdata_expires := _x.bomitem_expires;
        _row.bomdata_expired := _x.expired;
        _row.bomdata_future := _x.future;
        _row.bomdata_actunitcost := _x.actunitcost;
        _row.bomdata_stdunitcost := _x.stdunitcost;
        _row.bomdata_actextendedcost := _x.actextendedcost;
        _row.bomdata_stdextendedcost := _x.stdextendedcost;
        _row.bomdata_char_id := _x.bomitem_char_id;
        _row.bomdata_value := _x.bomitem_value;
        _row.bomdata_notes := _x.bomitem_notes;
        _row.bomdata_ref := _x.bomitem_ref;
        RETURN NEXT _row;
    END LOOP;

   ELSE

-- Use historical snapshot for inactive revisions
    FOR _x IN
        SELECT bomitem_id, bomitem_seqnumber, bomitem_seqnumber AS f_bomitem_seqnumber,
               item_id, item_number, uom_name,
               item_descrip1, item_descrip2,
               (item_descrip1 || ' ' || item_descrip2) AS itemdescription,
               (itemuomtouomratio(bomitem_item_id, bomitem_uom_id, NULL) * bomitem_qtyfxd) AS qtyfxd,
               (itemuomtouomratio(bomitem_item_id, bomitem_uom_id, NULL) * bomitem_qtyper) AS qtyper,
               bomitem_scrap, bomitem_createwo,
               CASE WHEN (bomitem_issuemethod='S') THEN 'Push'
                 WHEN (bomitem_issuemethod='L') THEN 'Pull'
                 WHEN (bomitem_issuemethod='M') THEN 'Mixed'
                 ELSE 'Special'
               END AS issuemethod,
               bomitem_effective, bomitem_expires,
               CASE WHEN (bomitem_expires <= CURRENT_DATE) THEN TRUE
                 ELSE FALSE
               END AS expired,
               CASE WHEN (bomitem_effective > CURRENT_DATE) THEN TRUE
                 ELSE FALSE
               END AS future,
               actcost(bomitem_item_id) AS actunitcost,
               stdcost(bomitem_item_id) AS stdunitcost,
               CASE WHEN item_type NOT IN ('R','T') THEN
                 itemuomtouom(bomitem_item_id, bomitem_uom_id, NULL,
                              (bomitem_qtyfxd/_batchsize + bomitem_qtyper) * (1 + bomitem_scrap), 'qtyper') * actcost(bomitem_item_id)
               ELSE 0.0 END AS actextendedcost,
               CASE WHEN item_type NOT IN ('R','T') THEN
                 itemuomtouom(bomitem_item_id, bomitem_uom_id, NULL,
                              (bomitem_qtyfxd/_batchsize + bomitem_qtyper) * (1 + bomitem_scrap), 'qtyper') * stdcost(bomitem_item_id)
               ELSE 0.0 END AS stdextendedcost,
               bomitem_char_id, bomitem_value, bomitem_notes, bomitem_ref
       FROM bomitem(pItemid,pRevisionid), item, uom
       WHERE ( (item_inv_uom_id=uom_id)
       AND (bomitem_item_id=item_id)
       AND (bomitem_expires > (CURRENT_DATE - pExpiredDays))
       AND (bomitem_effective <= (CURRENT_DATE + pFutureDays)) )
       UNION
       SELECT -1, -1, NULL, -1, costelem_type AS bomdata_item_number, '',
              '', '',
              '',
              NULL,
              NULL,
              NULL, NULL,
              NULL,
              NULL, NULL,
              false,false,
              bomhist_actunitcost AS actunitcost,
              bomhist_stdunitcost AS stdunitcost,
              bomhist_actunitcost AS actextendedcost,
              bomhist_stdunitcost AS stdextendedcost,
              NULL, NULL, NULL, NULL
       FROM bomhist, costelem
       WHERE ( (bomhist_item_id=costelem_id)
       AND (bomhist_item_type='E')
       AND (bomhist_rev_id=pRevisionid) )
       ORDER BY bomitem_seqnumber, bomitem_effective, item_number
    LOOP
        _row.bomdata_bomitem_id := _x.bomitem_id;
        _row.bomdata_bomwork_seqnumber := _x.f_bomitem_seqnumber;
        _row.bomdata_item_id := _x.item_id;
        _row.bomdata_item_number := _x.item_number;
        _row.bomdata_uom_name := _x.uom_name;
        _row.bomdata_item_descrip1 := _x.item_descrip1;
        _row.bomdata_item_descrip2 := _x.item_descrip2;
        _row.bomdata_itemdescription := _x.itemdescription;
        _row.bomdata_batchsize := _batchsize;
        _row.bomdata_qtyfxd := _x.qtyfxd;
        _row.bomdata_qtyper := _x.qtyper;
        _row.bomdata_scrap := _x.bomitem_scrap;
        _row.bomdata_createchild := _x.bomitem_createwo;
        _row.bomdata_issuemethod := _x.issuemethod;
        _row.bomdata_effective := _x.bomitem_effective;
        _row.bomdata_expires := _x.bomitem_expires;
        _row.bomdata_expired := _x.expired;
        _row.bomdata_future := _x.future;
        _row.bomdata_actunitcost := _x.actunitcost;
        _row.bomdata_stdunitcost := _x.stdunitcost;
        _row.bomdata_actextendedcost := _x.actextendedcost;
        _row.bomdata_stdextendedcost := _x.stdextendedcost;
        _row.bomdata_char_id := _x.bomitem_char_id;
        _row.bomdata_value := _x.bomitem_value;
        _row.bomdata_notes := _x.bomitem_notes;
        _row.bomdata_ref := _x.bomitem_ref;
        RETURN NEXT _row;
    END LOOP;
  END IF;

  RETURN;
END;
$_$;


ALTER FUNCTION public.singlelevelbom(integer, integer, integer, integer) OWNER TO admin;

--
-- TOC entry 2225 (class 1255 OID 146567076)
-- Dependencies: 2736 4536 8
-- Name: site(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION site() RETURNS SETOF whsinfo
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _row whsinfo%ROWTYPE;
  _r RECORD;

BEGIN

  IF ( (fetchMetricBool('MultiWhs')) AND
       (SELECT (COUNT(usrpref_id)=1)
        FROM usrpref
        WHERE ((usrpref_name='selectedSites')
        AND (usrpref_value='t')
        AND (usrpref_username=getEffectiveXtUser()))) ) THEN

    FOR _r IN SELECT *
            FROM whsinfo,usrsite
            WHERE ((warehous_id=usrsite_warehous_id)
            AND (usrsite_username=getEffectiveXtUser()))
    LOOP
      _row.warehous_id:=_r.warehous_id;
      _row.warehous_code:=_r.warehous_code;
      _row.warehous_descrip:=_r.warehous_descrip;
      _row.warehous_fob:=_r.warehous_fob;
      _row.warehous_active:=_r.warehous_active;
      _row.warehous_counttag_prefix:=_r.warehous_counttag_prefix;
      _row.warehous_counttag_number:=_r.warehous_counttag_number;
      _row.warehous_bol_prefix:=_r.warehous_bol_prefix;
      _row.warehous_bol_number:=_r.warehous_bol_number;
      _row.warehous_shipping:=_r.warehous_shipping;
      _row.warehous_useslips:=_r.warehous_useslips;
      _row.warehous_usezones:=_r.warehous_usezones;
      _row.warehous_aislesize:=_r.warehous_aislesize;
      _row.warehous_racksize:=_r.warehous_racksize;
      _row.warehous_binsize:=_r.warehous_binsize;
      _row.warehous_binalpha:=_r.warehous_binalpha;
      _row.warehous_locationsize:=_r.warehous_locationsize;
      _row.warehous_locationalpha:=_r.warehous_locationalpha;
      _row.warehous_enforcearbl:=_r.warehous_enforcearbl;
      _row.warehous_default_accnt_id:=_r.warehous_default_accnt_id;
      _row.warehous_shipping_commission:=_r.warehous_shipping_commission;
      _row.warehous_cntct_id:=_r.warehous_cntct_id;
      _row.warehous_addr_id:=_r.warehous_addr_id;
      _row.warehous_taxzone_id:=_r.warehous_taxzone_id;
      _row.warehous_transit:=_r.warehous_transit;
      _row.warehous_shipform_id:=_r.warehous_shipform_id;
      _row.warehous_shipvia_id:=_r.warehous_shipvia_id;
      _row.warehous_shipcomments:=_r.warehous_shipcomments;
      _row.warehous_costcat_id:=_r.warehous_costcat_id;
      _row.warehous_sitetype_id:=_r.warehous_sitetype_id;

      RETURN NEXT _row;
    END LOOP;
  ELSE
    FOR _r IN SELECT *
            FROM whsinfo
    LOOP
      _row.warehous_id:=_r.warehous_id;
      _row.warehous_code:=_r.warehous_code;
      _row.warehous_descrip:=_r.warehous_descrip;
      _row.warehous_fob:=_r.warehous_fob;
      _row.warehous_active:=_r.warehous_active;
      _row.warehous_counttag_prefix:=_r.warehous_counttag_prefix;
      _row.warehous_counttag_number:=_r.warehous_counttag_number;
      _row.warehous_bol_prefix:=_r.warehous_bol_prefix;
      _row.warehous_bol_number:=_r.warehous_bol_number;
      _row.warehous_shipping:=_r.warehous_shipping;
      _row.warehous_useslips:=_r.warehous_useslips;
      _row.warehous_usezones:=_r.warehous_usezones;
      _row.warehous_aislesize:=_r.warehous_aislesize;
      _row.warehous_racksize:=_r.warehous_racksize;
      _row.warehous_binsize:=_r.warehous_binsize;
      _row.warehous_binalpha:=_r.warehous_binalpha;
      _row.warehous_locationsize:=_r.warehous_locationsize;
      _row.warehous_locationalpha:=_r.warehous_locationalpha;
      _row.warehous_enforcearbl:=_r.warehous_enforcearbl;
      _row.warehous_default_accnt_id:=_r.warehous_default_accnt_id;
      _row.warehous_shipping_commission:=_r.warehous_shipping_commission;
      _row.warehous_cntct_id:=_r.warehous_cntct_id;
      _row.warehous_addr_id:=_r.warehous_addr_id;
      _row.warehous_taxzone_id:=_r.warehous_taxzone_id;
      _row.warehous_transit:=_r.warehous_transit;
      _row.warehous_shipform_id:=_r.warehous_shipform_id;
      _row.warehous_shipvia_id:=_r.warehous_shipvia_id;
      _row.warehous_shipcomments:=_r.warehous_shipcomments;
      _row.warehous_costcat_id:=_r.warehous_costcat_id;
      _row.warehous_sitetype_id:=_r.warehous_sitetype_id;

      RETURN NEXT _row;
    END LOOP;
  END IF;

  RETURN;
END;
$$;


ALTER FUNCTION public.site() OWNER TO admin;

--
-- TOC entry 2226 (class 1255 OID 146567077)
-- Dependencies: 4536 8
-- Name: snoozemessage(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION snoozemessage(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pMsgid ALIAS FOR $1;
  snooze INTERVAL := '10 minutes';

BEGIN

  UPDATE msg
  SET msg_scheduled=(msg_scheduled + snooze)
  WHERE (msg_id=pMsgid);

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.snoozemessage(integer) OWNER TO admin;

--
-- TOC entry 2227 (class 1255 OID 146567078)
-- Dependencies: 4536 8
-- Name: spellamount(numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION spellamount(numeric) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN spellAmount($1, baseCurrId());
END;
$_$;


ALTER FUNCTION public.spellamount(numeric) OWNER TO admin;

--
-- TOC entry 2230 (class 1255 OID 146567079)
-- Dependencies: 4536 8
-- Name: spellamount(numeric, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION spellamount(numeric, integer) RETURNS text
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pN ALIAS FOR $1;
  pCurrId ALIAS FOR $2;
  _t text;
  _dollars text;
  _cents text;
  _l integer;
  _p integer;
  _words text;
  _word text;
  _hundreds char;
  _tens char;
  _ones char;
  _fractionalPartName text;
  _curr curr_symbol%ROWTYPE;
BEGIN

  _t := ltrim(to_char(pN, '999999999990D99'),' ');
  IF strpos(_t, '.') > 0 THEN
    _dollars := split_part(_t, '.', 1);
    _cents := split_part(_t, '.', 2);
  ELSIF strpos(_t, ',') > 0 THEN
    _dollars := split_part(_t, ',', 1);
    _cents := split_part(_t, ',', 2);
  END IF;

  _p := 0;
  _l := length(_dollars);

  _words := '';
  WHILE (_p < _l) LOOP
    IF((_l - _p - 2) < 1) THEN
      _hundreds := '0';
    ELSE
      _hundreds := substr(_dollars, _l - _p - 2, 1);
    END IF;
    IF((_l - _p - 1) < 1) THEN
      _tens := '0';
    ELSE
      _tens := substr(_dollars, _l - _p - 1, 1);
    END IF;
    IF((_l - _p) < 1) THEN
      _ones := '0';
    ELSE
      _ones := substr(_dollars, _l - _p, 1);
    END IF;

    IF(_hundreds != '0' OR _tens != '0' OR _ones != '0') THEN
      IF (_p = 3) THEN
        _words := 'thousand ' || _words;
      ELSIF (_p = 6) THEN
        _words := 'million ' || _words;
      ELSIF (_p = 9) THEN
        _words := 'billion ' || _words;
      END IF;

      _word := '';
      IF(_tens = '1') THEN
        IF(_ones = '0') THEN
          _word := 'ten';
        ELSIF(_ones = '1') THEN
          _word := 'eleven';
        ELSIF(_ones = '2') THEN
          _word := 'twelve';
        ELSIF(_ones = '3') THEN
          _word := 'thirteen';
        ELSIF(_ones = '4') THEN
          _word := 'fourteen';
        ELSIF(_ones = '5') THEN
          _word := 'fifteen';
        ELSIF(_ones = '6') THEN
          _word := 'sixteen';
        ELSIF(_ones = '7') THEN
          _word := 'seventeen';
        ELSIF(_ones = '8') THEN
          _word := 'eighteen';
        ELSIF(_ones = '9') THEN
          _word := 'nineteen';
        ELSE
          _word := 'ERROR';
        END IF;
      ELSE
        IF(_ones = '1') THEN
          _word := 'one';
        ELSIF(_ones = '2') THEN
          _word := 'two';
        ELSIF(_ones = '3') THEN
          _word := 'three';
        ELSIF(_ones = '4') THEN
          _word := 'four';
        ELSIF(_ones = '5') THEN
          _word := 'five';
        ELSIF(_ones = '6') THEN
          _word := 'six';
        ELSIF(_ones = '7') THEN
          _word := 'seven';
        ELSIF(_ones = '8') THEN
          _word := 'eight';
        ELSIF(_ones = '9') THEN
          _word := 'nine';
        ELSIF(_ones != '0') THEN
          _word := 'ERROR';
        END IF;

        if(_tens != '0') THEN
          _word := '-' || _word;
        END IF;

        IF(_tens = '2') THEN
          _word := 'twenty' || _word;
        ELSIF(_tens = '3') THEN
          _word := 'thirty' || _word;
        ELSIF(_tens = '4') THEN
          _word := 'forty' || _word;
        ELSIF(_tens = '5') THEN
          _word := 'fifty' || _word;
        ELSIF(_tens = '6') THEN
          _word := 'sixty' || _word;
        ELSIF(_tens = '7') THEN
          _word := 'seventy' || _word;
        ELSIF(_tens = '8') THEN
          _word := 'eighty' || _word;
        ELSIF(_tens = '9') THEN
          _word := 'ninety' || _word;
        ELSIF(_tens != '0' AND _tens != '1') THEN
          _word := 'ERROR' || _word;
        END IF;
      END IF;
      if(_word != '') THEN
        _words := _word || ' ' || _words;
      END IF;

      _word := '';
      IF(_hundreds = '1') THEN
        _word := 'one hundred';
      ELSIF(_hundreds = '2') THEN
        _word := 'two hundred';
      ELSIF(_hundreds = '3') THEN
        _word := 'three hundred';
      ELSIF(_hundreds = '4') THEN
        _word := 'four hundred';
      ELSIF(_hundreds = '5') THEN
        _word := 'five hundred';
      ELSIF(_hundreds = '6') THEN
        _word := 'six hundred';
      ELSIF(_hundreds = '7') THEN
        _word := 'seven hundred';
      ELSIF(_hundreds = '8') THEN
        _word := 'eight hundred';
      ELSIF(_hundreds = '9') THEN
        _word := 'nine hundred';
      ELSIF(_hundreds != '0') THEN
        _words := 'ERROR';
      END IF;
      if(_word != '') THEN
        _words := _word || ' ' || _words;
      END IF;
    END IF;

    _p := _p + 3;
  END LOOP;

  _words := rtrim(_words, ' ');
  IF(_words = '') THEN
    _words := 'zero';
  END IF;

  SELECT * INTO _curr
    FROM curr_symbol
    WHERE curr_id = pCurrId;

  IF(_words = 'one') AND TRIM(_curr.curr_name) ~ '.*s' THEN
    _word := rtrim(_curr.curr_name, ' s');
  ELSE
    _word := trim(_curr.curr_name);
  END IF;

  IF _curr.curr_abbr = 'USD' OR _curr.curr_abbr = 'CAD' THEN
      IF (_cents = '1') THEN
        _fractionalPartName = ' cent';
      ELSE
        _fractionalPartName = ' cents';
      END IF;
  ELSE
    _fractionalPartName = ' / 100 ';
  END IF;

  RETURN _words || ' ' || _word || ' and ' || _cents || _fractionalPartName;
END;
$_$;


ALTER FUNCTION public.spellamount(numeric, integer) OWNER TO admin;

--
-- TOC entry 2231 (class 1255 OID 146567080)
-- Dependencies: 4536 8
-- Name: splitreceipt(integer, numeric, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION splitreceipt(integer, numeric, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  precvid	ALIAS FOR $1;
  pqty   	ALIAS FOR $2;
  pfreight	ALIAS FOR $3;
  _check       	RECORD;
  _seq      	INTEGER;

BEGIN
  -- validate
  IF (COALESCE(pQty,0) <= 0) THEN
    RETURN -7;
  END IF;

  SELECT * INTO _check
  FROM recv
  WHERE (recv_id=precvid);

  IF (FOUND) THEN
    IF (_check.recv_order_type != 'PO') THEN
      RETURN -1;
    ELSIF ( NOT _check.recv_posted) THEN
      RETURN -2;
    ELSIF ( (_check.recv_invoiced)
         OR (_check.recv_vohead_id IS NOT NULL)
         OR (_check.recv_voitem_id IS NOT NULL) ) THEN
      RETURN -3;
    ELSIF (pqty >= _check.recv_qty) THEN
      RETURN -4;
    ELSIF (COALESCE(pfreight,0) > _check.recv_freight) THEN
      RETURN -5;
    END IF;
  ELSE
    RETURN -6;
  END IF;

  -- Create new receipt record
  _seq := nextval('recv_recv_id_seq');

  INSERT INTO recv
  SELECT _seq, recv_order_type,recv_order_number,
         recv_orderitem_id, recv_agent_username, recv_itemsite_id, recv_vend_id,
         recv_vend_item_number, recv_vend_item_descrip, recv_vend_uom,
         recv_purchcost, recv_purchcost_curr_id, recv_duedate, pqty,
         recv_recvcost, recv_recvcost_curr_id, COALESCE(pfreight,0), recv_freight_curr_id, recv_date,
         ROUND(recv_value/recv_qty * pqty, 2), TRUE, FALSE, NULL, NULL,
         recv_trans_usr_name, recv_notes, recv_gldistdate, precvid
  FROM recv
  WHERE (recv_id=precvid);

  --  Update qty and value of old record
  UPDATE recv SET
    recv_qty = recv_qty-pqty,
    recv_value = recv_value - ROUND(recv_value/recv_qty * pqty, 2),
    recv_freight = recv_freight - COALESCE(pfreight,0)
  WHERE (recv_id=precvid);

  RETURN _seq;
END;
$_$;


ALTER FUNCTION public.splitreceipt(integer, numeric, numeric) OWNER TO admin;

--
-- TOC entry 2232 (class 1255 OID 146567081)
-- Dependencies: 4536 8
-- Name: splitrecurrence(integer, text, timestamp with time zone); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION splitrecurrence(integer, text, timestamp with time zone) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pParentid     ALIAS FOR $1;
  pType         TEXT := UPPER($2);
  pDatetime     TIMESTAMP WITH TIME ZONE := COALESCE($3, CURRENT_TIMESTAMP);

  _count         INTEGER;
  _newrecurid    INTEGER;
  _newparentid   INTEGER;
  _newparentstmt TEXT;
  _rt            RECORD;
  _updchildstmt  TEXT;

BEGIN
  IF (pParentid IS NULL) THEN
    RETURN -11;
  END IF;

  SELECT * INTO _rt FROM recurtype WHERE (UPPER(recurtype_type)=pType);
  GET DIAGNOSTICS _count = ROW_COUNT;
  IF (_count <= 0) THEN
    RETURN -10;
  END IF;

  _newparentstmt := 'SELECT [table]_id FROM [fulltable]'
                 || ' WHERE (([table]_recurring_[table]_id=$1)'
                 || '    AND NOT ([done])'
                 || '    AND ([schedcol]>=''$2''))'
                 || ' ORDER BY [schedcol]'
                 || ' LIMIT 1;';
  _newparentstmt := REPLACE(_newparentstmt, '[fulltable]', _rt.recurtype_table);
  _newparentstmt := REPLACE(_newparentstmt, '[table]',
                            REGEXP_REPLACE(_rt.recurtype_table, E'.*\\.', ''));
  _newparentstmt := REPLACE(_newparentstmt, '[done]',  _rt.recurtype_donecheck);
  _newparentstmt := REPLACE(_newparentstmt, '[schedcol]', _rt.recurtype_schedcol);
  _updchildstmt := 'UPDATE [fulltable] SET [table]_recurring_[table]_id=$1'
                || ' WHERE (([table]_recurring_[table]_id=$2)'
                || '   AND NOT ([done])'
                || '   AND ([schedcol] > ''$3''));';
  _updchildstmt := REPLACE(_updchildstmt, '[fulltable]', _rt.recurtype_table);
  _updchildstmt := REPLACE(_updchildstmt, '[table]',
                           REGEXP_REPLACE(_rt.recurtype_table, E'.*\\.', ''));
  _updchildstmt := REPLACE(_updchildstmt, '[done]',  _rt.recurtype_donecheck);
  _updchildstmt := REPLACE(_updchildstmt, '[schedcol]', _rt.recurtype_schedcol);

  -- 8.4+: EXECUTE _newparentstmt INTO _newparentid USING pParentid, pDatetime;
  EXECUTE REPLACE(REPLACE(_newparentstmt, '$1', pParentid::TEXT),
                                          '$2', pDatetime::TEXT)
          INTO _newparentid;

  -- if nothing to split
  IF (_newparentid = pParentid OR _newparentid IS NULL) THEN
    SELECT recur_id INTO _newrecurid
      FROM recur
     WHERE ((recur_parent_id=pParentid)
        AND (recur_parent_type=pType));

  ELSE
    INSERT INTO recur (recur_parent_id, recur_parent_type, recur_period,
                       recur_freq,      recur_start,       recur_end,
                       recur_max,       recur_data
             ) SELECT _newparentid,     pType,             recur_period,
                      recur_freq,       pDatetime,         recur_end,
                      recur_max,        recur_data
                 FROM recur
                WHERE ((recur_parent_id=pParentid)
                   AND (recur_parent_type=pType))
      RETURNING recur_id INTO _newrecurid;

    UPDATE recur SET recur_end=pDatetime
    WHERE ((recur_parent_id=pParentid)
       AND (recur_parent_type=pType));

    -- 8.4+: EXECUTE _updchildstmt USING _newparentid, pParentid, pDatetime;
    EXECUTE REPLACE(REPLACE(REPLACE(_updchildstmt, '$1', _newparentid::TEXT),
                                                   '$2', pParentid::TEXT),
                                                   '$3', pDatetime::TEXT);
  END IF;

  RETURN _newrecurid;
END;
$_$;


ALTER FUNCTION public.splitrecurrence(integer, text, timestamp with time zone) OWNER TO admin;

--
-- TOC entry 2233 (class 1255 OID 146567082)
-- Dependencies: 8
-- Name: startoftime(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION startoftime() RETURNS date
    LANGUAGE sql IMMUTABLE
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
SELECT DATE('1970-01-01') AS return;
$$;


ALTER FUNCTION public.startoftime() OWNER TO admin;

--
-- TOC entry 2234 (class 1255 OID 146567083)
-- Dependencies: 4536 8
-- Name: stdcost(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION stdcost(integer) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN stdCost($1, NULL);
END;
$_$;


ALTER FUNCTION public.stdcost(integer) OWNER TO admin;

--
-- TOC entry 2235 (class 1255 OID 146567084)
-- Dependencies: 4536 8
-- Name: stdcost(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION stdcost(integer, integer) RETURNS numeric
    LANGUAGE plpgsql STABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pBomitemid ALIAS FOR $2;
  _cost NUMERIC;

BEGIN

  SELECT SUM(COALESCE(bomitemcost_stdcost, itemcost_stdcost)) INTO _cost
  FROM itemcost
    LEFT OUTER JOIN bomitemcost ON (bomitemcost_bomitem_id=pBomitemid AND bomitemcost_costelem_id=itemcost_costelem_id)
  WHERE (itemcost_item_id=pItemid);

  IF (_cost IS NULL) THEN
    RETURN 0;
  ELSE
    RETURN _cost;
  END IF;

END;
$_$;


ALTER FUNCTION public.stdcost(integer, integer) OWNER TO admin;

--
-- TOC entry 2236 (class 1255 OID 146567085)
-- Dependencies: 4536 8
-- Name: sufficientinventorytoshipitem(text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION sufficientinventorytoshipitem(text, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pordertype    ALIAS FOR $1;
  porderitemid  ALIAS FOR $2;

BEGIN
  RETURN sufficientInventoryToShipItem(pordertype, porderitemid, NULL);
END;
$_$;


ALTER FUNCTION public.sufficientinventorytoshipitem(text, integer) OWNER TO admin;

--
-- TOC entry 2239 (class 1255 OID 146567086)
-- Dependencies: 4536 8
-- Name: sufficientinventorytoshipitem(text, integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION sufficientinventorytoshipitem(text, integer, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pordertype           ALIAS FOR $1;
  porderitemid         ALIAS FOR $2;
  pqty                 ALIAS FOR $3;
  _returnVal           INTEGER;
  _isqtyavail          BOOLEAN;

BEGIN
  IF (porderitemid IS NULL) THEN
    RETURN -1;
  END IF;

  IF (pordertype = 'SO') THEN
    IF ( SELECT fetchMetricBool('EnableSOReservations') ) THEN
      IF (SELECT (itemsite_costmethod = 'J')
          FROM coitem JOIN itemsite ON (coitem_itemsite_id=itemsite_id)
          WHERE (coitem_id=porderitemid)) THEN
        RETURN 0;
      END IF;

      SELECT (((COALESCE(pqty, roundQty(item_fractional,
		      noNeg(coitem_qtyord - coitem_qtyshipped +
			    coitem_qtyreturned - qtyAtShipping(pordertype, coitem_id)
			   ))) - coitem_qtyreserved) * coitem_qty_invuomratio
		      ) <= itemsite_qtyonhand)
              AND
             (((COALESCE(pqty, roundQty(item_fractional,
		      noNeg(coitem_qtyord - coitem_qtyshipped +
			    coitem_qtyreturned - qtyAtShipping(pordertype, coitem_id)
			   ))) - coitem_qtyreserved) * coitem_qty_invuomratio
		      ) <= qtyunreserved(itemsite_id))
        INTO _isqtyavail
        FROM coitem, itemsite, item
       WHERE ((coitem_itemsite_id=itemsite_id)
         AND (coitem_status <> 'X')
         AND  (NOT ((item_type IN ('R','J')) OR (itemsite_controlmethod = 'N')))
         AND (itemsite_item_id=item_id)
         AND (coitem_id=porderitemid));
    ELSE
      SELECT (COALESCE(pqty, roundQty(item_fractional,
		                      noNeg(coitem_qtyord - coitem_qtyshipped +
			              coitem_qtyreturned - qtyAtShipping(pordertype, coitem_id) - coitem_qtyreserved
			              ) * coitem_qty_invuomratio
		      )
              ) <= itemsite_qtyonhand)
        INTO _isqtyavail
        FROM coitem, itemsite, item
       WHERE ((coitem_itemsite_id=itemsite_id)
         AND (coitem_status <> 'X')
         AND  (NOT ((item_type IN ('R','J')) OR (itemsite_controlmethod = 'N')))
         AND (itemsite_item_id=item_id)
         AND (coitem_id=porderitemid));
    END IF;
  ELSEIF (pordertype = 'TO') THEN
    SELECT (COALESCE(pqty, roundQty(item_fractional,
		                    noNeg(toitem_qty_ordered - toitem_qty_shipped -
			            qtyAtShipping(pordertype, toitem_id)
		                    )
		    )
           ) <= itemsite_qtyonhand) INTO _isqtyavail
      FROM toitem, tohead, itemsite, item
     WHERE ((toitem_tohead_id=tohead_id)
       AND  (tohead_src_warehous_id=itemsite_warehous_id)
       AND  (toitem_item_id=itemsite_item_id)
       AND  (itemsite_warehous_id=tohead_src_warehous_id)
       AND  (itemsite_item_id=item_id)
       AND  (toitem_status <> 'X')
         AND  (NOT ((item_type IN ('R','J')) OR (itemsite_controlmethod = 'N')))
       AND  (toitem_id=porderitemid));
  ELSE
    RETURN -11;
  END IF;

  IF (NOT _isqtyavail) THEN
    RETURN -2;
  END IF;

  IF (pordertype = 'SO') THEN
    SELECT (COALESCE((SELECT SUM(itemloc_qty)
			FROM itemloc
		       WHERE (itemloc_itemsite_id=itemsite_id)), 0.0) >= roundQty(item_fractional,
			      COALESCE(pQty, noNeg( coitem_qtyord - coitem_qtyshipped + coitem_qtyreturned -
			      qtyAtShipping(pordertype, coitem_id) )) * coitem_qty_invuomratio
			     )) INTO _isqtyavail
      FROM coitem, itemsite, item
     WHERE ((coitem_itemsite_id=itemsite_id)
       AND (itemsite_item_id=item_id)
       AND (NOT ((item_type ='R') OR (itemsite_controlmethod = 'N')))
       AND ((itemsite_controlmethod IN ('L', 'S')) OR (itemsite_loccntrl))
       AND (coitem_id=porderitemid));

  ELSEIF (pordertype = 'TO') THEN
    SELECT (COALESCE((SELECT SUM(itemloc_qty)
			FROM itemloc
		       WHERE (itemloc_itemsite_id=itemsite_id)), 0.0) >= roundQty(item_fractional,
			      noNeg( toitem_qty_ordered - toitem_qty_shipped -
			      qtyAtShipping(pordertype, toitem_id) )
			     )) INTO _isqtyavail
      FROM toitem, tohead, itemsite, item
     WHERE ((toitem_tohead_id=tohead_id)
       AND  (tohead_src_warehous_id=itemsite_warehous_id)
       AND  (toitem_item_id=itemsite_item_id)
       AND  (itemsite_item_id=item_id)
       AND  (toitem_status <> 'X')
       AND  (NOT ((item_type ='R') OR (itemsite_costmethod = 'J') OR (itemsite_controlmethod = 'N')))
       AND  ((itemsite_controlmethod IN ('L', 'S')) OR (itemsite_loccntrl))
       AND  (toitem_id=porderitemid));
  END IF;

  IF (NOT _isqtyavail) THEN
    RETURN -3;
  END IF;

  IF (pordertype = 'SO') THEN
    IF ( SELECT fetchMetricBool('RequireSOReservations') ) THEN
      SELECT (COALESCE(pqty, coitem_qtyreserved) <= coitem_qtyreserved)
        INTO _isqtyavail
        FROM coitem, itemsite, item
       WHERE ((coitem_itemsite_id=itemsite_id)
         AND (coitem_status <> 'X')
         AND  (NOT ((item_type IN ('R','J')) OR (itemsite_controlmethod = 'N')))
         AND (itemsite_item_id=item_id)
         AND (coitem_id=porderitemid));
    END IF;
  END IF;

  IF (NOT _isqtyavail) THEN
    RETURN -4;
  END IF;

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.sufficientinventorytoshipitem(text, integer, numeric) OWNER TO admin;

--
-- TOC entry 2240 (class 1255 OID 146567087)
-- Dependencies: 4536 8
-- Name: sufficientinventorytoshiporder(text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION sufficientinventorytoshiporder(text, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pordertype	ALIAS FOR $1;
  porderid	ALIAS FOR $2;
  _s		RECORD;
  _returnVal	INTEGER := 0;

BEGIN
  IF (pordertype = 'SO') THEN
    FOR _s IN SELECT coitem_id
	        FROM coitem
	         JOIN itemsite ON (coitem_itemsite_id=itemsite_id)
	       WHERE((coitem_cohead_id=porderid)
	        AND (itemsite_costmethod != 'J')) LOOP
      _returnVal := sufficientInventoryToShipItem(pordertype, _s.coitem_id);
      EXIT WHEN (_returnVal < 0);
    END LOOP;
  ELSEIF (pordertype = 'TO') THEN
    FOR _s IN SELECT toitem_id
	        FROM toitem
	       WHERE(toitem_tohead_id=porderid) LOOP
      _returnVal := sufficientInventoryToShipItem(pordertype, _s.toitem_id);
      EXIT WHEN (_returnVal < 0);
    END LOOP;
  END IF;

  RETURN _returnVal;
END;
$_$;


ALTER FUNCTION public.sufficientinventorytoshiporder(text, integer) OWNER TO admin;

--
-- TOC entry 2241 (class 1255 OID 146567088)
-- Dependencies: 4536 8
-- Name: summarizedbom(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION summarizedbom(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  _revid INTEGER;

BEGIN

  SELECT getActiveRevId('BOM',pItemid) INTO _revid;

  RETURN summarizedBOM(pItemid, _revid);

END;
$_$;


ALTER FUNCTION public.summarizedbom(integer) OWNER TO admin;

--
-- TOC entry 2243 (class 1255 OID 146567090)
-- Dependencies: 4536 8
-- Name: summarizedbom(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION summarizedbom(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pRevisionid ALIAS FOR $2;
  _bomworkid INTEGER;
  _indexid INTEGER;
  _r RECORD;

BEGIN

--  Check on the temporary workspace
--  PERFORM maintainBOMWorkspace();

--  Grab a new index for this bomwork set
  SELECT NEXTVAL('misc_index_seq') INTO _indexid;

--  Step through all of the components of the passed pItemid
  FOR _r IN SELECT bomitem.*,
                   item_id,
                   (itemuomtouomratio(bomitem_item_id, bomitem_uom_id, NULL)
                              * bomitem_qtyfxd) AS qtyfxd,
                   (itemuomtouomratio(bomitem_item_id, bomitem_uom_id, NULL)
                              * bomitem_qtyper) AS qtyper,
                   stdcost(item_id, bomitem_id) AS standardcost,
                   actcost(item_id, bomitem_id) AS actualcost
  FROM bomitem(pItemid, pRevisionid), item
  WHERE (bomitem_item_id=item_id) LOOP

--  Insert the component and bomitem parameters
    SELECT NEXTVAL('bomwork_bomwork_id_seq') INTO _bomworkid;
    INSERT INTO bomwork
    ( bomwork_id, bomwork_set_id, bomwork_parent_id, bomwork_level,
      bomwork_parent_seqnumber, bomwork_seqnumber,
      bomwork_item_id, bomwork_createwo, bomwork_qtyreq,
      bomwork_qtyfxd, bomwork_qtyper, bomwork_scrap, bomwork_issuemethod,
      bomwork_effective, bomwork_expires,
      bomwork_stdunitcost, bomwork_actunitcost )
    VALUES
    ( _bomworkid, _indexid, -1, 1,
      0, _r.bomitem_seqnumber,
      _r.item_id, _r.bomitem_createwo, (_r.qtyfxd + _r.qtyper),
      _r.qtyfxd, _r.qtyper, _r.bomitem_scrap, _r.bomitem_issuemethod,
      _r.bomitem_effective, _r.bomitem_expires,
      _r.standardcost, _r.actualcost,
      _r.bomitem_char_id, _r.bomitem_value, _r.bomitem_notes, _r.bomitem_ref,
      _r.bomitem_id, _r.bomitem_ecn );

--  Explode the components of the current component
    PERFORM explodeBOM(_r.item_id, _bomworkid, 1);

  END LOOP;

--  Return a key to the result
  RETURN _indexid;

END;
$_$;


ALTER FUNCTION public.summarizedbom(integer, integer) OWNER TO admin;

--
-- TOC entry 2242 (class 1255 OID 146567089)
-- Dependencies: 4536 8
-- Name: summarizedbom(integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION summarizedbom(integer, integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pExpired ALIAS FOR $2;
  pFuture ALIAS FOR $3;
  _revid INTEGER;

BEGIN

  SELECT getActiveRevId('BOM',pItemid) INTO _revid;

  RETURN summarizedBOM(pItemid, _revid, pExpired, pFuture);

END;
$_$;


ALTER FUNCTION public.summarizedbom(integer, integer, integer) OWNER TO admin;

--
-- TOC entry 2244 (class 1255 OID 146567091)
-- Dependencies: 2657 4536 8
-- Name: summarizedbom(integer, integer, integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION summarizedbom(integer, integer, integer, integer) RETURNS SETOF bomdata
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pRevisionid ALIAS FOR $2;
  pExpiredDays  INTEGER := COALESCE($3, 0);
  pFutureDays   INTEGER := COALESCE($4, 0);
  _row bomdata%ROWTYPE;
  _bomworksetid INTEGER;
  _x RECORD;
  _check CHAR(1);
  _inactive BOOLEAN := FALSE;
  _batchsize NUMERIC;

BEGIN

  IF (pRevisionid != -1) THEN
    --Is this a deactivated revision?
    SELECT rev_status INTO _check
    FROM rev
    WHERE ((rev_id=pRevisionid)
    AND (rev_status='I'));
    IF (FOUND) THEN
      _inactive := TRUE;
    END IF;
  END IF;

  -- Get the batch quantity
  SELECT COALESCE( (
    SELECT bomhead_batchsize
    FROM bomhead
    WHERE ((bomhead_item_id=pItemId)
    AND (bomhead_rev_id=pRevisionid))),1) INTO _batchsize;

  IF NOT (_inactive) THEN

    --We can explode this out based on current data
    SELECT indentedBOM(pItemid, pRevisionid) INTO _bomworksetid;

    FOR _x IN
       SELECT item_number, uom_name,
               item_descrip1, item_descrip2,
               (item_descrip1 || ' ' || item_descrip2) AS itemdescription,
               SUM(bomwork_qtyreq) AS qtyreq,
               SUM(bomwork_qtyfxd * (1 + bomwork_scrap)) AS qtyfxd,
               SUM(bomwork_qtyper * (1 + bomwork_scrap)) AS qtyper,
       MAX(bomwork_actunitcost) AS actunitcost,
       MAX(bomwork_stdunitcost) AS stdunitcost,
       CASE WHEN item_type NOT IN ('R','T') THEN
         SUM(bomwork_actunitcost * bomwork_qtyreq)
       ELSE 0 END AS actextendedcost,
       CASE WHEN item_type NOT IN ('R','T') THEN
         SUM(bomwork_stdunitcost * bomwork_qtyreq)
       ELSE 0 END AS stdextendedcost,
       bomwork_effective,
       bomwork_expires,
       bomwork_effective > CURRENT_DATE AS future,
       bomwork_expires  <= CURRENT_DATE AS expired
       FROM ( SELECT item_number, item_type, uom_name,
                     item_descrip1, item_descrip2,
                     bomwork_qtyreq, bomwork_qtyfxd,
                     bomwork_qtyper, bomwork_scrap,
                     bomwork_actunitcost, bomwork_stdunitcost,
                     CASE WHEN (bomwork_effective > CURRENT_DATE) THEN (CURRENT_DATE + 1)
                          ELSE CURRENT_DATE END AS bomwork_effective,
                     CASE WHEN (bomwork_expires <= CURRENT_DATE) THEN (CURRENT_DATE - 1)
                          ELSE (CURRENT_DATE + 1) END AS bomwork_expires
                     FROM bomwork, item, uom
                     WHERE ( (bomwork_item_id=item_id)
                       AND (item_inv_uom_id=uom_id)
                       AND (bomwork_set_id=_bomworksetid) )
                       AND (bomwork_expires > (CURRENT_DATE - pExpiredDays))
                       AND (bomwork_effective <= (CURRENT_DATE + pFutureDays)) ) AS data
       GROUP BY item_number, uom_name, item_type,
                item_descrip1, item_descrip2,
                bomwork_effective, bomwork_expires
       ORDER BY item_number
    LOOP
        _row.bomdata_item_number := _x.item_number;
        _row.bomdata_uom_name := _x.uom_name;
        _row.bomdata_item_descrip1 := _x.item_descrip1;
        _row.bomdata_item_descrip2 := _x.item_descrip2;
        _row.bomdata_itemdescription := _x.itemdescription;
        _row.bomdata_qtyreq := _x.qtyreq;
        _row.bomdata_qtyfxd := _x.qtyfxd;
        _row.bomdata_qtyper := _x.qtyper;
        _row.bomdata_actunitcost := _x.actunitcost;
        _row.bomdata_stdunitcost := _x.stdunitcost;
        _row.bomdata_actextendedcost := _x.actextendedcost;
        _row.bomdata_stdextendedcost := _x.stdextendedcost;
        _row.bomdata_effective := _x.bomwork_effective;
        _row.bomdata_expires := _x.bomwork_expires;
        _row.bomdata_future := _x.future;
        _row.bomdata_expired := _x.expired;
        RETURN NEXT _row;
    END LOOP;

    PERFORM deleteBOMWorkset(_bomworksetid);

  ELSE

-- Use historical snapshot for inactive revisions
    FOR _x IN
       SELECT item_number, uom_name,
               item_descrip1, item_descrip2,
               (item_descrip1 || ' ' || item_descrip2) AS itemdescription,
               SUM(bomhist_qtyreq * (1 + bomhist_scrap)) AS qtyreq,
               SUM(bomhist_qtyfxd * (1 + bomhist_scrap)) AS qtyfxd,
               SUM(bomhist_qtyper * (1 + bomhist_scrap)) AS qtyper,
       MAX(bomhist_actunitcost) AS actunitcost,
       MAX(bomhist_stdunitcost) AS stdunitcost,
       CASE WHEN item_type NOT IN ('R','T') THEN
         MAX(bomhist_actunitcost) * SUM((bomhist_qtyfxd/_batchsize + bomhist_qtyper) * (1 + bomhist_scrap))
       ELSE 0 END AS actextendedcost,
       CASE WHEN item_type NOT IN ('R','T') THEN
         MAX(bomhist_stdunitcost) * SUM((bomhist_qtyfxd/_batchsize + bomhist_qtyper) * (1 + bomhist_scrap))
       ELSE 0 END AS stdextendedcost
       FROM bomhist, item, uom
       WHERE ( (bomhist_item_id=item_id)
       AND (item_inv_uom_id=uom_id)
       AND (bomhist_rev_id=pRevisionid) )
       AND (bomhist_expires > (CURRENT_DATE - pExpiredDays))
       AND (bomhist_effective <= (CURRENT_DATE + pFutureDays))
       GROUP BY item_number, uom_name, item_type,
                item_descrip1, item_descrip2
       ORDER BY item_number
    LOOP
        _row.bomdata_item_number := _x.item_number;
        _row.bomdata_uom_name := _x.uom_name;
        _row.bomdata_item_descrip1 := _x.item_descrip1;
        _row.bomdata_item_descrip2 := _x.item_descrip2;
        _row.bomdata_itemdescription := _x.itemdescription;
        _row.bomdata_qtyreq := _x.qtyreq;
        _row.bomdata_qtyfxd := _x.qtyfxd;
        _row.bomdata_qtyper := _x.qtyper;
        _row.bomdata_actunitcost := _x.actunitcost;
        _row.bomdata_stdunitcost := _x.stdunitcost;
        _row.bomdata_actextendedcost := _x.actextendedcost;
        _row.bomdata_stdextendedcost := _x.stdextendedcost;
        RETURN NEXT _row;
    END LOOP;

  END IF;

  RETURN;

END;
$_$;


ALTER FUNCTION public.summarizedbom(integer, integer, integer, integer) OWNER TO admin;

--
-- TOC entry 2245 (class 1255 OID 146567092)
-- Dependencies: 4536 8
-- Name: summarizetransactions(integer, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION summarizetransactions(integer, date, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pStartDate ALIAS FOR $2;
  pEndDate ALIAS FOR $3;
  _startDate DATE;
  _endDate DATE;
  _invhist RECORD;
  _itemuom TEXT;
  _transCounter INTEGER;
  _itemlocSeries INTEGER;

BEGIN

--  Cache the uom_name
  SELECT uom_name INTO _itemuom
  FROM itemsite, item, uom
  WHERE ((itemsite_item_id=item_id)
    AND (item_inv_uom_id=uom_id)
    AND (itemsite_id=pItemsiteid));

--  Can't summarize into the future...
  IF (pEndDate > CURRENT_DATE) THEN
    _endDate := CURRENT_DATE;
  ELSE
    _endDate := pEndDate;
  END IF;

--  Verify date bounds
  IF (pStartDate > pEndDate) THEN
    _startDate := pEndDate;
  ELSE
    _startDate := pStartDate;
  END IF;

--  Verify that history is not referenced elsewhere
  SELECT invhist_id INTO _transCounter
  FROM invhist JOIN womatlpost ON (womatlpost_invhist_id=invhist_id)
  WHERE ((invhist_itemsite_id=pItemsiteid)
    AND (invhist_transdate::DATE BETWEEN _startDate AND _endDate))
  LIMIT 1;
  IF (FOUND) THEN
    RETURN 0;
  END IF;

  SELECT invhist_id INTO _transCounter
  FROM invhist JOIN shipitem ON (shipitem_invhist_id=invhist_id)
  WHERE ((invhist_itemsite_id=pItemsiteid)
    AND (invhist_transdate::DATE BETWEEN _startDate AND _endDate))
  LIMIT 1;
  IF (FOUND) THEN
    RETURN 0;
  END IF;

  _transCounter := 0;
  _itemlocSeries := NEXTVAL('itemloc_series_seq');

  FOR _invhist IN SELECT invhist_transtype, invhist_costmethod, SUM(invhist_invqty) AS qty
                  FROM invhist
                  WHERE ((invhist_itemsite_id=pItemsiteid)
                   AND (invhist_transdate::DATE BETWEEN _startDate AND _endDate))
                  GROUP BY invhist_transtype, invhist_costmethod LOOP

    DELETE FROM invhist
    WHERE ((invhist_transdate::DATE BETWEEN _startDate AND _endDate)
     AND (invhist_transtype=_invhist.invhist_transtype)
     AND (invhist_itemsite_id=pItemsiteid));

    INSERT INTO invhist
    ( invhist_itemsite_id, invhist_transdate, invhist_transtype,
      invhist_invqty, invhist_qoh_before, invhist_qoh_after,
      invhist_invuom, invhist_user, invhist_ordnumber,
      invhist_costmethod, invhist_value_before, invhist_value_after,
      invhist_series )
    VALUES
    ( pItemsiteid, _endDate, _invhist.invhist_transtype,
      _invhist.qty, 0, 0,
      _itemuom, getEffectiveXtUser(), 'Summary',
      _invhist.invhist_costmethod, 0, 0,
      _itemlocSeries );

    _transCounter := (_transCounter + 1);

  END LOOP;

  RETURN _transCounter;

END;
$_$;


ALTER FUNCTION public.summarizetransactions(integer, date, date) OWNER TO admin;

--
-- TOC entry 2228 (class 1255 OID 146567094)
-- Dependencies: 4536 8
-- Name: summdemand(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION summdemand(integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pCalitemid ALIAS FOR $2;
  _value NUMERIC;

BEGIN

  SELECT summDemand(pItemsiteid, findPeriodStart(pCalitemid), findPeriodEnd(pCalitemid)) INTO _value;

  RETURN _value;

END;
$_$;


ALTER FUNCTION public.summdemand(integer, integer) OWNER TO admin;

--
-- TOC entry 2215 (class 1255 OID 146567093)
-- Dependencies: 4536 8
-- Name: summdemand(integer, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION summdemand(integer, date, date) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pStartDate ALIAS FOR $2;
  pEndDate ALIAS FOR $3;
  _value NUMERIC;

BEGIN

  SELECT SUM(wo_qtyord - wo_qtyrcv) INTO _value
  FROM wo
  WHERE ( (wo_itemsite_id=pItemsiteid)
   AND (wo_status IN ('R', 'I'))
   AND (wo_startdate::DATE BETWEEN pStartDate AND pEndDate) );

  IF (_value IS NULL) THEN
    _value := 0;
  END IF;

  RETURN _value;

END;
$_$;


ALTER FUNCTION public.summdemand(integer, date, date) OWNER TO admin;

--
-- TOC entry 2237 (class 1255 OID 146567096)
-- Dependencies: 4536 8
-- Name: summprod(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION summprod(integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pCalitemid ALIAS FOR $2;
  _value NUMERIC;

BEGIN

  SELECT summProd(pItemsiteid, findPeriodStart(pCalitemid), findPeriodEnd(pCalitemid)) INTO _value;

  RETURN _value;

END;
$_$;


ALTER FUNCTION public.summprod(integer, integer) OWNER TO admin;

--
-- TOC entry 2229 (class 1255 OID 146567095)
-- Dependencies: 4536 8
-- Name: summprod(integer, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION summprod(integer, date, date) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pStartDate ALIAS FOR $2;
  pEndDate ALIAS FOR $3;
  _value NUMERIC;

BEGIN

  SELECT SUM(invhist_invqty) INTO _value
  FROM invhist
  WHERE ( (invhist_itemsite_id=pItemsiteid)
   AND (invhist_transtype IN ('RM', 'RB'))
   AND (invhist_transdate::DATE BETWEEN pStartDate AND pEndDate) );

  IF (_value IS NULL) THEN
    _value := 0;
  END IF;

  RETURN _value;

END;
$_$;


ALTER FUNCTION public.summprod(integer, date, date) OWNER TO admin;

--
-- TOC entry 2246 (class 1255 OID 146567098)
-- Dependencies: 4536 8
-- Name: summtransa(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION summtransa(integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pCalitemid ALIAS FOR $2;
  _value NUMERIC;

BEGIN

  SELECT summTransA(pItemsiteid, findPeriodStart(pCalitemid), findPeriodEnd(pCalitemid)) INTO _value;

  RETURN _value;

END;
$_$;


ALTER FUNCTION public.summtransa(integer, integer) OWNER TO admin;

--
-- TOC entry 2238 (class 1255 OID 146567097)
-- Dependencies: 4536 8
-- Name: summtransa(integer, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION summtransa(integer, date, date) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pStartDate ALIAS FOR $2;
  pEndDate ALIAS FOR $3;
  _value NUMERIC;

BEGIN

  SELECT SUM(invhist_invqty) INTO _value
  FROM invhist
  WHERE ((invhist_transdate::DATE BETWEEN pStartDate AND pEndDate)
   AND (invhist_transtype IN ('AD', 'CC'))
   AND (invhist_itemsite_id=pItemsiteid));

  IF (_value IS NULL) THEN
    _value := 0;
  END IF;

  RETURN _value;

END;
$_$;


ALTER FUNCTION public.summtransa(integer, date, date) OWNER TO admin;

--
-- TOC entry 2248 (class 1255 OID 146567100)
-- Dependencies: 4536 8
-- Name: summtransc(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION summtransc(integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pCalitemid ALIAS FOR $2;
  _value NUMERIC;

BEGIN

  SELECT summTransC(pItemsiteid, findPeriodStart(pCalitemid), findPeriodEnd(pCalitemid)) INTO _value;

  RETURN _value;

END;
$_$;


ALTER FUNCTION public.summtransc(integer, integer) OWNER TO admin;

--
-- TOC entry 2247 (class 1255 OID 146567099)
-- Dependencies: 4536 8
-- Name: summtransc(integer, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION summtransc(integer, date, date) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pStartDate ALIAS FOR $2;
  pEndDAte ALIAS FOR $3;
  _value NUMERIC;

BEGIN

  SELECT SUM(invhist_invqty) INTO _value
  FROM invhist
  WHERE ((invhist_transdate::DATE BETWEEN pStartDate AND pEndDate)
   AND (invhist_transtype IN ('SI'))
   AND (invhist_itemsite_id=pItemsiteid));

  IF (_value IS NULL) THEN
    _value := 0;
  END IF;

  RETURN _value;

END;
$_$;


ALTER FUNCTION public.summtransc(integer, date, date) OWNER TO admin;

--
-- TOC entry 2250 (class 1255 OID 146567102)
-- Dependencies: 4536 8
-- Name: summtransi(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION summtransi(integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pCalitemid ALIAS FOR $2;
  _value NUMERIC;

BEGIN

  SELECT summTransI(pItemsiteid, findPeriodStart(pCalitemid), findPeriodEnd(pCalitemid)) INTO _value;

  RETURN _value;

END;
$_$;


ALTER FUNCTION public.summtransi(integer, integer) OWNER TO admin;

--
-- TOC entry 2249 (class 1255 OID 146567101)
-- Dependencies: 4536 8
-- Name: summtransi(integer, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION summtransi(integer, date, date) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pStartDate ALIAS FOR $2;
  pEndDate ALIAS FOR $3;
  _value NUMERIC;

BEGIN

  SELECT SUM(invhist_invqty) INTO _value
  FROM invhist
  WHERE ((invhist_transdate::DATE BETWEEN pStartDate AND pEndDate)
   AND (invhist_transtype IN ('IM', 'IC'))
   AND (invhist_itemsite_id=pItemsiteid));

  IF (_value IS NULL) THEN
    _value := 0;
  END IF;

  RETURN _value;

END;
$_$;


ALTER FUNCTION public.summtransi(integer, date, date) OWNER TO admin;

--
-- TOC entry 2252 (class 1255 OID 146567104)
-- Dependencies: 4536 8
-- Name: summtransr(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION summtransr(integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pCalitemid ALIAS FOR $2;
  _value NUMERIC;

BEGIN

  SELECT summTransR(pItemsiteid, findPeriodStart(pCalitemid), findPeriodEnd(pCalitemid)) INTO _value;

  RETURN _value;

END;
$_$;


ALTER FUNCTION public.summtransr(integer, integer) OWNER TO admin;

--
-- TOC entry 2251 (class 1255 OID 146567103)
-- Dependencies: 4536 8
-- Name: summtransr(integer, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION summtransr(integer, date, date) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pStartDate ALIAS FOR $2;
  pEndDate ALIAS FOR $3;
  _value NUMERIC;

BEGIN

  SELECT SUM(invhist_invqty) INTO _value
  FROM invhist
  WHERE ((invhist_transdate::DATE BETWEEN pStartDate AND pEndDate)
   AND (invhist_transtype IN ('RM', 'RP', 'RX'))
   AND (invhist_itemsite_id=pItemsiteid) );

  IF (_value IS NULL) THEN
    _value := 0;
  END IF;

  RETURN _value;

END;
$_$;


ALTER FUNCTION public.summtransr(integer, date, date) OWNER TO admin;

--
-- TOC entry 2254 (class 1255 OID 146567106)
-- Dependencies: 4536 8
-- Name: summtranss(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION summtranss(pitemsiteid integer, pcalitemid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pCalitemid ALIAS FOR $2;
  _value NUMERIC;

BEGIN

  SELECT summTransS(pItemsiteid, findPeriodStart(pCalitemid), findPeriodEnd(pCalitemid)) INTO _value;

  RETURN _value;

END;
$_$;


ALTER FUNCTION public.summtranss(pitemsiteid integer, pcalitemid integer) OWNER TO admin;

--
-- TOC entry 2253 (class 1255 OID 146567105)
-- Dependencies: 4536 8
-- Name: summtranss(integer, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION summtranss(pitemsiteid integer, pstartdate date, penddate date) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _value NUMERIC;

BEGIN

  SELECT SUM( CASE WHEN (invhist_transtype = 'RS') THEN (invhist_invqty * -1)
                   ELSE (invhist_invqty)
              END ) INTO _value
  FROM invhist
  WHERE ( (invhist_transdate::DATE BETWEEN pStartDate AND pEndDate)
   AND (invhist_transtype IN ('SC', 'SH', 'SV', 'RS'))
   AND (invhist_ordtype != 'TO')
   AND (invhist_itemsite_id=pItemsiteid) );

  IF (_value IS NULL) THEN
    _value := 0;
  END IF;

  RETURN _value;

END;
$$;


ALTER FUNCTION public.summtranss(pitemsiteid integer, pstartdate date, penddate date) OWNER TO admin;

--
-- TOC entry 2256 (class 1255 OID 146567108)
-- Dependencies: 4536 8
-- Name: summtranst(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION summtranst(integer, integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pCalitemid ALIAS FOR $2;
  _value NUMERIC;

BEGIN

  SELECT summTransT(pItemsiteid, findPeriodStart(pCalitemid), findPeriodEnd(pCalitemid)) INTO _value;

  RETURN _value;

END;
$_$;


ALTER FUNCTION public.summtranst(integer, integer) OWNER TO admin;

--
-- TOC entry 2255 (class 1255 OID 146567107)
-- Dependencies: 4536 8
-- Name: summtranst(integer, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION summtranst(integer, date, date) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pStartDate ALIAS FOR $2;
  pEndDate ALIAS FOR $3;
  _value NUMERIC;

BEGIN

  SELECT SUM( CASE WHEN (invhist_transtype = 'TS') THEN (invhist_invqty * -1)
                   ELSE (invhist_invqty)
              END ) INTO _value
  FROM invhist
  WHERE ( (invhist_transdate::DATE BETWEEN pStartDate AND pEndDate)
   AND (invhist_transtype IN ('TS', 'TR', 'TW'))
   AND (invhist_itemsite_id=pItemsiteid) );

  IF (_value IS NULL) THEN
    _value := 0;
  END IF;

  RETURN _value;

END;
$_$;


ALTER FUNCTION public.summtranst(integer, date, date) OWNER TO admin;

--
-- TOC entry 2259 (class 1255 OID 146567109)
-- Dependencies: 2705 4536 8
-- Name: taxassignments(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION taxassignments(integer, integer) RETURNS SETOF taxassign
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTaxZoneId ALIAS FOR $1;
  pTaxTypeId ALIAS FOR $2;
  _row taxassign%ROWTYPE;
  _qry text;
  _x RECORD;
  _y RECORD;
  _z RECORD;

BEGIN
  _qry = 'SELECT DISTINCT COALESCE(taxass_taxzone_id, -1) AS taxass_taxzone_id, COALESCE(taxass_taxtype_id, -1) AS taxass_taxtype_id, ';
  _qry = _qry || 'taxzone_code, taxtype_name FROM taxass LEFT OUTER JOIN taxzone ON (taxass_taxzone_id=taxzone_id) ';
  _qry = _qry || 'LEFT OUTER JOIN taxtype ON (taxass_taxtype_id=taxtype_id) ';

  IF ((pTaxZoneId > 0) OR (pTaxTypeId > 0)) THEN
    _qry := _qry || ' WHERE ';
    IF (pTaxZoneId > 0) THEN
      _qry := _qry || ' (taxass_taxzone_id = ' || pTaxZoneId ||')';
      IF (pTaxTypeId > 0) THEN
        _qry := _qry || ' AND ';
      END IF;
    END IF;
    IF (pTaxTypeId > 0) THEN
      _qry := _qry || ' (taxass_taxtype_id = ' || pTaxTypeId || ')';
    END IF;
  END IF;

  --This first query gets all the distinct tax zone and type groupings as if it were its own table.
  --This allows us to have a level 0 record as pictured in Tax Assignments window that code assignements will
  --Subordinate to.
  FOR _x IN  EXECUTE _qry
  LOOP
    --Map values to _row here
    _row.taxassign_taxzone_id = _x.taxass_taxzone_id;
    _row.taxassign_taxtype_id = _x.taxass_taxtype_id;
    _row.taxassign_level = 0;
    _row.taxassign_zone_code = _x.taxzone_code;
    _row.taxassign_type_descrip = _x.taxtype_name;
    _row.taxassign_taxclass_code = '';
    _row.taxassign_taxclass_sequence = NULL;
    RETURN NEXT _row; --so we get a level tax zone/type 0 record.

    -- Now get all the tax code assignments that belong to this Zone and Type pair
    FOR _y IN
      SELECT taxass_id, COALESCE(taxzone_id, -1) AS taxzone_id, tax_id,
      tax_code, tax_descrip, COALESCE(taxtype_id, -1) AS taxtype_id, taxzone_code,
      taxtype_descrip, taxclass_code,
      COALESCE(taxclass_sequence, 0) AS taxclass_sequence
      FROM taxass JOIN tax
         LEFT OUTER JOIN taxclass ON (tax_taxclass_id = taxclass_id)
      ON (taxass_tax_id = tax_id)
      LEFT OUTER JOIN taxzone ON (taxass_taxzone_id = taxzone_id)
      LEFT OUTER JOIN taxtype ON (taxass_taxtype_id = taxtype_id)
      WHERE COALESCE(taxass_taxzone_id, -1) = _x.taxass_taxzone_id
      AND   COALESCE(taxass_taxtype_id, -1) = _x.taxass_taxtype_id
    LOOP
      --Map results to _row
      _row.taxassign_taxzone_id = _y.taxzone_id;
      _row.taxassign_taxtype_id = _y.taxtype_id;
      _row.taxassign_level = 1;
      _row.taxassign_zone_code = _y.tax_code;
      _row.taxassign_type_descrip = _y.tax_descrip;
      _row.taxassign_taxclass_code = _y.taxclass_code;
      _row.taxassign_taxclass_sequence = _y.taxclass_sequence;
      RETURN NEXT _row; --to get code detail record;

      FOR _z IN SELECT * FROM getsubtax(_y.tax_id, 1) --a new recursive function described above
      LOOP
        --Map results to _row
        _row.taxassign_taxzone_id = _y.taxzone_id;
        _row.taxassign_taxtype_id = _y.taxtype_id;
        _row.taxassign_level = _z.subtax_taxcode_level;
        _row.taxassign_zone_code = _z.subtax_taxcode_code;
        _row.taxassign_type_descrip = _z.subtax_taxcode_descrip;
        _row.taxassign_taxclass_code = _y.taxclass_code;
        _row.taxassign_taxclass_sequence = _y.taxclass_sequence;
        RETURN NEXT _row;
      END  LOOP;

    END LOOP;

  END LOOP;

END;
$_$;


ALTER FUNCTION public.taxassignments(integer, integer) OWNER TO admin;

--
-- TOC entry 2260 (class 1255 OID 146567110)
-- Dependencies: 4536 8
-- Name: thawaccountingperiod(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION thawaccountingperiod(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pPeriodid ALIAS FOR $1;
  _r RECORD;

BEGIN

--  Check to make sure that the period is frozen
  IF ( ( SELECT (NOT period_freeze)
         FROM period
         WHERE (period_id=pPeriodid) ) ) THEN
    RETURN -2;
  END IF;

--  Check to make sure that the period is not closed
  IF ( ( SELECT (period_closed)
         FROM period
         WHERE (period_id=pPeriodid) ) ) THEN
    RETURN -1;
  END IF;

--  Reset the period_freeze flag
  UPDATE period
  SET period_freeze=FALSE
  WHERE (period_id=pPeriodid);

--  Post any unposted G/L Transactions into the period
  FOR _r IN SELECT DISTINCT gltrans_sequence
            FROM gltrans, accnt, period
            WHERE ( (gltrans_accnt_id=accnt_id)
             AND (NOT gltrans_posted)
             AND (gltrans_date BETWEEN period_start AND period_end)
             AND (period_id=pPeriodid) ) LOOP
    PERFORM postIntoTrialBalance(_r.gltrans_sequence);
  END LOOP;

  RETURN pPeriodid;

END;
$_$;


ALTER FUNCTION public.thawaccountingperiod(integer) OWNER TO admin;

--
-- TOC entry 2261 (class 1255 OID 146567111)
-- Dependencies: 4536 8
-- Name: thawitemsite(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION thawitemsite(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  _qoh            NUMERIC := 0;
  _netable_qoh    NUMERIC := 0;
  _nonnetable_qoh NUMERIC := 0;
  _value          NUMERIC := 0;
  _itemlocid INTEGER;
  _itemloc RECORD;
  _invhist RECORD;
  _coarse RECORD;
  _fine RECORD;

BEGIN

  IF ( SELECT itemsite_freeze
       FROM itemsite
       WHERE (itemsite_id=pItemsiteid) ) THEN

    SELECT invhist_id INTO _invhist
    FROM invhist
    WHERE ( (invhist_itemsite_id=pItemsiteid)
     AND (NOT invhist_posted) )
    LIMIT 1;
    IF (NOT FOUND) THEN
      UPDATE itemsite
      SET itemsite_freeze=FALSE
      WHERE (itemsite_id=pItemsiteid);
   END IF;

--  Run through any invdetail if this itemsite is still MLC and/or Lot/Serial
    IF ( SELECT ( (itemsite_loccntrl) OR
                  (itemsite_controlmethod IN ('L', 'S')) )
         FROM itemsite
         WHERE (itemsite_id=pItemsiteid) ) THEN

--  Grab all of the itemsite/location/lot/serial combinations
--  that have unposted detail
      FOR _coarse IN SELECT DISTINCT invdetail_location_id, invdetail_ls_id,
                                     invdetail_expiration, invdetail_warrpurc
                     FROM invhist, invdetail
                     WHERE ( (invdetail_invhist_id=invhist_id)
                      AND (NOT invhist_posted)
                      AND (invhist_itemsite_id=pItemsiteid) )
                     ORDER BY invdetail_location_id, invdetail_ls_id LOOP

--  Cache the initial qty of the itemloc specified by the
--  itemsite/location/lot/serial
        SELECT itemloc_id, itemloc_qty, COALESCE(location_netable, TRUE) AS location_netable
        INTO _itemloc
        FROM itemloc LEFT OUTER JOIN location ON (location_id=itemloc_location_id)
        WHERE ( (itemloc_itemsite_id=pItemsiteid)
         AND (itemloc_location_id=_coarse.invdetail_location_id)
         AND (COALESCE(itemloc_ls_id,-1)=COALESCE(_coarse.invdetail_ls_id,-1))
         AND (COALESCE(itemloc_expiration,endOfTime())=COALESCE(_coarse.invdetail_expiration,endOfTime()))
         AND (COALESCE(itemloc_warrpurc,endOfTime())=COALESCE(_coarse.invdetail_warrpurc,endOfTime())) );

--  If the itemloc in question cannot be found, create it
        IF (NOT FOUND) THEN
          SELECT NEXTVAL('itemloc_itemloc_id_seq') INTO _itemlocid;
          INSERT INTO itemloc
          ( itemloc_id, itemloc_itemsite_id,
            itemloc_location_id, itemloc_ls_id,
            itemloc_qty, itemloc_expiration )
          VALUES
          ( _itemlocid, pItemsiteid,
            _coarse.invdetail_location_id, _coarse.invdetail_ls_id,
            0, endOfTime() );

        _qoh := 0.0;
        _netable_qoh := 0.0;
        _nonnetable_qoh := 0.0;

        ELSE
          _itemlocid := _itemloc.itemloc_id;
          _qoh := _itemloc.itemloc_qty;
          IF (_itemloc.location_netable) THEN
            _netable_qoh := _itemloc.itemloc_qty;
          ELSE
            _nonnetable_qoh := _itemloc.itemloc_qty;
          END IF;
        END IF;

--  Now step through each unposted invdetail record for a given
--  itemsite/location/lot/serial
        FOR _fine IN SELECT invdetail_id, invdetail_qty
                     FROM invhist, invdetail
                     WHERE ( (invdetail_invhist_id=invhist_id)
                      AND (NOT invhist_posted)
                      AND (invhist_itemsite_id=pItemsiteid)
                      AND (invdetail_location_id=_coarse.invdetail_location_id)
                      AND (COALESCE(invdetail_ls_id,-1)=COALESCE(_coarse.invdetail_ls_id,-1))
                      AND (COALESCE(invdetail_expiration,endOfTime())=COALESCE(_coarse.invdetail_expiration,endOfTime()))
                      AND (COALESCE(invdetail_warrpurc,endOfTime())=COALESCE(_coarse.invdetail_warrpurc,endOfTime())) )
                     ORDER BY invhist_transdate LOOP

--  Update the running qoh fields in the detail record
          UPDATE invdetail
          SET invdetail_qty_before = _qoh,
              invdetail_qty_after = (_qoh + invdetail_qty)
          WHERE (invdetail_id=_fine.invdetail_id);

--  Update the running qoh
          _qoh = (_qoh + _fine.invdetail_qty);
          IF (_itemloc.location_netable) THEN
            _netable_qoh := (_netable_qoh + _fine.invdetail_qty);
          ELSE
            _nonnetable_qoh := (_nonnetable_qoh + _fine.invdetail_qty);
          END IF;

        END LOOP;

--  If the running qoh end up at 0, delete the itemloc in question
        IF (_qoh = 0) THEN
          DELETE FROM itemloc
          WHERE (itemloc_id=_itemlocid);

--  Otherwise, update the itemloc in question with the resultant qty
        ELSE
          UPDATE itemloc
          SET itemloc_qty=_qoh
          WHERE (itemloc_id=_itemlocid);
        END IF;

      END LOOP;

    END IF;

--  Cache the inital qoh of the itemsite
    SELECT itemsite_qtyonhand, itemsite_value INTO _qoh, _value
    FROM itemsite
    WHERE (itemsite_id=pItemsiteid);

--  We have to un-freeze the itemsite before update-ing its QOH
--  so that that itemsite trigger won't block the QOH update.
--  Also so the invhist trigger won't block the posted update.

    UPDATE itemsite
    SET itemsite_freeze=FALSE
    WHERE (itemsite_id=pItemsiteid);

    FOR _invhist IN SELECT invhist_id,
                           invhist_qoh_before, invhist_qoh_after,
                           invhist_value_before, invhist_value_after
                      FROM invhist
                     WHERE((invhist_itemsite_id=pItemsiteid)
                       AND (NOT invhist_posted))
                     ORDER BY invhist_transdate LOOP

      UPDATE invhist
      SET invhist_qoh_before = _qoh,
          invhist_qoh_after = ( _qoh +
                                _invhist.invhist_qoh_after -
                                _invhist.invhist_qoh_before ),
          invhist_value_before = _value,
          invhist_value_after = ( _value +
                                  _invhist.invhist_value_after -
                                  _invhist.invhist_value_before ),
          invhist_posted = TRUE
      WHERE (invhist_id=_invhist.invhist_id);

      _qoh := (_qoh + (_invhist.invhist_qoh_after - _invhist.invhist_qoh_before));
      _value := (_value + (_invhist.invhist_value_after - _invhist.invhist_value_before));

    END LOOP;

-- _qoh can be used for the netable qoh because of the negative NN transactions
    UPDATE itemsite
       SET itemsite_qtyonhand = _qoh,
           itemsite_nnqoh = _nonnetable_qoh,
           itemsite_value = CASE WHEN ((itemsite_costmethod='A') AND (_value < 0.0)) THEN 0.0
                                 ELSE _value END
     WHERE(itemsite_id=pItemsiteid);

  END IF;

  RETURN pItemsiteid;

END;
$_$;


ALTER FUNCTION public.thawitemsite(integer) OWNER TO admin;

--
-- TOC entry 233 (class 1259 OID 146567113)
-- Dependencies: 6042 6043 6044 8
-- Name: todoitem; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE todoitem (
    todoitem_id integer NOT NULL,
    todoitem_name text NOT NULL,
    todoitem_description text,
    todoitem_incdt_id integer,
    todoitem_creator_username text DEFAULT geteffectivextuser() NOT NULL,
    todoitem_status character(1),
    todoitem_active boolean DEFAULT true NOT NULL,
    todoitem_start_date date,
    todoitem_due_date date,
    todoitem_assigned_date date,
    todoitem_completed_date date,
    todoitem_seq integer DEFAULT 0 NOT NULL,
    todoitem_notes text,
    todoitem_crmacct_id integer,
    todoitem_ophead_id integer,
    todoitem_owner_username text,
    todoitem_priority_id integer,
    todoitem_username text,
    todoitem_recurring_todoitem_id integer,
    todoitem_cntct_id integer
);


ALTER TABLE public.todoitem OWNER TO admin;

--
-- TOC entry 9076 (class 0 OID 0)
-- Dependencies: 233
-- Name: TABLE todoitem; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE todoitem IS 'To-Do List items.';


--
-- TOC entry 9077 (class 0 OID 0)
-- Dependencies: 233
-- Name: COLUMN todoitem.todoitem_recurring_todoitem_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN todoitem.todoitem_recurring_todoitem_id IS 'The first todoitem record in the series if this is a recurring To-Do item. If the todoitem_recurring_todoitem_id is the same as the todoitem_id, this record is the first in the series.';


--
-- TOC entry 2262 (class 1255 OID 146567122)
-- Dependencies: 2886 4536 8
-- Name: todoitem(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION todoitem() RETURNS SETOF todoitem
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _row todoitem%ROWTYPE;
  _priv TEXT;
  _grant BOOLEAN;

BEGIN
  -- This query will give us the most permissive privilege the user has been granted
  SELECT privilege, granted INTO _priv, _grant
  FROM privgranted
  WHERE privilege IN ('MaintainAllToDoItems','ViewAllToDoItems','MaintainPersonalToDoItems','ViewPersonalToDoItems')
  ORDER BY granted DESC, sequence
  LIMIT 1;

  -- If have an 'All' privilege return all results
  IF (_priv ~ 'All' AND _grant) THEN
    FOR _row IN
      SELECT * FROM todoitem
    LOOP
      RETURN NEXT _row;
    END LOOP;
  -- Otherwise if have any other grant, must be personal privilege.
  ELSIF (_grant) THEN
    FOR _row IN
      SELECT * FROM todoitem
      WHERE getEffectiveXtUser() IN (todoitem_owner_username, todoitem_username)
    LOOP
      RETURN NEXT _row;
    END LOOP;
  END IF;

  RETURN;

END;
$$;


ALTER FUNCTION public.todoitem() OWNER TO admin;

--
-- TOC entry 9079 (class 0 OID 0)
-- Dependencies: 2262
-- Name: FUNCTION todoitem(); Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON FUNCTION todoitem() IS 'A table function that returns To Do Items results according to privilege settings.';


--
-- TOC entry 2263 (class 1255 OID 146567123)
-- Dependencies: 4536 8
-- Name: todoitemmove(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION todoitemmove(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  ptodoItemId ALIAS FOR $1;
  pHowFar     ALIAS FOR $2;   -- -1 moves toward front of list, +1 toward back
  _howFar     INTEGER := pHowFar;
  _username   TEXT;
  _currseq    INTEGER;
BEGIN
  SELECT todoitem_username, todoitem_seq INTO _username, _currseq
  FROM todoitem
  WHERE todoitem_id = ptodoItemId;

  IF NOT FOUND THEN
    RETURN -1;
  END IF;

  IF (_currseq + pHowFar <= 0) THEN
    _howFar = 1 - _currseq;   -- move to beginning
  END IF;

  UPDATE todoitem
  SET todoitem_seq=todoitem_seq - _howFar
  WHERE todoitem_seq >= _currseq + _howFar
    AND todoitem_id != ptodoItemId
    AND todoitem_username = _username
    AND todoitem_status != 'C';

  UPDATE todoitem
  SET todoitem_seq=_currseq + _howFar
  WHERE todoitem_id = ptodoItemId;

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.todoitemmove(integer, integer) OWNER TO admin;

--
-- TOC entry 2264 (class 1255 OID 146567124)
-- Dependencies: 4536 8
-- Name: todoitemmovedown(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION todoitemmovedown(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  ptodoItemId ALIAS FOR $1;
BEGIN
  RETURN todoItemMove(ptodoItemId, 1);        -- move toward end of list
END;
$_$;


ALTER FUNCTION public.todoitemmovedown(integer) OWNER TO admin;

--
-- TOC entry 2265 (class 1255 OID 146567125)
-- Dependencies: 4536 8
-- Name: todoitemmoveup(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION todoitemmoveup(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  ptodoItemId ALIAS FOR $1;
BEGIN
  RETURN todoItemMove(ptodoItemId, -1);       -- move toward front of list
END;
$_$;


ALTER FUNCTION public.todoitemmoveup(integer) OWNER TO admin;

--
-- TOC entry 2266 (class 1255 OID 146567126)
-- Dependencies: 4536 8
-- Name: togglebankreccleared(integer, text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION togglebankreccleared(integer, text, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
  pBankrecid ALIAS FOR $1;
  pSource    ALIAS FOR $2;
  pSourceid  ALIAS FOR $3;
  _cleared BOOLEAN;
  _r RECORD;

BEGIN

  SELECT bankrecitem_id, bankrecitem_cleared INTO _r
    FROM bankrecitem
   WHERE ( (bankrecitem_bankrec_id=pBankrecid)
     AND   (bankrecitem_source=pSource)
     AND   (bankrecitem_source_id=pSourceid) );
  IF ( NOT FOUND ) THEN
    _cleared := TRUE;
    INSERT INTO bankrecitem
    (bankrecitem_bankrec_id, bankrecitem_source,
     bankrecitem_source_id, bankrecitem_cleared)
    VALUES
    (pBankrecid, pSource, pSourceid, _cleared);
  ELSE
    _cleared := (NOT _r.bankrecitem_cleared);
    UPDATE bankrecitem
       SET bankrecitem_cleared=_cleared
     WHERE (bankrecitem_id=_r.bankrecitem_id);
  END IF;

  RETURN _cleared;
END;
$_$;


ALTER FUNCTION public.togglebankreccleared(integer, text, integer) OWNER TO admin;

--
-- TOC entry 2267 (class 1255 OID 146567127)
-- Dependencies: 4536 8
-- Name: togglebankreccleared(integer, text, integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION togglebankreccleared(integer, text, integer, numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
DECLARE
  pBankrecid ALIAS FOR $1;
  pSource    ALIAS FOR $2;
  pSourceid  ALIAS FOR $3;
  pCurrrate  ALIAS FOR $4;
  _cleared BOOLEAN;
  _r RECORD;

BEGIN

  SELECT bankrecitem_id, bankrecitem_cleared INTO _r
    FROM bankrecitem
   WHERE ( (bankrecitem_bankrec_id=pBankrecid)
     AND   (bankrecitem_source=pSource)
     AND   (bankrecitem_source_id=pSourceid) );
  IF ( NOT FOUND ) THEN
    _cleared := TRUE;
    INSERT INTO bankrecitem
    (bankrecitem_bankrec_id, bankrecitem_source,
     bankrecitem_source_id, bankrecitem_cleared,
     bankrecitem_curr_rate)
    VALUES
    (pBankrecid, pSource,
     pSourceid, _cleared,
     pCurrrate);
  ELSE
    _cleared := (NOT _r.bankrecitem_cleared);
    UPDATE bankrecitem
       SET bankrecitem_cleared=_cleared,
           bankrecitem_curr_rate=pCurrrate
     WHERE (bankrecitem_id=_r.bankrecitem_id);
  END IF;

  RETURN _cleared;
END;
$_$;


ALTER FUNCTION public.togglebankreccleared(integer, text, integer, numeric) OWNER TO admin;

--
-- TOC entry 2268 (class 1255 OID 146567128)
-- Dependencies: 4536 8
-- Name: togglebankreccleared(integer, text, integer, numeric, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION togglebankreccleared(integer, text, integer, numeric, numeric) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pBankrecid ALIAS FOR $1;
  pSource    ALIAS FOR $2;
  pSourceid  ALIAS FOR $3;
  pCurrrate  ALIAS FOR $4;
  pAmount    ALIAS FOR $5;
  _cleared BOOLEAN;
  _r RECORD;

BEGIN

  SELECT bankrecitem_id, bankrecitem_cleared INTO _r
    FROM bankrecitem
   WHERE ( (bankrecitem_bankrec_id=pBankrecid)
     AND   (bankrecitem_source=pSource)
     AND   (bankrecitem_source_id=pSourceid) );
  IF ( NOT FOUND ) THEN
    _cleared := TRUE;
    INSERT INTO bankrecitem
    (bankrecitem_bankrec_id, bankrecitem_source,
     bankrecitem_source_id, bankrecitem_cleared,
     bankrecitem_curr_rate, bankrecitem_amount)
    VALUES
    (pBankrecid, pSource,
     pSourceid, _cleared,
     pCurrrate, pAmount);
  ELSE
    _cleared := FALSE;
    DELETE FROM bankrecitem
    WHERE bankrecitem_id = _r.bankrecitem_id;
  END IF;

  RETURN _cleared;
END;
$_$;


ALTER FUNCTION public.togglebankreccleared(integer, text, integer, numeric, numeric) OWNER TO admin;

--
-- TOC entry 2269 (class 1255 OID 146567129)
-- Dependencies: 4536 8
-- Name: togglebomitemcost(integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION togglebomitemcost(integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pBomitemid ALIAS FOR $1;
  pEnabled   ALIAS FOR $2;

BEGIN

  IF (pEnabled) THEN
    INSERT INTO bomitemcost
    (bomitemcost_bomitem_id, bomitemcost_costelem_id,
     bomitemcost_lowlevel, bomitemcost_stdcost,
     bomitemcost_posted, bomitemcost_actcost,
     bomitemcost_updated, bomitemcost_curr_id)
    SELECT
     bomitem_id, itemcost_costelem_id,
     itemcost_lowlevel, itemcost_stdcost,
     itemcost_posted, itemcost_actcost,
     itemcost_updated, itemcost_curr_id
    FROM bomitem JOIN itemcost ON (itemcost_item_id=bomitem_item_id)
    WHERE (bomitem_id=pBomitemid);
  ELSE
    DELETE FROM bomitemcost
    WHERE (bomitemcost_bomitem_id=pBomitemid);
  END IF;

  RETURN 0;
END;
$_$;


ALTER FUNCTION public.togglebomitemcost(integer, boolean) OWNER TO admin;

--
-- TOC entry 2270 (class 1255 OID 146567130)
-- Dependencies: 4536 8
-- Name: tonumeric(text, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION tonumeric(text, numeric) RETURNS numeric
    LANGUAGE plpgsql IMMUTABLE
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pText ALIAS FOR $1;
  pDefault ALIAS FOR $2;

BEGIN

  IF (isNumeric(pText)) THEN
    RETURN TO_NUMBER(pText, '999999999999');
  ELSE
    RETURN pDefault;
  END IF;

END;
$_$;


ALTER FUNCTION public.tonumeric(text, numeric) OWNER TO admin;

--
-- TOC entry 2271 (class 1255 OID 146567131)
-- Dependencies: 4536 8
-- Name: transitwhs(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION transitwhs() RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _id	INTEGER;

BEGIN
  _id = fetchMetricValue('TransitWarehouse');

  IF (_id IS NOT NULL
      AND EXISTS(SELECT warehous_id FROM whsinfo WHERE (warehous_id=_id)) ) THEN
    RETURN _id;
  END IF;

  SELECT warehous_id INTO _id FROM whsinfo WHERE warehous_transit;

  IF (NOT FOUND) THEN
    _id := NEXTVAL('warehous_warehous_id_seq');

    INSERT INTO whsinfo (
      warehous_id,
      warehous_code,
      warehous_descrip,
      --warehous_fob,
      warehous_active,
      --warehous_counttag_prefix,
      --warehous_counttag_number,
      --warehous_bol_prefix,
      --warehous_bol_number,
      warehous_shipping,
      warehous_useslips,
      warehous_usezones,
      --warehous_aislesize,
      --warehous_aislealpha,
      --warehous_racksize,
      --warehous_rackalpha,
      --warehous_binsize,
      --warehous_binalpha,
      --warehous_locationsize,
      --warehous_locationalpha,
      warehous_enforcearbl,
      warehous_default_accnt_id,
      --warehous_shipping_commission,
      --warehous_cntct_id,
      --warehous_addr_id,
      warehous_taxzone_id
     ) VALUES (
       _id,
      'TRANSIT',
      'Intermediate Warehouse for Inter-Warehouse Transfers',
      --text,
      TRUE,
      --text,
      --integer,
      --text,
      --integer,
      TRUE,
      FALSE,
      FALSE,
      --integer,
      --boolean,
      --integer,
      --boolean,
      --integer,
      --boolean,
      --integer,
      --boolean,
      FALSE,
      fetchMetricValue('UnassignedAccount'),
      --numeric(8,4) default 0.00,
      --integer,
      --integer,
      NULL
    );
  END IF;

  PERFORM setMetric('TransitWarehouse', _id);

  RETURN _id;

END;
$$;


ALTER FUNCTION public.transitwhs() OWNER TO admin;

--
-- TOC entry 2272 (class 1255 OID 146567132)
-- Dependencies: 4536 8
-- Name: transtype(text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION transtype(text, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTransType ALIAS FOR $1;
  pTargetType ALIAS FOR $2;

BEGIN

  IF (pTargetType = 255) THEN
    RETURN TRUE;
  ELSIF (pTargetType = 1) THEN
    RETURN receipts(pTransType);
  ELSIF (pTargetType = 2) THEN
    RETURN issues(pTransType);
  ELSIF (pTargetType = 4) THEN
    RETURN shipments(pTransType);
  ELSIF (pTargetType = 8) THEN
    RETURN adjustments(pTransType);
  ELSIF (pTargetType = 16) THEN
    RETURN transfers(pTransType);
  ELSIF (pTargetType = 32) THEN
    RETURN scraps(pTransType);
  ELSE
    RETURN TRUE;
  END IF;

END;
$_$;


ALTER FUNCTION public.transtype(text, integer) OWNER TO admin;

--
-- TOC entry 2273 (class 1255 OID 146567133)
-- Dependencies: 4536 8
-- Name: trylock(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION trylock(integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pKey1 ALIAS FOR $1;
  pKey2 ALIAS FOR $2;
  _pid integer;
BEGIN

  /* The standard try lock ignores locks made by the current user in same
     session.  Check for ANY lock on this id, whether by this user or not */
  SELECT pid INTO _pid
  FROM pg_locks
  WHERE ((classid=pKey1)
   AND (objid=pKey2)
   AND (objsubid=2));

  IF (FOUND) THEN
    RETURN false;
  ELSE
    RETURN pg_try_advisory_lock(pKey1,pKey2);
  END IF;

END;
$_$;


ALTER FUNCTION public.trylock(integer, integer) OWNER TO admin;

--
-- TOC entry 2274 (class 1255 OID 146567134)
-- Dependencies: 4536 8
-- Name: undomerge(text, text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION undomerge(text, text, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pSchema       ALIAS FOR $1;
  pTable        ALIAS FOR $2;
  pId           ALIAS FOR $3;
  _qry          TEXT;
  _r            RECORD;
  _result       INTEGER;

BEGIN
  FOR _r IN
    SELECT *
      FROM mrgundo
     WHERE mrgundo_base_schema = pSchema
       AND mrgundo_base_table  = pTable
       AND mrgundo_base_id     = pId
       AND mrgundo_col IS NOT NULL  -- NULL mrgundo_col signals a row to delete on purge
  LOOP
    IF (_r.mrgundo_value IS NULL) THEN
      _qry := 'UPDATE ' || quote_ident(_r.mrgundo_schema)  ||
                    '.' || quote_ident(_r.mrgundo_table)   ||
                ' SET ' || quote_ident(_r.mrgundo_col)     || '= NULL
               WHERE (' || _r.mrgundo_pkey_col || '=' || _r.mrgundo_pkey_id || ');';
    ELSE
      _qry := 'UPDATE ' || quote_ident(_r.mrgundo_schema)  ||
                    '.' || quote_ident(_r.mrgundo_table)   ||
                ' SET ' || quote_ident(_r.mrgundo_col)     ||
              '= CAST(' || quote_literal(_r.mrgundo_value) || ' AS '
                        || quote_ident(_r.mrgundo_type)    || ')
               WHERE (' || _r.mrgundo_pkey_col || '=' || _r.mrgundo_pkey_id || ');';
    END IF;

    EXECUTE _qry;
  END LOOP;

  DELETE FROM mrgundo
   WHERE mrgundo_base_schema = pSchema
     AND mrgundo_base_table  = pTable
     AND mrgundo_base_id     = pId;

  GET DIAGNOSTICS _result = ROW_COUNT;

  RETURN _result;

END;
$_$;


ALTER FUNCTION public.undomerge(text, text, integer) OWNER TO admin;

--
-- TOC entry 2275 (class 1255 OID 146567135)
-- Dependencies: 4536 8
-- Name: unreleasepurchaseorder(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION unreleasepurchaseorder(ppoheadid integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN

  IF ( ( SELECT (COUNT(*) > 0)
         FROM poitem
         WHERE ( (poitem_pohead_id=pPoheadid)
           AND   ( (poitem_status='C') OR
                   (poitem_qty_received > 0.0) OR
                   (poitem_qty_returned > 0.0) OR
                   (poitem_qty_vouchered > 0.0) ) ) ) ) THEN
    RETURN -1;
  END IF;

  IF ( ( SELECT (pohead_status='O')
         FROM pohead
         WHERE (pohead_id=pPoheadid) ) ) THEN

    --update status and erase the date that the order was released on
    UPDATE pohead
    SET pohead_status='U', pohead_released = NULL
    WHERE (pohead_id=pPoheadid);

  END IF;

  --update status and erase the duedates at release
  UPDATE poitem
  SET poitem_status='U', poitem_rlsd_duedate = NULL
  WHERE (poitem_pohead_id=pPoheadid);

  RETURN 1;

END;
$$;


ALTER FUNCTION public.unreleasepurchaseorder(ppoheadid integer) OWNER TO admin;

--
-- TOC entry 2276 (class 1255 OID 146567136)
-- Dependencies: 2763 4536 8
-- Name: uomusedforitem(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION uomusedforitem(integer) RETURNS SETOF uom
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pitemid       ALIAS FOR $1;
  _row          uom%ROWTYPE;
BEGIN
  FOR _row IN SELECT DISTINCT *
              FROM uom
              WHERE uom_id IN (
                SELECT bomitem_uom_id AS uom_id
                FROM bomitem
                WHERE (bomitem_item_id=pitemid)
                UNION
                SELECT cmitem_qty_uom_id
                FROM cmitem, itemsite
                WHERE ((cmitem_itemsite_id=itemsite_id)
                   AND (itemsite_item_id=pitemid))
                UNION
                SELECT cmitem_price_uom_id
                FROM cmitem, itemsite
                WHERE ((cmitem_itemsite_id=itemsite_id)
                   AND (itemsite_item_id=pitemid))
                UNION
                SELECT coitem_qty_uom_id
                FROM coitem, itemsite
                WHERE ((coitem_itemsite_id=itemsite_id)
                   AND (itemsite_item_id=pitemid))
                UNION
                SELECT coitem_price_uom_id
                FROM coitem, itemsite
                WHERE ((coitem_itemsite_id=itemsite_id)
                   AND (itemsite_item_id=pitemid))
                UNION
                SELECT invcitem_qty_uom_id
                FROM invcitem
                WHERE ((invcitem_item_id=pitemid))
                UNION
                SELECT invcitem_price_uom_id
                FROM invcitem
                WHERE ((invcitem_item_id=pitemid))
                UNION
                SELECT ipsitem_qty_uom_id
                FROM ipsiteminfo
                WHERE (ipsitem_item_id=pitemid)
                UNION
                SELECT ipsitem_price_uom_id
                FROM ipsiteminfo
                WHERE (ipsitem_item_id=pitemid)
                UNION
                SELECT quitem_qty_uom_id
                FROM quitem, itemsite
                WHERE ((quitem_itemsite_id=itemsite_id)
                   AND (itemsite_item_id=pitemid))
                UNION
                SELECT quitem_price_uom_id
                FROM quitem, itemsite
                WHERE ((quitem_itemsite_id=itemsite_id)
                   AND (itemsite_item_id=pitemid))
                UNION
                SELECT womatl_uom_id
                FROM womatl, itemsite
                WHERE ((womatl_itemsite_id=itemsite_id)
                   AND (itemsite_item_id=pitemid))
  ) LOOP
    RETURN NEXT _row;
  END LOOP;

  IF (fetchmetricbool('MultiWhs')) THEN
    FOR _row IN SELECT DISTINCT *
                FROM uom
                WHERE uom_id IN (
                  SELECT rahist_uom_id
                  FROM rahist, itemsite
                  WHERE ((rahist_itemsite_id=itemsite_id)
                     AND (itemsite_item_id=pitemid))
    ) LOOP
      RETURN NEXT _row;
    END LOOP;
  END IF;

  RETURN;
END;
$_$;


ALTER FUNCTION public.uomusedforitem(integer) OWNER TO admin;

--
-- TOC entry 2277 (class 1255 OID 146567137)
-- Dependencies: 4536 8
-- Name: updateabcclass(text, numeric, numeric, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updateabcclass(text, numeric, numeric, date, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pClassCodePattern ALIAS FOR $1;
  pACutoff ALIAS FOR $2;
  pBCutoff ALIAS FOR $3;
  pStartDate ALIAS FOR $4;
  pEndDate ALIAS FOR $5;
  _result INTEGER;

BEGIN

  SELECT updateABCClass(pClassCodePattern, -1, pACutoff, pBCutoff, pStartDate, pEndDate) INTO _result;
  RETURN _result;

END;
$_$;


ALTER FUNCTION public.updateabcclass(text, numeric, numeric, date, date) OWNER TO admin;

--
-- TOC entry 2279 (class 1255 OID 146567139)
-- Dependencies: 4536 8
-- Name: updateabcclass(integer, numeric, numeric, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updateabcclass(integer, numeric, numeric, date, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pClasscodeid ALIAS FOR $1;
  pACutoff ALIAS FOR $2;
  pBCutoff ALIAS FOR $3;
  pStartDate ALIAS FOR $4;
  pEndDate ALIAS FOR $5;
  _result INTEGER;

BEGIN

  SELECT updateABCClass(pClassCodeid, -1, pACutoff, pBCutoff, pStartDate, pEndDate) INTO _result;
  RETURN _result;

END;
$_$;


ALTER FUNCTION public.updateabcclass(integer, numeric, numeric, date, date) OWNER TO admin;

--
-- TOC entry 2278 (class 1255 OID 146567138)
-- Dependencies: 4536 8
-- Name: updateabcclass(text, integer, numeric, numeric, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updateabcclass(text, integer, numeric, numeric, date, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pClassCodePattern ALIAS FOR $1;
  pWarehousid ALIAS FOR $2;
  pACutoff ALIAS FOR $3;
  pBCutoff ALIAS FOR $4;
  pStartDate ALIAS FOR $5;
  pEndDate ALIAS FOR $6;
  _updateCount INTEGER;
  _totalValue NUMERIC;
  _cumulativeValue NUMERIC;
  _itemsite RECORD;

BEGIN

  SELECT COUNT(*) INTO _updateCount
  FROM itemsite, item, classcode
  WHERE ( (itemsite_item_id=item_id)
   AND (item_classcode_id=classcode_id)
   AND (itemsite_autoabcclass)
   AND (classcode_code ~ pClassCodePattern)
   AND ((itemsite_warehous_id=pWarehousid) OR (pWarehousid=-1)) );

  IF (_updateCount IS NULL) THEN
    RETURN 0;
  ELSE

    UPDATE itemsite
    SET itemsite_abcclass='T'
    FROM item, classcode
    WHERE ( (itemsite_item_id=item_id)
     AND (item_classcode_id=classcode_id)
     AND (itemsite_autoabcclass)
     AND (classcode_code ~ pClassCodePattern)
     AND ((itemsite_warehous_id=pWarehousid) OR (pWarehousid=-1)) );

    SELECT SUM(ABS(invhist_qoh_before - invhist_qoh_after) * invhist_unitcost) INTO _totalValue
    FROM invhist, itemsite, item, classcode
    WHERE ( (invhist_itemsite_id=itemsite_id)
     AND (itemsite_item_id=item_id)
     AND (item_classcode_id=classcode_id)
     AND (invhist_analyze)
     AND (invhist_transtype ~ '^[IR]')
     AND (itemsite_autoabcclass)
     AND (classcode_code ~ pClassCodePattern)
     AND (invhist_transdate::DATE BETWEEN pStartDate AND pEndDate)
     AND ((itemsite_warehous_id=pWarehousid) OR (pWarehousid=-1)) );

    IF ( (_totalValue IS NULL) OR (_totalValue = 0) ) THEN
      UPDATE itemsite
      SET itemsite_abcclass='A'
      WHERE (itemsite_abcclass='T');
    ELSE

      _cumulativeValue := 0;

      FOR _itemsite IN SELECT itemsite_id, item_number,
                              SUM(ABS(invhist_qoh_before - invhist_qoh_after) * invhist_unitcost) AS value
                       FROM invhist, itemsite, item, classcode
                       WHERE ( (invhist_itemsite_id=itemsite_id)
                        AND (itemsite_item_id=item_id)
                        AND (item_classcode_id=classcode_id)
                        AND (invhist_analyze)
                        AND (invhist_transtype ~ '^[IR]')
                        AND (itemsite_autoabcclass)
                        AND (classcode_code ~ pClassCodePattern)
                        AND (invhist_transdate::DATE BETWEEN pStartDate AND pEndDate)
                        AND ((itemsite_warehous_id=pWarehousid) OR (pWarehousid=-1)) )
                       GROUP BY itemsite_id, item_number
                       ORDER BY value DESC LOOP

        IF (_itemsite.value IS NOT NULL) THEN
          _cumulativeValue := _cumulativeValue + _itemsite.value;
        END IF;

        IF ((_cumulativeValue / _totalValue) <= pACutoff) THEN
          UPDATE itemsite
          SET itemsite_abcclass='A'
          WHERE (itemsite_id=_itemsite.itemsite_id);
        ELSE
          IF ((_cumulativeValue / _totalValue) <= pBCutoff) THEN
            UPDATE itemsite
            SET itemsite_abcclass='B'
            WHERE (itemsite_id=_itemsite.itemsite_id);
          ELSE
            UPDATE itemsite
            SET itemsite_abcclass='C'
            WHERE (itemsite_id=_itemsite.itemsite_id);
          END IF;
        END IF;

      END LOOP;

      UPDATE itemsite
      SET itemsite_abcclass='C'
      WHERE (itemsite_abcclass='T');
    END IF;

  END IF;

  RETURN _updateCount;

END;
$_$;


ALTER FUNCTION public.updateabcclass(text, integer, numeric, numeric, date, date) OWNER TO admin;

--
-- TOC entry 2280 (class 1255 OID 146567140)
-- Dependencies: 4536 8
-- Name: updateabcclass(integer, integer, numeric, numeric, date, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updateabcclass(integer, integer, numeric, numeric, date, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pClasscodeid ALIAS FOR $1;
  pWarehousid ALIAS FOR $2;
  pACutoff ALIAS FOR $3;
  pBCutoff ALIAS FOR $4;
  pStartDate ALIAS FOR $5;
  pEndDate ALIAS FOR $6;
  _updateCount INTEGER;
  _totalValue NUMERIC;
  _cumulativeValue NUMERIC;
  _itemsite RECORD;

BEGIN

  SELECT COUNT(*) INTO _updateCount
  FROM itemsite, item
  WHERE ( (itemsite_item_id=item_id)
   AND ((item_classcode_id=pClasscodeid) OR (pClasscodeid=-1))
   AND ((itemsite_warehous_id=pWarehousid) OR (pWarehousid=-1)) );

  IF (_updateCount IS NULL) THEN
    _updateCount := 0;
  ELSE

    UPDATE itemsite
    SET itemsite_abcclass='T'
    FROM item
    WHERE ( (itemsite_item_id=item_id)
     AND ((item_classcode_id=pClasscodeid) OR (pClasscodeid=-1))
     AND ((itemsite_warehous_id=pWarehousid) OR (pWarehousid=-1)) );

    SELECT SUM(ABS(invhist_qoh_before - invhist_qoh_after) * invhist_unitcost) INTO _totalValue
    FROM invhist, itemsite, item
    WHERE ( (invhist_itemsite_id=itemsite_id)
     AND (itemsite_item_id=item_id)
     AND (invhist_analyze)
     AND (invhist_transtype ~ '^[IR]')
     AND ((item_classcode_id=pClasscodeid) OR (pClasscodeid=-1))
     AND (invhist_transdate::DATE BETWEEN pStartDate AND pEndDate)
     AND ((itemsite_warehous_id=pWarehousid) OR (pWarehousid=-1)) );

    IF ( (_totalValue IS NULL) OR (_totalValue = 0) ) THEN
      UPDATE itemsite
      SET itemsite_abcclass='A'
      WHERE (itemsite_abcclass='T');
    ELSE

      _cumulativeValue := 0;

      FOR _itemsite IN SELECT itemsite_id, item_number,
                              SUM(ABS(invhist_qoh_before - invhist_qoh_after) * invhist_unitcost) AS value
                       FROM invhist, itemsite, item
                       WHERE ( (invhist_itemsite_id=itemsite_id)
                        AND (itemsite_item_id=item_id)
                        AND (invhist_analyze)
                        AND (invhist_transtype ~ '^[IR]')
                        AND ((item_classcode_id=pClasscodeid) OR (pClasscodeid=-1))
                        AND (invhist_transdate::DATE BETWEEN pStartDate AND pEndDate)
                        AND ((itemsite_warehous_id=pWarehousid) OR (pWarehousid=-1)) )
                       GROUP BY itemsite_id, item_number
                       ORDER BY value DESC LOOP

        IF (_itemsite.value IS NOT NULL) THEN
          _cumulativeValue := _cumulativeValue + _itemsite.value;
        END IF;

        IF ((_cumulativeValue / _totalValue) <= pACutoff) THEN
          UPDATE itemsite
          SET itemsite_abcclass='A'
          WHERE (itemsite_id=_itemsite.itemsite_id);
        ELSE
          IF ((_cumulativeValue / _totalValue) <= pBCutoff) THEN
            UPDATE itemsite
            SET itemsite_abcclass='B'
            WHERE (itemsite_id=_itemsite.itemsite_id);
          ELSE
            UPDATE itemsite
            SET itemsite_abcclass='C'
            WHERE (itemsite_id=_itemsite.itemsite_id);
          END IF;
        END IF;

      END LOOP;

      UPDATE itemsite
      SET itemsite_abcclass='C'
      WHERE (itemsite_abcclass='T');
    END IF;

  END IF;

  RETURN _updateCount;

END;
$_$;


ALTER FUNCTION public.updateabcclass(integer, integer, numeric, numeric, date, date) OWNER TO admin;

--
-- TOC entry 2281 (class 1255 OID 146567141)
-- Dependencies: 4536 8
-- Name: updatecharassignment(text, integer, integer, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updatecharassignment(text, integer, integer, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTargetType ALIAS FOR $1;
  pTargetId ALIAS FOR $2;
  pCharId ALIAS FOR $3;
  pValue ALIAS FOR $4;
  _charassid INTEGER;

BEGIN

  SELECT updateCharAssignment(pTargetType, pTargetId, pCharId, pValue, 0) INTO _charassid;

  RETURN _charassid;

END;
$_$;


ALTER FUNCTION public.updatecharassignment(text, integer, integer, text) OWNER TO admin;

--
-- TOC entry 2282 (class 1255 OID 146567142)
-- Dependencies: 4536 8
-- Name: updatecharassignment(text, integer, integer, text, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updatecharassignment(text, integer, integer, text, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pTargetType ALIAS FOR $1;
  pTargetId ALIAS FOR $2;
  pCharId ALIAS FOR $3;
  pValue ALIAS FOR $4;
  pPrice ALIAS FOR $5;
  _charassid INTEGER;
  _charassprice NUMERIC;
  _explodedJob BOOLEAN = FALSE;
  _value TEXT;

BEGIN

  -- Check for Valid Assignment
  IF (pTargetType='SI') THEN
    SELECT (item_config AND wo_status != 'O') INTO _explodedJob
        FROM coitem,itemsite,item,wo
        WHERE ((coitem_id=pTargetId)
        AND (itemsite_id=coitem_itemsite_id)
        AND (item_id=itemsite_item_id)
        AND (wo_ordtype='S')
        AND (wo_ordid=coitem_id));
  END IF;

  SELECT charass_id,charass_value INTO _charassid, _value
    FROM charass
   WHERE ((charass_target_type=pTargetType)
     AND  (charass_target_id=pTargetId)
     AND  (charass_char_id=pCharId) )
   LIMIT 1;
  IF (FOUND) THEN
    IF (_explodedJob AND pValue != _value) THEN
      RAISE EXCEPTION  'Characteristic may not be updated for Configured Item with exploded Work Order.';
    ELSIF(COALESCE(pValue, '')!='') THEN
        UPDATE charass
        SET charass_value = pValue,
            charass_price = pPrice
        WHERE (charass_id=_charassid);
    ELSE
      DELETE
        FROM charass
       WHERE (charass_id=_charassid);
      _charassid := 0;
    END IF;
  ELSE
    IF ( (_explodedJob) AND (COALESCE(pValue, '')!='') ) THEN
      RAISE EXCEPTION  'Characteristics may not be updated for Configured Item with exploded Work Order.';
    ELSIF(COALESCE(pValue, '')!='') THEN
      SELECT nextval('charass_charass_id_seq') INTO _charassid;
      INSERT INTO charass
            (charass_id, charass_target_type, charass_target_id,
             charass_char_id, charass_value, charass_price)
      VALUES(_charassid, pTargetType, pTargetId,
             pCharId, pValue, pPrice);
    ELSE
      _charassid := 0;
    END IF;
  END IF;

  RETURN _charassid;

END;
$_$;


ALTER FUNCTION public.updatecharassignment(text, integer, integer, text, numeric) OWNER TO admin;

--
-- TOC entry 2283 (class 1255 OID 146567143)
-- Dependencies: 4536 8
-- Name: updatecost(integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updatecost(integer, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemcostid ALIAS FOR $1;
  pCost ALIAS FOR $2;

BEGIN
  RETURN updateCost(pItemcostid, pCost, baseCurrId());
END;
$_$;


ALTER FUNCTION public.updatecost(integer, numeric) OWNER TO admin;

--
-- TOC entry 2284 (class 1255 OID 146567146)
-- Dependencies: 4536 8
-- Name: updatecost(integer, numeric, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updatecost(integer, numeric, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
    pItemcostid ALIAS FOR $1;
    pCost ALIAS FOR $2;
    pCurrId ALIAS FOR $3;

BEGIN
  IF ( ( SELECT (itemcost_stdcost > 0)
           FROM itemcost
          WHERE (itemcost_id=pItemcostid) )  OR
        (pCost > 0) ) THEN
    UPDATE itemcost
       SET itemcost_actcost=pCost, itemcost_updated=CURRENT_DATE,
           itemcost_curr_id=pCurrId
     WHERE (itemcost_id=pItemcostid);

    RETURN pItemcostid;

  ELSE
    DELETE FROM itemcost
     WHERE (itemcost_id=pItemcostid);

    RETURN -1;
  END IF;

END;
$_$;


ALTER FUNCTION public.updatecost(integer, numeric, integer) OWNER TO admin;

--
-- TOC entry 2257 (class 1255 OID 146567144)
-- Dependencies: 4536 8
-- Name: updatecost(integer, text, boolean, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updatecost(integer, text, boolean, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  returnVal INTEGER;

BEGIN
  SELECT updateCost($1, $2, $3, $4, baseCurrId()) INTO returnVal;
  RETURN returnVal;
END;
$_$;


ALTER FUNCTION public.updatecost(integer, text, boolean, numeric) OWNER TO admin;

--
-- TOC entry 2258 (class 1255 OID 146567145)
-- Dependencies: 4536 8
-- Name: updatecost(integer, integer, boolean, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updatecost(integer, integer, boolean, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  returnVal INTEGER;

BEGIN
  SELECT updateCost($1, $2, $3, $4, baseCurrId()) INTO returnVal;
  RETURN returnVal;
END;
$_$;


ALTER FUNCTION public.updatecost(integer, integer, boolean, numeric) OWNER TO admin;

--
-- TOC entry 2285 (class 1255 OID 146567147)
-- Dependencies: 4536 8
-- Name: updatecost(integer, text, boolean, numeric, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updatecost(integer, text, boolean, numeric, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pCosttype ALIAS FOR $2;
  pLevel ALIAS FOR $3;
  pCost ALIAS FOR $4;
  pCurrid ALIAS FOR $5;
  _cost NUMERIC;
  _currId INTEGER;
  _p RECORD;
  _itemcostid INTEGER;

BEGIN

  IF (pCost IS NULL) THEN
    _cost = 0;
  ELSE
    _cost = pCost;
  END IF;

  IF (pCurrId IS NULL) THEN
    _currId := baseCurrID();
  ELSE
    _currId := pCurrId;
  END IF;

  SELECT itemcost_id, itemcost_stdcost INTO _p
  FROM itemcost, costelem
  WHERE ( (itemcost_costelem_id=costelem_id)
   AND (itemcost_item_id=pItemid)
   AND (itemcost_lowlevel=pLevel)
   AND (costelem_type=pCosttype) );

  IF (NOT FOUND) THEN
    IF (_cost > 0) THEN
      SELECT NEXTVAL('itemcost_itemcost_id_seq') INTO _itemcostid;
      INSERT INTO itemcost
      ( itemcost_id, itemcost_item_id, itemcost_costelem_id, itemcost_lowlevel,
        itemcost_stdcost, itemcost_posted, itemcost_actcost, itemcost_updated,
        itemcost_curr_id )
      SELECT _itemcostid, pItemid, costelem_id, pLevel,
             0, startOfTime(), _cost, CURRENT_DATE,
             _currId
      FROM costelem
      WHERE (costelem_type=pCosttype);

      RETURN _itemcostid;

    ELSE
      RETURN -1;
    END IF;

  ELSIF ( (_p.itemcost_stdcost > 0) OR (_cost > 0) ) THEN
    UPDATE itemcost
    SET itemcost_actcost=_cost,
        itemcost_curr_id = _currId,
        itemcost_updated=CURRENT_DATE
    WHERE (itemcost_id=_p.itemcost_id);

    RETURN _p.itemcost_id;

  ELSE
    DELETE FROM itemcost
    WHERE (itemcost_id=_p.itemcost_id);

    RETURN -1;
  END IF;

END;
$_$;


ALTER FUNCTION public.updatecost(integer, text, boolean, numeric, integer) OWNER TO admin;

--
-- TOC entry 2286 (class 1255 OID 146567148)
-- Dependencies: 4536 8
-- Name: updatecost(integer, integer, boolean, numeric, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updatecost(integer, integer, boolean, numeric, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pCostelemid ALIAS FOR $2;
  pLevel ALIAS FOR $3;
  pCost ALIAS FOR $4;
  pCurrid ALIAS FOR $5;
  _cost NUMERIC;
  _currId INTEGER;
  _p RECORD;
  _itemcostid INTEGER;

BEGIN

  IF (pCost IS NULL) THEN
    _cost = 0;
  ELSE
    _cost = pCost;
  END IF;

  IF (pCurrId IS NULL) THEN
    _currId := baseCurrID();
  ELSE
    _currId := pCurrId;
  END IF;

  SELECT itemcost_id, itemcost_stdcost INTO _p
  FROM itemcost
  WHERE ((itemcost_costelem_id=pCostelemid)
   AND (itemcost_item_id=pItemid)
   AND (itemcost_lowlevel=pLevel) );

  IF (NOT FOUND) THEN
    IF (_cost > 0) THEN
      SELECT NEXTVAL('itemcost_itemcost_id_seq') INTO _itemcostid;
      INSERT INTO itemcost
      ( itemcost_id, itemcost_item_id, itemcost_costelem_id, itemcost_lowlevel,
        itemcost_stdcost, itemcost_posted, itemcost_actcost, itemcost_updated,
        itemcost_curr_id )
      SELECT _itemcostid, pItemid, costelem_id, pLevel,
             0, startOfTime(), _cost, CURRENT_DATE,
             _currId
      FROM costelem
      WHERE (costelem_id=pCostelemid);

      RETURN _itemcostid;

    ELSE
      RETURN -1;
    END IF;

  ELSIF ( (_p.itemcost_stdcost > 0) OR (_cost > 0) ) THEN
    UPDATE itemcost
    SET itemcost_actcost=_cost,
        itemcost_curr_id = _currId,
        itemcost_updated=CURRENT_DATE
    WHERE (itemcost_id=_p.itemcost_id);

    RETURN _p.itemcost_id;

  ELSE
    DELETE FROM itemcost
    WHERE (itemcost_id=_p.itemcost_id);

    RETURN -1;
  END IF;

END;
$_$;


ALTER FUNCTION public.updatecost(integer, integer, boolean, numeric, integer) OWNER TO admin;

--
-- TOC entry 2287 (class 1255 OID 146567149)
-- Dependencies: 2849 2849 4536 8
-- Name: updatecreditmemoline(api.creditmemoline, api.creditmemoline); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updatecreditmemoline(api.creditmemoline, api.creditmemoline) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pNew ALIAS FOR $1;
  pOld ALIAS FOR $2;
  _check INTEGER;
  _r RECORD;

BEGIN
  SELECT cmitem_id INTO _check
  FROM cmitem
  WHERE ( (cmitem_cmhead_id=getCmheadId(pOld.memo_number, FALSE)) AND (cmitem_linenumber=pOld.line_number) );
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Credit Memo # % Line Number # not found', pOld.memo_number, pOld.line_number;
  END IF;

  UPDATE cmitem
    SET cmitem_itemsite_id=COALESCE(itemsite_id, -1),
        cmitem_qtycredit=pNew.qty_to_credit,
        cmitem_qtyreturned=pNew.qty_returned,
        cmitem_unitprice=pNew.net_unit_price,
        cmitem_comments=pNew.notes,
        cmitem_rsncode_id=getRsnId(pNew.reason_code),
        cmitem_taxtype_id=taxtype_id,
        cmitem_qty_uom_id=COALESCE(getUomId(pNew.qty_uom), item_inv_uom_id),
        cmitem_qty_invuomratio=CASE WHEN item_id IS NOT NULL THEN itemuomtouomratio(item_id, COALESCE(getUomId(pNew.qty_uom),item_inv_uom_id),item_inv_uom_id)
                                    ELSE 1
                               END,
        cmitem_price_uom_id=COALESCE(getUomId(pNew.price_uom),item_price_uom_id),
        cmitem_price_invuomratio=CASE WHEN item_id IS NOT NULL THEN itemuomtouomratio(item_id, COALESCE(getUomId(pNew.price_uom),item_price_uom_id),item_price_uom_id)
                                      ELSE 1
                                 END
  FROM cmhead LEFT OUTER JOIN item ON (item_id=getItemId(pNew.item_number))
              LEFT OUTER JOIN itemsite ON (itemsite_item_id=item_id AND
                                           itemsite_warehous_id=getWarehousId(pNew.recv_site, 'ALL'))
              LEFT OUTER JOIN taxtype ON (taxtype_id=CASE WHEN pNew.tax_type IS NULL THEN getItemTaxType(item_id,cmhead_taxzone_id)
                                                          WHEN pNew.tax_type = 'None' THEN NULL
                                                          ELSE getTaxTypeId(pNew.tax_type)
                                                     END)
  WHERE cmitem_cmhead_id=cmhead_id
    AND cmhead_number=pOld.memo_number
    AND cmitem_linenumber=pOld.line_number
    AND cmhead_posted=FALSE;

  RETURN TRUE;
END;
$_$;


ALTER FUNCTION public.updatecreditmemoline(api.creditmemoline, api.creditmemoline) OWNER TO admin;

--
-- TOC entry 2288 (class 1255 OID 146567150)
-- Dependencies: 4536 8
-- Name: updatecustomprivs(); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updatecustomprivs() RETURNS boolean
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _r RECORD;
BEGIN

  FOR _r IN SELECT priv_id
              FROM priv
             WHERE ((priv_name IN (SELECT priv_name
                                     FROM priv
                                    WHERE (priv_module='Custom')
                                   EXCEPT
                                   SELECT ('Custom'||cmd_privname)
                                     FROM cmd))
               AND  (priv_module='Custom')) LOOP
    -- TODO: something here
    DELETE FROM grppriv WHERE grppriv_priv_id=_r.priv_id;
    DELETE FROM usrpriv WHERE usrpriv_priv_id=_r.priv_id;
    DELETE FROM priv WHERE priv_id=_r.priv_id;
  END LOOP;

  FOR _r IN SELECT ('Custom'||cmd_privname) AS privname
              FROM cmd
            EXCEPT
            SELECT priv_name
              FROM priv
             WHERE (priv_module='Custom') LOOP
    -- TODO: something here
    INSERT INTO priv (priv_module, priv_name, priv_descrip)
              VALUES ('Custom', _r.privname, 'Auto Generated Custom Priv.');
  END LOOP;

  RETURN TRUE;
END;
$$;


ALTER FUNCTION public.updatecustomprivs() OWNER TO admin;

--
-- TOC entry 2291 (class 1255 OID 146567151)
-- Dependencies: 2875 2875 4536 8
-- Name: updateinvoicelineitem(api.invoiceline, api.invoiceline); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updateinvoicelineitem(api.invoiceline, api.invoiceline) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
	pNew ALIAS FOR $1;
	pOld ALIAS FOR $2;
	_r RECORD;
BEGIN
	UPDATE invcitem SET
		invcitem_linenumber=pNew.line_number,
		invcitem_item_id=COALESCE(item_id, -1),
		invcitem_custpn=pNew.customer_part_number,
		invcitem_number=(CASE WHEN item_id IS NULL THEN pNew.misc_item_number ELSE NULL END),
		invcitem_warehous_id=(CASE WHEN invcitem_warehous_id IS NULL THEN COALESCE(getwarehousid(pNew.site,'ALL'),-1) ELSE NULL END),
		invcitem_descrip=(CASE WHEN item_id IS NULL THEN pNew.misc_item_description ELSE NULL END),
		invcitem_ordered=pNew.qty_ordered,
		invcitem_billed=COALESCE(pNew.qty_billed, 0),
                invcitem_updateinv=COALESCE(pNew.update_inventory,FALSE),
		invcitem_price=COALESCE(pNew.net_unit_price,itemPrice(item_id,invchead_cust_id,
			invchead_shipto_id,pNew.qty_ordered,invchead_curr_id,invchead_orderdate)),
		invcitem_notes=COALESCE(pNew.notes,''),
		invcitem_salescat_id=CASE
			WHEN item_id IS NULL THEN
				(SELECT salescat_id FROM salescat WHERE salescat_name = pNew.sales_category)
			ELSE NULL
		END,
		invcitem_taxtype_id=taxtype_id,
		invcitem_qty_uom_id=CASE
			WHEN item_id IS NOT NULL THEN
				COALESCE((SELECT uom_id FROM uom WHERE (uom_name=pNew.qty_uom)), item_price_uom_id)
			ELSE NULL
		END,
		invcitem_qty_invuomratio=CASE
			WHEN item_id IS NOT NULL THEN
				itemuomtouomratio(item_id,
					COALESCE((SELECT uom_id FROM uom WHERE uom_name=pNew.qty_uom),item_price_uom_id),
					item_price_uom_id
				)
			ELSE 1
		END,
		invcitem_price_uom_id=CASE
			WHEN item_id IS NOT NULL THEN
				COALESCE((SELECT uom_id FROM uom WHERE uom_name=pNew.price_uom),item_price_uom_id)
			ELSE NULL
		END,
		invcitem_price_invuomratio=CASE
			WHEN item_id IS NOT NULL THEN
				itemuomtouomratio(item_id,
					COALESCE((SELECT uom_id FROM uom WHERE uom_name=pNew.price_uom),item_price_uom_id),
					item_price_uom_id
				)
			ELSE 1
		END,
                invcitem_rev_accnt_id=getGlAccntId(alternate_rev_account)
	FROM invchead
		LEFT OUTER JOIN item ON (item_id=getItemId(pNew.item_number))
		LEFT OUTER JOIN taxtype ON (taxtype_id=CASE
			WHEN pNew.tax_type IS NULL THEN getItemTaxType(item_id,invchead_taxzone_id)
			WHEN pNew.tax_type = 'None' THEN NULL
			ELSE (SELECT taxtype_id FROM taxtype WHERE taxtype_name=pNew.tax_type)
		END)
	WHERE invcitem_invchead_id=invchead_id
		AND invcitem_linenumber=pOld.line_number
		AND invchead_invcnumber=pOld.invoice_number
		AND invchead_posted=FALSE;
	RETURN TRUE;
END;
$_$;


ALTER FUNCTION public.updateinvoicelineitem(api.invoiceline, api.invoiceline) OWNER TO admin;

--
-- TOC entry 2292 (class 1255 OID 146567152)
-- Dependencies: 4536 8
-- Name: updateitemcost(integer, integer, integer, numeric, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updateitemcost(integer, integer, integer, numeric, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
pItemId ALIAS FOR $1;
pCostElemId ALIAS FOR $2;
pCurrId ALIAS FOR $3;
pCost ALIAS FOR $4;
pPostToStandard ALIAS FOR $5;
_itemcost_id INTEGER;
_update_return INTEGER;
_postcost_return BOOLEAN;

--This function is used with the api.itemcost View for updating
--the itemcost table

BEGIN
  SELECT itemcost_id INTO _itemcost_id
  FROM itemcost
  WHERE ( (itemcost_item_id = pItemId) AND (itemcost_costelem_id = pCostElemId) );

  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'itemcost % not found for. ', pItemId || ' & ' || pCostElemId;
  END IF;

  IF (pCost IS NULL OR pCost < 0) THEN
    RAISE EXCEPTION 'itemcost Actual Cost Invalid ', pCost;
  END IF;

  IF (pCost > 0) THEN
    UPDATE itemcost
    SET itemcost_actcost=pCost,
        itemcost_curr_id = pCurrId
    WHERE (itemcost_id=_itemcost_id);

    --Only Post Cost to standard if the parameter is set to true
    IF (pPostToStandard) THEN
      IF (NOT checkPrivilege('PostStandardCosts')) THEN
        RAISE EXCEPTION 'You do not have privileges to poststandard itemcosts. Set api.itemcost post_to_standard to false';
      END IF;
      SELECT postcost(_itemcost_id) INTO _postcost_return;
      IF (NOT _postcost_return) THEN
        RETURN -2;
      END IF;
    END IF;
  ELSE
    RETURN -1;
  END IF;

  RETURN _itemcost_id;

END;
$_$;


ALTER FUNCTION public.updateitemcost(integer, integer, integer, numeric, boolean) OWNER TO admin;

--
-- TOC entry 2293 (class 1255 OID 146567153)
-- Dependencies: 4536 8
-- Name: updateitemsiteleadtime(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updateitemsiteleadtime(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pPad ALIAS FOR $2;
  _p RECORD;
  _materialLeadTime INTEGER;
  _productionLeadTime INTEGER;
  _leadTime INTEGER;

BEGIN

  SELECT item_type, itemsite_wosupply INTO _p
  FROM item, itemsite
  WHERE ( (itemsite_item_id=item_id)
   AND (itemsite_id=pitemsiteid) );

  IF ( (_p.item_type IN ('M', 'P')) ) THEN

    IF (_p.item_type = 'M') THEN
      SELECT COALESCE(MAX(component.itemsite_leadtime), 0) INTO _materialLeadTime
      FROM bomitem, itemsite AS parent, itemsite AS component
      WHERE ( (bomitem_parent_item_id=parent.itemsite_item_id)
       AND (bomitem_rev_id=getActiveRevId('BOM',bomitem_parent_item_id))
       AND (bomitem_item_id=component.itemsite_item_id)
       AND (parent.itemsite_warehous_id=component.itemsite_warehous_id)
       AND (parent.itemsite_id=pItemsiteid) );

      SELECT COALESCE(MAX(booitem_execday), 0) INTO _productionLeadTime
      FROM xtmfg.booitem, itemsite
      WHERE ( (booitem_item_id=itemsite_item_id)
       AND (booitem_rev_id=getActiveRevId('BOO',booitem_item_id))
       AND (itemsite_id=pItemsiteid) );

      _leadTime := (_materialLeadTime + _productionLeadTime + pPad);

    ELSIF (_p.item_type IN ('P')) THEN
      SELECT COALESCE(MAX(itemsrc_leadtime), 0) INTO _leadTime
      FROM itemsrc, itemsite
      WHERE ( (itemsite_item_id=itemsrc_item_id)
       AND (itemsite_id=pItemsiteid) );

      _leadTime := (_leadTime + pPad);
    END IF;

  ELSE
    _leadTime = pPad;
  END IF;

  UPDATE itemsite
  SET itemsite_leadtime=_leadTime
  WHERE (itemsite_id=pItemsiteid);

  RETURN _leadTime;

END;
$_$;


ALTER FUNCTION public.updateitemsiteleadtime(integer, integer) OWNER TO admin;

--
-- TOC entry 2294 (class 1255 OID 146567154)
-- Dependencies: 4536 8
-- Name: updatelistprice(integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updatelistprice(integer, numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;
  pUpdateBy ALIAS FOR $2;

BEGIN

  UPDATE item
  SET item_listprice = (item_listprice * pUpdateBy)
  WHERE (item_id=pItemid);

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.updatelistprice(integer, numeric) OWNER TO admin;

--
-- TOC entry 2295 (class 1255 OID 146567155)
-- Dependencies: 4536 8
-- Name: updatelowerusercosts(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updatelowerusercosts(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid ALIAS FOR $1;

BEGIN
    RETURN updateLowerUserCosts(pItemid, TRUE);
END;
$_$;


ALTER FUNCTION public.updatelowerusercosts(integer) OWNER TO admin;

--
-- TOC entry 2296 (class 1255 OID 146567156)
-- Dependencies: 4536 8
-- Name: updatelowerusercosts(integer, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updatelowerusercosts(integer, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid	ALIAS FOR $1;
  pUpdateActual	ALIAS FOR $2;
  _bomitem RECORD;
  _type CHAR(1);

BEGIN

  SELECT item_type INTO _type
  FROM item
  WHERE (item_id=pItemid);

  IF (_type IN ('M', 'F', 'B', 'T')) THEN
    FOR _bomitem IN SELECT DISTINCT costelem_type
                    FROM ( SELECT COALESCE(bc.costelem_type, ic.costelem_type) AS costelem_type
                           FROM bomitem(pItemid)
                             JOIN item ON (item_id=bomitem_item_id AND item_type <> 'T')
                             JOIN itemcost ON (itemcost_item_id=bomitem_item_id)
                             JOIN costelem ic ON (ic.costelem_id=itemcost_costelem_id AND NOT ic.costelem_sys)
                             LEFT OUTER JOIN bomitemcost ON (bomitemcost_bomitem_id=bomitem_id)
                             LEFT OUTER JOIN costelem bc ON (bc.costelem_id=bomitemcost_costelem_id AND NOT bc.costelem_sys)
                           WHERE ( CURRENT_DATE BETWEEN bomitem_effective AND (bomitem_expires - 1) )

                           UNION SELECT costelem_type
                           FROM itemcost, costelem
                           WHERE ( (itemcost_costelem_id=costelem_id)
                            AND (itemcost_item_id=pItemid) ) ) AS data LOOP

      PERFORM updateSorACost( pItemid, _bomitem.costelem_type,
			      TRUE, lowerCost(pItemid, _bomitem.costelem_type, pUpdateActual),
			      pUpdateActual);
    END LOOP;

  ELSIF (_type = 'C') THEN
    FOR _bomitem IN SELECT DISTINCT costelem_type
                    FROM ( SELECT costelem_type
                           FROM itemcost, costelem,
                                xtmfg.bbomitem
                           WHERE ( (bbomitem_item_id=pItemid)
                            AND ( CURRENT_DATE BETWEEN bbomitem_effective
                                               AND (bbomitem_expires - 1) )
                            AND (NOT costelem_sys)
                            AND (bbomitem_item_id=itemcost_item_id)
                            AND (itemcost_costelem_id=costelem_id) )

                           UNION SELECT costelem_type
                           FROM itemcost, costelem,
                                xtmfg.bbomitem AS t,
                                xtmfg.bbomitem AS s
                           WHERE ( (t.bbomitem_item_id=pItemid)
                            AND ( CURRENT_DATE BETWEEN s.bbomitem_effective
                                               AND (s.bbomitem_expires - 1) )
                            AND ( CURRENT_DATE BETWEEN t.bbomitem_effective
                                               AND (t.bbomitem_expires - 1) )
                            AND (s.bbomitem_parent_item_id=t.bbomitem_parent_item_id)
                            AND (NOT costelem_sys)
                            AND (s.bbomitem_item_id=itemcost_item_id)
                            AND (itemcost_costelem_id=costelem_id) ) ) AS data LOOP

      PERFORM updateSorACost( pItemid, _bomitem.costelem_type,
			      TRUE, lowerCost(pItemid, _bomitem.costelem_type, pUpdateActual),
			      pUpdateActual);
    END LOOP;
  END IF;

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.updatelowerusercosts(integer, boolean) OWNER TO admin;

--
-- TOC entry 2297 (class 1255 OID 146567157)
-- Dependencies: 4536 8
-- Name: updatelowlevel(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updatelowlevel(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE

  pLowlevel ALIAS FOR $1;
  _num_back INTEGER;

BEGIN

  UPDATE costUpdate SET costUpdate_lowlevel_code = (pLowlevel + 1)
    WHERE costUpdate_item_id IN (
	  SELECT bomitem_item_id
	  FROM bomitem JOIN costUpdate ON (bomitem_parent_item_id = costUpdate_item_id)
	  WHERE ((costUpdate_lowlevel_code = pLowlevel)
            AND  (bomitem_rev_id=getActiveRevId('BOM',bomitem_parent_item_id))
	    AND  (CURRENT_DATE BETWEEN bomitem_effective
                                               AND (bomitem_expires - 1))))
      AND costUpdate_lowlevel_code >= pLowlevel;

  GET DIAGNOSTICS _num_back = ROW_COUNT;

  RETURN _num_back;

END;
$_$;


ALTER FUNCTION public.updatelowlevel(integer) OWNER TO admin;

--
-- TOC entry 2298 (class 1255 OID 146567158)
-- Dependencies: 4536 8
-- Name: updateoutlevel(integer, integer, integer[]); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updateoutlevel(integer, integer, integer[]) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pDays ALIAS FOR $2;
  pPeriods ALIAS FOR $3;
  _cursor INTEGER;
  _periodid INTEGER;
  _usage NUMERIC;
  _totalUsage NUMERIC;
  _totalDays INTEGER;
  _outLevel NUMERIC;
  _averageUsage NUMERIC;

BEGIN

  _cursor := 1;
  _totalUsage := 0;
  _totalDays := 0;

  _periodid = pPeriods[_cursor];
  WHILE (_periodid IS NOT NULL) LOOP
    SELECT COALESCE(SUM(invhist_invqty), 0) INTO _usage
    FROM invhist
    WHERE ( (invhist_itemsite_id=pItemsiteid)
     AND ( invhist_transdate::DATE BETWEEN findPeriodStart(_periodid)
                                   AND findPeriodEnd(_periodid) )
     AND (invhist_transtype IN ('SH', 'IM')) );

    _totalUsage := (_totalUsage + _usage);

    _totalDays := ( _totalDays + ( findPeriodEnd(_periodid) -
                                   findPeriodStart(_periodid) + 1 ) );

    _cursor := (_cursor + 1);
    _periodid = pPeriods[_cursor];
  END LOOP;

  IF (_totalDays > 0) THEN
    _outLevel := round(_totalUsage / _totalDays * pDays);

    IF (_outLevel > 0) THEN
      UPDATE itemsite
      SET itemsite_ordertoqty = _outLevel
      WHERE (itemsite_id=pItemsiteid);
    ELSE
      UPDATE itemsite
      SET itemsite_ordertoqty = 0
      WHERE (itemsite_id=pItemsiteid);
    END IF;

    RETURN TRUE;
  ELSE
    RETURN FALSE;
  END IF;

END;
$_$;


ALTER FUNCTION public.updateoutlevel(integer, integer, integer[]) OWNER TO admin;

--
-- TOC entry 2299 (class 1255 OID 146567159)
-- Dependencies: 4536 8
-- Name: updateprice(integer, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updateprice(integer, numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2012 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pIpsitemid ALIAS FOR $1;
  pUpdateBy ALIAS FOR $2;

BEGIN

  RETURN updatePrice(pIpsitemid, 'P', pUpdateBy);

END;

$_$;


ALTER FUNCTION public.updateprice(integer, numeric) OWNER TO admin;

--
-- TOC entry 2300 (class 1255 OID 146567160)
-- Dependencies: 4536 8
-- Name: updateprice(integer, character, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updateprice(integer, character, numeric) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2012 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pIpsitemid ALIAS FOR $1;
  pUpdateType ALIAS FOR $2;
  pUpdateBy ALIAS FOR $3;

BEGIN

  IF (pUpdateType IN('V')) THEN
    UPDATE ipsitem
    SET ipsitem_price = (ipsitem_price + pUpdateBy)
    WHERE (ipsitem_id=pIpsitemid);
    RETURN 1;
  ELSE
    UPDATE ipsitem
    SET ipsitem_price = (ipsitem_price * pUpdateBy)
    WHERE (ipsitem_id=pIpsitemid);
    RETURN 1;
  END IF;

END;
$_$;


ALTER FUNCTION public.updateprice(integer, character, numeric) OWNER TO admin;

--
-- TOC entry 2301 (class 1255 OID 146567161)
-- Dependencies: 4536 8
-- Name: updatepricesbypricingschedule(integer, character, numeric, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updatepricesbypricingschedule(pipsheadid integer, pupdatetype character, pupdateby numeric, pupdatecharprices boolean) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
  _percentMultiplier NUMERIC;
  _currencyDecimals INTEGER;
  _itemRows INTEGER :=0;
  _charRows INTEGER :=0;

BEGIN

	IF NOT (checkPrivilege('MaintainPricingSchedules')) THEN
		RAISE EXCEPTION 'You do not have privileges to maintain Price Schedules.';
	END IF;

	-- Get the current user's currency precision
	SELECT COALESCE(locale_curr_scale, 2) INTO _currencyDecimals
	FROM locale, usr
	WHERE usr_locale_id = locale_id AND usr_username = CURRENT_USER;

	IF (pUpdateType = 'V') THEN
		UPDATE ipsitem
		SET ipsitem_price = noNeg(ROUND( (ipsitem_price + pUpdateBy), _currencyDecimals))
		WHERE (ipsitem_ipshead_id = pIpsHeadId);

		GET DIAGNOSTICS _itemRows = ROW_COUNT;

	ELSE
		_percentMultiplier := (1.0 + (pUpdateBy / 100.0));

		UPDATE ipsitem
		SET ipsitem_price = noNeg(ROUND( (ipsitem_price * _percentMultiplier), _currencyDecimals))
		WHERE (ipsitem_ipshead_id = pIpsHeadId);

		GET DIAGNOSTICS _itemRows = ROW_COUNT;

		IF (pUpdateCharPrices) THEN
			UPDATE ipsitemchar
			SET ipsitemchar_price = noNeg(ROUND( (ipsitemchar_price * _percentMultiplier), _currencyDecimals))
			FROM ipsitem
			WHERE ipsitemchar_ipsitem_id = ipsitem_id AND ipsitem_ipshead_id = pIpsHeadId;

			GET DIAGNOSTICS _charRows = ROW_COUNT;
		END IF;

	END IF;

	RETURN _itemRows + _charRows;

END;
$$;


ALTER FUNCTION public.updatepricesbypricingschedule(pipsheadid integer, pupdatetype character, pupdateby numeric, pupdatecharprices boolean) OWNER TO admin;

--
-- TOC entry 2302 (class 1255 OID 146567162)
-- Dependencies: 4536 8
-- Name: updatepricesbyproductcategory(integer, text, character, numeric, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updatepricesbyproductcategory(pprodcatid integer, pprodcatpattern text, pupdatetype character, pupdateby numeric, pupdatecharprices boolean) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
DECLARE
  _percentMultiplier NUMERIC;
  _currencyDecimals INTEGER;
  _itemRows INTEGER :=0;
  _charRows INTEGER :=0;

BEGIN

	IF NOT (checkPrivilege('MaintainPricingSchedules')) THEN
		RAISE EXCEPTION 'You do not have privileges to maintain Price Schedules.';
	END IF;

	-- Get the current user's currency precision
	SELECT COALESCE(locale_curr_scale, 2) INTO _currencyDecimals
	FROM locale, usr
	WHERE usr_locale_id = locale_id AND usr_username = CURRENT_USER;

	_percentMultiplier := (1.0 + (pUpdateBy / 100.0));

	IF (pUpdateType = 'V') THEN

		IF (pProdCatId IS NOT NULL) THEN
			-- Specified category id
			UPDATE ipsitem
			SET ipsitem_price = noNeg(ROUND( (ipsitem_price + pUpdateBy), _currencyDecimals ))
			FROM item
			WHERE
				ipsitem_item_id = item_id
				AND item_prodcat_id = pProdCatId;

		ELSIF (pProdCatPattern IS NOT NULL) THEN
			-- Pattern match category
			UPDATE ipsitem
			SET ipsitem_price = noNeg(ROUND( (ipsitem_price + pUpdateBy), _currencyDecimals ))
			FROM item
			WHERE
				ipsitem_item_id = item_id
				AND item_prodcat_id IN (
					SELECT prodcat_id FROM prodcat
					WHERE (prodcat_code ~ pProdCatPattern)
				);
		ELSE
			-- All categories
			UPDATE ipsitem
			SET ipsitem_price = noNeg(ROUND( (ipsitem_price + pUpdateBy), _currencyDecimals ));
		END IF;

		GET DIAGNOSTICS _itemRows = ROW_COUNT;

	ELSE

		IF (pProdCatId IS NOT NULL) THEN
			-- Specified category id
			UPDATE ipsitem
			SET ipsitem_price = noNeg(ROUND( (ipsitem_price * _percentMultiplier), _currencyDecimals ))
			FROM item
			WHERE
				ipsitem_item_id = item_id
				AND item_prodcat_id = pProdCatId;

			GET DIAGNOSTICS _itemRows = ROW_COUNT;

			IF(pUpdateCharPrices) THEN
				UPDATE ipsitemchar
				SET ipsitemchar_price = noNeg(ROUND( (ipsitemchar_price * _percentMultiplier), _currencyDecimals ))
				FROM ipsitem, item
				WHERE
					item_prodcat_id = pProdCatId
					AND ipsitem_item_id = item_id
					AND ipsitemchar_ipsitem_id = ipsitem_id;

				GET DIAGNOSTICS _charRows = ROW_COUNT;
			END IF;

		ELSIF (pProdCatPattern IS NOT NULL) THEN
			-- Pattern match category
			UPDATE ipsitem
			SET ipsitem_price = noNeg(ROUND( (ipsitem_price * _percentMultiplier), _currencyDecimals ))
			FROM item
			WHERE
				item_prodcat_id IN (
					SELECT prodcat_id FROM prodcat
					WHERE (prodcat_code ~ pProdCatPattern )
				)
				AND ipsitem_item_id = item_id;

			GET DIAGNOSTICS _itemRows = ROW_COUNT;

			IF(pUpdateCharPrices) THEN
				UPDATE ipsitemchar
				SET ipsitemchar_price = noNeg(ROUND( (ipsitemchar_price * _percentMultiplier), _currencyDecimals ))
				FROM ipsitem, item
				WHERE
					item_prodcat_id IN (
						SELECT prodcat_id FROM prodcat
						WHERE (prodcat_code ~ pProdCatPattern )
					)
					AND ipsitem_item_id = item_id
					AND ipsitemchar_ipsitem_id = ipsitem_id;

				GET DIAGNOSTICS _charRows = ROW_COUNT;
			END IF;

		ELSE
			-- All categories
			UPDATE ipsitem
			SET ipsitem_price = noNeg(ROUND( (ipsitem_price * _percentMultiplier), _currencyDecimals ));

			GET DIAGNOSTICS _itemRows = ROW_COUNT;

			IF(pUpdateCharPrices) THEN
				UPDATE ipsitemchar
				SET ipsitemchar_price = noNeg(ROUND( (ipsitemchar_price * _percentMultiplier), _currencyDecimals ));

				GET DIAGNOSTICS _charRows = ROW_COUNT;
			END IF;

		END IF;

	END IF;

	RETURN _itemRows + _charRows;

END;
$$;


ALTER FUNCTION public.updatepricesbyproductcategory(pprodcatid integer, pprodcatpattern text, pupdatetype character, pupdateby numeric, pupdatecharprices boolean) OWNER TO admin;

--
-- TOC entry 2303 (class 1255 OID 146567163)
-- Dependencies: 4536 8
-- Name: updatereorderlevel(integer, integer, integer[]); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updatereorderlevel(integer, integer, integer[]) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pDays ALIAS FOR $2;
  pPeriods ALIAS FOR $3;
  _cursor INTEGER;
  _periodid INTEGER;
  _usage NUMERIC;
  _totalUsage NUMERIC;
  _totalDays INTEGER;
  _reorderLevel INTEGER;
  _averageUsage NUMERIC;
  _result	TEXT;

BEGIN

  _cursor := 1;
  _totalUsage := 0;
  _totalDays := 0;

  _periodid = pPeriods[_cursor];
  WHILE (_periodid IS NOT NULL) LOOP
    SELECT COALESCE(SUM(invhist_invqty), 0) INTO _usage
    FROM invhist
    WHERE ( (invhist_itemsite_id=pItemsiteid)
     AND ( invhist_transdate::DATE BETWEEN findPeriodStart(_periodid)
                                   AND findPeriodEnd(_periodid) )
     AND (invhist_transtype IN ('SH', 'IM')) );

    _totalUsage := (_totalUsage + _usage);

    _totalDays := ( _totalDays + ( findPeriodEnd(_periodid) -
                                   findPeriodStart(_periodid) + 1 ) );

    _cursor := (_cursor + 1);
    _periodid = pPeriods[_cursor];
  END LOOP;

  IF (_totalDays > 0) THEN
    _reorderLevel := round(_totalUsage / _totalDays * pDays);

    SELECT itemsite_stocked INTO _result from itemsite WHERE (itemsite_id=pItemsiteid);
    IF (_reorderLevel = 0 AND _result='t') THEN
      _reorderLevel := 1;
    END IF;

    IF (_reorderLevel > 0) THEN
      UPDATE itemsite
      SET itemsite_reorderlevel = _reorderLevel
      WHERE (itemsite_id=pItemsiteid);
    ELSE
      UPDATE itemsite
      SET itemsite_reorderlevel = 0
      WHERE (itemsite_id=pItemsiteid);
    END IF;

    RETURN TRUE;
  ELSE
    RETURN FALSE;
  END IF;

END;
$_$;


ALTER FUNCTION public.updatereorderlevel(integer, integer, integer[]) OWNER TO admin;

--
-- TOC entry 2305 (class 1255 OID 146567164)
-- Dependencies: 2696 4536 8
-- Name: updatereorderlevel(integer[], integer, boolean, integer[]); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updatereorderlevel(integer[], integer, boolean, integer[]) RETURNS SETOF reordlvl
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteids 		ALIAS FOR $1;
  pDays 		ALIAS FOR $2;
  pAddLeadtime		ALIAS FOR $3;
  pPeriodIds 		ALIAS FOR $4;
  _icursor 		INTEGER := 1;
  _pcursor 		INTEGER := 1;
  _totalUsage 		NUMERIC := 0;
  _totalDays 		INTEGER := 0;
  _reorderLevel 	INTEGER := 0;
  _result		TEXT;
  _usage		NUMERIC;
  _averageUsage 	NUMERIC;
  _row reordlvl		%ROWTYPE;

BEGIN
  -- Validate
  IF (pItemsiteIds[1] IS NULL OR pPeriodIds[1] IS NULL) THEN
    RETURN;
  END IF;

  -- Calculate total days
  FOR _pcursor IN 1..ARRAY_UPPER(pPeriodIds,1)
  LOOP
    _totalDays := ( _totalDays + ( findPeriodEnd(pPeriodIds[_pcursor]) -
                                      findPeriodStart(pPeriodIds[_pcursor]) + 1 ) );
  END LOOP;

  --  Loop through each itemsite id
  FOR _icursor IN 1..ARRAY_UPPER(pItemsiteIds,1)
  LOOP
      -- Get itemsite data
    SELECT itemsite_id,
      item_id,
      warehous_code,
      item_number,
      item_descrip1,
      itemsite_leadtime,
      0,
      itemsite_reorderlevel,
      0,
      0,
      0
      INTO _row
    FROM itemsite
      JOIN item ON (itemsite_item_id=item_id)
      JOIN whsinfo ON (itemsite_warehous_id=warehous_id)
    WHERE (itemsite_id=pItemsiteIds[_icursor]);

    IF (FOUND) THEN
      IF (pAddLeadtime) THEN
        _row.reordlvl_daysofstock := pDays + _row.reordlvl_leadtime;
      ELSE
        _row.reordlvl_daysofstock := pDays;
      END IF;

      --  Loop through each period id
      FOR _pcursor IN 1..ARRAY_UPPER(pPeriodIds,1)
      LOOP
        -- Sum days and usage shipping and inventory transactions
        SELECT COALESCE(SUM(invhist_invqty), 0) INTO _usage
        FROM invhist
        WHERE ( (invhist_itemsite_id=pItemsiteIds[_icursor])
         AND ( invhist_transdate::DATE BETWEEN findPeriodStart(pPeriodIds[_pcursor])
                                       AND findPeriodEnd(pPeriodIds[_pcursor]) )
         AND (invhist_transtype IN ('SH', 'IM')) );

        _totalUsage := (_totalUsage + _usage);

      END LOOP;

      -- Calculate reorder level
      IF (_totalDays > 0) THEN
        _reorderLevel := round(_totalUsage / _totalDays * _row.reordlvl_daysofstock);
      END IF;

      IF (_reorderLevel <= 0) THEN
        _reorderLevel := 0;
      END IF;

      SELECT itemsite_stocked INTO _result from itemsite WHERE (itemsite_id=pItemsiteIds[_icursor]);
      IF (_reorderLevel = 0 AND _result='t') THEN
        _reorderLevel := 1;
      END IF;

      -- Set values
      _row.reordlvl_total_days		:= _totalDays;
      _row.reordlvl_total_usage	:= _totalUsage;
      _row.reordlvl_calc_level		:= _reorderLevel;

      -- Return result
      RETURN NEXT _row;
    END IF;

    _usage		:= 0;
    _averageUsage	:= 0;
    _totalUsage		:= 0;
    _reorderLevel	:= 0;
  END LOOP;

  RETURN;
END;
$_$;


ALTER FUNCTION public.updatereorderlevel(integer[], integer, boolean, integer[]) OWNER TO admin;

--
-- TOC entry 2306 (class 1255 OID 146567165)
-- Dependencies: 4536 8
-- Name: updateretainedearnings(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updateretainedearnings(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pYearPeriodid ALIAS FOR $1;
  _r RECORD;
  _n RECORD;
  _c RECORD;
  _beginningPeriodid INTEGER;
  _trialbalid INTEGER;
  _accntid INTEGER;
  _totalProfitLoss      NUMERIC;
  _periodid INTEGER;
  _forwardupdate INTEGER;
BEGIN

--  First thing we need to do is to get the yearperiod

  SELECT * INTO _r FROM yearperiod where yearperiod_id = pYearPeriodid;

  IF (NOT FOUND) THEN
    RETURN -6;
  END IF;

--  Now we need to find the next yearperiod

  SELECT * INTO _n FROM yearperiod WHERE yearperiod_start = _r.yearperiod_end + interval '1 day';

  IF (NOT FOUND) THEN
    RETURN -4;
  END IF;

--  Now we have to find where to stick the end of year data

  SELECT period_id INTO _periodid FROM period WHERE period_start = _n.yearperiod_start;

  IF (NOT FOUND) THEN
    RETURN -8;
  END IF;

--  Loop through companies and process each one

  IF (coalesce(fetchMetricValue('GLCompanySize'),0) = 0) THEN
  --  Process for installs not using company segment
  --  Now we need to get the default account number for year end closing

    SELECT CAST ( metric_value AS integer ) INTO _accntid FROM metric WHERE metric_name = 'YearEndEquityAccount';

    IF (NOT FOUND) THEN
      RETURN -7;
    END IF;

  --  So far so good.  Now we need to calculate the profit-loss for the year that we are closing

    SELECT SUM(gltrans_amount) INTO _totalProfitLoss
     FROM gltrans, accnt
     WHERE ( (gltrans_accnt_id = accnt_id)
       AND   (accnt_type IN ( 'R', 'E' ) )
       AND   (gltrans_posted)
       AND   (NOT gltrans_deleted)
       AND   (gltrans_date between _r.yearperiod_start and _r.yearperiod_end ) );
    IF (_totalProfitLoss IS NULL) THEN
      _totalProfitLoss := 0;
    END IF;

  -- Get the trailbal_id

    SELECT trialbal_id INTO _trialbalid
      FROM trialbal
     WHERE ( (trialbal_period_id = _periodid )
       AND   (trialbal_accnt_id = _accntid) );

    IF (NOT FOUND) THEN
      RETURN -9;
    END IF;

  -- Lets do the update for the trialbal

    UPDATE trialbal
       SET trialbal_beginning = trialbal_beginning - trialbal_yearend + _totalProfitLoss,
           trialbal_ending = trialbal_beginning - trialbal_yearend - trialbal_debits + trialbal_credits + _totalProfitLoss,
           trialbal_yearend = _totalProfitLoss
     WHERE trialbal_id = _trialbalid;

  -- Now the forward update

    SELECT forwardupdatetrialbalance(_trialbalid) INTO _forwardupdate;

  ELSE  -- Process for a multi-company set up

    FOR _c IN
      SELECT company_number, company_yearend_accnt_id
      FROM company
    LOOP
  --  Calculate the profit-loss for the year that we are closing

      SELECT SUM(gltrans_amount) INTO _totalProfitLoss
       FROM gltrans, accnt
       WHERE ( (gltrans_accnt_id = accnt_id)
         AND   (accnt_type IN ( 'R', 'E' ) )
         AND   (gltrans_posted)
         AND   (NOT gltrans_deleted)
         AND   (accnt_company = _c.company_number)
         AND   (gltrans_date between _r.yearperiod_start and _r.yearperiod_end ) );
      IF(_totalProfitLoss IS NULL) THEN
        _totalProfitLoss := 0;
      END IF;

    -- Get the trailbal_id

      SELECT trialbal_id INTO _trialbalid
        FROM trialbal
          JOIN accnt ON (trialbal_accnt_id=accnt_id)
       WHERE ( (trialbal_period_id = _periodid )
         AND   (trialbal_accnt_id = _c.company_yearend_accnt_id) );

      IF (NOT FOUND) THEN
        -- Create a trial balance record
        SELECT NEXTVAL('trialbal_trialbal_id_seq') INTO _trialbalid;
        INSERT INTO trialbal
          ( trialbal_id, trialbal_accnt_id, trialbal_period_id,
            trialbal_beginning, trialbal_dirty,
            trialbal_ending,
            trialbal_credits,
            trialbal_debits,
            trialbal_yearend )
        VALUES
          ( _trialbalid, _c.company_yearend_accnt_id, _periodid,
            _totalProfitLoss, TRUE,
            _totalProfitLoss,
            0,
            0,
            _totalProfitLoss );
      ELSE
        -- Lets do the update for the trialbal
        UPDATE trialbal
           SET trialbal_beginning = trialbal_beginning - trialbal_yearend + _totalProfitLoss,
               trialbal_ending = trialbal_beginning - trialbal_yearend - trialbal_debits + trialbal_credits + _totalProfitLoss,
               trialbal_yearend = _totalProfitLoss
         WHERE trialbal_id = _trialbalid;
      END IF;

    -- Now the forward update

      SELECT forwardupdatetrialbalance(_trialbalid) INTO _forwardupdate;

    END LOOP;
  END IF;

  RETURN 0;

END;
$_$;


ALTER FUNCTION public.updateretainedearnings(integer) OWNER TO admin;

--
-- TOC entry 2307 (class 1255 OID 146567166)
-- Dependencies: 4536 8
-- Name: updatesoracost(integer, text, boolean, numeric, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updatesoracost(integer, text, boolean, numeric, boolean) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemid	ALIAS FOR $1;
  pCosttype	ALIAS FOR $2;
  pLevel	ALIAS FOR $3;
  pCost		ALIAS FOR $4;
  pUpdateActual	ALIAS FOR $5;

BEGIN
    IF (pUpdateActual) THEN
	RETURN updateCost(pItemid, pCosttype, pLevel, pCost);
    ELSE
	RETURN updateStdCost(pItemid, pCosttype, pLevel, pCost);
    END IF;
END;
$_$;


ALTER FUNCTION public.updatesoracost(integer, text, boolean, numeric, boolean) OWNER TO admin;

--
-- TOC entry 2309 (class 1255 OID 146567168)
-- Dependencies: 4536 8
-- Name: updatestdcost(integer, text, boolean, numeric); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updatestdcost(integer, text, boolean, numeric) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
    pItemid	ALIAS FOR $1;
    pCostType	ALIAS FOR $2;
    pLevel	ALIAS FOR $3;
    pCost	ALIAS FOR $4;
    _newCost	NUMERIC;
    _oldCost	NUMERIC := 0;
    _itemcostid	INTEGER;
    _updateRet	BOOLEAN;
    _itemNumber TEXT;

BEGIN
    IF (pCost IS NULL) THEN
	_newCost = 0;
    ELSE
	_newCost = pCost;
    END IF;

    SELECT itemcost_id, itemcost_stdCost, item_number
	INTO _itemcostid, _oldCost, _itemNumber
    FROM itemcost, costelem, item
    WHERE ((itemcost_costelem_id=costelem_id)
      AND  (itemcost_item_id=item_id)
      AND  (item_id=pItemid)
      AND  (itemcost_lowlevel=pLevel)
      AND  (costelem_type=pCosttype));
--    RAISE NOTICE 'updateStdCost(%, %, %, %) has itemcost_id % and stdcost %',
--    				pItemid, pCostType, plevel, _newCost, _itemcostid, _oldCost;

    IF (NOT FOUND) AND (_newCost > 0) THEN
	SELECT NEXTVAL('itemcost_itemcost_id_seq') INTO _itemcostid;
	RAISE NOTICE 'updateStdCost() inserting itemcost_id %', _itemcostid;
	INSERT INTO itemcost
	    (itemcost_id, itemcost_item_id, itemcost_costelem_id,
	     itemcost_lowlevel, itemcost_stdcost, itemcost_posted,
	     itemcost_actcost, itemcost_updated)
	SELECT
	      _itemcostid, pItemid, costelem_id,
	      pLevel, _newCost, CURRENT_DATE,
	      0, CURRENT_DATE
	FROM costelem
	WHERE (costelem_type=pCosttype);
    END IF;

    IF (_itemcostid IS NOT NULL) THEN
	SELECT updateStdCost(_itemcostid, _newCost, _oldCost, 'Post Cost',
               ('Set Standard Cost - ' || pCosttype || ' for item ' || _itemNumber)) INTO _updateRet;
	IF (_updateRet) THEN
	    RETURN _itemcostid;
	END IF;
    END IF;

    RETURN -1;
END;
$_$;


ALTER FUNCTION public.updatestdcost(integer, text, boolean, numeric) OWNER TO admin;

--
-- TOC entry 2308 (class 1255 OID 146567167)
-- Dependencies: 4536 8
-- Name: updatestdcost(integer, numeric, numeric, text, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updatestdcost(integer, numeric, numeric, text, text) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
    pItemcostid	ALIAS FOR $1;
    pNewcost	ALIAS FOR $2;
    pOldcost	ALIAS FOR $3;
    pDocNumber	ALIAS FOR $4;
    pNotes	ALIAS FOR $5;
    _itemcostid	INTEGER;
    _r		RECORD;
    _newcost	NUMERIC;
    _oldcost	NUMERIC;

BEGIN
  IF (pNewcost IS NULL) THEN
    _newcost := 0;
  ELSE
    _newcost := pNewcost;
  END IF;
  IF (pOldcost IS NULL) THEN
    _oldcost := 0;
  ELSE
    _oldcost := pOldcost;
  END IF;

  IF (_newcost > 0) THEN
    UPDATE itemcost
    SET itemcost_stdcost=_newcost,
        itemcost_posted=CURRENT_DATE
    WHERE (itemcost_id=pItemcostid);
  END IF;

--  Distribute to G/L, debit Inventory Asset, credit Inventory Cost Variance
  FOR _r IN SELECT itemsite_id, (itemsite_qtyonhand + itemsite_nnqoh) AS totalQty,
                   costcat_invcost_accnt_id, costcat_asset_accnt_id,
                   itemsite_costmethod
            FROM itemcost, itemsite, costcat
            WHERE ( (itemsite_item_id=itemcost_item_id)
             AND (itemsite_costcat_id=costcat_id)
             AND (itemsite_costmethod != 'A')
             AND ((itemsite_qtyonhand + itemsite_nnqoh) <> 0)
             AND (itemcost_id=pItemcostid) ) LOOP
--    IF (_newcost <> _oldcost) THEN
--      RAISE NOTICE 'itemcost_id = %, Qty = %, Old Cost = %, New Cost = %', pItemcostid, _r.totalQty, _oldcost, _newcost;
--    END IF;
    PERFORM insertGLTransaction( 'P/D', '', pDocNumber, pNotes,
                                 _r.costcat_invcost_accnt_id, _r.costcat_asset_accnt_id, _r.itemsite_id,
                                 ((_newcost - _oldcost) * _r.totalQty),
                                 CURRENT_DATE );
--  Update Itemsite Value if not Average Cost
    IF (_r.itemsite_costmethod <> 'A') THEN
--      RAISE NOTICE 'itemsite_id = %, Qty = %, New Cost = %', _r.itemsite_id, _r.totalQty, _newcost;
      UPDATE itemsite SET itemsite_value=(_r.totalQty * stdCost(itemsite_item_id))
      WHERE (itemsite_id=_r.itemsite_id);
    END IF;
  END LOOP;

  IF (_newcost = 0) THEN
    DELETE FROM itemcost
    WHERE (itemcost_id=pItemcostid);

    RETURN FALSE;
  END IF;

  IF ( SELECT metric_value
        FROM metric
        WHERE ((metric_name = 'EnableAsOfQOH')
        AND (metric_value = 't'))) THEN
    IF (pNewcost IS NOT NULL) THEN
      _newcost := pNewcost;
    END IF;
    IF (pOldcost IS NULL) THEN
      _oldcost := 0;
    ELSE
      _oldcost := pOldcost;
    END IF;
  --  Distribute to G/L, debit Inventory Asset, credit Inventory Cost Variance
    PERFORM postValueIntoInvBalance(
                  itemsite_id,
                  current_date,
                  asofinvqty(itemsite_id,current_date),
                  asofinvnn(itemsite_id,current_date),
                  _oldcost,
                  _newcost)
       FROM itemsite
       JOIN item ON (itemsite_item_id=item_id)
       JOIN itemcost ON (itemcost_item_id=item_id)
      WHERE((itemsite_costmethod = 'S')
        AND (itemcost_id=pItemcostid));
  END IF;

  RETURN TRUE;

END;
$_$;


ALTER FUNCTION public.updatestdcost(integer, numeric, numeric, text, text) OWNER TO admin;

--
-- TOC entry 2310 (class 1255 OID 146567169)
-- Dependencies: 4536 8
-- Name: updatetodoitem(integer, text, text, text, integer, integer, integer, date, date, character, date, date, integer, text, boolean, text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updatetodoitem(integer, text, text, text, integer, integer, integer, date, date, character, date, date, integer, text, boolean, text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN updateTodoItem($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, NULL);
END;
$_$;


ALTER FUNCTION public.updatetodoitem(integer, text, text, text, integer, integer, integer, date, date, character, date, date, integer, text, boolean, text) OWNER TO admin;

--
-- TOC entry 2313 (class 1255 OID 146567170)
-- Dependencies: 4536 8
-- Name: updatetodoitem(integer, text, text, text, integer, integer, integer, date, date, character, date, date, integer, text, boolean, text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION updatetodoitem(integer, text, text, text, integer, integer, integer, date, date, character, date, date, integer, text, boolean, text, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  ptodoitemid ALIAS FOR  $1;
  pusername   ALIAS FOR  $2;
  pname       ALIAS FOR  $3;
  pdesc       ALIAS FOR  $4;
  pincdtid    ALIAS FOR  $5;
  pcrmacctid  ALIAS FOR  $6;
  pOpheadid   ALIAS FOR  $7;
  pstarted    ALIAS FOR  $8;
  pdue        ALIAS FOR  $9;
  pstatus     ALIAS FOR $10;
  passigned   ALIAS FOR $11;
  pcompleted  ALIAS FOR $12;
  ppriority   ALIAS FOR $13;
  pnotes      ALIAS FOR $14;
  pactive     ALIAS FOR $15;
  powner	ALIAS FOR $16;
  pcntctid	ALIAS FOR $17;

  _priority   INTEGER         := ppriority;
  _status     CHARACTER(1)    := pstatus;
  _incdtid    INTEGER         := pincdtid;
  _crmacctid  INTEGER         := pcrmacctid;
  _opheadid   INTEGER         := pOpheadid;
  _assigned   DATE            := passigned;
  _active     BOOL            := pactive;
  _result     INTEGER;

BEGIN
  IF (pusername IS NULL OR pusername = '') THEN
    RETURN -1;
  END IF;

  IF (pname IS NULL OR pname = '') THEN
    RETURN -2;
  END IF;

  IF (pdue IS NULL) THEN
    RETURN -3;
  END IF;

  IF (ptodoitemid IS NULL OR ptodoitemid <= 0) THEN
    RETURN -10;
  END IF;

  IF (pcompleted IS NOT NULL) THEN
    _status := 'C';
  ELSIF (pstatus IS NULL AND pstarted IS NOT NULL) THEN
    _status := 'I';
  ELSIF (pstatus IS NULL) THEN
    _status := 'N';
  END IF;

  IF (_incdtid <= 0) THEN
    _incdtid := NULL;
  END IF;

  IF (_crmacctid <= 0) THEN
    _crmacctid := NULL;
  END IF;

  IF (_opheadid <= 0) THEN
    _opheadid := NULL;
  END IF;

  IF (_priority <= 0) THEN
    _priority := NULL;
  END IF;

  IF (_assigned IS NULL) THEN
    _assigned := CURRENT_DATE;
  END IF;

  IF (_active IS NULL) THEN
    _active := TRUE;
  END IF;

  UPDATE todoitem SET
      todoitem_username=pusername, todoitem_name=pname, todoitem_description=pdesc,
      todoitem_incdt_id=_incdtid, todoitem_status=_status,
      todoitem_active=_active, todoitem_start_date=pstarted,
      todoitem_due_date=pdue, todoitem_assigned_date=_assigned,
      todoitem_completed_date=pcompleted, todoitem_priority_id=_priority,
      todoitem_notes=pnotes, todoitem_crmacct_id=_crmacctid,
      todoitem_ophead_id=_opheadid, todoitem_owner_username=powner,
      todoitem_cntct_id=pcntctid
  WHERE (todoitem_id=ptodoitemid);

  RETURN ptodoitemid;
END;
$_$;


ALTER FUNCTION public.updatetodoitem(integer, text, text, text, integer, integer, integer, date, date, character, date, date, integer, text, boolean, text, integer) OWNER TO admin;

--
-- TOC entry 2314 (class 1255 OID 146567171)
-- Dependencies: 4536 8
-- Name: usedefaultlocation(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION usedefaultlocation(integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  _p RECORD;

BEGIN

  SELECT itemsite_location_id,
         LENGTH(itemsite_location) AS locationlength INTO _p
  FROM itemsite
  WHERE (itemsite_id=pItemsiteid);

  IF (NOT FOUND) THEN
    RETURN FALSE;

  ELSIF (_p.itemsite_location_id <> -1) THEN
    RETURN TRUE;

  ELSIF (_p.locationlength > 0) THEN
    RETURN TRUE;

  ELSE
    RETURN FALSE;
  END IF;

END;
$_$;


ALTER FUNCTION public.usedefaultlocation(integer) OWNER TO admin;

--
-- TOC entry 2315 (class 1255 OID 146567172)
-- Dependencies: 8
-- Name: usercancreateusers(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION usercancreateusers(text) RETURNS boolean
    LANGUAGE sql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
SELECT rolcreaterole OR rolsuper
  FROM pg_roles
 WHERE rolname=($1);
$_$;


ALTER FUNCTION public.usercancreateusers(text) OWNER TO admin;

--
-- TOC entry 2316 (class 1255 OID 146567173)
-- Dependencies: 4536 8
-- Name: usercanlogin(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION usercanlogin(pusername text) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _isactive  BOOLEAN;
  _mode      TEXT;
BEGIN
  IF (isDBA(pUsername) OR userCanCreateUsers(pUsername)) THEN
    RETURN TRUE;

  ELSIF (pg_has_role(pUsername, 'xtrole', 'member')) THEN
    _mode := COALESCE(fetchMetricText('AllowedUserLogins'), '');

    IF (_mode = 'AdminOnly') THEN
      RETURN FALSE; -- administrators were checked above
    END IF;

    IF (_mode NOT IN ('AdminOnly','ActiveOnly','Any')) THEN
      _mode := 'ActiveOnly';
    END IF;

    SELECT (usrpref_value = 't') INTO _isactive
      FROM usrpref
     WHERE usrpref_username = pUsername
       AND usrpref_name = 'active';

    IF (_isactive OR _mode = 'Any') THEN
      RETURN TRUE;
    END IF;
  END IF;

  RETURN FALSE;
END;
$$;


ALTER FUNCTION public.usercanlogin(pusername text) OWNER TO admin;

--
-- TOC entry 2317 (class 1255 OID 146567174)
-- Dependencies: 4536 8
-- Name: userid(text); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION userid(text) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pUsername ALIAS FOR $1;
  _userId INTEGER;

BEGIN

  SELECT usesysid INTO _userId
  FROM pg_user
  WHERE (usename=pUsername);

  IF (FOUND) THEN
    RETURN _userId;
  ELSE
    RETURN -1;
  END IF;

END;
$_$;


ALTER FUNCTION public.userid(text) OWNER TO admin;

--
-- TOC entry 2318 (class 1255 OID 146567175)
-- Dependencies: 4536 8
-- Name: validateorderqty(integer, numeric, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION validateorderqty(integer, numeric, boolean) RETURNS numeric
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pItemsiteid ALIAS FOR $1;
  pQty ALIAS FOR $2;
  pManual ALIAS FOR $3;
  _p RECORD;
  _qty NUMERIC;

BEGIN

  _qty := pQty;

  SELECT itemsite_useparams,
         CASE WHEN (itemsite_useparams) THEN itemsite_useparamsmanual ELSE FALSE END AS itemsite_useparamsmanual,
         CASE WHEN (itemsite_useparams) THEN itemsite_minordqty ELSE 0.0 END AS itemsite_minordqty,
         CASE WHEN (itemsite_useparams) THEN itemsite_multordqty ELSE 0.0 END AS itemsite_multordqty,
         item_fractional, item_type INTO _p
  FROM itemsite, item
  WHERE ( (itemsite_item_id=item_id)
   AND (itemsite_id=pItemsiteid) );

  IF ( (pManual AND (_p.itemsite_useparamsmanual)) OR
       ((NOT pManual) AND (_p.itemsite_useparams)) ) THEN

    IF (_qty < _p.itemsite_minordqty) THEN
      _qty := _p.itemsite_minordqty;
    END IF;

    IF ( (_p.itemsite_multordqty > 0) AND ((_qty % _p.itemsite_multordqty) > 0) ) THEN
      _qty := ((TRUNC(_qty / _p.itemsite_multordqty) * _p.itemsite_multordqty) + _p.itemsite_multordqty);
    END IF;

  END IF;

  _qty := roundQty(_p.item_fractional, _qty);

  RETURN _qty;

END;
$_$;


ALTER FUNCTION public.validateorderqty(integer, numeric, boolean) OWNER TO admin;

--
-- TOC entry 2319 (class 1255 OID 146567176)
-- Dependencies: 4536 8
-- Name: validlocation(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION validlocation(integer, integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pLocationid ALIAS FOR $1;
  pItemsiteid ALIAS FOR $2;
  _p RECORD;

BEGIN

  SELECT location_restrict INTO _p
  FROM location, itemsite
  WHERE ( (location_warehous_id=itemsite_warehous_id)
    AND (itemsite_id=pItemsiteid)
    AND (location_id=pLocationid) );

  IF (FOUND) THEN
    IF (_p.location_restrict) THEN

      SELECT locitem_id INTO _p
      FROM locitem, itemsite
      WHERE ( (locitem_item_id=itemsite_item_id)
       AND (itemsite_id=pItemsiteid)
       AND (locitem_location_id=pLocationid) );

      IF (FOUND) THEN
        RETURN TRUE;
      END IF;

    ELSE
      RETURN TRUE;
    END IF;

  ELSE
    RETURN FALSE;
  END IF;

  RETURN FALSE;

END;
$_$;


ALTER FUNCTION public.validlocation(integer, integer) OWNER TO admin;

--
-- TOC entry 2320 (class 1255 OID 146567177)
-- Dependencies: 4536 8
-- Name: valueatshipping(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION valueatshipping(plineitemid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RETURN valueAtShipping('SO', plineitemid);
END;
$$;


ALTER FUNCTION public.valueatshipping(plineitemid integer) OWNER TO admin;

--
-- TOC entry 2321 (class 1255 OID 146567178)
-- Dependencies: 4536 8
-- Name: valueatshipping(text, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION valueatshipping(pordertype text, plineitemid integer) RETURNS numeric
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _value NUMERIC := 0.0;

BEGIN

  IF (pordertype NOT IN ('SO', 'TO')) THEN
    RAISE EXCEPTION '% is not a valid order type', pordertype;
  END IF;

  SELECT COALESCE(SUM(shipitem_value), 0.0) INTO _value
  FROM shipitem JOIN shiphead ON (shipitem_shiphead_id=shiphead_id)
  WHERE ( (NOT shiphead_shipped)
    AND  (shiphead_order_type=pordertype)
    AND  (shipitem_orderitem_id=plineitemid) );

  RETURN _value;

END;
$$;


ALTER FUNCTION public.valueatshipping(pordertype text, plineitemid integer) OWNER TO admin;

--
-- TOC entry 2322 (class 1255 OID 146567179)
-- Dependencies: 4536 8
-- Name: voidapcheck(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION voidapcheck(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RAISE NOTICE 'voidAPCheck() is deprecated - use voidCheck() instead';
  RETURN voidCheck($1);
END;
$_$;


ALTER FUNCTION public.voidapcheck(integer) OWNER TO admin;

--
-- TOC entry 2289 (class 1255 OID 146567180)
-- Dependencies: 4536 8
-- Name: voidapopenvoucher(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION voidapopenvoucher(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pApopenid ALIAS FOR $1;
BEGIN
  RETURN voidApopenVoucher(pApopenid, fetchJournalNumber('AP-VO'));
END;
$_$;


ALTER FUNCTION public.voidapopenvoucher(integer) OWNER TO admin;

--
-- TOC entry 2290 (class 1255 OID 146567181)
-- Dependencies: 4536 8
-- Name: voidapopenvoucher(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION voidapopenvoucher(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pApopenid ALIAS FOR $1;
  pJournalNumber ALIAS FOR $2;
  _apopenid INTEGER;
  _apcreditapplyid INTEGER;
  _reference    TEXT;
  _result INTEGER;
  _sequence INTEGER;
  _totalAmount_base NUMERIC;
  _totalAmount NUMERIC;
  _itemAmount_base NUMERIC;
  _itemAmount NUMERIC;
  _test INTEGER;
  _a RECORD;
  _d RECORD;
  _g RECORD;
  _p RECORD;
  _n RECORD;
  _r RECORD;
  _costx RECORD;
  _pExplain BOOLEAN;
  _pLowLevel BOOLEAN;
  _exchGainFreight NUMERIC;
  _firstExchDateFreight	DATE;
  _tmpTotal		NUMERIC;
  _glDate		DATE;

BEGIN

  _totalAmount_base := 0;
  _totalAmount := 0;
  SELECT fetchGLSequence() INTO _sequence;

--  Cache APOpen Information
  SELECT apopen.* INTO _n
  FROM apopen
  WHERE ( (apopen_doctype='V')
    AND   (apopen_id=pApopenid) );
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Cannot Void Voucher #% as apopen not found', pApopenid;
  END IF;

--  Cache Voucher Infomation
  SELECT vohead.*,
	 vend_number || '-' || vend_name || ' ' || vohead_reference
							  AS glnotes,
	 COALESCE(pohead_orderdate, vohead_docdate) AS pohead_orderdate,
	 COALESCE(pohead_curr_id, vohead_curr_id) AS pohead_curr_id INTO _p
  FROM vohead JOIN vendinfo ON (vend_id=vohead_vend_id)
              LEFT OUTER JOIN pohead ON (vohead_pohead_id = pohead_id)
  WHERE (vohead_number=_n.apopen_docnumber);
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Cannot Void Voucher #% as vohead not found', _n.apopen_docnumber;
  END IF;

  _glDate := COALESCE(_p.vohead_gldistdate, _p.vohead_distdate);

-- there is no currency gain/loss on items, see issue 3892,
-- but there might be on freight, which is first encountered at p/o receipt
  SELECT recv_date::DATE INTO _firstExchDateFreight
  FROM recv
  WHERE (recv_vohead_id = _p.vohead_id);

--  Start by handling taxes
  FOR _r IN SELECT tax_sales_accnt_id,
              round(sum(taxdetail_tax),2) AS tax,
              currToBase(_p.vohead_curr_id, round(sum(taxdetail_tax),2), _p.vohead_docdate) AS taxbasevalue
            FROM tax
             JOIN calculateTaxDetailSummary('VO', _p.vohead_id, 'T') ON (taxdetail_tax_id=tax_id)
	    GROUP BY tax_id, tax_sales_accnt_id LOOP

    PERFORM insertIntoGLSeries( _sequence, 'A/P', 'VO', _p.vohead_number,
                                _r.tax_sales_accnt_id,
                                (_r.taxbasevalue * -1),
                                _glDate, _p.glnotes );

    _totalAmount_base := (_totalAmount_base - _r.taxbasevalue);
    _totalAmount := (_totalAmount - _r.tax);

  END LOOP;

--  Loop through the vodist records for the passed vohead that
--  are posted against a P/O Item
  FOR _g IN SELECT DISTINCT poitem_id, voitem_qty, poitem_expcat_id,
                            poitem_invvenduomratio,
                            COALESCE(itemsite_id, -1) AS itemsiteid,
                            COALESCE(itemsite_costcat_id, -1) AS costcatid,
                            COALESCE(itemsite_item_id, -1) AS itemsite_item_id,
                            (SELECT SUM(value)
                             FROM (
                                SELECT SUM(recv_value) AS value
                                FROM recv
                                WHERE (recv_voitem_id=voitem_id)
                             UNION
                                SELECT SUM(poreject_value)*-1 AS value
                                FROM poreject
                                WHERE (poreject_voitem_id=voitem_id)) as data)
                            AS value_base,
                            (poitem_freight_vouchered / poitem_qty_vouchered) * voitem_qty AS vouchered_freight,
                            currToBase(_p.pohead_curr_id, (poitem_freight_vouchered / poitem_qty_vouchered) * voitem_qty, _firstExchDateFreight ) AS vouchered_freight_base,
			    voitem_freight,
			    currToBase(_p.vohead_curr_id, voitem_freight,
                                       _p.vohead_distdate) AS voitem_freight_base
            FROM vodist, voitem,
                 poitem LEFT OUTER JOIN itemsite ON (poitem_itemsite_id=itemsite_id)
            WHERE ( (vodist_poitem_id=poitem_id)
             AND (voitem_poitem_id=poitem_id)
             AND (voitem_vohead_id=vodist_vohead_id)
             AND (vodist_vohead_id=_p.vohead_id)) LOOP

--  Grab the G/L Accounts
    IF (_g.costcatid = -1) THEN
      SELECT pp.accnt_id AS pp_accnt_id,
             lb.accnt_id AS lb_accnt_id INTO _a
      FROM expcat, accnt AS pp, accnt AS lb
      WHERE ( (expcat_purchprice_accnt_id=pp.accnt_id)
       AND (expcat_liability_accnt_id=lb.accnt_id)
       AND (expcat_id=_g.poitem_expcat_id) );
      IF (NOT FOUND) THEN
        RAISE EXCEPTION 'Cannot Void Voucher #% due to unassigned G/L Accounts.', _p.vohead_number;
      END IF;
    ELSE
      SELECT pp.accnt_id AS pp_accnt_id,
             lb.accnt_id AS lb_accnt_id INTO _a
      FROM costcat, accnt AS pp, accnt AS lb
      WHERE ( (costcat_purchprice_accnt_id=pp.accnt_id)
       AND (costcat_liability_accnt_id=lb.accnt_id)
       AND (costcat_id=_g.costcatid) );
      IF (NOT FOUND) THEN
        RAISE EXCEPTION 'Cannot Void Voucher #% due to unassigned G/L Accounts.', _p.vohead_number;
      END IF;
    END IF;

--  Clear the Item Amount accumulator
    _itemAmount_base := 0;
    _itemAmount := 0;

--  Figure out the total posted value for this line item
    FOR _d IN SELECT vodist_id, vodist_amount,
		     _p.vohead_curr_id, vodist_costelem_id,
		     currToBase(_p.vohead_curr_id, vodist_amount,
				_p.vohead_distdate) AS vodist_amount_base
              FROM vodist
              WHERE ( (vodist_vohead_id=_p.vohead_id)
               AND (vodist_poitem_id=_g.poitem_id) ) LOOP

       _pExplain := TRUE;
       SELECT * INTO _costx
         FROM itemcost
        WHERE ( (itemcost_item_id = _g.itemsite_item_id)
          AND   (itemcost_costelem_id = _d.vodist_costelem_id) );

       IF (FOUND) THEN
         _pExplain := _costx.itemcost_lowlevel;
       END IF;

--  Add the Distribution Amount to the Item Amount
      _itemAmount_base := _itemAmount_base + ROUND(_d.vodist_amount_base, 2);
      _itemAmount := _itemAmount + _d.vodist_amount;

    END LOOP;

--  Distribute from the clearing account
    PERFORM insertIntoGLSeries( _sequence, 'A/P', 'VO', text(_p.vohead_number),
                                _a.lb_accnt_id,
                                round(_g.value_base + _g.vouchered_freight_base, 2),
                                _glDate, _p.glnotes );

--  Attribute the correct portion to currency gain/loss
    _exchGainFreight := 0;
    SELECT currGain(_p.pohead_curr_id, _g.vouchered_freight,
		    _firstExchDateFreight, _p.vohead_distdate )
		    INTO _exchGainFreight;
    IF (round(_exchGainFreight, 2) <> 0) THEN
      PERFORM insertIntoGLSeries(_sequence, 'A/P', 'VO',
                                 text(_p.vohead_number),
                                 getGainLossAccntId(_a.lb_accnt_id), round(_exchGainFreight, 2) * -1,
                                 _glDate, _p.glnotes);
    END IF;

--  Distribute the remaining variance to the Purchase Price Variance account
    IF (round(_itemAmount_base, 2) <> round(_g.value_base, 2)) THEN
      _tmpTotal := round(_itemAmount_base, 2) - round(_g.value_base, 2);
      PERFORM insertIntoGLSeries( _sequence, 'A/P', 'VO', text(_p.vohead_number),
                                  _a.pp_accnt_id,
                                  _tmpTotal,
                                  _glDate, _p.glnotes );
    END IF;

--  Distribute the remaining freight variance to the Purchase Price Variance account
    IF (round(_g.voitem_freight_base + _exchGainFreight, 2) <> round(_g.vouchered_freight_base, 2)) THEN
      _tmpTotal := round(_g.voitem_freight_base + _exchGainFreight, 2) - round(_g.vouchered_freight_base, 2);
      PERFORM insertIntoGLSeries( _sequence, 'A/P', 'VO', text(_p.vohead_number),
                                  _a.pp_accnt_id,
                                  _tmpTotal,
                                  _glDate, _p.glnotes );
    END IF;

--  Add the distribution amount to the total amount to distribute
    _totalAmount_base := (_totalAmount_base + _itemAmount_base + _g.voitem_freight_base);
    _totalAmount := (_totalAmount + _itemAmount + _g.voitem_freight);

--  Reverse the posting for all the Tagged Receivings for this P/O Item
    UPDATE recv
    SET recv_invoiced=FALSE,
        recv_recvcost_curr_id=basecurrid(),
        recv_recvcost=0,
        recv_vohead_id=NULL,
        recv_voitem_id=NULL
    FROM poitem
    WHERE ( (recv_orderitem_id=poitem_id)
      AND   (recv_order_type='PO')
      AND   (recv_orderitem_id=_g.poitem_id)
      AND   (recv_vohead_id=_p.vohead_id) );

--  Reverse the posting for all the Tagged Rejections for this P/O Item
    UPDATE poreject
    SET poreject_invoiced=FALSE,
        poreject_vohead_id=NULL,
        poreject_voitem_id=NULL
    WHERE ( (poreject_poitem_id=_g.poitem_id)
      AND   (poreject_vohead_id=_p.vohead_id) );

--  Update the qty and freight vouchered fields
    UPDATE poitem
       SET poitem_qty_vouchered = (poitem_qty_vouchered - _g.voitem_qty),
           poitem_freight_vouchered = (poitem_freight_vouchered - _g.voitem_freight)
    WHERE (poitem_id=_g.poitem_id);

  END LOOP;

--  Loop through the vodist records for the passed vohead that
--  are not posted against a P/O Item
--  Skip the tax distributions
  FOR _d IN SELECT vodist_id,
		   currToBase(_p.vohead_curr_id, vodist_amount,
			      _p.vohead_distdate) AS vodist_amount_base,
		   vodist_amount,
		   vodist_accnt_id, vodist_expcat_id
            FROM vodist
            WHERE ( (vodist_vohead_id=_p.vohead_id)
              AND   (vodist_poitem_id=-1)
              AND   (vodist_tax_id=-1) ) LOOP

--  Distribute from the misc. account
    IF (_d.vodist_accnt_id = -1) THEN
      PERFORM insertIntoGLSeries( _sequence, 'A/P', 'VO', text(_p.vohead_number),
                                  expcat_exp_accnt_id,
                                  round(_d.vodist_amount_base, 2),
                                  _glDate, _p.glnotes )
      FROM expcat
      WHERE (expcat_id=_d.vodist_expcat_id);
    ELSE
      PERFORM insertIntoGLSeries( _sequence, 'A/P', 'VO', text(_p.vohead_number),
                                  _d.vodist_accnt_id,
                                  round(_d.vodist_amount_base, 2),
                                  _glDate, _p.glnotes );
    END IF;

--  Add the Distribution Amount to the Total Amount
    _totalAmount_base := _totalAmount_base + ROUND(_d.vodist_amount_base, 2);
    _totalAmount := _totalAmount + _d.vodist_amount;

  END LOOP;

  SELECT insertIntoGLSeries( _sequence, 'A/P', 'VO', text(vohead_number),
                             accnt_id, round(_totalAmount_base, 2) * -1,
                             _glDate, _p.glnotes ) INTO _test
  FROM vohead LEFT OUTER JOIN accnt ON (accnt_id=findAPAccount(vohead_vend_id))
  WHERE ( (findAPAccount(vohead_vend_id)=0 OR accnt_id > 0) -- G/L interface might be disabled
    AND   (vohead_id=_p.vohead_id) );
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Cannot Void Voucher #% due to an unassigned A/P Account.', _p.vohead_number;
  END IF;

  PERFORM postGLSeries(_sequence, pJournalNumber);

--  Create the A/P Open Item
  SELECT NEXTVAL('apopen_apopen_id_seq') INTO _apopenid;
  _reference := ('Void Voucher #' || _n.apopen_docnumber);
  INSERT INTO apopen
  ( apopen_id, apopen_username, apopen_journalnumber,
    apopen_vend_id, apopen_docnumber, apopen_doctype, apopen_ponumber,
    apopen_docdate, apopen_duedate, apopen_distdate, apopen_terms_id, apopen_curr_id,
    apopen_amount, apopen_paid, apopen_open, apopen_notes, apopen_discount, apopen_curr_rate )
  SELECT _apopenid, getEffectiveXtUser(), pJournalnumber,
         apopen_vend_id, apopen_docnumber, 'C', apopen_ponumber,
         _glDate, _glDate, _glDate, -1, apopen_curr_id,
         apopen_amount - apopen_paid, 0, TRUE, _reference, TRUE, apopen_curr_rate
    FROM apopen
   WHERE (apopen_id=_n.apopen_id);

  SELECT apcreditapply_id INTO _apcreditapplyid
    FROM apcreditapply
   WHERE ( (apcreditapply_source_apopen_id=_apopenid)
     AND   (apcreditapply_target_apopen_id=_n.apopen_id) );
  IF (FOUND) THEN
    UPDATE apcreditapply
       SET apcreditapply_amount=_n.apopen_amount-_n.apopen_paid
     WHERE (apcreditapply_id=_apcreditapplyid);
  ELSE
    SELECT nextval('apcreditapply_apcreditapply_id_seq') INTO _apcreditapplyid;
    INSERT INTO apcreditapply
           ( apcreditapply_id, apcreditapply_source_apopen_id,
             apcreditapply_target_apopen_id, apcreditapply_amount,
             apcreditapply_curr_id )
    VALUES ( _apcreditapplyid, _apopenid, _n.apopen_id, _n.apopen_amount-_n.apopen_paid, _n.apopen_curr_id );
  END IF;

  SELECT postAPCreditMemoApplication(_apopenid) INTO _result;

  IF (_result < 0) THEN
    RAISE EXCEPTION 'Credit application failed with result %.', _result;
  END IF;

--  Reopen all of the P/O Items that were closed by this Voucher
  UPDATE poitem
  SET poitem_status='O'
  FROM voitem
  WHERE ( (voitem_poitem_id=poitem_id)
    AND   (voitem_close)
    AND   (voitem_vohead_id=_p.vohead_id) );

--  Reopen the P/O
  UPDATE pohead
  SET pohead_status='O'
  WHERE (pohead_id=_p.vohead_pohead_id);

--  Mark as voided
  UPDATE apopen
  SET apopen_void=TRUE
  WHERE (apopen_id=_n.apopen_id);

  RETURN pJournalNumber;

END;
$_$;


ALTER FUNCTION public.voidapopenvoucher(integer, integer) OWNER TO admin;

--
-- TOC entry 2304 (class 1255 OID 146567183)
-- Dependencies: 4536 8
-- Name: voidcheck(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION voidcheck(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCheckid ALIAS FOR $1;

BEGIN

  IF ( SELECT (checkhead_void OR checkhead_posted OR checkhead_replaced)
       FROM checkhead
       WHERE (checkhead_id=pCheckid) ) THEN
    RETURN -1;
  END IF;

  UPDATE checkhead
  SET checkhead_void=TRUE
  WHERE (checkhead_id=pCheckid);

  RETURN 1;

END;
$_$;


ALTER FUNCTION public.voidcheck(integer) OWNER TO admin;

--
-- TOC entry 2311 (class 1255 OID 146567184)
-- Dependencies: 4536 8
-- Name: voidcreditmemo(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION voidcreditmemo(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCmheadid ALIAS FOR $1;
  _r RECORD;
  _p RECORD;
  _n RECORD;
  _glSequence INTEGER := 0;
  _glJournal INTEGER := 0;
  _itemlocSeries INTEGER := 0;
  _invhistid INTEGER;
  _test INTEGER;
  _amount NUMERIC;
  _roundedBase NUMERIC;
  _totalAmount NUMERIC   := 0;
  _totalRoundedBase NUMERIC := 0;
  _commissionDue NUMERIC := 0;
  _toApply NUMERIC;
  _toClose BOOLEAN;
  _glDate	DATE;
  _taxBaseValue	NUMERIC	:= 0;

BEGIN

--  Cache C/M information
  SELECT cmhead.*,
         findARAccount(cmhead_cust_id) AS ar_accnt_id,
         ( SELECT COALESCE(SUM(taxhist_tax), 0)
           FROM cmheadtax
           WHERE ( (taxhist_parent_id = cmhead_id)
             AND   (taxhist_taxtype_id = getAdjustmentTaxtypeId()) ) ) AS adjtax
         INTO _p
  FROM cmhead
  WHERE (cmhead_id=pCmheadid);
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Cannot Void Credit Memo as cmhead not found';
  END IF;
  IF (NOT _p.cmhead_posted) THEN
    RETURN -10;
  END IF;

--  Cache AROpen Information
  SELECT aropen.* INTO _n
  FROM aropen
  WHERE ( (aropen_doctype='C')
    AND   (aropen_docnumber=_p.cmhead_number) );
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Cannot Void Credit Memo as aropen not found';
  END IF;

--  Check for ARApplications
  SELECT arapply_id INTO _test
  FROM arapply
  WHERE (arapply_target_aropen_id=_n.aropen_id)
     OR (arapply_source_aropen_id=_n.aropen_id)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -20;
  END IF;

  _glDate := COALESCE(_p.cmhead_gldistdate, _p.cmhead_docdate);

  SELECT fetchGLSequence() INTO _glSequence;
  SELECT fetchJournalNumber('AR-IN') INTO _glJournal;

--  Start by handling taxes (reverse sense)
  FOR _r IN SELECT tax_sales_accnt_id,
              round(sum(taxdetail_tax),2) AS tax,
              currToBase(_p.cmhead_curr_id, round(sum(taxdetail_tax),2), _p.cmhead_docdate) AS taxbasevalue
            FROM tax
             JOIN calculateTaxDetailSummary('CM', _p.cmhead_id, 'T') ON (taxdetail_tax_id=tax_id)
	    GROUP BY tax_id, tax_sales_accnt_id LOOP

    PERFORM insertIntoGLSeries( _glSequence, 'A/R', 'CM', _p.cmhead_number,
                                _r.tax_sales_accnt_id,
                                (_r.taxbasevalue * -1.0),
                                _glDate, ('Void-' || _p.cmhead_billtoname) );

    _totalAmount := _totalAmount + _r.tax * -1;
    _totalRoundedBase := _totalRoundedBase + _r.taxbasevalue * -1;
  END LOOP;

-- Process line items
  FOR _r IN SELECT *
            FROM creditmemoitem
            WHERE ( (cmitem_cmhead_id=_p.cmhead_id)
              AND   (cmitem_qtycredit <> 0 ) ) LOOP

    IF (_r.extprice <> 0) THEN
--  Debit the Sales Account for the current cmitem (reverse sense)
      _roundedBase := round(currToBase(_p.cmhead_curr_id, _r.extprice, _p.cmhead_docdate), 2);
      SELECT insertIntoGLSeries( _glSequence, 'A/R', 'CM', _p.cmhead_number,
                                 CASE WHEN _p.cmhead_rahead_id IS NULL THEN
                                   getPrjAccntId(_p.cmhead_prj_id, salesaccnt_credit_accnt_id)
                                 ELSE
                                   getPrjAccntId(_p.cmhead_prj_id, salesaccnt_returns_accnt_id)
                                 END,
                                 _roundedBase,
                                 _glDate, ('Void-' || _p.cmhead_billtoname) ) INTO _test
      FROM salesaccnt
      WHERE (salesaccnt_id=findSalesAccnt(_r.cmitem_itemsite_id, 'IS', _p.cmhead_cust_id,
                                          _p.cmhead_saletype_id, _p.cmhead_shipzone_id));
      IF (NOT FOUND) THEN
        PERFORM deleteGLSeries(_glSequence);
        RETURN -11;
      END IF;
    END IF;

    _totalAmount := _totalAmount + round(_r.extprice, 2);
    _totalRoundedBase := _totalRoundedBase + _roundedBase;

  END LOOP;

--  Credit the Misc. Account for Miscellaneous Charges (reverse sense)
  IF (_p.cmhead_misc <> 0) THEN
    _roundedBase := round(currToBase(_p.cmhead_curr_id, _p.cmhead_misc, _p.cmhead_docdate), 2);
    SELECT insertIntoGLSeries( _glSequence, 'A/R', 'CM', _p.cmhead_number,
                               getPrjAccntId(_p.cmhead_prj_id, accnt_id),
                               _roundedBase,
                               _glDate, ('Void-' ||_p.cmhead_billtoname) ) INTO _test
    FROM accnt
    WHERE (accnt_id=_p.cmhead_misc_accnt_id);

--  If the Misc. Charges Account was not found then punt
    IF (NOT FOUND) THEN
      PERFORM deleteGLSeries(_glSequence);
      RETURN _test;
    END IF;

--  Cache the Misc. Amount distributed
    _totalAmount := _totalAmount + _p.cmhead_misc;
    _totalRoundedBase := _totalRoundedBase + _roundedBase;
  END IF;

--  Debit the Freight Account (reverse sense)
  IF (_p.cmhead_freight <> 0) THEN
    _roundedBase := round(currToBase(_p.cmhead_curr_id, _p.cmhead_freight, _p.cmhead_docdate), 2);
    SELECT insertIntoGLSeries( _glSequence, 'A/R', 'CM', _p.cmhead_number,
                               getPrjAccntId(_p.cmhead_prj_id, accnt_id),
                               _roundedBase,
                               _glDate, ('Void-' || _p.cmhead_billtoname) ) INTO _test
    FROM accnt
    WHERE (accnt_id=findFreightAccount(_p.cmhead_cust_id));

--  If the Freight Charges Account was not found then punt
    IF (NOT FOUND) THEN
      PERFORM deleteGLSeries(_glSequence);
      RETURN _test;
    END IF;

--  Cache the Amount Distributed to Freight
    _totalAmount := _totalAmount + _p.cmhead_freight;
    _totalRoundedBase := _totalRoundedBase + _roundedBase;
  END IF;

  _totalAmount := _totalAmount;

--  Credit the A/R for the total Amount (reverse sense)
  IF (_totalAmount <> 0) THEN
    IF (_p.ar_accnt_id != -1) THEN
      SELECT insertIntoGLSeries( _glSequence, 'A/R', 'CM', _p.cmhead_number,
                                 _p.ar_accnt_id,
                                 (_totalRoundedBase * -1.0),
                                 _glDate, ('Void-' || _p.cmhead_billtoname) ) INTO _test;
    ELSE
      PERFORM deleteGLSeries(_glSequence);
      RETURN _test;
    END IF;
  END IF;

--  Commit the GLSeries;
  SELECT postGLSeries(_glSequence, _glJournal) INTO _test;
  IF (_test < 0) THEN
    PERFORM deleteGLSeries(_glSequence);
    RETURN _test;
  END IF;

--  Delete sales history
  DELETE FROM cohisttax
  WHERE (taxhist_parent_id IN (SELECT cohist_id
                               FROM cohist
                               WHERE (cohist_doctype='C' AND cohist_ordernumber=_p.cmhead_number)));

  DELETE FROM cohist
  WHERE (cohist_doctype='C' AND cohist_ordernumber=_p.cmhead_number);

--  Delete the Invoice aropen item
  DELETE FROM aropen
  WHERE (aropen_doctype='C' AND aropen_docnumber=_p.cmhead_number);

-- Handle the Inventory and G/L Transactions for any returned Inventory where cmitem_updateinv is true (reverse sense)
  FOR _r IN SELECT cmitem_itemsite_id AS itemsite_id, cmitem_id,
                   (cmitem_qtyreturned * cmitem_qty_invuomratio) AS qty,
                   cmhead_number, cmhead_cust_id AS cust_id, item_number,
                   cmhead_prj_id AS prj_id, cmhead_saletype_id AS saletype_id,
                   cmhead_shipzone_id AS shipzone_id
            FROM cmhead, cmitem, itemsite, item
            WHERE ( (cmitem_cmhead_id=cmhead_id)
             AND (cmitem_itemsite_id=itemsite_id)
             AND (itemsite_item_id=item_id)
             AND (cmitem_qtyreturned <> 0)
             AND (cmitem_updateinv)
             AND (cmhead_id=_p.cmhead_id) ) LOOP

--  Return credited stock to inventory
    IF (_itemlocSeries = 0) THEN
      SELECT NEXTVAL('itemloc_series_seq') INTO _itemlocSeries;
    END IF;
    SELECT postInvTrans( itemsite_id, 'RS', (_r.qty * -1),
                         'S/O', 'CM', _r.cmhead_number, '',
                         ('Credit Voided ' || _r.item_number),
                         costcat_asset_accnt_id,
                         getPrjAccntId(_r.prj_id, resolveCOSAccount(itemsite_id, _r.cust_id, _r.saletype_id, _r.shipzone_id)),
                         _itemlocSeries, _glDate) INTO _invhistid
    FROM itemsite, costcat
    WHERE ( (itemsite_costcat_id=costcat_id)
     AND (itemsite_id=_r.itemsite_id) );

  END LOOP;

--  Update coitem to reflect the returned qty where cmitem_updateinv is true (reverse sense)
  FOR _r IN SELECT cmitem_qtyreturned, cmitem_itemsite_id, cohead_id
            FROM cmitem, cmhead, invchead, cohead
            WHERE ( (cmitem_cmhead_id=cmhead_id)
             AND (cmhead_invcnumber=invchead_invcnumber)
             AND (invchead_ordernumber=cohead_number)
             AND (cmitem_qtyreturned <> 0)
             AND (cmitem_updateinv)
             AND (cmhead_id=_p.cmhead_id) ) LOOP
    UPDATE coitem
    SET coitem_qtyreturned = (coitem_qtyreturned + (_r.cmitem_qtyreturned * -1.0))
    WHERE coitem_id IN ( SELECT coitem_id
                         FROM coitem
                         WHERE ( (coitem_cohead_id=_r.cohead_id)
                          AND (coitem_itemsite_id = _r.cmitem_itemsite_id) )
                         LIMIT 1 );
  END LOOP;

--  Mark the cmhead as voided
  UPDATE cmhead
  SET cmhead_void=TRUE
  WHERE (cmhead_id=_p.cmhead_id);

  RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.voidcreditmemo(integer) OWNER TO admin;

--
-- TOC entry 2312 (class 1255 OID 146567186)
-- Dependencies: 4536 8
-- Name: voidinvoice(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION voidinvoice(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pInvcheadid ALIAS FOR $1;
  _glSequence INTEGER := 0;
  _glJournal INTEGER := 0;
  _itemlocSeries INTEGER := 0;
  _aropenid INTEGER := 0;
  _invhistid INTEGER := 0;
  _amount NUMERIC;
  _roundedBase NUMERIC;
  _r RECORD;
  _p RECORD;
  _n RECORD;
  _test INTEGER;
  _totalAmount          NUMERIC := 0;
  _totalRoundedBase     NUMERIC := 0;
  _totalAmountBase      NUMERIC := 0;
  _appliedAmount        NUMERIC := 0;
  _commissionDue        NUMERIC := 0;
  _tmpAccntId INTEGER;
  _tmpCurrId  INTEGER;
  _firstExchDate        DATE;
  _glDate		DATE;
  _exchGain             NUMERIC := 0;

BEGIN

--  Cache Invoice information
  SELECT invchead.*,
         findFreightAccount(invchead_cust_id) AS freightaccntid,
         findARAccount(invchead_cust_id) AS araccntid,
         aropen_id, cohist_unitcost,
         ( SELECT COALESCE(SUM(taxhist_tax), 0)
           FROM invcheadtax
           WHERE ( (taxhist_parent_id = invchead_id)
             AND   (taxhist_taxtype_id = getFreightTaxtypeId()) ) ) AS freighttax,
         ( SELECT COALESCE(SUM(taxhist_tax), 0)
           FROM invcheadtax
           WHERE ( (taxhist_parent_id = invchead_id)
             AND   (taxhist_taxtype_id = getAdjustmentTaxtypeId()) ) ) AS adjtax
       INTO _p
  FROM invchead JOIN aropen ON (aropen_doctype='I' AND aropen_docnumber=invchead_invcnumber)
                JOIN cohist ON (cohist_doctype='I' AND cohist_invcnumber=invchead_invcnumber)
  WHERE (invchead_id=pInvcheadid);
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Cannot Void Invoice as invchead not found';
  END IF;
  IF (NOT _p.invchead_posted) THEN
    RETURN -10;
  END IF;

--  Cache AROpen Information
  SELECT aropen.* INTO _n
  FROM aropen
  WHERE ( (aropen_doctype='I')
    AND   (aropen_docnumber=_p.invchead_invcnumber) );
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'Cannot Void Invoice as aropen not found';
  END IF;

--  Check for ARApplications
  SELECT arapply_id INTO _test
  FROM arapply
  WHERE (arapply_target_aropen_id=_n.aropen_id)
  LIMIT 1;
  IF (FOUND) THEN
    RETURN -20;
  END IF;

  SELECT fetchGLSequence() INTO _glSequence;
  SELECT fetchJournalNumber('AR-IN') INTO _glJournal;

  _glDate := COALESCE(_p.invchead_gldistdate, _p.invchead_invcdate);

-- the 1st MC iteration used the cohead_orderdate so we could get curr exch
-- gain/loss between the sales and invoice dates, but see issue 3892.  leave
-- this condition TRUE until we make this configurable or decide not to.
  IF TRUE THEN
      _firstExchDate := _p.invchead_invcdate;
  ELSE
-- can we save a select by using: _firstExchDate := _p.invchead_orderdate;
      SELECT cohead_orderdate INTO _firstExchDate
      FROM cohead
      WHERE (cohead_number = _p.invchead_ordernumber);
  END IF;

--  Start by handling taxes (reverse sense)
  FOR _r IN SELECT tax_sales_accnt_id,
              round(sum(taxdetail_tax),2) AS tax,
              currToBase(_p.invchead_curr_id, round(sum(taxdetail_tax),2), _firstExchDate) AS taxbasevalue
            FROM tax
             JOIN calculateTaxDetailSummary('I', _p.invchead_id, 'T') ON (taxdetail_tax_id=tax_id)
	    GROUP BY tax_id, tax_sales_accnt_id LOOP

    PERFORM insertIntoGLSeries( _glSequence, 'A/R', 'IN', _p.invchead_invcnumber,
                                _r.tax_sales_accnt_id,
                                (_r.taxbasevalue * -1.0),
                                _glDate, ('Void-' || _p.invchead_billto_name) );

    _totalAmount := _totalAmount + _r.tax;
    _totalRoundedBase := _totalRoundedBase + _r.taxbasevalue;
  END LOOP;

--  March through the Non-Misc. Invcitems
  FOR _r IN SELECT *
            FROM invoiceitem
            WHERE ( (invcitem_invchead_id = _p.invchead_id)
              AND   (invcitem_item_id <> -1) ) LOOP

--  Cache the amount due for this line
    _amount := _r.extprice;

    IF (_amount > 0) THEN
--  Credit the Sales Account for the invcitem item (reverse sense)
      IF (_r.itemsite_id IS NULL) THEN
	SELECT getPrjAccntId(_p.invchead_prj_id, salesaccnt_sales_accnt_id)
	INTO _tmpAccntId
	FROM salesaccnt
	WHERE (salesaccnt_id=findSalesAccnt(_r.invcitem_item_id, 'I', _p.invchead_cust_id,
                                            _p.invchead_saletype_id, _p.invchead_shipzone_id));
      ELSE
	SELECT getPrjAccntId(_p.invchead_prj_id, salesaccnt_sales_accnt_id)
	INTO _tmpAccntId
	FROM salesaccnt
	WHERE (salesaccnt_id=findSalesAccnt(_r.itemsite_id, 'IS', _p.invchead_cust_id,
                                            _p.invchead_saletype_id, _p.invchead_shipzone_id));
      END IF;

--  If the Sales Account Assignment was not found then punt
      IF (NOT FOUND) THEN
        PERFORM deleteGLSeries(_glSequence);
        RETURN -11;
      END IF;

      _roundedBase := round(currToBase(_p.invchead_curr_id, _amount, _firstExchDate), 2);
      SELECT insertIntoGLSeries( _glSequence, 'A/R', 'IN', _p.invchead_invcnumber,
                                 _tmpAccntId,
                                 (_roundedBase * -1.0),
                                 _glDate, ('Void-' || _p.invchead_billto_name) ) INTO _test;

      _totalAmount := (_totalAmount + _amount);
      _totalRoundedBase := _totalRoundedBase + _roundedBase;
      _commissionDue := (_commissionDue + (_amount * _p.invchead_commission));
    END IF;

    _totalAmount := _totalAmount;
    _totalRoundedBase := _totalRoundedBase;

  END LOOP;

--  March through the Misc. Invcitems
  FOR _r IN SELECT *
            FROM invoiceitem JOIN salescat ON (salescat_id = invcitem_salescat_id)
            WHERE ( (invcitem_item_id = -1)
              AND   (invcitem_invchead_id=_p.invchead_id) ) LOOP

--  Cache the amount due for this line and the commission due for such
    _amount := _r.extprice;

    IF (_amount > 0) THEN
--  Credit the Sales Account for the invcitem item (reverse sense)
      _roundedBase = round(currToBase(_p.invchead_curr_id, _amount,
                                      _firstExchDate), 2);
      SELECT insertIntoGLSeries( _glSequence, 'A/R', 'IN', _p.invchead_invcnumber,
                                 getPrjAccntId(_p.invchead_prj_id, _r.salescat_sales_accnt_id),
                                 (_roundedBase * -1.0),
                                 _glDate, ('Void-' || _p.invchead_billto_name) ) INTO _test;

      IF (_test < 0) THEN
        PERFORM deleteGLSeries(_glSequence);
        RETURN _test;
      END IF;

      _totalAmount := (_totalAmount + _amount);
      _totalRoundedBase :=  _totalRoundedBase + _roundedBase;
      _commissionDue := (_commissionDue + (_amount * _p.invchead_commission));
    END IF;

  END LOOP;

--  Credit the Freight Account for Freight Charges (reverse sense)
  IF (_p.invchead_freight <> 0) THEN
    IF (_p.freightaccntid <> -1) THEN
      _roundedBase = round(currToBase(_p.invchead_curr_id, _p.invchead_freight,
                                      _firstExchDate), 2);
      SELECT insertIntoGLSeries( _glSequence, 'A/R', 'IN', _p.invchead_invcnumber,
                                 getPrjAccntId(_p.invchead_prj_id,_p.freightaccntid),
                                 (_roundedBase * -1.0),
                                 _glDate, ('Void-' || _p.invchead_billto_name) ) INTO _test;

--  Cache the Freight Amount distributed
        _totalAmount := (_totalAmount + _p.invchead_freight);
        _totalRoundedBase := _totalRoundedBase + _roundedBase;
    ELSE
      _test := -14;
    END IF;

--  If the Freight Account was not found then punt
    IF (_test < 0) THEN
      PERFORM deleteGLSeries(_glSequence);
      RETURN _test;
    END IF;

  END IF;

--  Credit the Misc. Account for Miscellaneous Charges (reverse sense)
  IF (_p.invchead_misc_amount <> 0) THEN
    _roundedBase := round(currToBase(_p.invchead_curr_id, _p.invchead_misc_amount,
                                     _firstExchDate), 2);
    SELECT insertIntoGLSeries( _glSequence, 'A/R', 'IN', _p.invchead_invcnumber,
                               getPrjAccntId(_p.invchead_prj_id, _p.invchead_misc_accnt_id),
                               (_roundedBase * -1.0),
                               _glDate, ('Void-' || _p.invchead_billto_name) ) INTO _test;

--  If the Misc. Charges Account was not found then punt
    IF (_test < 0) THEN
      PERFORM deleteGLSeries(_glSequence);
      RETURN _test;
    END IF;

--  Cache the Misc. Amount distributed
    _totalAmount := (_totalAmount + _p.invchead_misc_amount);
    _totalRoundedBase := _totalRoundedBase + _roundedBase;

  END IF;

-- ToDo: handle rounding errors (reverse sense)
    _exchGain := currGain(_p.invchead_curr_id, _totalAmount,
                          _firstExchDate, _glDate);
    IF (_exchGain <> 0) THEN
        SELECT insertIntoGLSeries( _glSequence, 'A/R', 'IN', _p.invchead_invcnumber,
                                   getGainLossAccntId(_p.araccntid),
                                   round(_exchGain, 2),
                                   _glDate, ('Void-' || _p.invchead_billto_name) ) INTO _test ;
        IF (_test < 0) THEN
          PERFORM deleteGLSeries(_glSequence);
          RETURN _test;
        END IF;
    END IF;

--  Debit A/R for the total Amount (reverse sense)
  IF (_totalRoundedBase <> 0) THEN
    IF (_p.araccntid != -1) THEN
      SELECT insertIntoGLSeries( _glSequence, 'A/R', 'IN', _p.invchead_invcnumber,
                                 _p.araccntid,
                                 round(_totalRoundedBase, 2),
                                 _glDate, ('Void-' || _p.invchead_billto_name) ) INTO _test;
    ELSE
      PERFORM deleteGLSeries(_glSequence);
      RETURN _test;
    END IF;
  END IF;

--  Commit the GLSeries;
  SELECT postGLSeries(_glSequence, _glJournal) INTO _test;
  IF (_test < 0) THEN
    PERFORM deleteGLSeries(_glSequence);
    RETURN _test;
  END IF;

--  Delete sales history
  DELETE FROM cohisttax
  WHERE (taxhist_parent_id IN (SELECT cohist_id
                               FROM cohist
                               WHERE (cohist_doctype='I' AND cohist_invcnumber=_p.invchead_invcnumber)));

  DELETE FROM cohist
  WHERE (cohist_doctype='I' AND cohist_invcnumber=_p.invchead_invcnumber);

--  Create the Credit aropen item
  SELECT nextval('aropen_aropen_id_seq') INTO _aropenid;
  INSERT INTO aropen
  ( aropen_id, aropen_username, aropen_journalnumber,
    aropen_open, aropen_posted,
    aropen_cust_id, aropen_ponumber,
    aropen_docnumber, aropen_applyto, aropen_doctype,
    aropen_docdate, aropen_duedate, aropen_distdate, aropen_terms_id,
    aropen_amount, aropen_paid,
    aropen_salesrep_id, aropen_commission_due, aropen_commission_paid,
    aropen_ordernumber, aropen_notes, aropen_cobmisc_id,
    aropen_curr_id )
  VALUES
  ( _aropenid, getEffectiveXtUser(), _glJournal,
    TRUE, FALSE,
    _p.invchead_cust_id, _p.invchead_ponumber,
    _p.invchead_invcnumber, _p.invchead_invcnumber, 'C',
    _p.invchead_invcdate, determineDueDate(_p.invchead_terms_id, _p.invchead_invcdate), _glDate, _p.invchead_terms_id,
    round(_totalAmount, 2), round(_totalAmount, 2),
    _p.invchead_salesrep_id, _commissionDue, FALSE,
    _p.invchead_ordernumber::text, _p.invchead_notes, pInvcheadid,
    _p.invchead_curr_id );

--  Alter the Invoice A/R Open Item to reflect the application
    UPDATE aropen
    SET aropen_paid = round(_totalAmount, 2)
    WHERE (aropen_id=_p.aropen_id);

--  Record the application
    INSERT INTO arapply
    ( arapply_cust_id,
      arapply_source_aropen_id, arapply_source_doctype, arapply_source_docnumber,
      arapply_target_aropen_id, arapply_target_doctype, arapply_target_docnumber,
      arapply_fundstype, arapply_refnumber,
      arapply_applied, arapply_closed,
      arapply_postdate, arapply_distdate, arapply_journalnumber, arapply_curr_id )
    VALUES
    ( _p.invchead_cust_id,
      _aropenid, 'C', _p.invchead_invcnumber,
      _p.aropen_id, 'I', _p.invchead_invcnumber,
      '', '',
      round(_totalAmount, 2), TRUE,
      CURRENT_DATE, _p.invchead_invcdate, 0, _p.invchead_curr_id );

-- Handle the Inventory and G/L Transactions for any billed Inventory where invcitem_updateinv is true (reverse sense)
  FOR _r IN SELECT itemsite_id AS itemsite_id, invcitem_id,
                   (invcitem_billed * invcitem_qty_invuomratio) AS qty,
                   invchead_invcnumber, invchead_cust_id AS cust_id, item_number,
                   invchead_prj_id AS prj_id, invchead_saletype_id AS saletype_id,
                   invchead_shipzone_id AS shipzone_id
            FROM invchead JOIN invcitem ON ( (invcitem_invchead_id=invchead_id) AND
                                             (invcitem_billed <> 0) AND
                                             (invcitem_updateinv) )
                          JOIN itemsite ON ( (itemsite_item_id=invcitem_item_id) AND
                                             (itemsite_warehous_id=invcitem_warehous_id) )
                          JOIN item ON (item_id=invcitem_item_id)
            WHERE (invchead_id=_p.invchead_id) LOOP

--  Return billed stock to inventory
    IF (_itemlocSeries = 0) THEN
      SELECT NEXTVAL('itemloc_series_seq') INTO _itemlocSeries;
    END IF;
    SELECT postInvTrans( itemsite_id, 'SH', (_r.qty * -1.0),
                         'S/O', 'IN', _r.invchead_invcnumber, '',
                         ('Invoice Voided ' || _r.item_number),
                         getPrjAccntId(_r.prj_id, resolveCOSAccount(itemsite_id, _r.cust_id, _r.saletype_id, _r.shipzone_id)),
                         costcat_asset_accnt_id, _itemlocSeries, _glDate,
                         (_p.cohist_unitcost * _r.qty)) INTO _invhistid
    FROM itemsite JOIN costcat ON (itemsite_costcat_id=costcat_id)
    WHERE (itemsite_id=_r.itemsite_id);

  END LOOP;

--  Reopen Billing
  UPDATE shipitem
  SET shipitem_invoiced=FALSE,
      shipitem_invcitem_id=NULL
  WHERE (shipitem_invcitem_id IN (SELECT invcitem_id
                                  FROM invcitem
                                  WHERE (invcitem_invchead_id=_p.invchead_id)));
  UPDATE cobill
  SET cobill_invcnum=NULL,
      cobill_invcitem_id=NULL
  WHERE (cobill_invcitem_id IN (SELECT invcitem_id
                                FROM invcitem
                                WHERE (invcitem_invchead_id=_p.invchead_id)));
  UPDATE cobmisc
  SET cobmisc_posted=FALSE,
      cobmisc_invcnumber=NULL,
      cobmisc_invchead_id=NULL
  WHERE (cobmisc_invchead_id=_p.invchead_id);

--  Mark the invoice as voided
  UPDATE invchead
  SET invchead_void=TRUE,
      invchead_notes=(invchead_notes || 'Voided on ' || current_date || ' by ' || getEffectiveXtUser())
  WHERE (invchead_id=_p.invchead_id);

  RETURN _itemlocSeries;

END;
$_$;


ALTER FUNCTION public.voidinvoice(integer) OWNER TO admin;

--
-- TOC entry 1115 (class 1255 OID 146567188)
-- Dependencies: 4536 8
-- Name: voidpostedapcheck(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION voidpostedapcheck(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RAISE NOTICE 'voidPostedAPCheck() is deprecated - use voidPostedCheck() instead';
  RETURN voidPostedCheck($1, fetchJournalNumber('AP-CK'), CURRENT_DATE);
END;
$_$;


ALTER FUNCTION public.voidpostedapcheck(integer) OWNER TO admin;

--
-- TOC entry 1145 (class 1255 OID 146567189)
-- Dependencies: 4536 8
-- Name: voidpostedapcheck(integer, integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION voidpostedapcheck(integer, integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RAISE NOTICE 'voidPostedAPCheck() is deprecated - use voidPostedCheck() instead';
  RETURN voidPostedCheck($1, $2, CURRENT_DATE);
END;
$_$;


ALTER FUNCTION public.voidpostedapcheck(integer, integer) OWNER TO admin;

--
-- TOC entry 1215 (class 1255 OID 146567190)
-- Dependencies: 4536 8
-- Name: voidpostedapcheck(integer, integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION voidpostedapcheck(integer, integer, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
BEGIN
  RAISE NOTICE 'voidPostedAPCheck() is deprecated - use voidPostedCheck() instead';
  RETURN voidPostedCheck($1, $2, $3);
END;
$_$;


ALTER FUNCTION public.voidpostedapcheck(integer, integer, date) OWNER TO admin;

--
-- TOC entry 1222 (class 1255 OID 146567191)
-- Dependencies: 4536 8
-- Name: voidpostedcheck(integer, integer, date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION voidpostedcheck(integer, integer, date) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pCheckid		ALIAS FOR $1;
  pJournalNumber	ALIAS FOR $2;
  pVoidDate		ALIAS FOR $3;
  _amount_base		NUMERIC := 0;
  _result               INTEGER;
  _apopenid		INTEGER;
  _credit_glaccnt	INTEGER;
  _docnumber		TEXT;
  _exchGain		NUMERIC := 0;
  _exchGainTmp		NUMERIC := 0;
  _gltransNote		TEXT;
  _p			RECORD;
  _r			RECORD;
  _sequence		INTEGER;
  _amount_check         NUMERIC := 0;

BEGIN

  SELECT fetchGLSequence() INTO _sequence;

  SELECT checkhead.*,
         checkhead_amount / checkhead_curr_rate AS checkhead_amount_base,
         bankaccnt_accnt_id AS bankaccntid,
         findPrepaidAccount(checkhead_recip_id) AS prepaidaccntid,
	 checkrecip.* INTO _p
  FROM bankaccnt, checkhead LEFT OUTER JOIN
       checkrecip ON ((checkrecip_type=checkhead_recip_type)
		  AND (checkrecip_id=checkhead_recip_id))
  WHERE ((checkhead_bankaccnt_id=bankaccnt_id)
    AND  (checkhead_id=pCheckid));

  IF (NOT _p.checkhead_posted) THEN
    RETURN -10;
  END IF;

  IF (_p.checkrecip_id IS NULL) THEN	-- outer join failed
    RETURN -11;
  END IF;

  -- Cannot void if already reconciled
  SELECT trans_id INTO _result
  FROM ( SELECT gltrans_id AS trans_id
         FROM gltrans
              LEFT OUTER JOIN bankrecitem ON (bankrecitem_source='GL' AND bankrecitem_source_id=gltrans_id)
         WHERE ( (gltrans_doctype='CK')
           AND   (gltrans_misc_id=_p.checkhead_id)
           AND   ((gltrans_rec) OR (bankrecitem_id IS NOT NULL)) )
         UNION ALL
         SELECT sltrans_id AS trans_id
         FROM sltrans
              LEFT OUTER JOIN bankrecitem ON (bankrecitem_source='GL' AND bankrecitem_source_id=sltrans_id)
         WHERE ( (sltrans_doctype='CK')
           AND   (sltrans_misc_id=_p.checkhead_id)
           AND   ((sltrans_rec) OR (bankrecitem_id IS NOT NULL)) )
       ) AS data;
  IF (FOUND) THEN
    RETURN -14;
  END IF;

  _gltransNote := 'Void Posted Check #' || _p.checkhead_number || ' ' ||
		  _p.checkrecip_number || '-' || _p.checkrecip_name;

  IF (_p.checkhead_misc) THEN
    IF (COALESCE(_p.checkhead_expcat_id, -1) < 0) THEN
      IF (_p.checkhead_recip_type = 'V') THEN
	PERFORM createAPDebitMemo(_p.checkhead_recip_id, pJournalNumber,
				  CAST(fetchAPMemoNumber() AS text), '',
				  pVoidDate, _p.checkhead_amount,
				  _gltransNote || ' '|| _p.checkhead_notes,
				  -1, pVoidDate, -1, _p.checkhead_curr_id );
	_credit_glaccnt := findAPPrepaidAccount(_p.checkhead_recip_id);

      ELSIF (_p.checkhead_recip_type = 'C') THEN
	PERFORM createARCreditMemo(NULL, _p.checkhead_recip_id,
				  fetchARMemoNumber(), '',
				  pVoidDate, _p.checkhead_amount,
				  _gltransNote || ' '|| _p.checkhead_notes,
				  -1, -1, -1, pVoidDate, -1, NULL, 0.0,
				  pJournalNumber, _p.checkhead_curr_id );
	_credit_glaccnt := _p.prepaidaccntid;

      ELSIF (_p.checkhead_recip_type = 'T') THEN
	-- TODO: should we create a debit memo for the tax authority? how?
	_credit_glaccnt := _p.checkrecip_accnt_id;

      END IF; -- recip type

    ELSE
      SELECT expcat_exp_accnt_id INTO _credit_glaccnt
      FROM expcat
      WHERE (expcat_id=_p.checkhead_expcat_id);
      IF (NOT FOUND) THEN
        RETURN -12;
      END IF;
    END IF;

    IF (COALESCE(_credit_glaccnt, -1) < 0) THEN
      RETURN -13;
    END IF;

    PERFORM insertIntoGLSeries( _sequence, _p.checkrecip_gltrans_source, 'CK',
				text(_p.checkhead_number),
				_credit_glaccnt,
				round(_p.checkhead_amount_base, 2),
				pVoidDate, _gltransNote, pCheckid);

    _amount_base := _p.checkhead_amount_base;

  ELSE
    FOR _r IN SELECT checkitem_amount, checkitem_discount,
                     CASE WHEN (checkitem_apopen_id IS NOT NULL AND apopen_doctype='C') THEN
                            checkitem_amount / apopen_curr_rate * -1.0
                          WHEN (checkitem_apopen_id IS NOT NULL) THEN
                            checkitem_amount / apopen_curr_rate
                          ELSE
                            currToBase(checkitem_curr_id,
                                       checkitem_amount,
                                       COALESCE(checkitem_docdate, _p.checkhead_checkdate))
                     END AS checkitem_amount_base,
                     currTocurr(checkitem_curr_id, _p.checkhead_curr_id,
                                CASE WHEN (checkitem_apopen_id IS NOT NULL AND apopen_doctype='C') THEN
                                          checkitem_amount * -1.0
                                     ELSE checkitem_amount END,
                                  _p.checkhead_checkdate) AS amount_check,
                     apopen_id, apopen_doctype, apopen_docnumber, apopen_curr_rate, apopen_docdate,
                     aropen_id, aropen_doctype, aropen_docnumber,
                     checkitem_curr_id, checkitem_curr_rate,
                     COALESCE(checkitem_docdate, _p.checkhead_checkdate) AS docdate
              FROM (checkitem LEFT OUTER JOIN
		    apopen ON (checkitem_apopen_id=apopen_id)) LEFT OUTER JOIN
		    aropen ON (checkitem_aropen_id=aropen_id)
              WHERE (checkitem_checkhead_id=pcheckid) LOOP

      _exchGainTmp := 0;
      IF (_r.apopen_id IS NOT NULL) THEN
	-- undo the APDiscount Credit Memo if a discount was taken
        IF(_r.checkitem_discount > 0) THEN
          SELECT NEXTVAL('apopen_apopen_id_seq') INTO _apopenid;
          SELECT fetchAPMemoNumber() INTO _docnumber;
          INSERT INTO apopen
          ( apopen_id, apopen_username, apopen_journalnumber,
            apopen_vend_id, apopen_docnumber, apopen_doctype, apopen_ponumber,
            apopen_docdate, apopen_duedate, apopen_distdate, apopen_terms_id,
            apopen_amount, apopen_paid, apopen_open,
	    apopen_notes,
	    apopen_accnt_id, apopen_curr_id, apopen_discount, apopen_curr_rate,
            apopen_closedate )
          VALUES
          ( _apopenid, getEffectiveXtUser(), pJournalNumber,
            _p.checkhead_recip_id, _docnumber, 'D', '',
            pVoidDate, pVoidDate, pVoidDate, -1,
            _r.checkitem_discount, _r.checkitem_discount, FALSE,
            ('Reverse Posted Discount ' || _r.apopen_doctype || ' ' ||
	      _r.apopen_docnumber),
	    -1, _p.checkhead_curr_id, TRUE, _r.apopen_curr_rate,
            current_date );


          PERFORM insertIntoGLSeries( _sequence, _p.checkrecip_gltrans_source,
                                      'DS', _r.apopen_docnumber,
                                      findAPDiscountAccount(_p.checkhead_recip_id),
                                      round(_r.checkitem_discount / _r.apopen_curr_rate, 2) * -1,
                                      pVoidDate, _gltransNote, pCheckid);

          PERFORM insertIntoGLSeries( _sequence, _p.checkrecip_gltrans_source,
                                      'DS', _r.apopen_docnumber,
                                      findAPAccount(_p.checkhead_recip_id),
                                      round(_r.checkitem_discount / _r.apopen_curr_rate, 2),
                                      pVoidDate, _gltransNote, pCheckid);

	  --  Post the application
          INSERT INTO apapply
          ( apapply_vend_id, apapply_postdate, apapply_username,
            apapply_source_apopen_id, apapply_source_doctype, apapply_source_docnumber,
            apapply_target_apopen_id, apapply_target_doctype, apapply_target_docnumber,
            apapply_journalnumber, apapply_amount, apapply_curr_id )
          VALUES
          ( _p.checkhead_recip_id, pVoidDate, getEffectiveXtUser(),
            _apopenid, 'D', _docnumber,
            _r.apopen_id, _r.apopen_doctype, _r.apopen_docnumber,
            pJournalNumber, (_r.checkitem_discount * -1), _r.checkitem_curr_id );
        END IF; -- discount was taken

        UPDATE apopen
       SET apopen_paid = round(apopen_paid -
				(_r.checkitem_amount + noNeg(_r.checkitem_discount)), 2),
            apopen_open = round(apopen_amount, 2) >
			  round(apopen_paid -
				(_r.checkitem_amount + noNeg(_r.checkitem_discount)), 2),
            apopen_closedate = CASE WHEN (round(apopen_amount, 2) >
			                  round(apopen_paid -
				           (_r.checkitem_amount + noNeg(_r.checkitem_discount)))) THEN NULL ELSE apopen_closedate END
        WHERE (apopen_id=_r.apopen_id);

	--  Post the application
        INSERT INTO apapply
        ( apapply_vend_id, apapply_postdate, apapply_username,
          apapply_source_apopen_id, apapply_source_doctype, apapply_source_docnumber,
          apapply_target_apopen_id, apapply_target_doctype, apapply_target_docnumber,
          apapply_journalnumber, apapply_amount, apapply_curr_id )
        VALUES
        ( _p.checkhead_recip_id, pVoidDate, getEffectiveXtUser(),
          -1, 'K', _p.checkhead_number,
          _r.apopen_id, _r.apopen_doctype, _r.apopen_docnumber,
          pJournalNumber, (_r.checkitem_amount * -1), _r.checkitem_curr_id );
      END IF; -- if check item's apopen_id is not null

      IF (_r.aropen_id IS NOT NULL) THEN
        UPDATE aropen
        SET aropen_paid = round(aropen_paid -_r.checkitem_amount, 2),
            aropen_open = round(aropen_amount, 2) >
			  round(aropen_paid - _r.checkitem_amount, 2)
        WHERE (aropen_id=_r.aropen_id);

	--  Post the application
        INSERT INTO arapply
        ( arapply_cust_id, arapply_postdate, arapply_distdate, arapply_username,
          arapply_source_aropen_id, arapply_source_doctype, arapply_source_docnumber,
          arapply_target_aropen_id, arapply_target_doctype, arapply_target_docnumber,
          arapply_journalnumber, arapply_applied, arapply_curr_id )
        VALUES
        ( _p.checkhead_recip_id, pVoidDate, pVoidDate, getEffectiveXtUser(),
          -1, 'K', _p.checkhead_number,
          _r.aropen_id, _r.aropen_doctype, _r.aropen_docnumber,
          pJournalNumber, (_r.checkitem_amount * -1), _r.checkitem_curr_id );

      END IF; -- if check item's aropen_id is not null

--  calculate currency gain/loss
      IF (_r.apopen_id IS NOT NULL) THEN
        IF (_p.checkhead_curr_id = _r.checkitem_curr_id) THEN
          IF (_r.apopen_docdate > _p.checkhead_checkdate) THEN
            _exchGainTmp := ((_r.checkitem_amount/_p.checkhead_curr_rate) - (_r.checkitem_amount / _r.apopen_curr_rate)) * -1;
          ELSE
            _exchGainTmp := ((_r.checkitem_amount / _r.apopen_curr_rate) - (_r.checkitem_amount/_p.checkhead_curr_rate));
          END IF;
        ELSE
          -- unusual condition where bank overridden and different currency from voucher
          -- this does not work for all situations
          --IF (_r.apopen_docdate > _p.checkhead_checkdate) THEN
          --  _exchGainTmp := ((_r.checkitem_amount/_r.checkitem_curr_rate) - (_r.checkitem_amount / _r.apopen_curr_rate)) * -1;
          --ELSE
          --  _exchGainTmp := ((_r.checkitem_amount / _r.apopen_curr_rate) - (_r.checkitem_amount/_r.checkitem_curr_rate));
          --END IF;
          _exchGainTmp := 0.0;
        END IF;
      ELSE
        SELECT arCurrGain(_r.aropen_id,_r.checkitem_curr_id, _r.checkitem_amount,
                        _p.checkhead_checkdate)
              INTO _exchGainTmp;
      END IF;
      _exchGain := _exchGain + _exchGainTmp;

      PERFORM insertIntoGLSeries( _sequence, _p.checkrecip_gltrans_source,
				  'CK', text(_p.checkhead_number),
                                  _p.checkrecip_accnt_id,
                                  round(_r.checkitem_amount_base, 2),
                                  pVoidDate, _gltransNote, pCheckid);
      IF (_exchGainTmp <> 0) THEN
          PERFORM insertIntoGLSeries( _sequence, _p.checkrecip_gltrans_source,
				      'CK', text(_p.checkhead_number),
				      getGainLossAccntId(_p.checkrecip_accnt_id),
				      round(_exchGainTmp, 2) * -1,
				      pVoidDate, _gltransNote, pCheckid);
      END IF;

      _amount_check := (_amount_check + _r.amount_check);
      _amount_base := (_amount_base + _r.checkitem_amount_base);

    END LOOP;

    IF( (_amount_check - _p.checkhead_amount) <> 0.0 ) THEN
      _exchGainTmp :=  (_amount_check - _p.checkhead_amount) / _p.checkhead_curr_rate;
      _exchGain := _exchGain + _exchGainTmp;
    END IF;

    --  ensure that the check balances, attribute rounding errors to gain/loss
    IF round(_amount_base, 2) - round(_exchGain, 2) <> round(_p.checkhead_amount_base, 2) THEN
      IF round(_amount_base - _exchGain, 2) = round(_p.checkhead_amount_base, 2) THEN
	PERFORM insertIntoGLSeries( _sequence, _p.checkrecip_gltrans_source,
				    'CK',
				    text(_p.checkhead_number), getGainLossAccntId(_p.bankaccntid),
				    (round(_amount_base, 2) -
				     round(_exchGain, 2) -
				     round(_p.checkhead_amount_base, 2)) * -1,
				    pVoidDate, _gltransNote, pCheckid);
      ELSE
	RAISE EXCEPTION 'checkhead_id % does not balance (% - % <> %)', pCheckid,
	      _amount_base, _exchGain, _p.checkhead_amount_base;
      END IF;
    END IF;
  END IF;

  PERFORM insertIntoGLSeries( _sequence, _p.checkrecip_gltrans_source, 'CK',
			      text(_p.checkhead_number),
                              _p.bankaccntid,
			      round(_p.checkhead_amount_base, 2) * -1,
                              pVoidDate, _gltransNote, pCheckid);

  PERFORM postGLSeries(_sequence, pJournalNumber);

  UPDATE gltrans
     SET gltrans_misc_id=pCheckid
   WHERE gltrans_sequence=_sequence;

  UPDATE checkhead
  SET checkhead_posted=false,
      checkhead_void=true,
      checkhead_journalnumber=pJournalNumber
  WHERE (checkhead_id=pCheckid);

  RETURN pJournalNumber;

END;
$_$;


ALTER FUNCTION public.voidpostedcheck(integer, integer, date) OWNER TO admin;

--
-- TOC entry 1254 (class 1255 OID 146567193)
-- Dependencies: 4536 8
-- Name: woeffectivedate(date); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION woeffectivedate(date) RETURNS date
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  pStartDate ALIAS FOR $1;

BEGIN

  IF (explodeWoEffective() = 'E') THEN
    RETURN CURRENT_DATE;
  ELSE
    RETURN pStartDate;
  END IF;

END;
$_$;


ALTER FUNCTION public.woeffectivedate(date) OWNER TO admin;

--
-- TOC entry 2324 (class 1255 OID 146567195)
-- Dependencies: 2714 4536 8
-- Name: woinvavail(integer, integer, boolean, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION woinvavail(integer, integer, boolean, boolean) RETURNS SETOF woinvav
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
   pwoid ALIAS FOR $1;
   plevel ALIAS FOR $2;
   pshowshortage ALIAS FOR $3;
   pshowlowinventory ALIAS FOR $4;
  _row woinvav%ROWTYPE;
  _x RECORD;
  _subx RECORD;
  _index INTEGER;
  _level INTEGER;
  _qry TEXT;
BEGIN
    FOR _x IN
          SELECT wo_id,
                itemsite_id,
                item_type,
                wo_number,
                wo_subnumber,
                item_number,
                item_descrip1,
                item_descrip2,
                uom_name,
                qoh,
                wobalance,
                allocated,
                ordered,
                reorderlevel,
                (qoh + ordered - wobalance) AS woavail,
                (qoh + ordered - allocated) AS totalavail
         FROM(SELECT wo_id,
                itemsite_id,
                item_type,
                wo_number,
                wo_subnumber,
                item_number,
                item_descrip1,
                item_descrip2,
                uom_name,
                noNeg(itemsite_qtyonhand) AS qoh,
                noNeg(wo_qtyord - wo_qtyrcv) AS wobalance,
                qtyAllocated(itemsite_id, wo_duedate) AS allocated,
                qtyOrdered(itemsite_id, wo_duedate) AS ordered,
                CASE WHEN(itemsite_useparams) THEN itemsite_reorderlevel ELSE 0.0 END AS reorderlevel
          FROM wo, itemsite, item, uom
         WHERE ((wo_ordid = pwoid)
           AND NOT (wo_status = 'C')
           AND (itemsite_id = wo_itemsite_id)
           AND (itemsite_item_id=item_id)
           AND (item_inv_uom_id=uom_id))
         ORDER BY wo_number, wo_subnumber) AS data
       LOOP
         _row.woinvav_itemsite_id := _x.itemsite_id;
         _row.woinvav_womatl_id := -1;
         _row.woinvav_type := _x.item_type;
         _row.woinvav_item_wo_number := _x.wo_number || '-' || _x.wo_subnumber;
         _row.woinvav_descrip := _x.item_descrip1 || ' ' || _x.item_descrip2;
         _row.woinvav_uomname := _x.uom_name;
         _row.woinvav_qoh := _x.qoh;
         _row.woinvav_balance := _x.wobalance;
         _row.woinvav_allocated := _x.allocated;
         _row.woinvav_ordered := _x.ordered;
         _row.woinvav_woavail := _x.woavail;
         _row.woinvav_totalavail := _x.totalavail;
         _row.woinvav_reorderlevel := _x.reorderlevel;
         _row.woinvav_level := plevel;
         RETURN NEXT _row;
        --get materials for this level
        FOR _subx IN
          SELECT * FROM woinvavailmatl(_x.wo_id, plevel + 1, pshowshortage, pshowlowinventory)
        LOOP
	  RETURN NEXT _subx;
	END LOOP;
        --get next level wo
        FOR _subx IN
          SELECT * FROM woinvavail(_x.wo_id, plevel + 1, pshowshortage, pshowlowinventory)
        LOOP
	  RETURN NEXT _subx;
	END LOOP;
      END LOOP;
  RETURN;
END;
$_$;


ALTER FUNCTION public.woinvavail(integer, integer, boolean, boolean) OWNER TO admin;

--
-- TOC entry 2323 (class 1255 OID 146567194)
-- Dependencies: 2714 4536 8
-- Name: woinvavail(integer, boolean, boolean, boolean, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION woinvavail(integer, boolean, boolean, boolean, boolean) RETURNS SETOF woinvav
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
   pwoid ALIAS FOR $1;
   pshowchildindent ALIAS FOR $2;
   pshowchildsum ALIAS FOR $3;
   pshowshortage ALIAS FOR $4;
   pshowlowinventory ALIAS FOR $5;
  _row woinvav%ROWTYPE;
  _subrow woinvav%ROWTYPE;
  _wonumber TEXT;
  _x RECORD;
  _subx RECORD;
  _qry TEXT;

BEGIN

    IF(pshowchildindent) THEN
      --get top level order
      FOR _x IN
          SELECT wo_id,
                itemsite_id,
                item_type,
                wo_number,
                wo_subnumber,
                item_number,
                item_descrip1,
                item_descrip2,
                uom_name,
                qoh,
                wobalance,
                allocated,
                ordered,
                reorderlevel,
                (qoh + ordered - wobalance) AS woavail,
                (qoh + ordered - allocated) AS totalavail
         FROM(SELECT wo_id,
                itemsite_id,
                item_type,
                wo_number,
                wo_subnumber,
                item_number,
                item_descrip1,
                item_descrip2,
                uom_name,
                noNeg(itemsite_qtyonhand) AS qoh,
                noNeg(wo_qtyord - wo_qtyrcv) AS wobalance,
                qtyAllocated(itemsite_id, wo_duedate) AS allocated,
                qtyOrdered(itemsite_id, wo_duedate) AS ordered,
                CASE WHEN(itemsite_useparams) THEN itemsite_reorderlevel ELSE 0.0 END AS reorderlevel
          FROM wo, itemsite, item, uom
         WHERE ((wo_id = pwoid)
           AND (itemsite_id = wo_itemsite_id)
           AND (itemsite_item_id=item_id)
           AND (item_inv_uom_id=uom_id))
         ORDER BY wo_number, wo_subnumber) AS data
       LOOP
         _row.woinvav_itemsite_id := _x.itemsite_id;
         _row.woinvav_womatl_id := -1;
         _row.woinvav_type := _x.item_type;
         _row.woinvav_item_wo_number := _x.wo_number || '-' || _x.wo_subnumber;
         _row.woinvav_descrip := _x.item_descrip1 || ' ' || _x.item_descrip2;
         _row.woinvav_uomname := _x.uom_name;
         _row.woinvav_qoh := _x.qoh;
         _row.woinvav_balance := _x.wobalance;
         _row.woinvav_allocated := _x.allocated;
         _row.woinvav_ordered := _x.ordered;
         _row.woinvav_woavail := _x.woavail;
         _row.woinvav_totalavail := _x.totalavail;
         _row.woinvav_reorderlevel := _x.reorderlevel;
         _row.woinvav_level := 0;
         RETURN NEXT _row;
        --get materials for this level
        FOR _subx IN
          SELECT * FROM woinvavailmatl(_x.wo_id, 1, pshowshortage, pshowlowinventory)
        LOOP
	  RETURN NEXT _subx;
	END LOOP;
	FOR _subx IN
          SELECT * FROM woinvavail(_x.wo_id, 1, pshowshortage, pshowlowinventory)
        LOOP
	  RETURN NEXT _subx;
	END LOOP;
     END LOOP;
    ELSE
       SELECT wo_number FROM wo WHERE wo_id=pwoid LIMIT 1 INTO _wonumber;
       --display a single level sum of work order requirements
       _qry := 'SELECT  wo_id,
                        itemsite_id,
		        womatl_id,
			item_type,
			wo_number,
                        item_number,
                        item_descrip1,
                        item_descrip2,
                        uom_name,
                        qoh,
                        wobalance,
                        allocated,
                        ordered,
                        reorderlevel,
                        (qoh + ordered - wobalance) AS woavail,
                        (qoh + ordered - allocated) AS totalavail
	          FROM (SELECT wo_id,
	                itemsite_id,
			womatl_id,
			item_type,
			wo_number,
                        item_number,
                        item_descrip1,
                        item_descrip2,
                        uom_name,
                        noNeg(itemsite_qtyonhand) AS qoh,
                        noNeg(itemuomtouom(itemsite_item_id, womatl_uom_id, NULL, womatl_qtyreq - womatl_qtyiss)) AS wobalance,
                        qtyAllocated(itemsite_id, womatl_duedate) AS allocated,
                        qtyOrdered(itemsite_id, womatl_duedate) AS ordered,
                        CASE WHEN(itemsite_useparams) THEN itemsite_reorderlevel ELSE 0.0 END AS reorderlevel
                   FROM wo, womatl, itemsite, item, uom
                 WHERE (womatl_wo_id=wo_id)
                   AND (womatl_itemsite_id=itemsite_id)
                   AND (itemsite_item_id=item_id)
                   AND (item_inv_uom_id=uom_id) ';
                IF(pshowchildsum) THEN
                  _qry := _qry || ' AND (wo_number=' || _wonumber || ')';
                ELSE
                  _qry := _qry || ' AND (womatl_wo_id=' || pwoid || ')';
                END IF;
                 _qry := _qry || ' ORDER BY item_number) AS data ';
                IF(pshowshortage) THEN
                  _qry := _qry || ' WHERE (((qoh + ordered - allocated) < 0) OR ((qoh + ordered - wobalance) < 0)) ';
                END IF;
                IF(pshowlowinventory AND NOT pshowshortage) THEN
                  _qry := _qry || ' WHERE (((qoh - allocated) < 0) OR ((qoh - wobalance) < 0)) ';
                END IF;

      FOR _x IN
         EXECUTE _qry
      LOOP
        _row.woinvav_itemsite_id := _x.itemsite_id;
        _row.woinvav_womatl_id := _x.womatl_id;
        _row.woinvav_type := _x.item_type;
        _row.woinvav_item_wo_number := _x.item_number;
        _row.woinvav_descrip := _x.item_descrip1 || ' ' || _x.item_descrip2;
        _row.woinvav_uomname := _x.uom_name;
        _row.woinvav_qoh := _x.qoh;
        _row.woinvav_balance := _x.wobalance;
        _row.woinvav_allocated := _x.allocated;
        _row.woinvav_ordered := _x.ordered;
        _row.woinvav_woavail := _x.woavail;
        _row.woinvav_totalavail := _x.totalavail;
        _row.woinvav_reorderlevel := _x.reorderlevel;
        _row.woinvav_level := 0;
        RETURN NEXT _row;
  END LOOP;
  END IF;
  RETURN;
END;
$_$;


ALTER FUNCTION public.woinvavail(integer, boolean, boolean, boolean, boolean) OWNER TO admin;

--
-- TOC entry 2325 (class 1255 OID 146567196)
-- Dependencies: 2714 4536 8
-- Name: woinvavailmatl(integer, integer, boolean, boolean); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION woinvavailmatl(integer, integer, boolean, boolean) RETURNS SETOF woinvav
    LANGUAGE plpgsql
    AS $_$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
   pwoid ALIAS FOR $1;
   plevel ALIAS FOR $2;
   pshowshortage ALIAS FOR $3;
   pshowlowinventory ALIAS FOR $4;
  _subrow woinvav%ROWTYPE;
  _subx RECORD;
  _qry TEXT;
BEGIN

   _qry := 'SELECT itemsite_id,
           womatl_id,
           item_type,
           wo_number,
           wo_subnumber,
           womatl_ref,
           womatl_notes,
           item_number,
           item_descrip1,
           item_descrip2,
           uom_name,
           qoh,
           wobalance,
           allocated,
           ordered,
           (qoh + ordered - wobalance) AS woavail,
           (qoh + ordered - allocated) AS totalavail,
           reorderlevel
    FROM(SELECT itemsite_id,
                womatl_id,
                item_type,
                wo_number,
                wo_subnumber,
                womatl_ref,
                womatl_notes,
                item_number,
                item_descrip1,
                item_descrip2,
                uom_name,
                noNeg(itemsite_qtyonhand) AS qoh,
                noNeg(itemuomtouom(itemsite_item_id, womatl_uom_id, NULL, womatl_qtyreq - womatl_qtyiss)) AS wobalance,
                qtyAllocated(itemsite_id, womatl_duedate) AS allocated,
                qtyOrdered(itemsite_id, womatl_duedate) AS ordered,
                CASE WHEN(itemsite_useparams) THEN itemsite_reorderlevel ELSE 0.0 END AS reorderlevel
    FROM womatl, wo, itemsite, item, uom
    WHERE ((wo_id = womatl_wo_id)
     AND (womatl_itemsite_id = itemsite_id)
     AND (itemsite_item_id=item_id)
     AND (womatl_uom_id=uom_id)
     AND (NOT womatl_createwo OR womatl_createwo IS NULL))';
     _qry := _qry || ' AND (wo_id=' || pwoid || ') ORDER BY item_number) AS data';
     IF(pshowshortage) THEN
     _qry := _qry || ' WHERE (((qoh + ordered - allocated) < 0) OR ((qoh + ordered - wobalance) < 0)) ';
     END IF;
     IF(pshowlowinventory AND NOT pshowshortage) THEN
     _qry := _qry || ' WHERE (((qoh - allocated) < 0) OR ((qoh - wobalance) < 0)) ';
     END IF;



  FOR _subx IN
      EXECUTE _qry
  LOOP
     _subrow.woinvav_itemsite_id := _subx.itemsite_id;
     _subrow.woinvav_womatl_id := _subx.womatl_id;
     _subrow.woinvav_type := _subx.item_type;
     _subrow.woinvav_item_wo_number := _subx.item_number;
     _subrow.woinvav_descrip := _subx.item_descrip1 || ' ' || _subx.item_descrip2;
     _subrow.woinvav_uomname := _subx.uom_name;
     _subrow.woinvav_qoh := _subx.qoh;
     _subrow.woinvav_balance := _subx.wobalance;
     _subrow.woinvav_allocated := _subx.allocated;
     _subrow.woinvav_ordered := _subx.ordered;
     _subrow.woinvav_woavail := _subx.woavail;
     _subrow.woinvav_totalavail := _subx.totalavail;
     _subrow.woinvav_reorderlevel := _subx.reorderlevel;
     _subrow.woinvav_level := plevel;
    RETURN NEXT _subrow;
  END LOOP;
  RETURN;
END;
$_$;


ALTER FUNCTION public.woinvavailmatl(integer, integer, boolean, boolean) OWNER TO admin;

--
-- TOC entry 2326 (class 1255 OID 146567197)
-- Dependencies: 4536 8
-- Name: wostarted(integer); Type: FUNCTION; Schema: public; Owner: admin
--

CREATE FUNCTION wostarted(pwoid integer) RETURNS boolean
    LANGUAGE plpgsql
    AS $$
-- Copyright (c) 1999-2014 by OpenMFG LLC, d/b/a xTuple.
-- See www.xtuple.com/CPAL for the full text of the software license.
DECLARE
  _result BOOLEAN := FALSE;

BEGIN
  -- is it really this simple?
  SELECT (wo_wipvalue > 0) INTO _result
    FROM wo
   WHERE wo_id=pWoid;

  RETURN COALESCE(_result, FALSE);
END;
$$;


ALTER FUNCTION public.wostarted(pwoid integer) OWNER TO admin;


SET search_path = public, pg_catalog;

--
-- TOC entry 4537 (class 1255 OID 146567211)
-- Dependencies: 1238 8
-- Name: concatagg(text); Type: AGGREGATE; Schema: public; Owner: admin
--

CREATE AGGREGATE concatagg(text) (
    SFUNC = concataggsfunc,
    STYPE = text,
    INITCOND = ''
);


ALTER AGGREGATE public.concatagg(text) OWNER TO admin;

--
-- TOC entry 4538 (class 1255 OID 146567212)
-- Dependencies: 1581 8
-- Name: first(anyelement); Type: AGGREGATE; Schema: public; Owner: admin
--

CREATE AGGREGATE first(anyelement) (
    SFUNC = first_agg,
    STYPE = anyelement
);


ALTER AGGREGATE public.first(anyelement) OWNER TO admin;

--
-- TOC entry 4539 (class 1255 OID 146567213)
-- Dependencies: 1903 8
-- Name: last(anyelement); Type: AGGREGATE; Schema: public; Owner: admin
--

CREATE AGGREGATE last(anyelement) (
    SFUNC = last_agg,
    STYPE = anyelement
);


ALTER AGGREGATE public.last(anyelement) OWNER TO admin;

--
-- TOC entry 234 (class 1259 OID 146567214)
-- Dependencies: 6046 6047 6048 6049 6050 6051 6052 6053 6054 6056 8
-- Name: addr; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE addr (
    addr_id integer NOT NULL,
    addr_active boolean DEFAULT true,
    addr_line1 text DEFAULT ''::text,
    addr_line2 text DEFAULT ''::text,
    addr_line3 text DEFAULT ''::text,
    addr_city text DEFAULT ''::text,
    addr_state text DEFAULT ''::text,
    addr_postalcode text DEFAULT ''::text,
    addr_country text DEFAULT ''::text,
    addr_notes text DEFAULT ''::text,
    addr_number text NOT NULL,
    CONSTRAINT addr_addr_number_check CHECK ((addr_number <> ''::text))
);


ALTER TABLE public.addr OWNER TO admin;

--
-- TOC entry 9081 (class 0 OID 0)
-- Dependencies: 234
-- Name: TABLE addr; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE addr IS 'Postal Address';


SET search_path = api, pg_catalog;

--
-- TOC entry 235 (class 1259 OID 146567230)
-- Dependencies: 8477 6
-- Name: account; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW account AS
    SELECT (c.crmacct_number)::character varying AS account_number, p.crmacct_number AS parent_account, c.crmacct_name AS account_name, c.crmacct_active AS active, CASE WHEN (c.crmacct_type = 'O'::bpchar) THEN 'Organization'::text ELSE 'Individual'::text END AS type, pc.cntct_number AS primary_contact_number, pc.cntct_honorific AS primary_contact_honorific, pc.cntct_first_name AS primary_contact_first, pc.cntct_middle AS primary_contact_middle, pc.cntct_last_name AS primary_contact_last, pc.cntct_suffix AS primary_contact_suffix, pc.cntct_title AS primary_contact_job_title, pc.cntct_phone AS primary_contact_voice, pc.cntct_fax AS primary_contact_fax, pc.cntct_email AS primary_contact_email, ''::text AS primary_contact_change, m.addr_number AS primary_contact_address_number, m.addr_line1 AS primary_contact_address1, m.addr_line2 AS primary_contact_address2, m.addr_line3 AS primary_contact_address3, m.addr_city AS primary_contact_city, m.addr_state AS primary_contact_state, m.addr_postalcode AS primary_contact_postalcode, m.addr_country AS primary_contact_country, ''::text AS primary_contact_address_change, sc.cntct_number AS secondary_contact_number, sc.cntct_honorific AS secondary_contact_honorific, sc.cntct_first_name AS secondary_contact_first, sc.cntct_middle AS secondary_contact_middle, sc.cntct_last_name AS secondary_contact_last, sc.cntct_suffix AS secondary_contact_suffix, sc.cntct_title AS secondary_contact_job_title, sc.cntct_phone AS secondary_contact_voice, sc.cntct_fax AS secondary_contact_fax, sc.cntct_email AS secondary_contact_email, sc.cntct_webaddr AS secondary_contact_web, ''::text AS secondary_contact_change, s.addr_number AS secondary_contact_address_number, s.addr_line1 AS secondary_contact_address1, s.addr_line2 AS secondary_contact_address2, s.addr_line3 AS secondary_contact_address3, s.addr_city AS secondary_contact_city, s.addr_state AS secondary_contact_state, s.addr_postalcode AS secondary_contact_postalcode, s.addr_country AS secondary_contact_country, ''::text AS secondary_contact_address_change, c.crmacct_notes AS notes FROM (((((public.crmacct c LEFT JOIN public.crmacct p ON ((c.crmacct_parent_id = p.crmacct_id))) LEFT JOIN public.cntct pc ON ((c.crmacct_cntct_id_1 = pc.cntct_id))) LEFT JOIN public.addr m ON ((pc.cntct_addr_id = m.addr_id))) LEFT JOIN public.cntct sc ON ((c.crmacct_cntct_id_2 = sc.cntct_id))) LEFT JOIN public.addr s ON ((sc.cntct_addr_id = s.addr_id)));


ALTER TABLE api.account OWNER TO admin;

--
-- TOC entry 9083 (class 0 OID 0)
-- Dependencies: 235
-- Name: VIEW account; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW account IS 'Account';


SET search_path = public, pg_catalog;

--
-- TOC entry 236 (class 1259 OID 146567235)
-- Dependencies: 6057 6058 6059 6060 6061 6062 6063 6064 6065 6066 6067 6068 6069 6071 8
-- Name: char; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE "char" (
    char_id integer NOT NULL,
    char_name text NOT NULL,
    char_items boolean,
    char_options boolean,
    char_attributes boolean,
    char_lotserial boolean,
    char_notes text,
    char_customers boolean,
    char_crmaccounts boolean,
    char_addresses boolean,
    char_contacts boolean,
    char_opportunity boolean,
    char_employees boolean DEFAULT false,
    char_mask text,
    char_validator text,
    char_incidents boolean DEFAULT false,
    char_type integer DEFAULT 0 NOT NULL,
    char_order integer DEFAULT 0 NOT NULL,
    char_search boolean DEFAULT true NOT NULL,
    char_quotes boolean DEFAULT false,
    char_salesorders boolean DEFAULT false,
    char_invoices boolean DEFAULT false,
    char_vendors boolean DEFAULT false,
    char_purchaseorders boolean DEFAULT false,
    char_vouchers boolean DEFAULT false,
    char_projects boolean DEFAULT false,
    char_tasks boolean DEFAULT false,
    CONSTRAINT char_char_name_check CHECK ((char_name <> ''::text))
);


ALTER TABLE public."char" OWNER TO admin;


--
-- TOC entry 237 (class 1259 OID 146567255)
-- Dependencies: 6073 6074 8
-- Name: charass; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE charass (
    charass_id integer NOT NULL,
    charass_target_type text,
    charass_target_id integer,
    charass_char_id integer,
    charass_value text,
    charass_default boolean DEFAULT false NOT NULL,
    charass_price numeric(16,4) DEFAULT 0 NOT NULL
);


ALTER TABLE public.charass OWNER TO admin;

--
-- TOC entry 9087 (class 0 OID 0)
-- Dependencies: 237
-- Name: TABLE charass; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE charass IS 'Characteristic assignment information';


SET search_path = api, pg_catalog;

--
-- TOC entry 238 (class 1259 OID 146567263)
-- Dependencies: 8478 6
-- Name: accountchar; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW accountchar AS
    SELECT (crmacct.crmacct_number)::character varying AS account_number, ("char".char_name)::character varying AS characteristic, charass.charass_value AS value FROM public.crmacct, public."char", public.charass WHERE ((('CRMACCT'::text = charass.charass_target_type) AND (crmacct.crmacct_id = charass.charass_target_id)) AND (charass.charass_char_id = "char".char_id));


ALTER TABLE api.accountchar OWNER TO admin;

--
-- TOC entry 9089 (class 0 OID 0)
-- Dependencies: 238
-- Name: VIEW accountchar; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW accountchar IS 'Account Characteristics';


SET search_path = public, pg_catalog;

--
-- TOC entry 239 (class 1259 OID 146567267)
-- Dependencies: 6076 6077 6078 8
-- Name: cmnttype; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE cmnttype (
    cmnttype_id integer NOT NULL,
    cmnttype_name text NOT NULL,
    cmnttype_descrip text NOT NULL,
    cmnttype_usedin text,
    cmnttype_sys boolean DEFAULT false NOT NULL,
    cmnttype_editable boolean DEFAULT false NOT NULL,
    cmnttype_order integer,
    CONSTRAINT cmnttype_cmnttype_name_check CHECK ((cmnttype_name <> ''::text))
);


ALTER TABLE public.cmnttype OWNER TO admin;

--
-- TOC entry 9091 (class 0 OID 0)
-- Dependencies: 239
-- Name: TABLE cmnttype; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE cmnttype IS 'Comment Type information';


--
-- TOC entry 240 (class 1259 OID 146567276)
-- Dependencies: 6079 8
-- Name: comment; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE comment (
    comment_id integer DEFAULT nextval(('"comment_comment_id_seq"'::text)::regclass) NOT NULL,
    comment_source_id integer,
    comment_date timestamp with time zone,
    comment_user text,
    comment_text text,
    comment_cmnttype_id integer,
    comment_source text,
    comment_public boolean
);


ALTER TABLE public.comment OWNER TO admin;

--
-- TOC entry 9093 (class 0 OID 0)
-- Dependencies: 240
-- Name: TABLE comment; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE comment IS 'Comment information';


SET search_path = api, pg_catalog;

--
-- TOC entry 241 (class 1259 OID 146567283)
-- Dependencies: 8479 6
-- Name: accountcomment; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW accountcomment AS
    SELECT (crmacct.crmacct_number)::character varying AS account_number, cmnttype.cmnttype_name AS type, comment.comment_date AS date, comment.comment_user AS username, comment.comment_text AS text FROM public.crmacct, public.cmnttype, public.comment WHERE (((comment.comment_source = 'CRMA'::text) AND (comment.comment_source_id = crmacct.crmacct_id)) AND (comment.comment_cmnttype_id = cmnttype.cmnttype_id));


ALTER TABLE api.accountcomment OWNER TO admin;

--
-- TOC entry 9095 (class 0 OID 0)
-- Dependencies: 241
-- Name: VIEW accountcomment; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW accountcomment IS 'Account Comment';


SET search_path = public, pg_catalog;

--
-- TOC entry 242 (class 1259 OID 146567287)
-- Dependencies: 6081 6082 6083 8
-- Name: docass; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE docass (
    docass_id integer NOT NULL,
    docass_source_id integer NOT NULL,
    docass_source_type text NOT NULL,
    docass_target_id integer NOT NULL,
    docass_target_type text DEFAULT 'URL'::text NOT NULL,
    docass_purpose character(1) DEFAULT 'S'::bpchar NOT NULL,
    CONSTRAINT docass_docass_purpose_check CHECK (((((((((docass_purpose = 'I'::bpchar) OR (docass_purpose = 'E'::bpchar)) OR (docass_purpose = 'M'::bpchar)) OR (docass_purpose = 'P'::bpchar)) OR (docass_purpose = 'A'::bpchar)) OR (docass_purpose = 'C'::bpchar)) OR (docass_purpose = 'S'::bpchar)) OR (docass_purpose = 'D'::bpchar)))
);


ALTER TABLE public.docass OWNER TO admin;


--
-- TOC entry 243 (class 1259 OID 146567296)
-- Dependencies: 8
-- Name: file; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE file (
    file_id integer NOT NULL,
    file_title text NOT NULL,
    file_stream bytea,
    file_descrip text NOT NULL
);


ALTER TABLE public.file OWNER TO admin;

--
-- TOC entry 244 (class 1259 OID 146567302)
-- Dependencies: 8
-- Name: urlinfo; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE urlinfo (
    url_id integer NOT NULL,
    url_title text NOT NULL,
    url_url text NOT NULL
);


ALTER TABLE public.urlinfo OWNER TO admin;

--
-- TOC entry 245 (class 1259 OID 146567308)
-- Dependencies: 8480 8
-- Name: url; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW url AS
    SELECT docass.docass_id AS url_id, docass.docass_source_id AS url_source_id, docass.docass_source_type AS url_source, file.file_title AS url_title, file.file_descrip AS url_url, file.file_stream AS url_stream FROM (file JOIN docass ON (((docass.docass_target_id = file.file_id) AND (docass.docass_target_type = 'FILE'::text)))) UNION ALL SELECT docass.docass_id AS url_id, docass.docass_source_id AS url_source_id, docass.docass_source_type AS url_source, urlinfo.url_title, urlinfo.url_url, NULL::bytea AS url_stream FROM (urlinfo JOIN docass ON (((docass.docass_target_id = urlinfo.url_id) AND (docass.docass_target_type = 'URL'::text))));


ALTER TABLE public.url OWNER TO admin;

SET search_path = api, pg_catalog;

--
-- TOC entry 246 (class 1259 OID 146567313)
-- Dependencies: 8481 6
-- Name: accountfile; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW accountfile AS
    SELECT crmacct.crmacct_number AS account_number, url.url_title AS title, url.url_url AS url FROM public.crmacct, public.url WHERE ((crmacct.crmacct_id = url.url_source_id) AND (url.url_source = 'CRMA'::text));


ALTER TABLE api.accountfile OWNER TO admin;

--
-- TOC entry 9102 (class 0 OID 0)
-- Dependencies: 246
-- Name: VIEW accountfile; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW accountfile IS 'Account File';


SET search_path = public, pg_catalog;

--
-- TOC entry 247 (class 1259 OID 146567317)
-- Dependencies: 242 8
-- Name: docass_docass_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE docass_docass_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.docass_docass_id_seq OWNER TO admin;

--
-- TOC entry 9104 (class 0 OID 0)
-- Dependencies: 247
-- Name: docass_docass_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE docass_docass_id_seq OWNED BY docass.docass_id;


--
-- TOC entry 248 (class 1259 OID 146567319)
-- Dependencies: 6086 8
-- Name: image; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE image (
    image_id integer DEFAULT nextval(('"image_image_id_seq"'::text)::regclass) NOT NULL,
    image_name text,
    image_descrip text,
    image_data text
);


ALTER TABLE public.image OWNER TO admin;

--
-- TOC entry 9106 (class 0 OID 0)
-- Dependencies: 248
-- Name: TABLE image; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE image IS 'Image information';


--
-- TOC entry 249 (class 1259 OID 146567326)
-- Dependencies: 6087 6088 8
-- Name: imageass; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE imageass (
    imageass_id integer DEFAULT nextval('docass_docass_id_seq'::regclass) NOT NULL,
    imageass_source_id integer NOT NULL,
    imageass_source text NOT NULL,
    imageass_image_id integer NOT NULL,
    imageass_purpose character(1) NOT NULL,
    CONSTRAINT imageass_imageass_purpose_check CHECK (((((((((imageass_purpose = 'I'::bpchar) OR (imageass_purpose = 'E'::bpchar)) OR (imageass_purpose = 'M'::bpchar)) OR (imageass_purpose = 'P'::bpchar)) OR (imageass_purpose = 'A'::bpchar)) OR (imageass_purpose = 'C'::bpchar)) OR (imageass_purpose = 'D'::bpchar)) OR (imageass_purpose = 'S'::bpchar)))
);


ALTER TABLE public.imageass OWNER TO admin;

--
-- TOC entry 9108 (class 0 OID 0)
-- Dependencies: 249
-- Name: TABLE imageass; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE imageass IS 'Image Assignement References';


SET search_path = api, pg_catalog;

--
-- TOC entry 250 (class 1259 OID 146567334)
-- Dependencies: 8482 6
-- Name: accountimage; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW accountimage AS
    SELECT crmacct.crmacct_number AS account_number, image.image_name FROM public.crmacct, public.imageass, public.image WHERE (((crmacct.crmacct_id = imageass.imageass_source_id) AND (imageass.imageass_source = 'CRMA'::text)) AND (imageass.imageass_image_id = image.image_id));


ALTER TABLE api.accountimage OWNER TO admin;

--
-- TOC entry 9110 (class 0 OID 0)
-- Dependencies: 250
-- Name: VIEW accountimage; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW accountimage IS 'Account Image';


--
-- TOC entry 251 (class 1259 OID 146567338)
-- Dependencies: 8483 6
-- Name: address; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW address AS
    SELECT (addr.addr_number)::character varying AS address_number, addr.addr_line1 AS address1, addr.addr_line2 AS address2, addr.addr_line3 AS address3, addr.addr_city AS city, addr.addr_state AS state, addr.addr_postalcode AS postal_code, addr.addr_country AS country, addr.addr_active AS active, addr.addr_notes AS notes, ''::text AS change FROM public.addr;


ALTER TABLE api.address OWNER TO admin;

--
-- TOC entry 9112 (class 0 OID 0)
-- Dependencies: 251
-- Name: VIEW address; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW address IS 'Address';


--
-- TOC entry 252 (class 1259 OID 146567342)
-- Dependencies: 8484 6
-- Name: addresschar; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW addresschar AS
    SELECT (addr.addr_number)::character varying AS address_number, ("char".char_name)::character varying AS characteristic, charass.charass_value AS value FROM public.addr, public."char", public.charass WHERE ((('ADDR'::text = charass.charass_target_type) AND (addr.addr_id = charass.charass_target_id)) AND (charass.charass_char_id = "char".char_id));


ALTER TABLE api.addresschar OWNER TO admin;

--
-- TOC entry 9114 (class 0 OID 0)
-- Dependencies: 252
-- Name: VIEW addresschar; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW addresschar IS 'Address Characteristics';


--
-- TOC entry 253 (class 1259 OID 146567346)
-- Dependencies: 8485 6
-- Name: addresscomment; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW addresscomment AS
    SELECT (addr.addr_number)::character varying AS address_number, cmnttype.cmnttype_name AS type, comment.comment_date AS date, comment.comment_user AS username, comment.comment_text AS text FROM public.addr, public.cmnttype, public.comment WHERE (((comment.comment_source = 'ADDR'::text) AND (comment.comment_source_id = addr.addr_id)) AND (comment.comment_cmnttype_id = cmnttype.cmnttype_id));


ALTER TABLE api.addresscomment OWNER TO admin;

--
-- TOC entry 9116 (class 0 OID 0)
-- Dependencies: 253
-- Name: VIEW addresscomment; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW addresscomment IS 'Address Comment';


SET search_path = public, pg_catalog;

--
-- TOC entry 254 (class 1259 OID 146567350)
-- Dependencies: 6089 6090 6091 8
-- Name: bomhead; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE bomhead (
    bomhead_id integer DEFAULT nextval(('"bomhead_bomhead_id_seq"'::text)::regclass) NOT NULL,
    bomhead_item_id integer NOT NULL,
    bomhead_serial integer,
    bomhead_docnum text,
    bomhead_revision text,
    bomhead_revisiondate date,
    bomhead_batchsize numeric(18,6),
    bomhead_requiredqtyper numeric(20,8),
    bomhead_rev_id integer DEFAULT (-1),
    CONSTRAINT bomhead_bomhead_batchsize_check CHECK ((bomhead_batchsize > (0)::numeric))
);


ALTER TABLE public.bomhead OWNER TO admin;


SET search_path = api, pg_catalog;

--
-- TOC entry 255 (class 1259 OID 146567359)
-- Dependencies: 8486 6
-- Name: bom; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW bom AS
    SELECT (item.item_number)::character varying AS item_number, (bomhead.bomhead_revision)::character varying AS revision, bomhead.bomhead_docnum AS document_number, bomhead.bomhead_revisiondate AS revision_date, bomhead.bomhead_batchsize AS batch_size, bomhead.bomhead_requiredqtyper AS total_qty_per FROM public.bomhead, public.item WHERE (bomhead.bomhead_item_id = item.item_id);


ALTER TABLE api.bom OWNER TO admin;

--
-- TOC entry 9120 (class 0 OID 0)
-- Dependencies: 255
-- Name: VIEW bom; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW bom IS 'Bill of Material Header';


--
-- TOC entry 256 (class 1259 OID 146567363)
-- Dependencies: 8487 6
-- Name: bomitem; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW bomitem AS
    SELECT bomitem.bomitem_id AS id, (p.item_number)::character varying AS bom_item_number, (bomhead.bomhead_revision)::character varying AS bom_revision, bomitem.bomitem_seqnumber AS sequence_number, i.item_number, CASE WHEN (bomitem.bomitem_effective = public.startoftime()) THEN 'Always'::text ELSE public.formatdate(bomitem.bomitem_effective) END AS effective, CASE WHEN (bomitem.bomitem_expires = public.endoftime()) THEN 'Never'::text ELSE public.formatdate(bomitem.bomitem_expires) END AS expires, bomitem.bomitem_qtyper AS qty_per, uom.uom_name AS issue_uom, bomitem.bomitem_scrap AS scrap, bomitem.bomitem_createwo AS create_child_wo, CASE WHEN (bomitem.bomitem_issuemethod = 'M'::bpchar) THEN 'Mixed'::text WHEN (bomitem.bomitem_issuemethod = 'L'::bpchar) THEN 'Pull'::text WHEN (bomitem.bomitem_issuemethod = 'S'::bpchar) THEN 'Push'::text ELSE NULL::text END AS issue_method, public.formatbooseq(p.item_id, bomitem.bomitem_booitem_seq_id) AS used_at, bomitem.bomitem_schedatwooper AS schedule_at_wo_operation, bomitem.bomitem_ecn AS ecn_number, bomitem.bomitem_notes AS notes, bomitem.bomitem_ref AS reference, CASE WHEN (bomitem.bomitem_subtype = 'N'::bpchar) THEN 'No'::text WHEN (bomitem.bomitem_subtype = 'I'::bpchar) THEN 'Item-Defined'::text WHEN (bomitem.bomitem_subtype = 'B'::bpchar) THEN 'BOM-Defined'::text ELSE NULL::text END AS substitutions, "char".char_name AS characteristic, bomitem.bomitem_value AS value FROM ((public.bomitem LEFT JOIN public.bomhead ON (((bomitem.bomitem_parent_item_id = bomhead.bomhead_item_id) AND (bomitem.bomitem_rev_id = bomhead.bomhead_rev_id)))) LEFT JOIN public."char" ON ((bomitem.bomitem_char_id = "char".char_id))), public.item p, public.item i, public.uom WHERE (((bomitem.bomitem_parent_item_id = p.item_id) AND (bomitem.bomitem_item_id = i.item_id)) AND (bomitem.bomitem_uom_id = uom.uom_id)) ORDER BY p.item_number, bomitem.bomitem_seqnumber;


ALTER TABLE api.bomitem OWNER TO admin;

--
-- TOC entry 9122 (class 0 OID 0)
-- Dependencies: 256
-- Name: VIEW bomitem; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW bomitem IS 'Bill of Material Item';


--
-- TOC entry 257 (class 1259 OID 146567368)
-- Dependencies: 8488 6
-- Name: bomitemcomment; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW bomitemcomment AS
    SELECT bomitem.bomitem_id, cmnttype.cmnttype_name AS type, comment.comment_date AS date, comment.comment_user AS username, comment.comment_text AS text FROM (public.bomitem LEFT JOIN public.bomhead ON (((bomitem.bomitem_parent_item_id = bomhead.bomhead_item_id) AND (bomitem.bomitem_rev_id = bomhead.bomhead_rev_id)))), public.item, public.cmnttype, public.comment WHERE ((((comment.comment_source = 'BMI'::text) AND (comment.comment_source_id = bomitem.bomitem_id)) AND (comment.comment_cmnttype_id = cmnttype.cmnttype_id)) AND (bomitem.bomitem_parent_item_id = item.item_id)) ORDER BY item.item_number, bomhead.bomhead_revision, bomitem.bomitem_seqnumber, comment.comment_date;


ALTER TABLE api.bomitemcomment OWNER TO admin;

--
-- TOC entry 9124 (class 0 OID 0)
-- Dependencies: 257
-- Name: VIEW bomitemcomment; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW bomitemcomment IS 'Bill of Material Comment';


SET search_path = public, pg_catalog;

--
-- TOC entry 258 (class 1259 OID 146567373)
-- Dependencies: 8
-- Name: bomitemsub; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE bomitemsub (
    bomitemsub_id integer NOT NULL,
    bomitemsub_bomitem_id integer NOT NULL,
    bomitemsub_item_id integer NOT NULL,
    bomitemsub_uomratio numeric(20,10) NOT NULL,
    bomitemsub_rank integer NOT NULL
);


ALTER TABLE public.bomitemsub OWNER TO admin;

--
-- TOC entry 9126 (class 0 OID 0)
-- Dependencies: 258
-- Name: TABLE bomitemsub; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE bomitemsub IS 'Bill of Materials (BOM) defined Substitutions information';


SET search_path = api, pg_catalog;

--
-- TOC entry 259 (class 1259 OID 146567376)
-- Dependencies: 8489 6
-- Name: bomitemsubstitute; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW bomitemsubstitute AS
    SELECT bomitem.bomitem_id, (p.item_number)::character varying AS bom_item_number, (bomhead.bomhead_revision)::character varying AS bom_revision, bomitem.bomitem_seqnumber AS sequence_number, (s.item_number)::character varying AS substitute_item_number, bomitemsub.bomitemsub_uomratio AS sub_parent_uom_ratio, bomitemsub.bomitemsub_rank AS ranking FROM public.item p, public.item s, (public.bomitem LEFT JOIN public.bomhead ON (((bomitem.bomitem_parent_item_id = bomhead.bomhead_item_id) AND (bomitem.bomitem_rev_id = bomhead.bomhead_rev_id)))), public.bomitemsub WHERE (((p.item_id = bomitem.bomitem_parent_item_id) AND (s.item_id = bomitemsub.bomitemsub_item_id)) AND (bomitemsub.bomitemsub_bomitem_id = bomitem.bomitem_id));


ALTER TABLE api.bomitemsubstitute OWNER TO admin;

--
-- TOC entry 9128 (class 0 OID 0)
-- Dependencies: 259
-- Name: VIEW bomitemsubstitute; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW bomitemsubstitute IS 'Bill of Material Item Substitute';


SET search_path = public, pg_catalog;

--
-- TOC entry 260 (class 1259 OID 146567381)
-- Dependencies: 6094 8
-- Name: budghead; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE budghead (
    budghead_id integer NOT NULL,
    budghead_name text NOT NULL,
    budghead_descrip text,
    CONSTRAINT budghead_budghead_name_check CHECK ((budghead_name <> ''::text))
);


ALTER TABLE public.budghead OWNER TO admin;

SET search_path = api, pg_catalog;

--
-- TOC entry 261 (class 1259 OID 146567388)
-- Dependencies: 8490 6
-- Name: budget; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW budget AS
    SELECT budghead.budghead_name AS name, budghead.budghead_descrip AS description FROM public.budghead ORDER BY budghead.budghead_name;


ALTER TABLE api.budget OWNER TO admin;

--
-- TOC entry 9131 (class 0 OID 0)
-- Dependencies: 261
-- Name: VIEW budget; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW budget IS 'Budget Header';


SET search_path = public, pg_catalog;

--
-- TOC entry 262 (class 1259 OID 146567392)
-- Dependencies: 6095 6096 6097 6098 8
-- Name: accnt; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE accnt (
    accnt_id integer DEFAULT nextval(('accnt_accnt_id_seq'::text)::regclass) NOT NULL,
    accnt_number text,
    accnt_descrip text,
    accnt_comments text,
    accnt_profit text,
    accnt_sub text,
    accnt_type character(1) NOT NULL,
    accnt_extref text,
    accnt_company text,
    accnt_forwardupdate boolean,
    accnt_subaccnttype_code text,
    accnt_curr_id integer DEFAULT basecurrid(),
    accnt_active boolean DEFAULT true NOT NULL,
    accnt_name text,
    CONSTRAINT accnt_accnt_type_check CHECK ((accnt_type = ANY (ARRAY['A'::bpchar, 'E'::bpchar, 'L'::bpchar, 'Q'::bpchar, 'R'::bpchar])))
);


ALTER TABLE public.accnt OWNER TO admin;


--
-- TOC entry 263 (class 1259 OID 146567402)
-- Dependencies: 8
-- Name: budgitem; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE budgitem (
    budgitem_id integer NOT NULL,
    budgitem_budghead_id integer NOT NULL,
    budgitem_period_id integer NOT NULL,
    budgitem_accnt_id integer NOT NULL,
    budgitem_amount numeric(20,4) NOT NULL
);


ALTER TABLE public.budgitem OWNER TO admin;

--
-- TOC entry 264 (class 1259 OID 146567405)
-- Dependencies: 6101 8
-- Name: period; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE period (
    period_id integer NOT NULL,
    period_start date,
    period_end date,
    period_closed boolean,
    period_freeze boolean,
    period_initial boolean DEFAULT false,
    period_name text,
    period_yearperiod_id integer,
    period_quarter integer,
    period_number integer NOT NULL
);


ALTER TABLE public.period OWNER TO admin;

--
-- TOC entry 9136 (class 0 OID 0)
-- Dependencies: 264
-- Name: TABLE period; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE period IS 'Accounting Period information';


SET search_path = api, pg_catalog;

--
-- TOC entry 265 (class 1259 OID 146567412)
-- Dependencies: 8491 6
-- Name: budgetentry; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW budgetentry AS
    SELECT budghead.budghead_name AS name, public.formatglaccount(accnt.accnt_id) AS account, period.period_start, budgitem.budgitem_amount AS amount FROM public.budgitem, public.budghead, public.period, public.accnt WHERE (((budgitem.budgitem_budghead_id = budghead.budghead_id) AND (budgitem.budgitem_period_id = period.period_id)) AND (budgitem.budgitem_accnt_id = accnt.accnt_id)) ORDER BY budghead.budghead_name, period.period_start, public.formatglaccount(accnt.accnt_id);


ALTER TABLE api.budgetentry OWNER TO admin;

--
-- TOC entry 9138 (class 0 OID 0)
-- Dependencies: 265
-- Name: VIEW budgetentry; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW budgetentry IS 'Budget Entry';


SET search_path = public, pg_catalog;

--
-- TOC entry 266 (class 1259 OID 146567416)
-- Dependencies: 6102 6103 6104 6105 6106 6108 8
-- Name: bankaccnt; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE bankaccnt (
    bankaccnt_id integer NOT NULL,
    bankaccnt_name text NOT NULL,
    bankaccnt_descrip text,
    bankaccnt_bankname text,
    bankaccnt_accntnumber text,
    bankaccnt_ar boolean,
    bankaccnt_ap boolean,
    bankaccnt_nextchknum integer,
    bankaccnt_type character(1),
    bankaccnt_accnt_id integer,
    bankaccnt_check_form_id integer,
    bankaccnt_userec boolean,
    bankaccnt_rec_accnt_id integer,
    bankaccnt_curr_id integer DEFAULT basecurrid(),
    bankaccnt_notes text,
    bankaccnt_routing text DEFAULT ''::text NOT NULL,
    bankaccnt_ach_enabled boolean DEFAULT false NOT NULL,
    bankaccnt_ach_origin text DEFAULT ''::text NOT NULL,
    bankaccnt_ach_genchecknum boolean DEFAULT false NOT NULL,
    bankaccnt_ach_leadtime integer,
    bankaccnt_ach_lastdate date,
    bankaccnt_ach_lastfileid character(1),
    bankaccnt_ach_origintype text,
    bankaccnt_ach_originname text,
    bankaccnt_ach_desttype text,
    bankaccnt_ach_fed_dest text,
    bankaccnt_ach_destname text,
    bankaccnt_ach_dest text,
    CONSTRAINT bankaccnt_bankaccnt_name_check CHECK ((bankaccnt_name <> ''::text))
);


ALTER TABLE public.bankaccnt OWNER TO admin;


--
-- TOC entry 267 (class 1259 OID 146567428)
-- Dependencies: 6109 6110 6111 6112 6113 6114 6115 6117 8
-- Name: cashrcpt; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE cashrcpt (
    cashrcpt_id integer NOT NULL,
    cashrcpt_cust_id integer NOT NULL,
    cashrcpt_amount numeric(20,2) NOT NULL,
    cashrcpt_fundstype character(1) NOT NULL,
    cashrcpt_docnumber text,
    cashrcpt_bankaccnt_id integer NOT NULL,
    cashrcpt_notes text,
    cashrcpt_distdate date DEFAULT ('now'::text)::date,
    cashrcpt_salescat_id integer DEFAULT (-1),
    cashrcpt_curr_id integer DEFAULT basecurrid(),
    cashrcpt_usecustdeposit boolean DEFAULT false NOT NULL,
    cashrcpt_void boolean DEFAULT false NOT NULL,
    cashrcpt_number text NOT NULL,
    cashrcpt_docdate date,
    cashrcpt_posted boolean DEFAULT false NOT NULL,
    cashrcpt_posteddate date,
    cashrcpt_postedby text,
    cashrcpt_applydate date,
    cashrcpt_discount numeric(20,2) DEFAULT 0.00 NOT NULL,
    cashrcpt_curr_rate numeric NOT NULL,
    CONSTRAINT cashrcpt_cashrcpt_number_check CHECK ((cashrcpt_number <> ''::text))
);


ALTER TABLE public.cashrcpt OWNER TO admin;


SET search_path = api, pg_catalog;

--
-- TOC entry 268 (class 1259 OID 146567442)
-- Dependencies: 8492 6
-- Name: cashreceipt; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW cashreceipt AS
    SELECT (custinfo.cust_number)::character varying AS customer_number, cashrcpt.cashrcpt_number AS cashreceipt_number, CASE WHEN (cashrcpt.cashrcpt_fundstype = 'C'::bpchar) THEN 'Check'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'T'::bpchar) THEN 'Certified Check'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'M'::bpchar) THEN 'Master Card'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'V'::bpchar) THEN 'Visa'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'A'::bpchar) THEN 'American Express'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'D'::bpchar) THEN 'Discover Card'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'R'::bpchar) THEN 'Other Credit Card'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'K'::bpchar) THEN 'Cash'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'W'::bpchar) THEN 'Wire Transfer'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'O'::bpchar) THEN 'Other'::character varying ELSE NULL::character varying END AS funds_type, (cashrcpt.cashrcpt_docnumber)::character varying AS check_document_number, custinfo.cust_name AS customer_name, m.addr_line1 AS customer_address, curr_symbol.curr_abbr AS currency, cashrcpt.cashrcpt_amount AS amount_received, bankaccnt.bankaccnt_name AS post_to, public.formatdate(cashrcpt.cashrcpt_distdate) AS distribution_date, CASE WHEN cashrcpt.cashrcpt_usecustdeposit THEN 'Customer Deposit'::text ELSE 'Credit Memo'::text END AS apply_balance_as, salescat.salescat_name AS sales_category, cashrcpt.cashrcpt_notes AS notes FROM ((((((public.cashrcpt LEFT JOIN public.custinfo ON ((custinfo.cust_id = cashrcpt.cashrcpt_cust_id))) LEFT JOIN public.cntct mc ON ((custinfo.cust_cntct_id = mc.cntct_id))) LEFT JOIN public.addr m ON ((mc.cntct_addr_id = m.addr_id))) LEFT JOIN public.curr_symbol ON ((curr_symbol.curr_id = cashrcpt.cashrcpt_curr_id))) LEFT JOIN public.bankaccnt ON ((bankaccnt.bankaccnt_id = cashrcpt.cashrcpt_bankaccnt_id))) LEFT JOIN public.salescat ON ((salescat.salescat_id = cashrcpt.cashrcpt_salescat_id)));


ALTER TABLE api.cashreceipt OWNER TO admin;

--
-- TOC entry 9144 (class 0 OID 0)
-- Dependencies: 268
-- Name: VIEW cashreceipt; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW cashreceipt IS '
This view can be used as an interface to import Cash Receipt data directly
into the system.  Required fields will be checked and default values will be
populated';


SET search_path = public, pg_catalog;

--
-- TOC entry 269 (class 1259 OID 146567447)
-- Dependencies: 6119 6120 8
-- Name: cashrcptitem; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE cashrcptitem (
    cashrcptitem_id integer NOT NULL,
    cashrcptitem_cashrcpt_id integer NOT NULL,
    cashrcptitem_aropen_id integer NOT NULL,
    cashrcptitem_amount numeric(20,2) NOT NULL,
    cashrcptitem_discount numeric(20,2) DEFAULT 0.00 NOT NULL,
    cashrcptitem_applied boolean DEFAULT true
);


ALTER TABLE public.cashrcptitem OWNER TO admin;


SET search_path = api, pg_catalog;

--
-- TOC entry 270 (class 1259 OID 146567452)
-- Dependencies: 8493 6
-- Name: cashreceiptapply; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW cashreceiptapply AS
    SELECT (custinfo.cust_number)::character varying AS customer_number, CASE WHEN (cashrcpt.cashrcpt_fundstype = 'C'::bpchar) THEN 'Check'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'T'::bpchar) THEN 'Certified Check'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'M'::bpchar) THEN 'Master Card'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'V'::bpchar) THEN 'Visa'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'A'::bpchar) THEN 'American Express'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'D'::bpchar) THEN 'Discover Card'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'R'::bpchar) THEN 'Other Credit Card'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'K'::bpchar) THEN 'Cash'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'W'::bpchar) THEN 'Wire Transfer'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'O'::bpchar) THEN 'Other'::character varying ELSE NULL::character varying END AS funds_type, (cashrcpt.cashrcpt_docnumber)::character varying AS check_document_number, (aropen.aropen_doctype)::character varying AS doc_type, (aropen.aropen_docnumber)::character varying AS doc_number, custinfo.cust_name AS customer_name, m.addr_line1 AS customer_address, public.formatdate(aropen.aropen_docdate) AS doc_date, public.formatdate(aropen.aropen_duedate) AS due_date, curr_symbol.curr_abbr AS currency, aropen.aropen_amount AS open_amount, cashrcptitem.cashrcptitem_amount AS amount_to_apply, cashrcptitem.cashrcptitem_discount FROM ((((((public.cashrcptitem LEFT JOIN public.cashrcpt ON ((cashrcpt.cashrcpt_id = cashrcptitem.cashrcptitem_cashrcpt_id))) LEFT JOIN public.custinfo ON ((custinfo.cust_id = cashrcpt.cashrcpt_cust_id))) LEFT JOIN public.cntct mc ON ((custinfo.cust_cntct_id = mc.cntct_id))) LEFT JOIN public.addr m ON ((mc.cntct_addr_id = m.addr_id))) LEFT JOIN public.curr_symbol ON ((curr_symbol.curr_id = cashrcpt.cashrcpt_curr_id))) LEFT JOIN public.aropen ON ((aropen.aropen_id = cashrcptitem.cashrcptitem_aropen_id)));


ALTER TABLE api.cashreceiptapply OWNER TO admin;

--
-- TOC entry 9148 (class 0 OID 0)
-- Dependencies: 270
-- Name: VIEW cashreceiptapply; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW cashreceiptapply IS '
This view can be used as an interface to import Cash Receipt Application data directly
into the system.  Required fields will be checked and default values will be
populated';


SET search_path = public, pg_catalog;

--
-- TOC entry 271 (class 1259 OID 146567457)
-- Dependencies: 8
-- Name: cashrcptmisc; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE cashrcptmisc (
    cashrcptmisc_id integer NOT NULL,
    cashrcptmisc_cashrcpt_id integer NOT NULL,
    cashrcptmisc_accnt_id integer NOT NULL,
    cashrcptmisc_amount numeric(20,2) NOT NULL,
    cashrcptmisc_notes text
);


ALTER TABLE public.cashrcptmisc OWNER TO admin;


SET search_path = api, pg_catalog;

--
-- TOC entry 272 (class 1259 OID 146567463)
-- Dependencies: 8494 6
-- Name: cashreceiptapplymisc; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW cashreceiptapplymisc AS
    SELECT (custinfo.cust_number)::character varying AS customer_number, CASE WHEN (cashrcpt.cashrcpt_fundstype = 'C'::bpchar) THEN 'Check'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'T'::bpchar) THEN 'Certified Check'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'M'::bpchar) THEN 'Master Card'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'V'::bpchar) THEN 'Visa'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'A'::bpchar) THEN 'American Express'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'D'::bpchar) THEN 'Discover Card'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'R'::bpchar) THEN 'Other Credit Card'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'K'::bpchar) THEN 'Cash'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'W'::bpchar) THEN 'Wire Transfer'::character varying WHEN (cashrcpt.cashrcpt_fundstype = 'O'::bpchar) THEN 'Other'::character varying ELSE NULL::character varying END AS funds_type, (cashrcpt.cashrcpt_docnumber)::character varying AS check_document_number, (public.formatglaccount(accnt.accnt_id))::character varying AS account, custinfo.cust_name AS customer_name, m.addr_line1 AS customer_address, accnt.accnt_descrip AS account_description, curr_symbol.curr_abbr AS currency, cashrcptmisc.cashrcptmisc_amount AS amount_to_distribute, cashrcptmisc.cashrcptmisc_notes AS notes FROM ((((((public.cashrcptmisc LEFT JOIN public.cashrcpt ON ((cashrcpt.cashrcpt_id = cashrcptmisc.cashrcptmisc_cashrcpt_id))) LEFT JOIN public.custinfo ON ((custinfo.cust_id = cashrcpt.cashrcpt_cust_id))) LEFT JOIN public.cntct mc ON ((custinfo.cust_cntct_id = mc.cntct_id))) LEFT JOIN public.addr m ON ((mc.cntct_addr_id = m.addr_id))) LEFT JOIN public.curr_symbol ON ((curr_symbol.curr_id = cashrcpt.cashrcpt_curr_id))) LEFT JOIN public.accnt ON ((accnt.accnt_id = cashrcptmisc.cashrcptmisc_accnt_id)));


ALTER TABLE api.cashreceiptapplymisc OWNER TO admin;

--
-- TOC entry 9152 (class 0 OID 0)
-- Dependencies: 272
-- Name: VIEW cashreceiptapplymisc; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW cashreceiptapplymisc IS '
This view can be used as an interface to import Cash Receipt Miscellaneous Application
data directly into the system.  Required fields will be checked and default values
will be populated';


--
-- TOC entry 273 (class 1259 OID 146567468)
-- Dependencies: 8495 6
-- Name: contact; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW contact AS
    SELECT (cntct.cntct_number)::character varying AS contact_number, cntct.cntct_honorific AS honorific, cntct.cntct_first_name AS first, cntct.cntct_middle AS middle, cntct.cntct_last_name AS last, cntct.cntct_suffix AS suffix, cntct.cntct_initials AS initials, crmacct.crmacct_number AS crm_account, cntct.cntct_active AS active, cntct.cntct_title AS job_title, cntct.cntct_phone AS voice, cntct.cntct_phone2 AS alternate, cntct.cntct_fax AS fax, cntct.cntct_email AS email, cntct.cntct_webaddr AS web, ''::text AS contact_change, addr.addr_number AS address_number, addr.addr_line1 AS address1, addr.addr_line2 AS address2, addr.addr_line3 AS address3, addr.addr_city AS city, addr.addr_state AS state, addr.addr_postalcode AS postal_code, addr.addr_country AS country, cntct.cntct_notes AS notes, ''::text AS address_change FROM ((public.cntct LEFT JOIN public.addr ON ((cntct.cntct_addr_id = addr.addr_id))) LEFT JOIN public.crmacct ON ((cntct.cntct_crmacct_id = crmacct.crmacct_id)));


ALTER TABLE api.contact OWNER TO admin;

--
-- TOC entry 9154 (class 0 OID 0)
-- Dependencies: 273
-- Name: VIEW contact; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW contact IS 'Contact';


--
-- TOC entry 274 (class 1259 OID 146567473)
-- Dependencies: 8496 6
-- Name: contactchar; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW contactchar AS
    SELECT cntct.cntct_number AS contact_number, ("char".char_name)::character varying AS characteristic, charass.charass_value AS value FROM public.cntct, public."char", public.charass WHERE ((('CNTCT'::text = charass.charass_target_type) AND (cntct.cntct_id = charass.charass_target_id)) AND (charass.charass_char_id = "char".char_id));


ALTER TABLE api.contactchar OWNER TO admin;

--
-- TOC entry 9156 (class 0 OID 0)
-- Dependencies: 274
-- Name: VIEW contactchar; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW contactchar IS 'Contact Characteristics';


--
-- TOC entry 275 (class 1259 OID 146567477)
-- Dependencies: 8497 6
-- Name: contactcomment; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW contactcomment AS
    SELECT cntct.cntct_number AS contact_number, cmnttype.cmnttype_name AS type, comment.comment_date AS date, comment.comment_user AS username, comment.comment_text AS text FROM public.cntct, public.cmnttype, public.comment WHERE (((comment.comment_source = 'T'::text) AND (comment.comment_source_id = cntct.cntct_id)) AND (comment.comment_cmnttype_id = cmnttype.cmnttype_id));


ALTER TABLE api.contactcomment OWNER TO admin;

--
-- TOC entry 9158 (class 0 OID 0)
-- Dependencies: 275
-- Name: VIEW contactcomment; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW contactcomment IS 'Contact Comment';


--
-- TOC entry 276 (class 1259 OID 146567481)
-- Dependencies: 8498 6
-- Name: custchar; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW custchar AS
    SELECT (custinfo.cust_number)::character varying AS customer_number, ("char".char_name)::character varying AS characteristic, charass.charass_value AS value FROM public.custinfo, public."char", public.charass WHERE ((('C'::text = charass.charass_target_type) AND (custinfo.cust_id = charass.charass_target_id)) AND (charass.charass_char_id = "char".char_id));


ALTER TABLE api.custchar OWNER TO admin;

--
-- TOC entry 9160 (class 0 OID 0)
-- Dependencies: 276
-- Name: VIEW custchar; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW custchar IS 'Customer Characteristics';


--
-- TOC entry 277 (class 1259 OID 146567486)
-- Dependencies: 8499 6
-- Name: custcomment; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW custcomment AS
    SELECT (custinfo.cust_number)::character varying AS customer_number, cmnttype.cmnttype_name AS type, comment.comment_date AS date, comment.comment_user AS username, comment.comment_text AS text FROM public.custinfo, public.cmnttype, public.comment WHERE (((comment.comment_source = 'C'::text) AND (comment.comment_source_id = custinfo.cust_id)) AND (comment.comment_cmnttype_id = cmnttype.cmnttype_id));


ALTER TABLE api.custcomment OWNER TO admin;

--
-- TOC entry 9162 (class 0 OID 0)
-- Dependencies: 277
-- Name: VIEW custcomment; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW custcomment IS 'Customer Comment';


SET search_path = public, pg_catalog;

--
-- TOC entry 278 (class 1259 OID 146567491)
-- Dependencies: 6122 6123 6124 6125 6126 6127 6128 8
-- Name: ccard; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE ccard (
    ccard_id integer NOT NULL,
    ccard_seq integer DEFAULT 10 NOT NULL,
    ccard_cust_id integer NOT NULL,
    ccard_active boolean DEFAULT true,
    ccard_name bytea,
    ccard_address1 bytea,
    ccard_address2 bytea,
    ccard_city bytea,
    ccard_state bytea,
    ccard_zip bytea,
    ccard_country bytea,
    ccard_number bytea,
    ccard_debit boolean DEFAULT false,
    ccard_month_expired bytea,
    ccard_year_expired bytea,
    ccard_type character(1) NOT NULL,
    ccard_date_added timestamp without time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL,
    ccard_lastupdated timestamp without time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL,
    ccard_added_by_username text DEFAULT geteffectivextuser() NOT NULL,
    ccard_last_updated_by_username text DEFAULT geteffectivextuser() NOT NULL
);


ALTER TABLE public.ccard OWNER TO admin;

--
-- TOC entry 9164 (class 0 OID 0)
-- Dependencies: 278
-- Name: TABLE ccard; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE ccard IS 'Credit Card Information - all bytea data is encrypted';


SET search_path = api, pg_catalog;

--
-- TOC entry 279 (class 1259 OID 146567504)
-- Dependencies: 8500 6
-- Name: custcreditcard; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW custcreditcard AS
    SELECT (custinfo.cust_number)::character varying AS customer_number, CASE WHEN (ccard.ccard_type = 'V'::bpchar) THEN 'Visa'::text WHEN (ccard.ccard_type = 'M'::bpchar) THEN 'Master Card'::text WHEN (ccard.ccard_type = 'A'::bpchar) THEN 'American Express'::text WHEN (ccard.ccard_type = 'D'::bpchar) THEN 'Discover'::text ELSE 'Not Supported'::text END AS credit_card_type, ccard.ccard_active AS active, ccard.ccard_number AS credit_card_number, ccard.ccard_name AS name, ccard.ccard_address1 AS street_address1, ccard.ccard_address2 AS street_address2, ccard.ccard_city AS city, ccard.ccard_state AS state, ccard.ccard_zip AS postal_code, ccard.ccard_country AS country, ccard.ccard_month_expired AS expiration_month, ccard.ccard_year_expired AS expiration_year, ''::text AS key FROM public.ccard, public.custinfo WHERE (ccard.ccard_cust_id = custinfo.cust_id);


ALTER TABLE api.custcreditcard OWNER TO admin;

--
-- TOC entry 9166 (class 0 OID 0)
-- Dependencies: 279
-- Name: VIEW custcreditcard; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW custcreditcard IS 'Customer Credit Cards.';


SET search_path = public, pg_catalog;

--
-- TOC entry 280 (class 1259 OID 146567509)
-- Dependencies: 6130 6131 6132 8
-- Name: custtype; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE custtype (
    custtype_id integer DEFAULT nextval(('custtype_custtype_id_seq'::text)::regclass) NOT NULL,
    custtype_code text NOT NULL,
    custtype_descrip text NOT NULL,
    custtype_char boolean DEFAULT false NOT NULL,
    CONSTRAINT custtype_custtype_code_check CHECK ((custtype_code <> ''::text))
);


ALTER TABLE public.custtype OWNER TO admin;

--
-- TOC entry 9168 (class 0 OID 0)
-- Dependencies: 280
-- Name: TABLE custtype; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE custtype IS 'Customer Type information';


--
-- TOC entry 281 (class 1259 OID 146567518)
-- Dependencies: 6134 8
-- Name: shipchrg; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE shipchrg (
    shipchrg_id integer NOT NULL,
    shipchrg_name text NOT NULL,
    shipchrg_descrip text,
    shipchrg_custfreight boolean,
    shipchrg_handling character(1),
    CONSTRAINT shipchrg_shipchrg_name_check CHECK ((shipchrg_name <> ''::text))
);


ALTER TABLE public.shipchrg OWNER TO admin;

--
-- TOC entry 9170 (class 0 OID 0)
-- Dependencies: 281
-- Name: TABLE shipchrg; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE shipchrg IS 'Shipping Charge information';


--
-- TOC entry 282 (class 1259 OID 146567525)
-- Dependencies: 6135 6136 8
-- Name: shipform; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE shipform (
    shipform_id integer DEFAULT nextval(('"shipform_shipform_id_seq"'::text)::regclass) NOT NULL,
    shipform_name text NOT NULL,
    shipform_report_id integer,
    shipform_report_name text,
    CONSTRAINT shipform_shipform_name_check CHECK ((shipform_name <> ''::text))
);


ALTER TABLE public.shipform OWNER TO admin;

--
-- TOC entry 9172 (class 0 OID 0)
-- Dependencies: 282
-- Name: TABLE shipform; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE shipform IS 'Shipping Form information';


--
-- TOC entry 9173 (class 0 OID 0)
-- Dependencies: 282
-- Name: COLUMN shipform.shipform_report_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN shipform.shipform_report_id IS 'Obsolete -- reference shipform_report_name instead.';


SET search_path = api, pg_catalog;

--
-- TOC entry 283 (class 1259 OID 146567534)
-- Dependencies: 8501 6
-- Name: customer; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW customer AS
    SELECT (custinfo.cust_number)::character varying AS customer_number, custtype.custtype_code AS customer_type, custinfo.cust_name AS customer_name, custinfo.cust_active AS active, salesrep.salesrep_number AS sales_rep, (custinfo.cust_commprcnt * (100)::numeric) AS commission, custinfo.cust_shipvia AS ship_via, shipform.shipform_name AS ship_form, shipchrg.shipchrg_name AS shipping_charges, custinfo.cust_backorder AS accepts_backorders, custinfo.cust_partialship AS accepts_partial_shipments, custinfo.cust_ffshipto AS allow_free_form_shipto, custinfo.cust_ffbillto AS allow_free_form_billto, whsinfo.warehous_code AS preferred_selling_site, taxzone.taxzone_code AS default_tax_zone, terms.terms_code AS default_terms, CASE WHEN (custinfo.cust_balmethod = 'B'::bpchar) THEN 'Balance Forward'::text ELSE 'Open Item'::text END AS balance_method, custinfo.cust_discntprcnt AS default_discount, dc.curr_abbr AS default_currency, clc.curr_abbr AS credit_limit_currency, custinfo.cust_creditlmt AS credit_limit, CASE WHEN (COALESCE(custinfo.cust_gracedays, 0) > 0) THEN custinfo.cust_gracedays ELSE NULL::integer END AS alternate_grace_days, custinfo.cust_creditrating AS credit_rating, CASE WHEN (custinfo.cust_creditstatus = 'G'::bpchar) THEN 'In Good Standing'::text WHEN (custinfo.cust_creditstatus = 'W'::bpchar) THEN 'On Credit Warning'::text ELSE 'On Credit Hold'::text END AS credit_status, custinfo.cust_autoupdatestatus AS credit_status_exceed_warn, custinfo.cust_autoholdorders AS credit_status_exceed_hold, custinfo.cust_usespos AS uses_purchase_orders, custinfo.cust_blanketpos AS uses_blanket_pos, mc.cntct_number AS billing_contact_number, mc.cntct_honorific AS billing_contact_honorific, mc.cntct_first_name AS billing_contact_first, mc.cntct_middle AS billing_contact_middle, mc.cntct_last_name AS billing_contact_last, mc.cntct_suffix AS billing_contact_suffix, mc.cntct_title AS billing_contact_job_title, mc.cntct_phone AS billing_contact_voice, mc.cntct_phone2 AS billing_contact_alternate, mc.cntct_fax AS billing_contact_fax, mc.cntct_email AS billing_contact_email, mc.cntct_webaddr AS billing_contact_web, ''::text AS billing_contact_change, m.addr_number AS billing_contact_address_number, m.addr_line1 AS billing_contact_address1, m.addr_line2 AS billing_contact_address2, m.addr_line3 AS billing_contact_address3, m.addr_city AS billing_contact_city, m.addr_state AS billing_contact_state, m.addr_postalcode AS billing_contact_postalcode, m.addr_country AS billing_contact_country, ''::text AS billing_contact_address_change, cc.cntct_number AS correspond_contact_number, cc.cntct_honorific AS correspond_contact_honorific, cc.cntct_first_name AS correspond_contact_first, cc.cntct_middle AS correspond_contact_middle, cc.cntct_last_name AS correspond_contact_last, cc.cntct_suffix AS correspond_contact_suffix, cc.cntct_title AS correspond_contact_job_title, cc.cntct_phone AS correspond_contact_voice, cc.cntct_phone2 AS correspond_contact_alternate, cc.cntct_fax AS correspond_contact_fax, cc.cntct_email AS correspond_contact_email, cc.cntct_webaddr AS correspond_contact_web, ''::text AS correspond_contact_change, c.addr_number AS correspond_contact_address_number, c.addr_line1 AS correspond_contact_address1, c.addr_line2 AS correspond_contact_address2, c.addr_line3 AS correspond_contact_address3, c.addr_city AS correspond_contact_city, c.addr_state AS correspond_contact_state, c.addr_postalcode AS correspond_contact_postalcode, c.addr_country AS correspond_contact_country, ''::text AS correspond_contact_address_change, custinfo.cust_comments AS notes FROM ((((((((public.custinfo LEFT JOIN public.shipchrg ON ((custinfo.cust_shipchrg_id = shipchrg.shipchrg_id))) LEFT JOIN public.whsinfo ON ((custinfo.cust_preferred_warehous_id = whsinfo.warehous_id))) LEFT JOIN public.cntct mc ON ((custinfo.cust_cntct_id = mc.cntct_id))) LEFT JOIN public.addr m ON ((mc.cntct_addr_id = m.addr_id))) LEFT JOIN public.cntct cc ON ((custinfo.cust_corrcntct_id = cc.cntct_id))) LEFT JOIN public.addr c ON ((cc.cntct_addr_id = c.addr_id))) LEFT JOIN public.taxzone ON ((custinfo.cust_taxzone_id = taxzone.taxzone_id))) LEFT JOIN public.shipform ON ((custinfo.cust_shipform_id = shipform.shipform_id))), public.custtype, public.salesrep, public.curr_symbol dc, public.curr_symbol clc, public.terms WHERE (((((custinfo.cust_custtype_id = custtype.custtype_id) AND (custinfo.cust_salesrep_id = salesrep.salesrep_id)) AND (custinfo.cust_curr_id = dc.curr_id)) AND (custinfo.cust_creditlmt_curr_id = clc.curr_id)) AND (custinfo.cust_terms_id = terms.terms_id));


ALTER TABLE api.customer OWNER TO admin;

--
-- TOC entry 9175 (class 0 OID 0)
-- Dependencies: 283
-- Name: VIEW customer; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW customer IS 'Customer';


SET search_path = public, pg_catalog;

--
-- TOC entry 284 (class 1259 OID 146567539)
-- Dependencies: 6138 8
-- Name: taxauth; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE taxauth (
    taxauth_id integer NOT NULL,
    taxauth_code text NOT NULL,
    taxauth_name text,
    taxauth_extref text,
    taxauth_addr_id integer,
    taxauth_curr_id integer,
    taxauth_county text,
    taxauth_accnt_id integer,
    CONSTRAINT taxauth_taxauth_code_check CHECK ((taxauth_code <> ''::text))
);


ALTER TABLE public.taxauth OWNER TO admin;


--
-- TOC entry 285 (class 1259 OID 146567549)
-- Dependencies: 6139 6140 6141 6143 8
-- Name: taxreg; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE taxreg (
    taxreg_id integer NOT NULL,
    taxreg_rel_id integer NOT NULL,
    taxreg_rel_type character(1),
    taxreg_taxauth_id integer,
    taxreg_number text NOT NULL,
    taxreg_taxzone_id integer,
    taxreg_effective date DEFAULT startoftime(),
    taxreg_expires date DEFAULT endoftime(),
    taxreg_notes text DEFAULT ''::text,
    CONSTRAINT taxreg_taxreg_number_check CHECK ((taxreg_number <> ''::text))
);


ALTER TABLE public.taxreg OWNER TO admin;

--
-- TOC entry 9180 (class 0 OID 0)
-- Dependencies: 285
-- Name: TABLE taxreg; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE taxreg IS 'Stores Tax Registration numbers related to objects and a given tax authority. The rel_id specifies the object id and teh rel_type specifies the object type. See column comment for additional detail on types.';


--
-- TOC entry 9181 (class 0 OID 0)
-- Dependencies: 285
-- Name: COLUMN taxreg.taxreg_rel_type; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN taxreg.taxreg_rel_type IS 'The type of relation this record is for. Known values are C=Customer, V=Vendor, NULL=This Manufacturer in which case taxreg_rel_id is meaningless and should be -1.';


SET search_path = api, pg_catalog;

--
-- TOC entry 286 (class 1259 OID 146567560)
-- Dependencies: 8502 6
-- Name: customertaxreg; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW customertaxreg AS
    SELECT (custinfo.cust_number)::character varying AS customer_number, (COALESCE(taxzone.taxzone_code, 'Any'::text))::character varying AS tax_zone, (taxauth.taxauth_code)::character varying AS tax_authority, taxreg.taxreg_number AS registration_number, CASE WHEN (taxreg.taxreg_effective = public.startoftime()) THEN 'Always'::text ELSE public.formatdate(taxreg.taxreg_effective) END AS start_date, CASE WHEN (taxreg.taxreg_expires = public.endoftime()) THEN 'Never'::text ELSE public.formatdate(taxreg.taxreg_expires) END AS end_date, taxreg.taxreg_notes AS notes FROM (((public.taxreg LEFT JOIN public.custinfo ON ((custinfo.cust_id = taxreg.taxreg_rel_id))) LEFT JOIN public.taxauth ON ((taxauth.taxauth_id = taxreg.taxreg_taxauth_id))) LEFT JOIN public.taxzone ON ((taxzone.taxzone_id = taxreg.taxreg_taxzone_id))) WHERE (taxreg.taxreg_rel_type = 'C'::bpchar) ORDER BY custinfo.cust_number, taxreg.taxreg_number;


ALTER TABLE api.customertaxreg OWNER TO admin;

--
-- TOC entry 9183 (class 0 OID 0)
-- Dependencies: 286
-- Name: VIEW customertaxreg; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW customertaxreg IS 'Customer Tax Registrations';


--
-- TOC entry 287 (class 1259 OID 146567566)
-- Dependencies: 8503 6
-- Name: customertype; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW customertype AS
    SELECT (custtype.custtype_code)::character varying AS code, custtype.custtype_descrip AS description, custtype.custtype_char AS enable_characteristics_profile FROM public.custtype ORDER BY custtype.custtype_code;


ALTER TABLE api.customertype OWNER TO admin;

--
-- TOC entry 9185 (class 0 OID 0)
-- Dependencies: 287
-- Name: VIEW customertype; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW customertype IS 'Customer Type';


--
-- TOC entry 288 (class 1259 OID 146567570)
-- Dependencies: 8504 6
-- Name: customertypechar; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW customertypechar AS
    SELECT (custtype.custtype_code)::character varying AS customer_type, ("char".char_name)::character varying AS characteristic, charass.charass_value AS value, charass.charass_default AS is_default FROM public.custtype, public."char", public.charass WHERE ((('CT'::text = charass.charass_target_type) AND (custtype.custtype_id = charass.charass_target_id)) AND (charass.charass_char_id = "char".char_id));


ALTER TABLE api.customertypechar OWNER TO admin;

--
-- TOC entry 9187 (class 0 OID 0)
-- Dependencies: 288
-- Name: VIEW customertypechar; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW customertypechar IS 'Customer Type Characteristics';


--
-- TOC entry 289 (class 1259 OID 146567574)
-- Dependencies: 8505 6
-- Name: custshipto; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW custshipto AS
    SELECT (custinfo.cust_number)::character varying AS customer_number, (shiptoinfo.shipto_num)::character varying AS shipto_number, shiptoinfo.shipto_active AS active, shiptoinfo.shipto_name AS name, shiptoinfo.shipto_default AS default_flag, addr.addr_number AS address_number, addr.addr_line1 AS address1, addr.addr_line2 AS address2, addr.addr_line3 AS address3, addr.addr_city AS city, addr.addr_state AS state, addr.addr_postalcode AS postal_code, addr.addr_country AS country, ''::text AS address_change, cntct.cntct_number AS contact_number, cntct.cntct_honorific AS honorific, cntct.cntct_first_name AS first, cntct.cntct_middle AS middle, cntct.cntct_last_name AS last, cntct.cntct_suffix AS suffix, cntct.cntct_title AS job_title, cntct.cntct_phone AS phone, cntct.cntct_fax AS fax, cntct.cntct_email AS email, ''::text AS contact_change, salesrep.salesrep_number AS sales_rep, (shiptoinfo.shipto_commission * 100.0) AS commission, shipzone.shipzone_name AS zone, taxzone.taxzone_code AS tax_zone, shiptoinfo.shipto_shipvia AS ship_via, shipform.shipform_name AS ship_form, shipchrg.shipchrg_name AS shipping_charges, CASE WHEN (shiptoinfo.shipto_ediprofile_id = (-1)) THEN 'No EDI'::text WHEN (shiptoinfo.shipto_ediprofile_id = (-2)) THEN 'Use Customer Master'::text ELSE public.getediprofilename(shiptoinfo.shipto_ediprofile_id) END AS edi_profile, shiptoinfo.shipto_comments AS general_notes, shiptoinfo.shipto_shipcomments AS shipping_notes FROM public.custinfo, ((((((public.shiptoinfo LEFT JOIN public.shipchrg ON ((shiptoinfo.shipto_shipchrg_id = shipchrg.shipchrg_id))) LEFT JOIN public.cntct ON ((shiptoinfo.shipto_cntct_id = cntct.cntct_id))) LEFT JOIN public.addr ON ((shiptoinfo.shipto_addr_id = addr.addr_id))) LEFT JOIN public.taxzone ON ((shiptoinfo.shipto_taxzone_id = taxzone.taxzone_id))) LEFT JOIN public.shipzone ON ((shiptoinfo.shipto_shipzone_id = shipzone.shipzone_id))) LEFT JOIN public.salesrep ON ((shiptoinfo.shipto_salesrep_id = salesrep.salesrep_id))), public.shipform WHERE ((custinfo.cust_id = shiptoinfo.shipto_cust_id) AND (custinfo.cust_shipform_id = shipform.shipform_id));


ALTER TABLE api.custshipto OWNER TO admin;

--
-- TOC entry 9189 (class 0 OID 0)
-- Dependencies: 289
-- Name: VIEW custshipto; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW custshipto IS 'Customer Shipto Address';


--
-- TOC entry 290 (class 1259 OID 146567579)
-- Dependencies: 8506 6
-- Name: custtax; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW custtax AS
    SELECT (custinfo.cust_number)::character varying AS customer_number, (taxauth.taxauth_code)::character varying AS tax_authority, taxreg.taxreg_number AS registration_number FROM public.custinfo, public.taxauth, public.taxreg WHERE (((taxreg.taxreg_rel_type = 'C'::bpchar) AND (taxreg.taxreg_rel_id = custinfo.cust_id)) AND (taxreg.taxreg_taxauth_id = taxauth.taxauth_id));


ALTER TABLE api.custtax OWNER TO admin;

--
-- TOC entry 9191 (class 0 OID 0)
-- Dependencies: 290
-- Name: VIEW custtax; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW custtax IS 'Customer Tax Registration';


SET search_path = public, pg_catalog;

--
-- TOC entry 291 (class 1259 OID 146567583)
-- Dependencies: 6145 8
-- Name: dept; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE dept (
    dept_id integer NOT NULL,
    dept_number text NOT NULL,
    dept_name text NOT NULL,
    CONSTRAINT dept_dept_number_check CHECK ((dept_number <> ''::text))
);


ALTER TABLE public.dept OWNER TO admin;

--
-- TOC entry 9193 (class 0 OID 0)
-- Dependencies: 291
-- Name: TABLE dept; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE dept IS 'List of Departments';


--
-- TOC entry 292 (class 1259 OID 146567590)
-- Dependencies: 6146 6147 6148 6150 6151 6152 6153 8
-- Name: emp; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE emp (
    emp_id integer NOT NULL,
    emp_code text NOT NULL,
    emp_number text NOT NULL,
    emp_active boolean DEFAULT true NOT NULL,
    emp_cntct_id integer,
    emp_warehous_id integer,
    emp_mgr_emp_id integer,
    emp_wage_type text NOT NULL,
    emp_wage numeric,
    emp_wage_curr_id integer DEFAULT basecurrid(),
    emp_wage_period text NOT NULL,
    emp_dept_id integer,
    emp_shift_id integer,
    emp_notes text,
    emp_image_id integer,
    emp_username text,
    emp_extrate numeric,
    emp_extrate_period text NOT NULL,
    emp_startdate date DEFAULT ('now'::text)::date,
    emp_name text NOT NULL,
    CONSTRAINT emp_check CHECK (((((COALESCE(emp_wage_type, ''::text) = ''::text) OR (COALESCE(emp_wage_type, ''::text) = 'H'::text)) OR (COALESCE(emp_wage_type, ''::text) = 'S'::text)) AND ((COALESCE(emp_wage, (0)::numeric) = (0)::numeric) OR ((COALESCE(emp_wage_type, ''::text) <> ''::text) AND (emp_wage IS NOT NULL))))),
    CONSTRAINT emp_emp_code_check CHECK ((emp_code <> ''::text)),
    CONSTRAINT emp_emp_number_check CHECK ((emp_number <> ''::text)),
    CONSTRAINT emp_emp_wage_period_check CHECK ((((((((COALESCE(emp_wage_period, ''::text) = ''::text) OR (COALESCE(emp_wage_period, ''::text) = 'H'::text)) OR (COALESCE(emp_wage_period, ''::text) = 'D'::text)) OR (COALESCE(emp_wage_period, ''::text) = 'W'::text)) OR (COALESCE(emp_wage_period, ''::text) = 'BW'::text)) OR (COALESCE(emp_wage_period, ''::text) = 'M'::text)) OR (COALESCE(emp_wage_period, ''::text) = 'Y'::text)))
);


ALTER TABLE public.emp OWNER TO admin;

--
-- TOC entry 293 (class 1259 OID 146567603)
-- Dependencies: 6155 8
-- Name: shift; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE shift (
    shift_id integer NOT NULL,
    shift_number text NOT NULL,
    shift_name text NOT NULL,
    CONSTRAINT shift_shift_number_check CHECK ((shift_number <> ''::text))
);


ALTER TABLE public.shift OWNER TO admin;

--
-- TOC entry 9204 (class 0 OID 0)
-- Dependencies: 293
-- Name: TABLE shift; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE shift IS 'List of work Shifts';


SET search_path = api, pg_catalog;

--
-- TOC entry 294 (class 1259 OID 146567610)
-- Dependencies: 8507 6
-- Name: employee; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW employee AS
    SELECT (e.emp_code)::character varying AS code, (e.emp_number)::character varying AS number, e.emp_active AS active, e.emp_startdate AS start_date, cntct.cntct_number AS contact_number, cntct.cntct_honorific AS honorific, cntct.cntct_first_name AS first, cntct.cntct_middle AS middle, cntct.cntct_last_name AS last, cntct.cntct_suffix AS suffix, cntct.cntct_title AS job_title, cntct.cntct_phone AS voice, cntct.cntct_phone2 AS alternate, cntct.cntct_fax AS fax, cntct.cntct_email AS email, cntct.cntct_webaddr AS web, ''::text AS contact_change, addr.addr_number AS address_number, addr.addr_line1 AS address1, addr.addr_line2 AS address2, addr.addr_line3 AS address3, addr.addr_city AS city, addr.addr_state AS state, addr.addr_postalcode AS postalcode, addr.addr_country AS country, ''::text AS address_change, whsinfo.warehous_code AS site, m.emp_code AS manager_code, CASE WHEN (e.emp_wage_type = 'H'::text) THEN 'Hourly'::text WHEN (e.emp_wage_type = 'S'::text) THEN 'Salaried'::text WHEN (e.emp_wage_type IS NULL) THEN NULL::text ELSE 'Error'::text END AS wage_type, e.emp_wage AS wage, curr_symbol.curr_abbr AS wage_currency, CASE WHEN (e.emp_wage_period = 'H'::text) THEN 'Hour'::text WHEN (e.emp_wage_period = 'D'::text) THEN 'Day'::text WHEN (e.emp_wage_period = 'W'::text) THEN 'Week'::text WHEN (e.emp_wage_period = 'BW'::text) THEN 'Biweek'::text WHEN (e.emp_wage_period = 'M'::text) THEN 'Month'::text WHEN (e.emp_wage_period = 'Y'::text) THEN 'Year'::text WHEN (e.emp_wage_period IS NULL) THEN NULL::text ELSE 'Error'::text END AS wage_period, dept.dept_number AS department, shift.shift_number AS shift, (crmacct.crmacct_usr_username IS NOT NULL) AS is_user, (salesrep.salesrep_id IS NOT NULL) AS is_salesrep, (vendinfo.vend_id IS NOT NULL) AS is_vendor, e.emp_notes AS notes, image.image_name AS image, e.emp_extrate AS rate, curr_symbol.curr_abbr AS billing_currency, CASE WHEN (e.emp_extrate_period = 'H'::text) THEN 'Hour'::text WHEN (e.emp_extrate_period = 'D'::text) THEN 'Day'::text WHEN (e.emp_extrate_period = 'W'::text) THEN 'Week'::text WHEN (e.emp_extrate_period = 'BW'::text) THEN 'Biweek'::text WHEN (e.emp_extrate_period = 'M'::text) THEN 'Month'::text WHEN (e.emp_extrate_period = 'Y'::text) THEN 'Year'::text WHEN (e.emp_extrate_period IS NULL) THEN NULL::text ELSE 'Error'::text END AS billing_period FROM (((((((((((public.emp e JOIN public.crmacct ON ((e.emp_id = crmacct.crmacct_emp_id))) LEFT JOIN public.cntct ON ((e.emp_cntct_id = cntct.cntct_id))) LEFT JOIN public.addr ON ((cntct.cntct_addr_id = addr.addr_id))) LEFT JOIN public.whsinfo ON ((e.emp_warehous_id = whsinfo.warehous_id))) LEFT JOIN public.emp m ON ((e.emp_mgr_emp_id = m.emp_id))) LEFT JOIN public.dept ON ((e.emp_dept_id = dept.dept_id))) LEFT JOIN public.shift ON ((e.emp_shift_id = shift.shift_id))) LEFT JOIN public.salesrep ON ((crmacct.crmacct_salesrep_id = salesrep.salesrep_id))) LEFT JOIN public.vendinfo ON ((crmacct.crmacct_vend_id = vendinfo.vend_id))) LEFT JOIN public.image ON ((e.emp_image_id = image.image_id))) JOIN public.curr_symbol ON ((e.emp_wage_curr_id = curr_symbol.curr_id)));


ALTER TABLE api.employee OWNER TO admin;

--
-- TOC entry 9206 (class 0 OID 0)
-- Dependencies: 294
-- Name: VIEW employee; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW employee IS 'Employee';


--
-- TOC entry 295 (class 1259 OID 146567615)
-- Dependencies: 8508 6
-- Name: employeechar; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW employeechar AS
    SELECT (emp.emp_code)::character varying AS employee_code, ("char".char_name)::character varying AS characteristic, charass.charass_value AS value FROM public.emp, public."char", public.charass WHERE ((('EMP'::text = charass.charass_target_type) AND (emp.emp_id = charass.charass_target_id)) AND (charass.charass_char_id = "char".char_id));


ALTER TABLE api.employeechar OWNER TO admin;

--
-- TOC entry 9208 (class 0 OID 0)
-- Dependencies: 295
-- Name: VIEW employeechar; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW employeechar IS 'Employee Characteristics';


--
-- TOC entry 296 (class 1259 OID 146567619)
-- Dependencies: 8509 6
-- Name: employeecomment; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW employeecomment AS
    SELECT (emp.emp_code)::character varying AS code, (cmnttype.cmnttype_name)::character varying AS type, comment.comment_date AS date, comment.comment_user AS username, comment.comment_text AS text FROM public.emp, public.cmnttype, public.comment WHERE (((comment.comment_source = 'EMP'::text) AND (comment.comment_source_id = emp.emp_id)) AND (comment.comment_cmnttype_id = cmnttype.cmnttype_id));


ALTER TABLE api.employeecomment OWNER TO admin;

--
-- TOC entry 9210 (class 0 OID 0)
-- Dependencies: 296
-- Name: VIEW employeecomment; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW employeecomment IS 'Employee Comment';


SET search_path = public, pg_catalog;

--
-- TOC entry 297 (class 1259 OID 146567623)
-- Dependencies: 6156 6157 6158 6159 8
-- Name: shipdata; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE shipdata (
    shipdata_cohead_number text NOT NULL,
    shipdata_cosmisc_tracknum text NOT NULL,
    shipdata_cosmisc_packnum_tracknum text NOT NULL,
    shipdata_weight numeric(16,4),
    shipdata_base_freight numeric(16,4),
    shipdata_total_freight numeric(16,4),
    shipdata_shipper text DEFAULT 'UPS'::text,
    shipdata_billing_option text,
    shipdata_package_type text,
    shipdata_void_ind character(1) NOT NULL,
    shipdata_lastupdated timestamp without time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL,
    shipdata_shiphead_number text,
    shipdata_base_freight_curr_id integer DEFAULT basecurrid(),
    shipdata_total_freight_curr_id integer DEFAULT basecurrid()
);


ALTER TABLE public.shipdata OWNER TO admin;

--
-- TOC entry 9212 (class 0 OID 0)
-- Dependencies: 297
-- Name: TABLE shipdata; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE shipdata IS 'Shipping Interface information - note that the shipdata_cohead_nember is text and not int.  That is due to ODBC chopping off during the transfer';


SET search_path = api, pg_catalog;

--
-- TOC entry 298 (class 1259 OID 146567633)
-- Dependencies: 8510 6
-- Name: extshipmaint; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW extshipmaint AS
    SELECT (shipdata.shipdata_cohead_number)::character varying AS so_number, (shipdata.shipdata_shiphead_number)::character varying AS shipment_number, (shipdata.shipdata_shipper)::character varying AS shipper, (shipdata.shipdata_cosmisc_packnum_tracknum)::character varying AS package_tracking_number, shipdata.shipdata_void_ind AS void, shipdata.shipdata_billing_option AS billing_option, shipdata.shipdata_weight AS weight, shipdata.shipdata_base_freight AS base_freight, base.curr_abbr AS base_freight_currency, shipdata.shipdata_total_freight AS total_freight, total.curr_abbr AS total_freight_currency, shipdata.shipdata_package_type AS package_type, shipdata.shipdata_cosmisc_tracknum AS tracking_number, shipdata.shipdata_lastupdated AS last_updated FROM public.shipdata, public.curr_symbol base, public.curr_symbol total WHERE ((shipdata.shipdata_base_freight_curr_id = base.curr_id) AND (shipdata.shipdata_total_freight_curr_id = total.curr_id)) ORDER BY shipdata.shipdata_cohead_number, shipdata.shipdata_shiphead_number;


ALTER TABLE api.extshipmaint OWNER TO admin;

--
-- TOC entry 9214 (class 0 OID 0)
-- Dependencies: 298
-- Name: VIEW extshipmaint; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW extshipmaint IS 'External Shipping Maintenance';


SET search_path = public, pg_catalog;

--
-- TOC entry 299 (class 1259 OID 146567638)
-- Dependencies: 6161 8
-- Name: freightclass; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE freightclass (
    freightclass_id integer NOT NULL,
    freightclass_code text NOT NULL,
    freightclass_descrip text,
    CONSTRAINT freightclass_freightclass_code_check CHECK ((freightclass_code <> ''::text))
);


ALTER TABLE public.freightclass OWNER TO admin;

--
-- TOC entry 9216 (class 0 OID 0)
-- Dependencies: 299
-- Name: TABLE freightclass; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE freightclass IS 'This table is the freight price schedules.';


--
-- TOC entry 300 (class 1259 OID 146567645)
-- Dependencies: 6163 6164 8
-- Name: ipsfreight; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE ipsfreight (
    ipsfreight_id integer NOT NULL,
    ipsfreight_ipshead_id integer NOT NULL,
    ipsfreight_qtybreak numeric DEFAULT 0 NOT NULL,
    ipsfreight_price numeric DEFAULT 0 NOT NULL,
    ipsfreight_type character(1) NOT NULL,
    ipsfreight_warehous_id integer,
    ipsfreight_shipzone_id integer,
    ipsfreight_freightclass_id integer,
    ipsfreight_shipvia text
);


ALTER TABLE public.ipsfreight OWNER TO admin;

--
-- TOC entry 301 (class 1259 OID 146567653)
-- Dependencies: 6165 6166 6167 8
-- Name: ipshead; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE ipshead (
    ipshead_id integer DEFAULT nextval(('"ipshead_ipshead_id_seq"'::text)::regclass) NOT NULL,
    ipshead_name text NOT NULL,
    ipshead_descrip text,
    ipshead_effective date,
    ipshead_expires date,
    ipshead_curr_id integer DEFAULT basecurrid() NOT NULL,
    ipshead_updated date,
    CONSTRAINT ipshead_ipshead_name_check CHECK ((ipshead_name <> ''::text))
);


ALTER TABLE public.ipshead OWNER TO admin;


SET search_path = api, pg_catalog;

--
-- TOC entry 302 (class 1259 OID 146567662)
-- Dependencies: 8511 6
-- Name: freightpricingscheduleitem; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW freightpricingscheduleitem AS
    SELECT (ipshead.ipshead_name)::character varying AS pricing_schedule, ipsfreight.ipsfreight_qtybreak AS qty_break, (qtyuom.uom_name)::character varying AS qty_uom, ipsfreight.ipsfreight_price AS price, CASE WHEN (ipsfreight.ipsfreight_type = 'F'::bpchar) THEN 'Flat Rate'::text ELSE 'Price Per UOM'::text END AS price_type, COALESCE(whsinfo.warehous_code, 'Any'::text) AS from_site, COALESCE(shipzone.shipzone_name, 'Any'::text) AS to_shipzone, COALESCE(ipsfreight.ipsfreight_shipvia, 'Any'::text) AS ship_via, COALESCE(freightclass.freightclass_code, 'Any'::text) AS freight_class FROM (((((public.ipsfreight JOIN public.ipshead ON ((ipsfreight.ipsfreight_ipshead_id = ipshead.ipshead_id))) LEFT JOIN public.uom qtyuom ON (qtyuom.uom_item_weight)) LEFT JOIN public.whsinfo ON ((whsinfo.warehous_id = ipsfreight.ipsfreight_warehous_id))) LEFT JOIN public.shipzone ON ((shipzone.shipzone_id = ipsfreight.ipsfreight_shipzone_id))) LEFT JOIN public.freightclass ON ((freightclass.freightclass_id = ipsfreight.ipsfreight_freightclass_id)));


ALTER TABLE api.freightpricingscheduleitem OWNER TO admin;

--
-- TOC entry 9221 (class 0 OID 0)
-- Dependencies: 302
-- Name: VIEW freightpricingscheduleitem; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW freightpricingscheduleitem IS 'Freight Pricing Schedule Item';


--
-- TOC entry 303 (class 1259 OID 146567667)
-- Dependencies: 8512 6
-- Name: glaccount; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW glaccount AS
    SELECT (accnt.accnt_company)::character varying AS company, (accnt.accnt_profit)::character varying AS profit_center, (accnt.accnt_number)::character varying AS account_number, (accnt.accnt_sub)::character varying AS sub_account, accnt.accnt_descrip AS description, accnt.accnt_extref AS ext_reference, CASE WHEN (accnt.accnt_type = 'A'::bpchar) THEN 'Asset'::text WHEN (accnt.accnt_type = 'L'::bpchar) THEN 'Liability'::text WHEN (accnt.accnt_type = 'E'::bpchar) THEN 'Expense'::text WHEN (accnt.accnt_type = 'R'::bpchar) THEN 'Revenue'::text WHEN (accnt.accnt_type = 'Q'::bpchar) THEN 'Equity'::text ELSE '?'::text END AS type, accnt.accnt_subaccnttype_code AS sub_type, accnt.accnt_forwardupdate AS forward_update_trial_balances, accnt.accnt_comments AS notes FROM public.accnt ORDER BY accnt.accnt_company, accnt.accnt_profit, accnt.accnt_number, accnt.accnt_sub;


ALTER TABLE api.glaccount OWNER TO admin;

--
-- TOC entry 9223 (class 0 OID 0)
-- Dependencies: 303
-- Name: VIEW glaccount; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW glaccount IS 'GL Account';


SET search_path = public, pg_catalog;

--
-- TOC entry 304 (class 1259 OID 146567672)
-- Dependencies: 6169 8
-- Name: incdtcat; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE incdtcat (
    incdtcat_id integer NOT NULL,
    incdtcat_name text NOT NULL,
    incdtcat_order integer,
    incdtcat_descrip text,
    incdtcat_ediprofile_id integer,
    CONSTRAINT incdtcat_incdtcat_name_check CHECK ((incdtcat_name <> ''::text))
);


ALTER TABLE public.incdtcat OWNER TO admin;

--
-- TOC entry 9225 (class 0 OID 0)
-- Dependencies: 304
-- Name: TABLE incdtcat; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE incdtcat IS 'Incident Category table';


--
-- TOC entry 305 (class 1259 OID 146567679)
-- Dependencies: 6171 8
-- Name: incdtpriority; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE incdtpriority (
    incdtpriority_id integer NOT NULL,
    incdtpriority_name text NOT NULL,
    incdtpriority_order integer,
    incdtpriority_descrip text,
    CONSTRAINT incdtpriority_incdtpriority_name_check CHECK ((incdtpriority_name <> ''::text))
);


ALTER TABLE public.incdtpriority OWNER TO admin;

--
-- TOC entry 9227 (class 0 OID 0)
-- Dependencies: 305
-- Name: TABLE incdtpriority; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE incdtpriority IS 'Incident Priority table';


--
-- TOC entry 306 (class 1259 OID 146567686)
-- Dependencies: 6173 8
-- Name: incdtresolution; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE incdtresolution (
    incdtresolution_id integer NOT NULL,
    incdtresolution_name text NOT NULL,
    incdtresolution_order integer,
    incdtresolution_descrip text,
    CONSTRAINT incdtresolution_incdtresolution_name_check CHECK ((incdtresolution_name <> ''::text))
);


ALTER TABLE public.incdtresolution OWNER TO admin;

--
-- TOC entry 9229 (class 0 OID 0)
-- Dependencies: 306
-- Name: TABLE incdtresolution; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE incdtresolution IS 'Incident Resolution table';


--
-- TOC entry 307 (class 1259 OID 146567693)
-- Dependencies: 6175 8
-- Name: incdtseverity; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE incdtseverity (
    incdtseverity_id integer NOT NULL,
    incdtseverity_name text NOT NULL,
    incdtseverity_order integer,
    incdtseverity_descrip text,
    CONSTRAINT incdtseverity_incdtseverity_name_check CHECK ((incdtseverity_name <> ''::text))
);


ALTER TABLE public.incdtseverity OWNER TO admin;

--
-- TOC entry 9231 (class 0 OID 0)
-- Dependencies: 307
-- Name: TABLE incdtseverity; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE incdtseverity IS 'Incident Severity table';


SET search_path = api, pg_catalog;

--
-- TOC entry 308 (class 1259 OID 146567700)
-- Dependencies: 8513 6
-- Name: incident; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW incident AS
    SELECT incdt.incdt_number AS incident_number, incdtcat.incdtcat_name AS category, incdt.incdt_summary AS description, crmacct.crmacct_number AS crm_account, incdt.incdt_assigned_username AS assigned_to, CASE WHEN (incdt.incdt_status = 'N'::bpchar) THEN 'New'::text WHEN (incdt.incdt_status = 'F'::bpchar) THEN 'Feedback'::text WHEN (incdt.incdt_status = 'C'::bpchar) THEN 'Confirmed'::text WHEN (incdt.incdt_status = 'A'::bpchar) THEN 'Assigned'::text WHEN (incdt.incdt_status = 'R'::bpchar) THEN 'Resolved'::text WHEN (incdt.incdt_status = 'L'::bpchar) THEN 'Closed'::text ELSE '?'::text END AS status, incdtseverity.incdtseverity_name AS severity, incdtpriority.incdtpriority_name AS priority, incdtresolution.incdtresolution_name AS resolution, cntct.cntct_number AS contact_number, cntct.cntct_honorific AS honorific, cntct.cntct_first_name AS first, cntct.cntct_middle AS middle, cntct.cntct_last_name AS last, cntct.cntct_suffix AS suffix, cntct.cntct_title AS job_title, cntct.cntct_phone AS phone, cntct.cntct_fax AS fax, cntct.cntct_email AS email, ''::text AS contact_change, incdt.incdt_descrip AS notes, item.item_number, incdt.incdt_lotserial AS lot_serial_number, CASE WHEN (aropen.aropen_doctype = 'C'::bpchar) THEN 'C/M'::text WHEN (aropen.aropen_doctype = 'D'::bpchar) THEN 'D/M'::text WHEN (aropen.aropen_doctype = 'I'::bpchar) THEN 'Invoice'::text WHEN (aropen.aropen_doctype = 'R'::bpchar) THEN 'C/D'::text ELSE ''::text END AS ar_doc_type, aropen.aropen_docnumber AS ar_doc_number FROM ((((((((public.incdt LEFT JOIN public.incdtcat ON ((incdtcat.incdtcat_id = incdt.incdt_incdtcat_id))) LEFT JOIN public.crmacct ON ((crmacct.crmacct_id = incdt.incdt_crmacct_id))) LEFT JOIN public.incdtseverity ON ((incdtseverity.incdtseverity_id = incdt.incdt_incdtseverity_id))) LEFT JOIN public.incdtpriority ON ((incdtpriority.incdtpriority_id = incdt.incdt_incdtpriority_id))) LEFT JOIN public.incdtresolution ON ((incdtresolution.incdtresolution_id = incdt.incdt_incdtresolution_id))) LEFT JOIN public.cntct ON ((cntct.cntct_id = incdt.incdt_cntct_id))) LEFT JOIN public.item ON ((item.item_id = incdt.incdt_item_id))) LEFT JOIN public.aropen ON ((aropen.aropen_id = incdt.incdt_aropen_id)));


ALTER TABLE api.incident OWNER TO admin;

--
-- TOC entry 9233 (class 0 OID 0)
-- Dependencies: 308
-- Name: VIEW incident; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW incident IS 'Incident';


--
-- TOC entry 309 (class 1259 OID 146567705)
-- Dependencies: 8514 6
-- Name: incidentchar; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW incidentchar AS
    SELECT incdt.incdt_number AS incident_number, ("char".char_name)::character varying AS characteristic, charass.charass_value AS value FROM public.incdt, public."char", public.charass WHERE ((('INCDT'::text = charass.charass_target_type) AND (incdt.incdt_id = charass.charass_target_id)) AND (charass.charass_char_id = "char".char_id));


ALTER TABLE api.incidentchar OWNER TO admin;

--
-- TOC entry 9235 (class 0 OID 0)
-- Dependencies: 309
-- Name: VIEW incidentchar; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW incidentchar IS 'Incident Characteristics';


--
-- TOC entry 310 (class 1259 OID 146567709)
-- Dependencies: 8515 6
-- Name: incidentcomment; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW incidentcomment AS
    SELECT incdt.incdt_number AS incident_number, cmnttype.cmnttype_name AS type, comment.comment_date AS date, comment.comment_user AS username, comment.comment_text AS text, comment.comment_public AS public FROM public.incdt, public.cmnttype, public.comment WHERE (((comment.comment_source = 'INCDT'::text) AND (comment.comment_source_id = incdt.incdt_id)) AND (comment.comment_cmnttype_id = cmnttype.cmnttype_id));


ALTER TABLE api.incidentcomment OWNER TO admin;

--
-- TOC entry 9237 (class 0 OID 0)
-- Dependencies: 310
-- Name: VIEW incidentcomment; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW incidentcomment IS 'Incident Comment';


--
-- TOC entry 311 (class 1259 OID 146567713)
-- Dependencies: 8516 6
-- Name: incidentfile; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW incidentfile AS
    SELECT incdt.incdt_number AS incident_number, url.url_title AS title, url.url_url AS url FROM public.incdt, public.url WHERE ((incdt.incdt_id = url.url_source_id) AND (url.url_source = 'INCDT'::text));


ALTER TABLE api.incidentfile OWNER TO admin;

--
-- TOC entry 9239 (class 0 OID 0)
-- Dependencies: 311
-- Name: VIEW incidentfile; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW incidentfile IS 'Incident File';


--
-- TOC entry 312 (class 1259 OID 146567717)
-- Dependencies: 8517 6
-- Name: incidentimage; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW incidentimage AS
    SELECT incdt.incdt_number AS incident_number, image.image_name FROM public.incdt, public.imageass, public.image WHERE (((incdt.incdt_id = imageass.imageass_source_id) AND (imageass.imageass_source = 'INCDT'::text)) AND (imageass.imageass_image_id = image.image_id));


ALTER TABLE api.incidentimage OWNER TO admin;

--
-- TOC entry 9241 (class 0 OID 0)
-- Dependencies: 312
-- Name: VIEW incidentimage; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW incidentimage IS 'Incident Image';


SET search_path = public, pg_catalog;

--
-- TOC entry 313 (class 1259 OID 146567721)
-- Dependencies: 6176 6177 8
-- Name: classcode; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE classcode (
    classcode_id integer DEFAULT nextval(('classcode_classcode_id_seq'::text)::regclass) NOT NULL,
    classcode_code text NOT NULL,
    classcode_descrip text,
    classcode_mfg boolean,
    classcode_creator text,
    classcode_created timestamp without time zone,
    classcode_modifier text,
    classcode_modified timestamp without time zone,
    classcode_type text,
    CONSTRAINT classcode_classcode_code_check CHECK ((classcode_code <> ''::text))
);


ALTER TABLE public.classcode OWNER TO admin;

--
-- TOC entry 9243 (class 0 OID 0)
-- Dependencies: 313
-- Name: TABLE classcode; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE classcode IS 'Class Code information';


--
-- TOC entry 314 (class 1259 OID 146567729)
-- Dependencies: 6178 6179 8
-- Name: prodcat; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE prodcat (
    prodcat_id integer DEFAULT nextval(('prodcat_prodcat_id_seq'::text)::regclass) NOT NULL,
    prodcat_code text NOT NULL,
    prodcat_descrip text,
    CONSTRAINT prodcat_prodcat_code_check CHECK ((prodcat_code <> ''::text))
);


ALTER TABLE public.prodcat OWNER TO admin;

--
-- TOC entry 9245 (class 0 OID 0)
-- Dependencies: 314
-- Name: TABLE prodcat; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE prodcat IS 'Product Category information';


SET search_path = api, pg_catalog;

--
-- TOC entry 315 (class 1259 OID 146567737)
-- Dependencies: 8518 6
-- Name: item; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW item AS
    SELECT (item.item_number)::character varying AS item_number, item.item_active AS active, item.item_descrip1 AS description1, item.item_descrip2 AS description2, CASE WHEN (item.item_type = 'P'::bpchar) THEN 'Purchased'::text WHEN (item.item_type = 'M'::bpchar) THEN 'Manufactured'::text WHEN (item.item_type = 'J'::bpchar) THEN 'Job'::text WHEN (item.item_type = 'K'::bpchar) THEN 'Kit'::text WHEN (item.item_type = 'F'::bpchar) THEN 'Phantom'::text WHEN (item.item_type = 'R'::bpchar) THEN 'Reference'::text WHEN (item.item_type = 'S'::bpchar) THEN 'Costing'::text WHEN (item.item_type = 'T'::bpchar) THEN 'Tooling'::text WHEN (item.item_type = 'O'::bpchar) THEN 'Outside Process'::text WHEN (item.item_type = 'L'::bpchar) THEN 'Planning'::text WHEN (item.item_type = 'B'::bpchar) THEN 'Breeder'::text WHEN (item.item_type = 'C'::bpchar) THEN 'Co-Product'::text WHEN (item.item_type = 'Y'::bpchar) THEN 'By-Product'::text ELSE NULL::text END AS item_type, item.item_maxcost AS maximum_desired_cost, classcode.classcode_code AS class_code, i.uom_name AS inventory_uom, item.item_picklist AS pick_list_item, item.item_fractional AS fractional, item.item_config AS configured, item.item_sold AS item_is_sold, prodcat.prodcat_code AS product_category, item.item_exclusive AS exclusive, item.item_listprice AS list_price, item.item_listcost AS list_cost, p.uom_name AS list_price_uom, item.item_upccode AS upc_code, item.item_prodweight AS product_weight, item.item_packweight AS packaging_weight, item.item_comments AS notes, item.item_extdescrip AS ext_description FROM (public.item LEFT JOIN public.prodcat ON ((item.item_prodcat_id = prodcat.prodcat_id))), public.classcode, public.uom i, public.uom p WHERE (((item.item_classcode_id = classcode.classcode_id) AND (item.item_inv_uom_id = i.uom_id)) AND (item.item_price_uom_id = p.uom_id)) ORDER BY (item.item_number)::character varying;


ALTER TABLE api.item OWNER TO admin;

--
-- TOC entry 9247 (class 0 OID 0)
-- Dependencies: 315
-- Name: VIEW item; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW item IS 'Item';


SET search_path = public, pg_catalog;

--
-- TOC entry 316 (class 1259 OID 146567742)
-- Dependencies: 6180 6181 8
-- Name: itemalias; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE itemalias (
    itemalias_id integer DEFAULT nextval(('"itemalias_itemalias_id_seq"'::text)::regclass) NOT NULL,
    itemalias_item_id integer NOT NULL,
    itemalias_number text NOT NULL,
    itemalias_comments text,
    itemalias_usedescrip boolean NOT NULL,
    itemalias_descrip1 text,
    itemalias_descrip2 text,
    itemalias_crmacct_id integer,
    CONSTRAINT itemalias_itemalias_number_check CHECK ((itemalias_number <> ''::text))
);


ALTER TABLE public.itemalias OWNER TO admin;


SET search_path = api, pg_catalog;

--
-- TOC entry 317 (class 1259 OID 146567750)
-- Dependencies: 8519 6
-- Name: itemalias; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW itemalias AS
    SELECT (item.item_number)::character varying AS item_number, itemalias.itemalias_number AS alias_number, itemalias.itemalias_usedescrip AS use_description, itemalias.itemalias_descrip1 AS description1, itemalias.itemalias_descrip2 AS description2, itemalias.itemalias_comments AS comments FROM public.item, public.itemalias WHERE (item.item_id = itemalias.itemalias_item_id);


ALTER TABLE api.itemalias OWNER TO admin;

--
-- TOC entry 9252 (class 0 OID 0)
-- Dependencies: 317
-- Name: VIEW itemalias; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW itemalias IS 'Item Alias';


--
-- TOC entry 318 (class 1259 OID 146567754)
-- Dependencies: 8520 6
-- Name: itemchar; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW itemchar AS
    SELECT (item.item_number)::character varying AS item_number, ("char".char_name)::character varying AS characteristic, charass.charass_value AS value, charass.charass_default AS is_default FROM public.item, public."char", public.charass WHERE ((('I'::text = charass.charass_target_type) AND (item.item_id = charass.charass_target_id)) AND (charass.charass_char_id = "char".char_id));


ALTER TABLE api.itemchar OWNER TO admin;

--
-- TOC entry 9254 (class 0 OID 0)
-- Dependencies: 318
-- Name: VIEW itemchar; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW itemchar IS 'Item Characteristic';


--
-- TOC entry 319 (class 1259 OID 146567758)
-- Dependencies: 8521 6
-- Name: itemcomment; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW itemcomment AS
    SELECT (item.item_number)::character varying AS item_number, cmnttype.cmnttype_name AS type, comment.comment_date AS date, comment.comment_user AS username, comment.comment_text AS text FROM public.item, public.cmnttype, public.comment WHERE (((comment.comment_source = 'I'::text) AND (comment.comment_source_id = item.item_id)) AND (comment.comment_cmnttype_id = cmnttype.cmnttype_id));


ALTER TABLE api.itemcomment OWNER TO admin;

--
-- TOC entry 9256 (class 0 OID 0)
-- Dependencies: 319
-- Name: VIEW itemcomment; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW itemcomment IS 'Item Comments';


SET search_path = public, pg_catalog;

--
-- TOC entry 320 (class 1259 OID 146567762)
-- Dependencies: 6182 6183 8
-- Name: costelem; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE costelem (
    costelem_id integer DEFAULT nextval(('costelem_costelem_id_seq'::text)::regclass) NOT NULL,
    costelem_type text NOT NULL,
    costelem_sys boolean,
    costelem_po boolean,
    costelem_active boolean,
    costelem_exp_accnt_id integer,
    costelem_cost_item_id integer,
    CONSTRAINT costelem_costelem_type_check CHECK ((costelem_type <> ''::text))
);


ALTER TABLE public.costelem OWNER TO admin;

--
-- TOC entry 9258 (class 0 OID 0)
-- Dependencies: 320
-- Name: TABLE costelem; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE costelem IS 'Costing Element information';


--
-- TOC entry 321 (class 1259 OID 146567770)
-- Dependencies: 6184 6185 6186 6187 6188 8
-- Name: itemcost; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE itemcost (
    itemcost_id integer DEFAULT nextval(('itemcost_itemcost_id_seq'::text)::regclass) NOT NULL,
    itemcost_item_id integer NOT NULL,
    itemcost_costelem_id integer NOT NULL,
    itemcost_lowlevel boolean DEFAULT false NOT NULL,
    itemcost_stdcost numeric(16,6) DEFAULT 0 NOT NULL,
    itemcost_posted date,
    itemcost_actcost numeric(16,6) DEFAULT 0 NOT NULL,
    itemcost_updated date,
    itemcost_curr_id integer DEFAULT basecurrid() NOT NULL
);


ALTER TABLE public.itemcost OWNER TO admin;

--
-- TOC entry 9260 (class 0 OID 0)
-- Dependencies: 321
-- Name: TABLE itemcost; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE itemcost IS 'Item Cost information';


SET search_path = api, pg_catalog;

--
-- TOC entry 322 (class 1259 OID 146567778)
-- Dependencies: 8522 6
-- Name: itemcost; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW itemcost AS
    SELECT (item.item_number)::character varying(100) AS item_number, (costelem.costelem_type)::character varying(100) AS costing_element, itemcost.itemcost_actcost AS actual_cost, curr_symbol.curr_abbr AS currency, false AS post_to_standard FROM (((public.itemcost LEFT JOIN public.item ON ((itemcost.itemcost_item_id = item.item_id))) LEFT JOIN public.costelem ON ((itemcost.itemcost_costelem_id = costelem.costelem_id))) LEFT JOIN public.curr_symbol ON ((itemcost.itemcost_curr_id = curr_symbol.curr_id))) ORDER BY (item.item_number)::character varying(100), (costelem.costelem_type)::character varying(100);


ALTER TABLE api.itemcost OWNER TO admin;

--
-- TOC entry 9262 (class 0 OID 0)
-- Dependencies: 322
-- Name: VIEW itemcost; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW itemcost IS 'Item Cost';


--
-- TOC entry 323 (class 1259 OID 146567783)
-- Dependencies: 8523 6
-- Name: itemfile; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW itemfile AS
    SELECT (item.item_number)::character varying AS item_number, url.url_title AS title, url.url_url AS url FROM public.item, public.url WHERE ((item.item_id = url.url_source_id) AND (url.url_source = 'I'::text));


ALTER TABLE api.itemfile OWNER TO admin;

--
-- TOC entry 9264 (class 0 OID 0)
-- Dependencies: 323
-- Name: VIEW itemfile; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW itemfile IS 'Item File';


--
-- TOC entry 324 (class 1259 OID 146567787)
-- Dependencies: 8524 6
-- Name: itemimage; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW itemimage AS
    SELECT (item.item_number)::character varying AS item_number, CASE WHEN (imageass.imageass_purpose = 'P'::bpchar) THEN 'Product Description'::text WHEN (imageass.imageass_purpose = 'I'::bpchar) THEN 'Inventory Description'::text WHEN (imageass.imageass_purpose = 'E'::bpchar) THEN 'Engineering Reference'::text WHEN (imageass.imageass_purpose = 'M'::bpchar) THEN 'Miscellaneous'::text ELSE 'Other'::text END AS purpose, image.image_name FROM public.item, public.imageass, public.image WHERE (((item.item_id = imageass.imageass_source_id) AND (imageass.imageass_source = 'I'::text)) AND (imageass.imageass_image_id = image.image_id));


ALTER TABLE api.itemimage OWNER TO admin;

--
-- TOC entry 9266 (class 0 OID 0)
-- Dependencies: 324
-- Name: VIEW itemimage; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW itemimage IS 'Item Image';


SET search_path = public, pg_catalog;

--
-- TOC entry 325 (class 1259 OID 146567792)
-- Dependencies: 6189 6190 8
-- Name: costcat; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE costcat (
    costcat_id integer DEFAULT nextval(('costcat_costcat_id_seq'::text)::regclass) NOT NULL,
    costcat_code text NOT NULL,
    costcat_descrip text,
    costcat_asset_accnt_id integer,
    costcat_liability_accnt_id integer,
    costcat_adjustment_accnt_id integer,
    costcat_matusage_accnt_id integer,
    costcat_purchprice_accnt_id integer,
    costcat_laboroverhead_accnt_id integer,
    costcat_scrap_accnt_id integer,
    costcat_invcost_accnt_id integer,
    costcat_wip_accnt_id integer,
    costcat_shipasset_accnt_id integer,
    costcat_mfgscrap_accnt_id integer,
    costcat_transform_accnt_id integer,
    costcat_freight_accnt_id integer,
    costcat_toliability_accnt_id integer,
    costcat_exp_accnt_id integer,
    CONSTRAINT costcat_costcat_code_check CHECK ((costcat_code <> ''::text))
);


ALTER TABLE public.costcat OWNER TO admin;

--
-- TOC entry 9268 (class 0 OID 0)
-- Dependencies: 325
-- Name: TABLE costcat; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE costcat IS 'Cost Category information';


--
-- TOC entry 326 (class 1259 OID 146567800)
-- Dependencies: 6191 6192 8
-- Name: plancode; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE plancode (
    plancode_id integer DEFAULT nextval(('plancode_plancode_id_seq'::text)::regclass) NOT NULL,
    plancode_code text NOT NULL,
    plancode_name text,
    plancode_mpsexplosion character(1),
    plancode_consumefcst boolean,
    plancode_mrpexcp_resched boolean,
    plancode_mrpexcp_delete boolean,
    CONSTRAINT plancode_plancode_code_check CHECK ((plancode_code <> ''::text))
);


ALTER TABLE public.plancode OWNER TO admin;

--
-- TOC entry 9270 (class 0 OID 0)
-- Dependencies: 326
-- Name: TABLE plancode; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE plancode IS 'Planner Code information';


SET search_path = api, pg_catalog;

--
-- TOC entry 327 (class 1259 OID 146567808)
-- Dependencies: 8525 6
-- Name: itemsite; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW itemsite AS
    SELECT (item.item_number)::character varying AS item_number, (whsinfo.warehous_code)::character varying AS site, itemsite.itemsite_active AS active, itemsite.itemsite_wosupply AS wo_supplied_at_site, itemsite.itemsite_createwo AS create_wos, itemsite.itemsite_posupply AS po_supplied_at_site, itemsite.itemsite_createpr AS create_prs, itemsite.itemsite_createsopr AS create_soprs, itemsite.itemsite_createsopo AS create_sopos, itemsite.itemsite_dropship AS dropship, itemsite.itemsite_sold AS sold_from_site, itemsite.itemsite_soldranking AS ranking, CASE WHEN (itemsite.itemsite_costmethod = 'N'::bpchar) THEN 'None'::text WHEN (itemsite.itemsite_costmethod = 'A'::bpchar) THEN 'Average'::text WHEN (itemsite.itemsite_costmethod = 'S'::bpchar) THEN 'Standard'::text WHEN (itemsite.itemsite_costmethod = 'J'::bpchar) THEN 'Job'::text ELSE NULL::text END AS cost_method, CASE WHEN (itemsite.itemsite_controlmethod = 'N'::bpchar) THEN 'None'::text WHEN (itemsite.itemsite_controlmethod = 'R'::bpchar) THEN 'Regular'::text WHEN (itemsite.itemsite_controlmethod = 'S'::bpchar) THEN 'Serial #'::text WHEN (itemsite.itemsite_controlmethod = 'L'::bpchar) THEN 'Lot #'::text ELSE NULL::text END AS control_method, plancode.plancode_code AS planner_code, costcat.costcat_code AS cost_category, itemsite.itemsite_stocked AS stocked, itemsite.itemsite_abcclass AS abc_class, itemsite.itemsite_autoabcclass AS allow_automatic_updates, itemsite.itemsite_cyclecountfreq AS cycl_cnt_freq, itemsite.itemsite_eventfence AS event_fence, itemsite.itemsite_loccntrl AS multiple_location_control, public.formatlocationname(itemsite.itemsite_location_id) AS location, public.formatlocationname(itemsite.itemsite_recvlocation_id) AS receive_location, public.formatlocationname(itemsite.itemsite_issuelocation_id) AS issue_location, itemsite.itemsite_location_dist AS auto_distr_location, itemsite.itemsite_recvlocation_dist AS auto_distr_receive_location, itemsite.itemsite_issuelocation_dist AS auto_distr_issue_location, itemsite.itemsite_location AS user_defined_location, itemsite.itemsite_location_comments AS location_comment, itemsite.itemsite_disallowblankwip AS disallow_blank_wip_locations, itemsite.itemsite_useparams AS enforce_order_parameters, itemsite.itemsite_reorderlevel AS reorder_level, itemsite.itemsite_ordertoqty AS order_up_to, itemsite.itemsite_minordqty AS minimum_order, itemsite.itemsite_maxordqty AS maximum_order, itemsite.itemsite_multordqty AS order_multiple, itemsite.itemsite_useparamsmanual AS enforce_on_manual_orders, CASE WHEN (itemsite.itemsite_planning_type = 'N'::bpchar) THEN 'None'::text WHEN (itemsite.itemsite_planning_type = 'M'::bpchar) THEN 'MRP'::text WHEN (itemsite.itemsite_planning_type = 'S'::bpchar) THEN 'MPS'::text ELSE NULL::text END AS planning_system, itemsite.itemsite_ordergroup AS group_mps_mrp_orders, itemsite.itemsite_ordergroup_first AS first_group, itemsite.itemsite_mps_timefence AS mps_time_fence, itemsite.itemsite_leadtime AS lead_time, itemsite.itemsite_safetystock AS safety_stock, COALESCE((SELECT whsinfo.warehous_code FROM (public.itemsite supplysite JOIN public.whsinfo ON ((whsinfo.warehous_id = supplysite.itemsite_warehous_id))) WHERE (supplysite.itemsite_id = itemsite.itemsite_supply_itemsite_id)), 'None'::text) AS supplied_from_site, itemsite.itemsite_notes AS notes, itemsite.itemsite_perishable AS perishable, itemsite.itemsite_warrpurc AS require_warranty, itemsite.itemsite_autoreg AS auto_register FROM ((((public.itemsite JOIN public.item ON ((item.item_id = itemsite.itemsite_item_id))) JOIN public.plancode ON ((plancode.plancode_id = itemsite.itemsite_plancode_id))) JOIN public.costcat ON ((costcat.costcat_id = itemsite.itemsite_costcat_id))) JOIN public.whsinfo ON ((whsinfo.warehous_id = itemsite.itemsite_warehous_id)));


ALTER TABLE api.itemsite OWNER TO admin;

--
-- TOC entry 9272 (class 0 OID 0)
-- Dependencies: 327
-- Name: VIEW itemsite; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW itemsite IS 'Item Site';


--
-- TOC entry 328 (class 1259 OID 146567813)
-- Dependencies: 8526 6
-- Name: itemsitecomment; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW itemsitecomment AS
    SELECT (item.item_number)::character varying AS item_number, (whsinfo.warehous_code)::character varying AS site, cmnttype.cmnttype_name AS type, comment.comment_date AS date, comment.comment_user AS username, comment.comment_text AS text FROM public.itemsite, public.item, public.whsinfo, public.cmnttype, public.comment WHERE ((itemsite.itemsite_item_id = item.item_id) AND ((((itemsite.itemsite_warehous_id = whsinfo.warehous_id) AND (comment.comment_source = 'IS'::text)) AND (comment.comment_source_id = itemsite.itemsite_id)) AND (comment.comment_cmnttype_id = cmnttype.cmnttype_id)));


ALTER TABLE api.itemsitecomment OWNER TO admin;

--
-- TOC entry 9274 (class 0 OID 0)
-- Dependencies: 328
-- Name: VIEW itemsitecomment; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW itemsitecomment IS 'Item Site Comments';


SET search_path = public, pg_catalog;

--
-- TOC entry 329 (class 1259 OID 146567818)
-- Dependencies: 8
-- Name: contrct; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE contrct (
    contrct_id integer NOT NULL,
    contrct_number text NOT NULL,
    contrct_vend_id integer NOT NULL,
    contrct_descrip text,
    contrct_effective date NOT NULL,
    contrct_expires date NOT NULL,
    contrct_note text
);


ALTER TABLE public.contrct OWNER TO admin;

--
-- TOC entry 9276 (class 0 OID 0)
-- Dependencies: 329
-- Name: TABLE contrct; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE contrct IS 'Grouping of Item Sources for a Vendor with common effective and expiration dates.';


--
-- TOC entry 9277 (class 0 OID 0)
-- Dependencies: 329
-- Name: COLUMN contrct.contrct_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN contrct.contrct_id IS 'Sequence identifier for contract.';


--
-- TOC entry 9278 (class 0 OID 0)
-- Dependencies: 329
-- Name: COLUMN contrct.contrct_number; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN contrct.contrct_number IS 'User defined identifier for contract.';


--
-- TOC entry 9279 (class 0 OID 0)
-- Dependencies: 329
-- Name: COLUMN contrct.contrct_vend_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN contrct.contrct_vend_id IS 'Vendor associated with contract.';


--
-- TOC entry 9280 (class 0 OID 0)
-- Dependencies: 329
-- Name: COLUMN contrct.contrct_descrip; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN contrct.contrct_descrip IS 'Description for contract.';


--
-- TOC entry 9281 (class 0 OID 0)
-- Dependencies: 329
-- Name: COLUMN contrct.contrct_effective; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN contrct.contrct_effective IS 'Effective date for contract.  Constraint for overlap.';


--
-- TOC entry 9282 (class 0 OID 0)
-- Dependencies: 329
-- Name: COLUMN contrct.contrct_expires; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN contrct.contrct_expires IS 'Expiration date for contract.  Constraint for overlap.';


--
-- TOC entry 9283 (class 0 OID 0)
-- Dependencies: 329
-- Name: COLUMN contrct.contrct_note; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN contrct.contrct_note IS 'Notes for contract.';


--
-- TOC entry 330 (class 1259 OID 146567824)
-- Dependencies: 6194 6195 6196 6197 6198 6199 6200 8
-- Name: itemsrc; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE itemsrc (
    itemsrc_id integer DEFAULT nextval(('"itemsrc_itemsrc_id_seq"'::text)::regclass) NOT NULL,
    itemsrc_item_id integer NOT NULL,
    itemsrc_vend_id integer NOT NULL,
    itemsrc_vend_item_number text,
    itemsrc_vend_item_descrip text,
    itemsrc_comments text,
    itemsrc_vend_uom text NOT NULL,
    itemsrc_invvendoruomratio numeric(20,10) NOT NULL,
    itemsrc_minordqty numeric(18,6) NOT NULL,
    itemsrc_multordqty numeric(18,6) NOT NULL,
    itemsrc_leadtime integer NOT NULL,
    itemsrc_ranking integer NOT NULL,
    itemsrc_active boolean NOT NULL,
    itemsrc_manuf_name text DEFAULT ''::text NOT NULL,
    itemsrc_manuf_item_number text DEFAULT ''::text NOT NULL,
    itemsrc_manuf_item_descrip text,
    itemsrc_default boolean,
    itemsrc_upccode text,
    itemsrc_effective date DEFAULT startoftime() NOT NULL,
    itemsrc_expires date DEFAULT endoftime() NOT NULL,
    itemsrc_contrct_id integer,
    itemsrc_contrct_max numeric(18,6) DEFAULT 0.0 NOT NULL,
    itemsrc_contrct_min numeric(18,6) DEFAULT 0.0 NOT NULL
);


ALTER TABLE public.itemsrc OWNER TO admin;

--
-- TOC entry 9285 (class 0 OID 0)
-- Dependencies: 330
-- Name: TABLE itemsrc; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE itemsrc IS 'Item Source information';


--
-- TOC entry 9286 (class 0 OID 0)
-- Dependencies: 330
-- Name: COLUMN itemsrc.itemsrc_effective; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN itemsrc.itemsrc_effective IS 'Effective date for item source.  Constraint for overlap.';


--
-- TOC entry 9287 (class 0 OID 0)
-- Dependencies: 330
-- Name: COLUMN itemsrc.itemsrc_expires; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN itemsrc.itemsrc_expires IS 'Expiration date for item source.  Constraint for overlap.';


--
-- TOC entry 9288 (class 0 OID 0)
-- Dependencies: 330
-- Name: COLUMN itemsrc.itemsrc_contrct_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN itemsrc.itemsrc_contrct_id IS 'Associated contract for item source.  Inherits effective, expiration dates.';


SET search_path = api, pg_catalog;

--
-- TOC entry 331 (class 1259 OID 146567837)
-- Dependencies: 8527 6
-- Name: itemsource; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW itemsource AS
    SELECT (item.item_number)::character varying AS item_number, (vendinfo.vend_number)::character varying AS vendor, itemsrc.itemsrc_vend_item_number AS vendor_item_number, itemsrc.itemsrc_active AS active, itemsrc.itemsrc_default, itemsrc.itemsrc_vend_uom AS vendor_uom, itemsrc.itemsrc_invvendoruomratio AS inventory_vendor_uom_ratio, itemsrc.itemsrc_minordqty AS minimum_order, itemsrc.itemsrc_multordqty AS order_multiple, itemsrc.itemsrc_ranking AS vendor_ranking, itemsrc.itemsrc_leadtime AS lead_time, itemsrc.itemsrc_comments AS notes, itemsrc.itemsrc_vend_item_descrip AS vendor_description, itemsrc.itemsrc_manuf_name AS manufacturer_name, itemsrc.itemsrc_manuf_item_number AS manufacturer_item_number, itemsrc.itemsrc_manuf_item_descrip AS manufacturer_description, itemsrc.itemsrc_upccode AS bar_code, contrct.contrct_number AS contract_number, itemsrc.itemsrc_effective AS effective_date, itemsrc.itemsrc_expires AS expires_date FROM (((public.itemsrc LEFT JOIN public.item ON ((itemsrc.itemsrc_item_id = item.item_id))) LEFT JOIN public.vendinfo ON ((itemsrc.itemsrc_vend_id = vendinfo.vend_id))) LEFT JOIN public.contrct ON ((itemsrc.itemsrc_contrct_id = contrct.contrct_id))) ORDER BY (item.item_number)::character varying(100), (vendinfo.vend_number)::character varying(100);


ALTER TABLE api.itemsource OWNER TO admin;

--
-- TOC entry 9290 (class 0 OID 0)
-- Dependencies: 331
-- Name: VIEW itemsource; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW itemsource IS 'Item Source';


SET search_path = public, pg_catalog;

--
-- TOC entry 332 (class 1259 OID 146567842)
-- Dependencies: 6201 6202 6203 6204 6205 8
-- Name: itemsrcp; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE itemsrcp (
    itemsrcp_id integer DEFAULT nextval(('itemsrcp_itemsrcp_id_seq'::text)::regclass) NOT NULL,
    itemsrcp_itemsrc_id integer NOT NULL,
    itemsrcp_qtybreak numeric(18,6) NOT NULL,
    itemsrcp_price numeric(16,6),
    itemsrcp_updated date,
    itemsrcp_curr_id integer DEFAULT basecurrid() NOT NULL,
    itemsrcp_dropship boolean DEFAULT false NOT NULL,
    itemsrcp_warehous_id integer DEFAULT (-1) NOT NULL,
    itemsrcp_type character(1) NOT NULL,
    itemsrcp_discntprcnt numeric(16,6),
    itemsrcp_fixedamtdiscount numeric(16,6),
    CONSTRAINT valid_itemsrcp_type CHECK ((itemsrcp_type = ANY (ARRAY['N'::bpchar, 'D'::bpchar])))
);


ALTER TABLE public.itemsrcp OWNER TO admin;

--
-- TOC entry 9292 (class 0 OID 0)
-- Dependencies: 332
-- Name: TABLE itemsrcp; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE itemsrcp IS 'Item Source Price information';


--
-- TOC entry 9293 (class 0 OID 0)
-- Dependencies: 332
-- Name: COLUMN itemsrcp.itemsrcp_dropship; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN itemsrcp.itemsrcp_dropship IS 'Used to determine if item source price applies only to drop ship purchase orders.';


--
-- TOC entry 9294 (class 0 OID 0)
-- Dependencies: 332
-- Name: COLUMN itemsrcp.itemsrcp_warehous_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN itemsrcp.itemsrcp_warehous_id IS 'Used to determine if item source price applies only to specific site on purchase orders.';


--
-- TOC entry 9295 (class 0 OID 0)
-- Dependencies: 332
-- Name: COLUMN itemsrcp.itemsrcp_type; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN itemsrcp.itemsrcp_type IS 'Pricing type for item source price.  Valid values are N-nominal and D-discount.';


--
-- TOC entry 9296 (class 0 OID 0)
-- Dependencies: 332
-- Name: COLUMN itemsrcp.itemsrcp_discntprcnt; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN itemsrcp.itemsrcp_discntprcnt IS 'Discount percent for item source price.';


--
-- TOC entry 9297 (class 0 OID 0)
-- Dependencies: 332
-- Name: COLUMN itemsrcp.itemsrcp_fixedamtdiscount; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN itemsrcp.itemsrcp_fixedamtdiscount IS 'Fixed amount discount for item source price.';


SET search_path = api, pg_catalog;

--
-- TOC entry 333 (class 1259 OID 146567850)
-- Dependencies: 8528 6
-- Name: itemsourceprice; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW itemsourceprice AS
    SELECT (item.item_number)::character varying AS item_number, (vendinfo.vend_number)::character varying AS vendor, itemsrcp.itemsrcp_qtybreak AS qty_break, CASE WHEN (itemsrcp.itemsrcp_type = 'N'::bpchar) THEN 'Nominal'::text ELSE 'Discount'::text END AS pricing_type, CASE WHEN (itemsrcp.itemsrcp_warehous_id = (-1)) THEN 'All'::text ELSE whsinfo.warehous_code END AS pricing_site, itemsrcp.itemsrcp_dropship AS dropship_only, itemsrcp.itemsrcp_price AS price_per_unit, curr_symbol.curr_abbr AS currency, (itemsrcp.itemsrcp_discntprcnt * 100.0) AS discount_percent, itemsrcp.itemsrcp_fixedamtdiscount AS discount_fixed_amount FROM (((((public.itemsrcp LEFT JOIN public.itemsrc ON ((itemsrc.itemsrc_id = itemsrcp.itemsrcp_itemsrc_id))) LEFT JOIN public.item ON ((itemsrc.itemsrc_item_id = item.item_id))) LEFT JOIN public.vendinfo ON ((itemsrc.itemsrc_vend_id = vendinfo.vend_id))) LEFT JOIN public.curr_symbol ON ((itemsrcp.itemsrcp_curr_id = curr_symbol.curr_id))) LEFT JOIN public.whsinfo ON ((itemsrcp.itemsrcp_warehous_id = whsinfo.warehous_id))) ORDER BY (item.item_number)::character varying(100), (vendinfo.vend_number)::character varying(100);


ALTER TABLE api.itemsourceprice OWNER TO admin;

--
-- TOC entry 9299 (class 0 OID 0)
-- Dependencies: 333
-- Name: VIEW itemsourceprice; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW itemsourceprice IS 'Item Source Price';


SET search_path = public, pg_catalog;

--
-- TOC entry 334 (class 1259 OID 146567855)
-- Dependencies: 6206 8
-- Name: itemsub; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE itemsub (
    itemsub_id integer DEFAULT nextval(('itemsub_itemsub_id_seq'::text)::regclass) NOT NULL,
    itemsub_parent_item_id integer NOT NULL,
    itemsub_sub_item_id integer NOT NULL,
    itemsub_uomratio numeric(20,10) NOT NULL,
    itemsub_rank integer NOT NULL
);


ALTER TABLE public.itemsub OWNER TO admin;

--
-- TOC entry 9301 (class 0 OID 0)
-- Dependencies: 334
-- Name: TABLE itemsub; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE itemsub IS 'Item Substitutes information';


SET search_path = api, pg_catalog;

--
-- TOC entry 335 (class 1259 OID 146567859)
-- Dependencies: 8529 6
-- Name: itemsubstitute; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW itemsubstitute AS
    SELECT (p.item_number)::character varying AS root_item_number, (s.item_number)::character varying AS substitute_item_number, itemsub.itemsub_uomratio AS sub_parent_uom_ratio, itemsub.itemsub_rank AS ranking FROM public.item p, public.item s, public.itemsub WHERE ((p.item_id = itemsub.itemsub_parent_item_id) AND (s.item_id = itemsub.itemsub_sub_item_id));


ALTER TABLE api.itemsubstitute OWNER TO admin;

--
-- TOC entry 9303 (class 0 OID 0)
-- Dependencies: 335
-- Name: VIEW itemsubstitute; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW itemsubstitute IS 'Item Substitute';


SET search_path = public, pg_catalog;

--
-- TOC entry 336 (class 1259 OID 146567863)
-- Dependencies: 8
-- Name: itemtax; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE itemtax (
    itemtax_id integer NOT NULL,
    itemtax_item_id integer NOT NULL,
    itemtax_taxtype_id integer NOT NULL,
    itemtax_taxzone_id integer
);


ALTER TABLE public.itemtax OWNER TO admin;

--
-- TOC entry 9305 (class 0 OID 0)
-- Dependencies: 336
-- Name: TABLE itemtax; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE itemtax IS 'This table associates tax types in a specified tax authority for the given item.';


SET search_path = api, pg_catalog;

--
-- TOC entry 337 (class 1259 OID 146567866)
-- Dependencies: 8530 6
-- Name: itemtaxtype; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW itemtaxtype AS
    SELECT (item.item_number)::character varying AS item_number, CASE WHEN (taxzone.taxzone_id IS NULL) THEN 'Any'::character varying ELSE (taxzone.taxzone_code)::character varying END AS tax_zone, taxtype.taxtype_name AS tax_type FROM public.item, (public.itemtax LEFT JOIN public.taxzone ON ((itemtax.itemtax_taxzone_id = taxzone.taxzone_id))), public.taxtype WHERE ((item.item_id = itemtax.itemtax_item_id) AND (itemtax.itemtax_taxtype_id = taxtype.taxtype_id));


ALTER TABLE api.itemtaxtype OWNER TO admin;

--
-- TOC entry 9307 (class 0 OID 0)
-- Dependencies: 337
-- Name: VIEW itemtaxtype; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW itemtaxtype IS 'Item Tax Type';


SET search_path = public, pg_catalog;

--
-- TOC entry 338 (class 1259 OID 146567870)
-- Dependencies: 6209 6210 8
-- Name: itemuomconv; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE itemuomconv (
    itemuomconv_id integer NOT NULL,
    itemuomconv_item_id integer NOT NULL,
    itemuomconv_from_uom_id integer NOT NULL,
    itemuomconv_from_value numeric(20,10) NOT NULL,
    itemuomconv_to_uom_id integer NOT NULL,
    itemuomconv_to_value numeric(20,10) NOT NULL,
    itemuomconv_fractional boolean DEFAULT false NOT NULL,
    CONSTRAINT itemuomconv_uom CHECK ((itemuomconv_from_uom_id <> itemuomconv_to_uom_id))
);


ALTER TABLE public.itemuomconv OWNER TO admin;


SET search_path = api, pg_catalog;

--
-- TOC entry 339 (class 1259 OID 146567875)
-- Dependencies: 8531 6
-- Name: itemuomconversion; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW itemuomconversion AS
    SELECT (item.item_number)::character varying AS item_number, (f.uom_name)::character varying AS uom, itemuomconv.itemuomconv_from_value AS uom_value, p.uom_name AS per_uom, itemuomconv.itemuomconv_to_value AS per_uom_value, itemuomconv.itemuomconv_fractional AS fractional, public.fetchitemuomconvtypes(itemuomconv.itemuomconv_id) AS selected_types FROM public.item, public.itemuomconv, public.uom f, public.uom p WHERE (((item.item_id = itemuomconv.itemuomconv_item_id) AND (itemuomconv.itemuomconv_from_uom_id = f.uom_id)) AND (itemuomconv.itemuomconv_to_uom_id = p.uom_id));


ALTER TABLE api.itemuomconversion OWNER TO admin;

--
-- TOC entry 9311 (class 0 OID 0)
-- Dependencies: 339
-- Name: VIEW itemuomconversion; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW itemuomconversion IS 'Item Unit of Measure Conversion';


SET search_path = public, pg_catalog;

--
-- TOC entry 340 (class 1259 OID 146567879)
-- Dependencies: 6211 6212 6213 6214 8
-- Name: gltrans; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE gltrans (
    gltrans_id integer DEFAULT nextval(('"gltrans_gltrans_id_seq"'::text)::regclass) NOT NULL,
    gltrans_exported boolean,
    gltrans_created timestamp with time zone,
    gltrans_date date NOT NULL,
    gltrans_sequence integer,
    gltrans_accnt_id integer NOT NULL,
    gltrans_source text,
    gltrans_docnumber text,
    gltrans_misc_id integer,
    gltrans_amount numeric(20,2) NOT NULL,
    gltrans_notes text,
    gltrans_journalnumber integer,
    gltrans_posted boolean NOT NULL,
    gltrans_doctype text,
    gltrans_rec boolean DEFAULT false NOT NULL,
    gltrans_username text DEFAULT geteffectivextuser() NOT NULL,
    gltrans_deleted boolean DEFAULT false
);


ALTER TABLE public.gltrans OWNER TO admin;

--
-- TOC entry 9313 (class 0 OID 0)
-- Dependencies: 340
-- Name: TABLE gltrans; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE gltrans IS 'General Ledger (G/L) transaction information';


SET search_path = api, pg_catalog;

--
-- TOC entry 341 (class 1259 OID 146567889)
-- Dependencies: 8532 6
-- Name: journalentry; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW journalentry AS
    SELECT curr_symbol.curr_abbr AS currency, c.gltrans_amount AS amount, c.gltrans_date AS dist_date, c.gltrans_docnumber AS doc_number, public.formatglaccount(da.accnt_id) AS debit, public.formatglaccount(ca.accnt_id) AS credit, c.gltrans_notes AS notes FROM public.gltrans d, public.gltrans c, public.accnt da, public.accnt ca, public.curr_symbol WHERE ((((((((d.gltrans_sequence = c.gltrans_sequence) AND (d.gltrans_accnt_id = da.accnt_id)) AND (c.gltrans_accnt_id = ca.accnt_id)) AND (d.gltrans_amount < (0)::numeric)) AND (c.gltrans_amount > (0)::numeric)) AND (d.gltrans_doctype = 'JE'::text)) AND (c.gltrans_doctype = 'JE'::text)) AND (curr_symbol.curr_id = public.basecurrid())) ORDER BY d.gltrans_date DESC;


ALTER TABLE api.journalentry OWNER TO admin;

--
-- TOC entry 9315 (class 0 OID 0)
-- Dependencies: 341
-- Name: VIEW journalentry; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW journalentry IS 'Journal Entry';


SET search_path = public, pg_catalog;

--
-- TOC entry 342 (class 1259 OID 146567894)
-- Dependencies: 6215 8
-- Name: location; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE location (
    location_id integer DEFAULT nextval(('location_location_id_seq'::text)::regclass) NOT NULL,
    location_warehous_id integer NOT NULL,
    location_name text NOT NULL,
    location_descrip text,
    location_restrict boolean,
    location_netable boolean,
    location_whsezone_id integer,
    location_aisle text,
    location_rack text,
    location_bin text
);


ALTER TABLE public.location OWNER TO admin;


--
-- TOC entry 343 (class 1259 OID 146567901)
-- Dependencies: 8
-- Name: whsezone; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE whsezone (
    whsezone_id integer NOT NULL,
    whsezone_warehous_id integer NOT NULL,
    whsezone_name text NOT NULL,
    whsezone_descrip text
);


ALTER TABLE public.whsezone OWNER TO admin;

--
-- TOC entry 9319 (class 0 OID 0)
-- Dependencies: 343
-- Name: TABLE whsezone; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE whsezone IS 'Warehouse Zone information';


SET search_path = api, pg_catalog;

--
-- TOC entry 344 (class 1259 OID 146567907)
-- Dependencies: 8533 6
-- Name: location; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW location AS
    SELECT (whsinfo.warehous_code)::character varying AS site, (location.location_aisle)::character varying AS aisle, (location.location_rack)::character varying AS rack, (location.location_bin)::character varying AS bin, (location.location_name)::character varying AS location, whsezone.whsezone_name AS zone, location.location_netable AS netable, location.location_restrict AS restricted, location.location_descrip AS description FROM ((public.location LEFT JOIN public.whsinfo ON ((whsinfo.warehous_id = location.location_warehous_id))) LEFT JOIN public.whsezone ON ((whsezone.whsezone_id = location.location_whsezone_id)));


ALTER TABLE api.location OWNER TO admin;

--
-- TOC entry 9321 (class 0 OID 0)
-- Dependencies: 344
-- Name: VIEW location; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW location IS 'Location';


--
-- TOC entry 345 (class 1259 OID 146567912)
-- Dependencies: 8534 6
-- Name: misccounttag; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW misccounttag AS
    SELECT 'This view is for inserts only'::text AS site, 'This view is for inserts only'::text AS item_number, (0)::numeric AS quantity, 'This view is for inserts only'::text AS comment;


ALTER TABLE api.misccounttag OWNER TO admin;

--
-- TOC entry 9323 (class 0 OID 0)
-- Dependencies: 345
-- Name: VIEW misccounttag; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW misccounttag IS 'Miscellaneous Count Tag';


--
-- TOC entry 346 (class 1259 OID 146567916)
-- Dependencies: 8535 6
-- Name: pricingschedule; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW pricingschedule AS
    SELECT (ipshead.ipshead_name)::character varying AS name, ipshead.ipshead_descrip AS description, public.formatdate(ipshead.ipshead_effective, 'Always'::text) AS effective, public.formatdate(ipshead.ipshead_expires, 'Never'::text) AS expires, curr_symbol.curr_abbr AS currency FROM public.ipshead, public.curr_symbol WHERE (curr_symbol.curr_id = ipshead.ipshead_curr_id);


ALTER TABLE api.pricingschedule OWNER TO admin;

--
-- TOC entry 9325 (class 0 OID 0)
-- Dependencies: 346
-- Name: VIEW pricingschedule; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW pricingschedule IS 'Pricing Schedule';


SET search_path = public, pg_catalog;

--
-- TOC entry 347 (class 1259 OID 146567920)
-- Dependencies: 6218 8
-- Name: ipsass; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE ipsass (
    ipsass_id integer NOT NULL,
    ipsass_ipshead_id integer NOT NULL,
    ipsass_cust_id integer,
    ipsass_custtype_id integer,
    ipsass_custtype_pattern text,
    ipsass_shipto_id integer DEFAULT (-1),
    ipsass_shipto_pattern text
);


ALTER TABLE public.ipsass OWNER TO admin;


SET search_path = api, pg_catalog;

--
-- TOC entry 348 (class 1259 OID 146567927)
-- Dependencies: 8536 6
-- Name: pricingscheduleassign; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW pricingscheduleassign AS
    SELECT (COALESCE(custinfo.cust_number, 'Any'::text))::character varying AS customer_number, (COALESCE(shiptoinfo.shipto_num, 'Any'::text))::character varying AS customer_shipto, (COALESCE(ipsass.ipsass_shipto_pattern, 'N/A'::text))::character varying AS customer_shipto_pattern, (COALESCE(custtype.custtype_code, 'N/A'::text))::character varying AS customer_type, (COALESCE(ipsass.ipsass_custtype_pattern, 'N/A'::text))::character varying AS customer_type_pattern, (ipshead.ipshead_name)::character varying AS pricing_schedule FROM ((((public.ipshead JOIN public.ipsass ON ((ipshead.ipshead_id = ipsass.ipsass_ipshead_id))) LEFT JOIN public.custinfo ON ((ipsass.ipsass_cust_id = custinfo.cust_id))) LEFT JOIN public.custtype ON ((ipsass.ipsass_custtype_id = custtype.custtype_id))) LEFT JOIN public.shiptoinfo ON ((ipsass.ipsass_shipto_id = shiptoinfo.shipto_id))) ORDER BY (COALESCE(custinfo.cust_number, 'Any'::text))::character varying, (COALESCE(shiptoinfo.shipto_num, 'Any'::text))::character varying, (COALESCE(custtype.custtype_code, 'N/A'::text))::character varying, (COALESCE(ipsass.ipsass_custtype_pattern, 'N/A'::text))::character varying, (ipshead.ipshead_name)::character varying;


ALTER TABLE api.pricingscheduleassign OWNER TO admin;

--
-- TOC entry 9329 (class 0 OID 0)
-- Dependencies: 348
-- Name: VIEW pricingscheduleassign; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW pricingscheduleassign IS 'Pricing Schedule Assignments';


SET search_path = public, pg_catalog;

--
-- TOC entry 349 (class 1259 OID 146567932)
-- Dependencies: 6219 6220 6221 6222 8
-- Name: ipsiteminfo; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE ipsiteminfo (
    ipsitem_id integer DEFAULT nextval(('"ipsitem_ipsitem_id_seq"'::text)::regclass) NOT NULL,
    ipsitem_ipshead_id integer,
    ipsitem_item_id integer,
    ipsitem_qtybreak numeric(18,6) NOT NULL,
    ipsitem_price numeric(16,4) NOT NULL,
    ipsitem_qty_uom_id integer,
    ipsitem_price_uom_id integer,
    ipsitem_discntprcnt numeric(10,6) DEFAULT 0.00 NOT NULL,
    ipsitem_fixedamtdiscount numeric(16,4) DEFAULT 0.00 NOT NULL,
    ipsitem_prodcat_id integer,
    ipsitem_type character(1) NOT NULL,
    ipsitem_warehous_id integer,
    CONSTRAINT valid_ipsitem_type CHECK ((ipsitem_type = ANY (ARRAY['N'::bpchar, 'D'::bpchar, 'M'::bpchar])))
);


ALTER TABLE public.ipsiteminfo OWNER TO admin;

--
-- TOC entry 9331 (class 0 OID 0)
-- Dependencies: 349
-- Name: TABLE ipsiteminfo; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE ipsiteminfo IS 'Pricing Schedule Item information';


--
-- TOC entry 9332 (class 0 OID 0)
-- Dependencies: 349
-- Name: COLUMN ipsiteminfo.ipsitem_prodcat_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN ipsiteminfo.ipsitem_prodcat_id IS 'Product category for pricing schedule item.';


--
-- TOC entry 9333 (class 0 OID 0)
-- Dependencies: 349
-- Name: COLUMN ipsiteminfo.ipsitem_type; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN ipsiteminfo.ipsitem_type IS 'Pricing type for pricing schedule item.  Valid values are N-nominal, D-discount, and M-markup';


--
-- TOC entry 9334 (class 0 OID 0)
-- Dependencies: 349
-- Name: COLUMN ipsiteminfo.ipsitem_warehous_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN ipsiteminfo.ipsitem_warehous_id IS 'Site for pricing schedule item which enables pricing by site.';


SET search_path = api, pg_catalog;

--
-- TOC entry 350 (class 1259 OID 146567939)
-- Dependencies: 8537 6
-- Name: pricingscheduleitem; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW pricingscheduleitem AS
    SELECT (ipshead.ipshead_name)::character varying AS pricing_schedule, CASE WHEN (COALESCE(ipsiteminfo.ipsitem_item_id, (-1)) > 0) THEN 'Item'::character varying ELSE 'Product Category'::character varying END AS type, (COALESCE(item.item_number, ''::text))::character varying AS item_number, (COALESCE(prodcat.prodcat_code, ''::text))::character varying AS product_category, ipsiteminfo.ipsitem_qtybreak AS qty_break, (qtyuom.uom_name)::character varying AS qty_uom, (priceuom.uom_name)::character varying AS price_uom, ipsiteminfo.ipsitem_price AS price, ipsiteminfo.ipsitem_discntprcnt AS percent, ipsiteminfo.ipsitem_fixedamtdiscount AS fixedamt, CASE WHEN (ipsiteminfo.ipsitem_type = 'N'::bpchar) THEN 'Nominal'::character varying WHEN (ipsiteminfo.ipsitem_type = 'D'::bpchar) THEN 'Discount'::character varying WHEN (ipsiteminfo.ipsitem_type = 'M'::bpchar) THEN 'Markup'::character varying ELSE NULL::character varying END AS pricing_type FROM (((((public.ipsiteminfo JOIN public.ipshead ON ((ipsiteminfo.ipsitem_ipshead_id = ipshead.ipshead_id))) LEFT JOIN public.item ON ((ipsiteminfo.ipsitem_item_id = item.item_id))) LEFT JOIN public.prodcat ON ((ipsiteminfo.ipsitem_prodcat_id = prodcat.prodcat_id))) LEFT JOIN public.uom qtyuom ON ((ipsiteminfo.ipsitem_qty_uom_id = qtyuom.uom_id))) LEFT JOIN public.uom priceuom ON ((ipsiteminfo.ipsitem_price_uom_id = priceuom.uom_id)));


ALTER TABLE api.pricingscheduleitem OWNER TO admin;

--
-- TOC entry 9336 (class 0 OID 0)
-- Dependencies: 350
-- Name: VIEW pricingscheduleitem; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW pricingscheduleitem IS 'Pricing Schedule Item';


SET search_path = public, pg_catalog;

--
-- TOC entry 351 (class 1259 OID 146567944)
-- Dependencies: 8
-- Name: ipsitemchar; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE ipsitemchar (
    ipsitemchar_id integer NOT NULL,
    ipsitemchar_ipsitem_id integer NOT NULL,
    ipsitemchar_char_id integer NOT NULL,
    ipsitemchar_value text NOT NULL,
    ipsitemchar_price numeric(16,4)
);


ALTER TABLE public.ipsitemchar OWNER TO admin;

--
-- TOC entry 9338 (class 0 OID 0)
-- Dependencies: 351
-- Name: TABLE ipsitemchar; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE ipsitemchar IS 'Item Price Schedule Characteristic Prices.';


SET search_path = api, pg_catalog;

--
-- TOC entry 352 (class 1259 OID 146567950)
-- Dependencies: 8538 6
-- Name: pricingscheduleitemchar; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW pricingscheduleitemchar AS
    SELECT (ipshead.ipshead_name)::character varying AS pricing_schedule, (item.item_number)::character varying AS item_number, ipsiteminfo.ipsitem_qtybreak AS qty_break, (qtyuom.uom_name)::character varying AS qty_uom, (priceuom.uom_name)::character varying AS price_uom, ("char".char_name)::character varying AS characteristic, (ipsitemchar.ipsitemchar_value)::character varying AS value, ipsitemchar.ipsitemchar_price AS price FROM public.ipshead, public.ipsiteminfo, public.ipsitemchar, public.item, public."char", public.uom qtyuom, public.uom priceuom WHERE ((((((ipshead.ipshead_id = ipsiteminfo.ipsitem_ipshead_id) AND (ipsiteminfo.ipsitem_id = ipsitemchar.ipsitemchar_ipsitem_id)) AND (ipsiteminfo.ipsitem_item_id = item.item_id)) AND (ipsiteminfo.ipsitem_qty_uom_id = qtyuom.uom_id)) AND (ipsiteminfo.ipsitem_price_uom_id = priceuom.uom_id)) AND (ipsitemchar.ipsitemchar_char_id = "char".char_id));


ALTER TABLE api.pricingscheduleitemchar OWNER TO admin;

--
-- TOC entry 9340 (class 0 OID 0)
-- Dependencies: 352
-- Name: VIEW pricingscheduleitemchar; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW pricingscheduleitemchar IS 'Pricing Schedule Item Characteristics';


--
-- TOC entry 353 (class 1259 OID 146567955)
-- Dependencies: 8539 6
-- Name: project; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW project AS
    SELECT prj.prj_number AS number, prj.prj_name AS name, prj.prj_descrip AS description, prj.prj_owner_username AS owner, prj.prj_username AS assigned_to, prj.prj_so AS sales_orders, prj.prj_wo AS work_orders, prj.prj_po AS purchase_orders, CASE WHEN (prj.prj_status = 'P'::bpchar) THEN 'Concept'::text WHEN (prj.prj_status = 'O'::bpchar) THEN 'In-Process'::text WHEN (prj.prj_status = 'C'::bpchar) THEN 'Closed'::text ELSE 'Error'::text END AS status, prj.prj_due_date AS due, prj.prj_assigned_date AS assigned, prj.prj_start_date AS started, prj.prj_completed_date AS completed FROM public.prj;


ALTER TABLE api.project OWNER TO admin;

--
-- TOC entry 9342 (class 0 OID 0)
-- Dependencies: 353
-- Name: VIEW project; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW project IS 'Project';


--
-- TOC entry 354 (class 1259 OID 146567959)
-- Dependencies: 8540 6
-- Name: projectcomment; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW projectcomment AS
    SELECT (prj.prj_number)::character varying AS project_number, cmnttype.cmnttype_name AS type, comment.comment_date AS date, comment.comment_user AS username, comment.comment_text AS text FROM public.prj, public.cmnttype, public.comment WHERE (((comment.comment_source = 'J'::text) AND (comment.comment_source_id = prj.prj_id)) AND (comment.comment_cmnttype_id = cmnttype.cmnttype_id));


ALTER TABLE api.projectcomment OWNER TO admin;

--
-- TOC entry 9344 (class 0 OID 0)
-- Dependencies: 354
-- Name: VIEW projectcomment; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW projectcomment IS 'Project Comment';


SET search_path = public, pg_catalog;

--
-- TOC entry 355 (class 1259 OID 146567963)
-- Dependencies: 8
-- Name: cust_cust_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE cust_cust_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cust_cust_id_seq OWNER TO admin;

--
-- TOC entry 356 (class 1259 OID 146567965)
-- Dependencies: 6224 6225 6226 6227 8
-- Name: prospect; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE prospect (
    prospect_id integer DEFAULT nextval('cust_cust_id_seq'::regclass) NOT NULL,
    prospect_active boolean DEFAULT true NOT NULL,
    prospect_number text NOT NULL,
    prospect_name text NOT NULL,
    prospect_cntct_id integer,
    prospect_comments text,
    prospect_created date DEFAULT ('now'::text)::date NOT NULL,
    prospect_salesrep_id integer,
    prospect_warehous_id integer,
    prospect_taxzone_id integer,
    CONSTRAINT prospect_prospect_number_check CHECK ((prospect_number <> ''::text))
);


ALTER TABLE public.prospect OWNER TO admin;


SET search_path = api, pg_catalog;

--
-- TOC entry 357 (class 1259 OID 146567975)
-- Dependencies: 8541 6
-- Name: prospect; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW prospect AS
    SELECT (prospect.prospect_number)::character varying AS prospect_number, prospect.prospect_name, prospect.prospect_active AS active, salesrep.salesrep_number AS sales_rep, whsinfo.warehous_code AS site_code, taxzone.taxzone_code AS default_tax_zone, prospect.prospect_comments AS notes, cntct.cntct_number AS contact_number, cntct.cntct_honorific AS contact_honorific, cntct.cntct_first_name AS contact_first, cntct.cntct_middle AS contact_middle, cntct.cntct_last_name AS contact_last, cntct.cntct_suffix AS contact_suffix, cntct.cntct_title AS contact_job_title, cntct.cntct_phone AS contact_voice, cntct.cntct_phone2 AS contact_alternate, cntct.cntct_fax AS contact_fax, cntct.cntct_email AS contact_email, cntct.cntct_webaddr AS contact_web, ''::text AS contact_change, addr.addr_number AS contact_address_number, addr.addr_line1 AS contact_address1, addr.addr_line2 AS contact_address2, addr.addr_line3 AS contact_address3, addr.addr_city AS contact_city, addr.addr_state AS contact_state, addr.addr_postalcode AS contact_postalcode, addr.addr_country AS contact_country, ''::text AS contact_address_change FROM (((((public.prospect LEFT JOIN public.cntct ON ((prospect.prospect_cntct_id = cntct.cntct_id))) LEFT JOIN public.addr ON ((cntct.cntct_addr_id = addr.addr_id))) LEFT JOIN public.taxzone ON ((prospect.prospect_taxzone_id = taxzone.taxzone_id))) LEFT JOIN public.salesrep ON ((prospect.prospect_salesrep_id = salesrep.salesrep_id))) LEFT JOIN public.whsinfo ON ((prospect.prospect_warehous_id = whsinfo.warehous_id)));


ALTER TABLE api.prospect OWNER TO admin;

--
-- TOC entry 9349 (class 0 OID 0)
-- Dependencies: 357
-- Name: VIEW prospect; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW prospect IS 'Prospect';


SET search_path = public, pg_catalog;

--
-- TOC entry 358 (class 1259 OID 146567980)
-- Dependencies: 6229 8
-- Name: expcat; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE expcat (
    expcat_id integer NOT NULL,
    expcat_code text NOT NULL,
    expcat_descrip text,
    expcat_exp_accnt_id integer,
    expcat_liability_accnt_id integer,
    expcat_active boolean,
    expcat_purchprice_accnt_id integer,
    expcat_freight_accnt_id integer,
    CONSTRAINT expcat_expcat_code_check CHECK ((expcat_code <> ''::text))
);


ALTER TABLE public.expcat OWNER TO admin;

--
-- TOC entry 9351 (class 0 OID 0)
-- Dependencies: 358
-- Name: TABLE expcat; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE expcat IS 'Expense Category information';


--
-- TOC entry 359 (class 1259 OID 146567987)
-- Dependencies: 6230 6231 6232 6233 6234 6235 8
-- Name: womatl; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE womatl (
    womatl_id integer DEFAULT nextval(('womatl_womatl_id_seq'::text)::regclass) NOT NULL,
    womatl_wo_id integer,
    womatl_itemsite_id integer,
    womatl_qtyper numeric(20,8) NOT NULL,
    womatl_scrap numeric(8,4) NOT NULL,
    womatl_qtyreq numeric(18,6) NOT NULL,
    womatl_qtyiss numeric(18,6) NOT NULL,
    womatl_qtywipscrap numeric(18,6) NOT NULL,
    womatl_lastissue date,
    womatl_lastreturn date,
    womatl_cost numeric(16,6),
    womatl_picklist boolean,
    womatl_status character(1),
    womatl_imported boolean DEFAULT false,
    womatl_createwo boolean,
    womatl_issuemethod character(1),
    womatl_wooper_id integer,
    womatl_bomitem_id integer,
    womatl_duedate date,
    womatl_schedatwooper boolean,
    womatl_uom_id integer NOT NULL,
    womatl_notes text,
    womatl_ref text,
    womatl_scrapvalue numeric(16,6) DEFAULT 0,
    womatl_qtyfxd numeric(20,8) DEFAULT 0 NOT NULL,
    womatl_issuewo boolean DEFAULT false NOT NULL,
    womatl_price numeric(16,6) DEFAULT 0 NOT NULL
);


ALTER TABLE public.womatl OWNER TO admin;

--
-- TOC entry 9353 (class 0 OID 0)
-- Dependencies: 359
-- Name: TABLE womatl; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE womatl IS 'Work Order Material Requirements information';


--
-- TOC entry 9354 (class 0 OID 0)
-- Dependencies: 359
-- Name: COLUMN womatl.womatl_qtyfxd; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN womatl.womatl_qtyfxd IS 'The fixed quantity required';


SET search_path = api, pg_catalog;

--
-- TOC entry 360 (class 1259 OID 146567999)
-- Dependencies: 8542 6
-- Name: purchaseline; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW purchaseline AS
    SELECT (pohead.pohead_number)::character varying AS order_number, poitem.poitem_linenumber AS line_number, item.item_number, whsinfo.warehous_code AS site, expcat.expcat_code AS expense_category, poitem.poitem_qty_ordered AS qty_ordered, poitem.poitem_unitprice AS unit_price, poitem.poitem_freight AS freight, poitem.poitem_duedate AS due_date, prj.prj_number AS project_number, poitem.poitem_vend_item_number AS vend_item_number, poitem.poitem_vend_item_descrip AS vendor_description, poitem.poitem_manuf_name AS manufacturer_name, poitem.poitem_manuf_item_number AS manufacturer_item_number, poitem.poitem_manuf_item_descrip AS manufacturer_description, poitem.poitem_comments AS notes, public.formatrevnumber('BOM'::text, poitem.poitem_bom_rev_id) AS bill_of_materials_revision, public.formatrevnumber('BOO'::text, poitem.poitem_boo_rev_id) AS bill_of_operations_revision, public.formatsonumber(coitem.coitem_id) AS sales_order_number, public.formatwonumber(womatl.womatl_wo_id) AS work_order_number FROM ((((((((public.pohead JOIN public.poitem ON ((pohead.pohead_id = poitem.poitem_pohead_id))) LEFT JOIN public.prj ON ((poitem.poitem_prj_id = prj.prj_id))) LEFT JOIN public.expcat ON ((poitem.poitem_expcat_id = expcat.expcat_id))) LEFT JOIN public.itemsite ON ((poitem.poitem_itemsite_id = itemsite.itemsite_id))) LEFT JOIN public.item ON ((itemsite.itemsite_item_id = item.item_id))) LEFT JOIN public.whsinfo ON ((itemsite.itemsite_warehous_id = whsinfo.warehous_id))) LEFT JOIN public.coitem ON (((coitem.coitem_id = poitem.poitem_order_id) AND (poitem.poitem_order_type = 'S'::bpchar)))) LEFT JOIN public.womatl ON (((womatl.womatl_id = poitem.poitem_order_id) AND (poitem.poitem_order_type = 'W'::bpchar)))) ORDER BY pohead.pohead_number, poitem.poitem_linenumber;


ALTER TABLE api.purchaseline OWNER TO admin;

--
-- TOC entry 9356 (class 0 OID 0)
-- Dependencies: 360
-- Name: VIEW purchaseline; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW purchaseline IS 'Purchase Order Line';


--
-- TOC entry 361 (class 1259 OID 146568004)
-- Dependencies: 8543 6
-- Name: purchaselinechar; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW purchaselinechar AS
    SELECT (data.order_number)::character varying AS order_number, data.line_number, data.characteristic, COALESCE(pi.charass_value, i3.charass_value) AS value FROM (((((SELECT DISTINCT "char".char_id, poitem.poitem_id, poitem.poitem_itemsite_id, pohead.pohead_number AS order_number, poitem.poitem_linenumber AS line_number, "char".char_name AS characteristic FROM public.pohead, public.poitem, public.itemsite, public.item, public.charass, public."char" WHERE ((((((pohead.pohead_id = poitem.poitem_pohead_id) AND (poitem.poitem_itemsite_id = itemsite.itemsite_id)) AND (itemsite.itemsite_item_id = item.item_id)) AND (charass.charass_char_id = "char".char_id)) AND (charass.charass_target_type = 'I'::text)) AND (charass.charass_target_id = item.item_id))) data LEFT JOIN public.charass pi ON ((((data.poitem_id = pi.charass_target_id) AND ('PI'::text = pi.charass_target_type)) AND (pi.charass_char_id = data.char_id)))) LEFT JOIN public.itemsite i1 ON ((data.poitem_itemsite_id = i1.itemsite_id))) LEFT JOIN public.item i2 ON ((i1.itemsite_item_id = i2.item_id))) LEFT JOIN public.charass i3 ON (((((i2.item_id = i3.charass_target_id) AND ('I'::text = i3.charass_target_type)) AND (i3.charass_char_id = data.char_id)) AND i3.charass_default))) ORDER BY (data.order_number)::character varying, data.line_number, data.characteristic;


ALTER TABLE api.purchaselinechar OWNER TO admin;

--
-- TOC entry 9358 (class 0 OID 0)
-- Dependencies: 361
-- Name: VIEW purchaselinechar; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW purchaselinechar IS 'Purchase Order Line Item Characteristic';


--
-- TOC entry 362 (class 1259 OID 146568009)
-- Dependencies: 8544 6
-- Name: purchaselinecomment; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW purchaselinecomment AS
    SELECT (pohead.pohead_number)::character varying AS order_number, poitem.poitem_linenumber AS line_number, cmnttype.cmnttype_name AS type, comment.comment_date AS date, comment.comment_user AS username, comment.comment_text AS text FROM public.pohead, public.poitem, public.cmnttype, public.comment WHERE ((((pohead.pohead_id = poitem.poitem_pohead_id) AND (comment.comment_source = 'PI'::text)) AND (comment.comment_source_id = poitem.poitem_id)) AND (comment.comment_cmnttype_id = cmnttype.cmnttype_id)) ORDER BY pohead.pohead_number, poitem.poitem_linenumber, comment.comment_date DESC;


ALTER TABLE api.purchaselinecomment OWNER TO admin;

--
-- TOC entry 9360 (class 0 OID 0)
-- Dependencies: 362
-- Name: VIEW purchaselinecomment; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW purchaselinecomment IS 'Purchase Order Line Item Comment';


SET search_path = public, pg_catalog;

--
-- TOC entry 363 (class 1259 OID 146568014)
-- Dependencies: 6236 6237 8
-- Name: tax; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE tax (
    tax_id integer DEFAULT nextval(('"tax_tax_id_seq"'::text)::regclass) NOT NULL,
    tax_code text NOT NULL,
    tax_descrip text,
    tax_sales_accnt_id integer,
    tax_taxclass_id integer,
    tax_taxauth_id integer,
    tax_basis_tax_id integer,
    CONSTRAINT tax_tax_code_check CHECK ((tax_code <> ''::text))
);


ALTER TABLE public.tax OWNER TO admin;


--
-- TOC entry 364 (class 1259 OID 146568022)
-- Dependencies: 6238 8
-- Name: vendaddrinfo; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE vendaddrinfo (
    vendaddr_id integer DEFAULT nextval(('vendaddr_vendaddr_id_seq'::text)::regclass) NOT NULL,
    vendaddr_vend_id integer,
    vendaddr_code text,
    vendaddr_name text,
    vendaddr_comments text,
    vendaddr_cntct_id integer,
    vendaddr_addr_id integer,
    vendaddr_taxzone_id integer
);


ALTER TABLE public.vendaddrinfo OWNER TO admin;

--
-- TOC entry 9365 (class 0 OID 0)
-- Dependencies: 364
-- Name: TABLE vendaddrinfo; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE vendaddrinfo IS 'Vendor Address information';


SET search_path = api, pg_catalog;

--
-- TOC entry 365 (class 1259 OID 146568029)
-- Dependencies: 8545 6
-- Name: purchaseorder; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW purchaseorder AS
    SELECT (pohead.pohead_number)::character varying AS order_number, pohead.pohead_orderdate AS order_date, terms.terms_code AS terms, taxzone.taxzone_code AS tax_zone, whsinfo.warehous_code AS receiving_site, pohead.pohead_agent_username AS purchasing_agent, vendinfo.vend_number AS vendor_number, COALESCE(ua.vendaddr_code, 'MAIN'::text) AS alt_address, pohead.pohead_fob AS fob, pohead.pohead_shipvia AS ship_via, curr_symbol.curr_abbr AS currency, (SELECT COALESCE(sum(data.tax), 0.00) AS tax FROM (SELECT round(sum(calculatetaxdetailsummary.taxdetail_tax), 2) AS tax FROM (public.tax JOIN public.calculatetaxdetailsummary('PO'::text, pohead.pohead_id, 'T'::text) calculatetaxdetailsummary(taxdetail_tax_id, taxdetail_tax_code, taxdetail_tax_descrip, taxdetail_tax_basis_tax_id, taxdetail_taxrate_percent, taxdetail_taxrate_amount, taxdetail_level, taxdetail_taxclass_id, taxdetail_taxclass_code, taxdetail_taxclass_sequence, taxdetail_tax, taxdetail_curr_id, taxdetail_curr_abbr) ON ((calculatetaxdetailsummary.taxdetail_tax_id = tax.tax_id))) GROUP BY tax.tax_id) data) AS tax, pohead.pohead_freight AS freight, pohead.pohead_comments AS notes, pohead.pohead_dropship AS dropship, vc.cntct_number AS vend_contact_number, pohead.pohead_vend_cntct_honorific AS vend_cntct_honorific, pohead.pohead_vend_cntct_first_name AS vend_cntct_first_name, pohead.pohead_vend_cntct_middle AS vend_cntct_middle, pohead.pohead_vend_cntct_last_name AS vend_cntct_last_name, pohead.pohead_vend_cntct_suffix AS vend_cntct_suffix, pohead.pohead_vend_cntct_phone AS vend_cntct_phone, pohead.pohead_vend_cntct_title AS vend_cntct_title, pohead.pohead_vend_cntct_fax AS vend_cntct_fax, pohead.pohead_vend_cntct_email AS vend_cntct_email, pohead.pohead_vendaddress1 AS vendaddress1, pohead.pohead_vendaddress2 AS vendaddress2, pohead.pohead_vendaddress3 AS vendaddress3, pohead.pohead_vendcity AS vendcity, pohead.pohead_vendstate AS vendstate, pohead.pohead_vendzipcode AS vendzipcode, pohead.pohead_vendcountry AS vendcountry, sc.cntct_number AS shipto_contact_number, pohead.pohead_shipto_cntct_honorific AS shipto_cntct_honorific, pohead.pohead_shipto_cntct_first_name AS shipto_cntct_first_name, pohead.pohead_shipto_cntct_middle AS shipto_cntct_middle, pohead.pohead_shipto_cntct_last_name AS shipto_cntct_last_name, pohead.pohead_shipto_cntct_suffix AS shipto_cntct_suffix, pohead.pohead_shipto_cntct_phone AS shipto_cntct_phone, pohead.pohead_shipto_cntct_title AS shipto_cntct_title, pohead.pohead_shipto_cntct_fax AS shipto_cntct_fax, pohead.pohead_shipto_cntct_email AS shipto_cntct_email, addr.addr_number AS shiptoaddress_number, pohead.pohead_shiptoaddress1 AS shiptoaddress1, pohead.pohead_shiptoaddress2 AS shiptoaddress2, pohead.pohead_shiptoaddress3 AS shiptoaddress3, pohead.pohead_shiptocity AS shiptocity, pohead.pohead_shiptostate AS shiptostate, pohead.pohead_shiptozipcode AS shiptozipcode, pohead.pohead_shiptocountry AS shiptocountry, cohead.cohead_number AS sales_order_number FROM ((((((((((public.pohead LEFT JOIN public.cntct vc ON ((pohead.pohead_vend_cntct_id = vc.cntct_id))) LEFT JOIN public.cntct sc ON ((pohead.pohead_shipto_cntct_id = sc.cntct_id))) LEFT JOIN public.addr ON ((pohead.pohead_shiptoaddress_id = addr.addr_id))) LEFT JOIN public.terms ON ((pohead.pohead_terms_id = terms.terms_id))) LEFT JOIN public.taxzone ON ((pohead.pohead_taxzone_id = taxzone.taxzone_id))) LEFT JOIN public.whsinfo ON ((pohead.pohead_warehous_id = whsinfo.warehous_id))) LEFT JOIN public.vendaddrinfo ua ON ((pohead.pohead_vendaddr_id = ua.vendaddr_id))) LEFT JOIN public.cohead ON ((pohead.pohead_cohead_id = cohead.cohead_id))) JOIN public.vendinfo ON ((pohead.pohead_vend_id = vendinfo.vend_id))) JOIN public.curr_symbol ON ((pohead.pohead_curr_id = curr_symbol.curr_id))) ORDER BY pohead.pohead_number;


ALTER TABLE api.purchaseorder OWNER TO admin;

--
-- TOC entry 9367 (class 0 OID 0)
-- Dependencies: 365
-- Name: VIEW purchaseorder; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW purchaseorder IS 'Purchase Order';


--
-- TOC entry 366 (class 1259 OID 146568034)
-- Dependencies: 8546 6
-- Name: purchaseordercomment; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW purchaseordercomment AS
    SELECT (pohead.pohead_number)::character varying AS order_number, cmnttype.cmnttype_name AS type, comment.comment_date AS date, comment.comment_user AS username, comment.comment_text AS text FROM public.pohead, public.cmnttype, public.comment WHERE (((comment.comment_source = 'P'::text) AND (comment.comment_source_id = pohead.pohead_id)) AND (comment.comment_cmnttype_id = cmnttype.cmnttype_id));


ALTER TABLE api.purchaseordercomment OWNER TO admin;

--
-- TOC entry 9369 (class 0 OID 0)
-- Dependencies: 366
-- Name: VIEW purchaseordercomment; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW purchaseordercomment IS 'Purchase Order Comment';


SET search_path = public, pg_catalog;

--
-- TOC entry 367 (class 1259 OID 146568038)
-- Dependencies: 6239 6240 6241 6242 6243 6244 6245 6246 8
-- Name: quhead; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE quhead (
    quhead_id integer DEFAULT nextval(('"quhead_quhead_id_seq"'::text)::regclass) NOT NULL,
    quhead_number text NOT NULL,
    quhead_cust_id integer NOT NULL,
    quhead_quotedate date,
    quhead_shipto_id integer,
    quhead_shiptoname text,
    quhead_shiptoaddress1 text,
    quhead_shiptoaddress2 text,
    quhead_shiptoaddress3 text,
    quhead_shiptocity text,
    quhead_shiptostate text,
    quhead_shiptozipcode text,
    quhead_shiptophone text,
    quhead_salesrep_id integer,
    quhead_terms_id integer,
    quhead_freight numeric(16,4),
    quhead_ordercomments text,
    quhead_shipcomments text,
    quhead_billtoname text,
    quhead_billtoaddress1 text,
    quhead_billtoaddress2 text,
    quhead_billtoaddress3 text,
    quhead_billtocity text,
    quhead_billtostate text,
    quhead_billtozip text,
    quhead_commission numeric(16,4),
    quhead_custponumber text,
    quhead_fob text,
    quhead_shipvia text,
    quhead_warehous_id integer,
    quhead_packdate date,
    quhead_prj_id integer,
    quhead_misc numeric(16,4) DEFAULT 0 NOT NULL,
    quhead_misc_accnt_id integer,
    quhead_misc_descrip text,
    quhead_billtocountry text,
    quhead_shiptocountry text,
    quhead_curr_id integer DEFAULT basecurrid(),
    quhead_imported boolean DEFAULT false,
    quhead_expire date,
    quhead_calcfreight boolean DEFAULT false NOT NULL,
    quhead_shipto_cntct_id integer,
    quhead_shipto_cntct_honorific text,
    quhead_shipto_cntct_first_name text,
    quhead_shipto_cntct_middle text,
    quhead_shipto_cntct_last_name text,
    quhead_shipto_cntct_suffix text,
    quhead_shipto_cntct_phone text,
    quhead_shipto_cntct_title text,
    quhead_shipto_cntct_fax text,
    quhead_shipto_cntct_email text,
    quhead_billto_cntct_id integer,
    quhead_billto_cntct_honorific text,
    quhead_billto_cntct_first_name text,
    quhead_billto_cntct_middle text,
    quhead_billto_cntct_last_name text,
    quhead_billto_cntct_suffix text,
    quhead_billto_cntct_phone text,
    quhead_billto_cntct_title text,
    quhead_billto_cntct_fax text,
    quhead_billto_cntct_email text,
    quhead_taxzone_id integer,
    quhead_taxtype_id integer,
    quhead_ophead_id integer,
    quhead_status text,
    quhead_saletype_id integer,
    quhead_shipzone_id integer,
    CONSTRAINT quhead_check CHECK ((((quhead_misc = (0)::numeric) AND (quhead_misc_accnt_id IS NULL)) OR ((quhead_misc <> (0)::numeric) AND (quhead_misc_accnt_id IS NOT NULL)))),
    CONSTRAINT quhead_quhead_number_check CHECK ((quhead_number <> ''::text)),
    CONSTRAINT quhead_quhead_status_check CHECK ((((quhead_status = 'O'::text) OR (quhead_status = 'C'::text)) OR (quhead_status = 'X'::text)))
);


ALTER TABLE public.quhead OWNER TO admin;


SET search_path = api, pg_catalog;

--
-- TOC entry 368 (class 1259 OID 146568052)
-- Dependencies: 8547 6
-- Name: quote; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW quote AS
    SELECT (quhead.quhead_number)::character varying AS quote_number, whsinfo.warehous_code AS site, quhead.quhead_quotedate AS quote_date, quhead.quhead_packdate AS pack_date, saletype.saletype_code AS sale_type, salesrep.salesrep_number AS sales_rep, quhead.quhead_commission AS commission, taxzone.taxzone_code AS tax_zone, taxtype.taxtype_name AS tax_type, terms.terms_code AS terms, prj.prj_number AS project_number, COALESCE(custinfo.cust_number, prospect.prospect_number) AS customer_number, quhead.quhead_billtoname AS billto_name, quhead.quhead_billtoaddress1 AS billto_address1, quhead.quhead_billtoaddress2 AS billto_address2, quhead.quhead_billtoaddress3 AS billto_address3, quhead.quhead_billtocity AS billto_city, quhead.quhead_billtostate AS billto_state, quhead.quhead_billtozip AS billto_postal_code, quhead.quhead_billtocountry AS billto_country, shiptoinfo.shipto_num AS shipto_number, quhead.quhead_shiptoname AS shipto_name, quhead.quhead_shiptophone AS shipto_phone, quhead.quhead_shiptoaddress1 AS shipto_address1, quhead.quhead_shiptoaddress2 AS shipto_address2, quhead.quhead_shiptoaddress3 AS shipto_address3, quhead.quhead_shiptocity AS shipto_city, quhead.quhead_shiptostate AS shipto_state, quhead.quhead_shiptozipcode AS shipto_postal_code, quhead.quhead_shiptocountry AS shipto_country, shipzone.shipzone_name AS shipto_shipzone, quhead.quhead_custponumber AS cust_po_number, quhead.quhead_fob AS fob, quhead.quhead_shipvia AS ship_via, curr_symbol.curr_abbr AS currency, quhead.quhead_misc_descrip AS misc_charge_description, CASE WHEN (quhead.quhead_misc_accnt_id IS NULL) THEN NULL::text ELSE public.formatglaccount(quhead.quhead_misc_accnt_id) END AS misc_account_number, quhead.quhead_misc AS misc_charge, quhead.quhead_freight AS freight, quhead.quhead_ordercomments AS order_notes, quhead.quhead_shipcomments AS shipping_notes, false AS add_to_packing_list_batch, quhead.quhead_expire AS expire_date, CASE WHEN (quhead.quhead_status = 'C'::text) THEN 'Converted'::text ELSE 'Open'::text END AS status FROM public.curr_symbol, (((((((((((public.quhead LEFT JOIN public.whsinfo ON ((quhead.quhead_warehous_id = whsinfo.warehous_id))) LEFT JOIN public.prj ON ((quhead.quhead_prj_id = prj.prj_id))) LEFT JOIN public.shiptoinfo ON ((quhead.quhead_shipto_id = shiptoinfo.shipto_id))) LEFT JOIN public.taxzone ON ((quhead.quhead_taxzone_id = taxzone.taxzone_id))) LEFT JOIN public.taxtype ON ((quhead.quhead_taxtype_id = taxtype.taxtype_id))) LEFT JOIN public.custinfo ON ((quhead.quhead_cust_id = custinfo.cust_id))) LEFT JOIN public.prospect ON ((quhead.quhead_cust_id = prospect.prospect_id))) LEFT JOIN public.salesrep ON ((quhead.quhead_salesrep_id = salesrep.salesrep_id))) LEFT JOIN public.terms ON ((quhead.quhead_terms_id = terms.terms_id))) LEFT JOIN public.saletype ON ((quhead.quhead_saletype_id = saletype.saletype_id))) LEFT JOIN public.shipzone ON ((quhead.quhead_shipzone_id = shipzone.shipzone_id))) WHERE (quhead.quhead_curr_id = curr_symbol.curr_id);


ALTER TABLE api.quote OWNER TO admin;

--
-- TOC entry 9375 (class 0 OID 0)
-- Dependencies: 368
-- Name: VIEW quote; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW quote IS 'Quote';


--
-- TOC entry 369 (class 1259 OID 146568057)
-- Dependencies: 8548 6
-- Name: quotecomment; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW quotecomment AS
    SELECT quhead.quhead_number AS quote_number, cmnttype.cmnttype_name AS type, comment.comment_date AS date, comment.comment_user AS username, comment.comment_text AS text FROM public.quhead, public.cmnttype, public.comment WHERE (((comment.comment_source = 'Q'::text) AND (comment.comment_source_id = quhead.quhead_id)) AND (comment.comment_cmnttype_id = cmnttype.cmnttype_id));


ALTER TABLE api.quotecomment OWNER TO admin;

--
-- TOC entry 9377 (class 0 OID 0)
-- Dependencies: 369
-- Name: VIEW quotecomment; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW quotecomment IS 'Quote Comment';


SET search_path = public, pg_catalog;

--
-- TOC entry 370 (class 1259 OID 146568061)
-- Dependencies: 6247 6248 6249 6250 6251 8
-- Name: quitem; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE quitem (
    quitem_id integer DEFAULT nextval(('"quitem_quitem_id_seq"'::text)::regclass) NOT NULL,
    quitem_quhead_id integer,
    quitem_linenumber integer,
    quitem_itemsite_id integer,
    quitem_scheddate date,
    quitem_qtyord numeric(18,6),
    quitem_unitcost numeric(16,6),
    quitem_price numeric(16,4),
    quitem_custprice numeric(16,4),
    quitem_memo text,
    quitem_custpn text,
    quitem_createorder boolean,
    quitem_order_warehous_id integer,
    quitem_item_id integer,
    quitem_prcost numeric(16,6),
    quitem_imported boolean DEFAULT false,
    quitem_qty_uom_id integer NOT NULL,
    quitem_qty_invuomratio numeric(20,10) NOT NULL,
    quitem_price_uom_id integer NOT NULL,
    quitem_price_invuomratio numeric(20,10) NOT NULL,
    quitem_promdate date,
    quitem_taxtype_id integer,
    quitem_dropship boolean DEFAULT false,
    quitem_itemsrc_id integer,
    quitem_pricemode character(1) DEFAULT 'D'::bpchar NOT NULL,
    CONSTRAINT valid_quitem_pricemode CHECK ((quitem_pricemode = ANY (ARRAY['D'::bpchar, 'M'::bpchar])))
);


ALTER TABLE public.quitem OWNER TO admin;


SET search_path = api, pg_catalog;

--
-- TOC entry 371 (class 1259 OID 146568072)
-- Dependencies: 8549 6
-- Name: quoteline; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW quoteline AS
    SELECT quhead.quhead_number AS quote_number, quitem.quitem_linenumber AS line_number, l.item_number, quitem.quitem_custpn AS customer_pn, i.warehous_code AS sold_from_site, quitem.quitem_qtyord AS qty_ordered, q.uom_name AS qty_uom, quitem.quitem_price AS net_unit_price, p.uom_name AS price_uom, quitem.quitem_scheddate AS scheduled_date, COALESCE((SELECT taxtype.taxtype_name FROM public.taxtype WHERE (taxtype.taxtype_id = public.getitemtaxtype(l.item_id, quhead.quhead_taxzone_id))), 'None'::text) AS tax_type, CASE WHEN (quitem.quitem_price = (0)::numeric) THEN '100'::text WHEN (quitem.quitem_custprice = (0)::numeric) THEN 'N/A'::text ELSE (round((((1)::numeric - (quitem.quitem_price / quitem.quitem_custprice)) * (100)::numeric), 4))::text END AS discount_pct_from_list, quitem.quitem_createorder AS create_order, s.warehous_code AS supplying_site, quitem.quitem_prcost AS overwrite_po_price, quitem.quitem_memo AS notes FROM public.quhead, public.uom q, public.uom p, (public.quitem LEFT JOIN public.whsinfo s ON ((quitem.quitem_order_warehous_id = s.warehous_id))), public.itemsite il, public.item l, public.whsinfo i WHERE ((((((quhead.quhead_id = quitem.quitem_quhead_id) AND (quitem.quitem_itemsite_id = il.itemsite_id)) AND (il.itemsite_item_id = l.item_id)) AND (il.itemsite_warehous_id = i.warehous_id)) AND (quitem.quitem_qty_uom_id = q.uom_id)) AND (quitem.quitem_price_uom_id = p.uom_id)) ORDER BY quhead.quhead_number, quitem.quitem_linenumber;


ALTER TABLE api.quoteline OWNER TO admin;

--
-- TOC entry 9382 (class 0 OID 0)
-- Dependencies: 371
-- Name: VIEW quoteline; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW quoteline IS 'Quote Line Item';


--
-- TOC entry 372 (class 1259 OID 146568077)
-- Dependencies: 8550 6
-- Name: quotelinechar; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW quotelinechar AS
    SELECT DISTINCT quhead.quhead_number AS quote_number, quitem.quitem_linenumber AS line_number, "char".char_name AS characteristic, COALESCE((SELECT b.charass_value FROM public.charass b WHERE (((b.charass_target_type = 'QI'::text) AND (b.charass_target_id = quitem.quitem_id)) AND (b.charass_char_id = "char".char_id))), (SELECT c.charass_value FROM public.charass c WHERE ((((c.charass_target_type = 'I'::text) AND (c.charass_target_id = item.item_id)) AND c.charass_default) AND (c.charass_char_id = "char".char_id)) LIMIT 1)) AS value FROM public.quhead, public.quitem, public.itemsite, public.item, public.charass a, public."char" WHERE ((((((quhead.quhead_id = quitem.quitem_quhead_id) AND (quitem.quitem_itemsite_id = itemsite.itemsite_id)) AND (itemsite.itemsite_item_id = item.item_id)) AND (a.charass_char_id = "char".char_id)) AND (a.charass_target_type = 'I'::text)) AND (a.charass_target_id = item.item_id)) ORDER BY quhead.quhead_number, quitem.quitem_linenumber, "char".char_name;


ALTER TABLE api.quotelinechar OWNER TO admin;

--
-- TOC entry 9384 (class 0 OID 0)
-- Dependencies: 372
-- Name: VIEW quotelinechar; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW quotelinechar IS 'Quote Line Item Characteristics';


--
-- TOC entry 373 (class 1259 OID 146568082)
-- Dependencies: 8551 6
-- Name: quotelinecomment; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW quotelinecomment AS
    SELECT quhead.quhead_number AS quote_number, quitem.quitem_linenumber AS line_number, cmnttype.cmnttype_name AS type, comment.comment_date AS date, comment.comment_user AS username, comment.comment_text AS text FROM public.quhead, public.quitem, public.cmnttype, public.comment WHERE ((((quhead.quhead_id = quitem.quitem_quhead_id) AND (comment.comment_source = 'QI'::text)) AND (comment.comment_source_id = quitem.quitem_id)) AND (comment.comment_cmnttype_id = cmnttype.cmnttype_id)) ORDER BY quhead.quhead_number, quitem.quitem_linenumber, comment.comment_date DESC;


ALTER TABLE api.quotelinecomment OWNER TO admin;

--
-- TOC entry 9386 (class 0 OID 0)
-- Dependencies: 373
-- Name: VIEW quotelinecomment; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW quotelinecomment IS 'Quote Line Item Comment';


SET search_path = public, pg_catalog;

--
-- TOC entry 374 (class 1259 OID 146568087)
-- Dependencies: 6252 6253 8
-- Name: aropenalloc; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE aropenalloc (
    aropenalloc_aropen_id integer NOT NULL,
    aropenalloc_doctype character(1) NOT NULL,
    aropenalloc_doc_id integer NOT NULL,
    aropenalloc_amount numeric(20,2) DEFAULT 0.00 NOT NULL,
    aropenalloc_curr_id integer DEFAULT basecurrid()
);


ALTER TABLE public.aropenalloc OWNER TO admin;

SET search_path = api, pg_catalog;

--
-- TOC entry 375 (class 1259 OID 146568092)
-- Dependencies: 8552 6
-- Name: salescredit; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW salescredit AS
    SELECT custinfo.cust_number AS customer_number, aropen.aropen_docnumber AS cm_number, cohead.cohead_number AS so_number, (aropenalloc.aropenalloc_amount)::numeric(16,4) AS amount, curr.curr_abbr AS currency FROM ((((public.aropenalloc LEFT JOIN public.aropen ON ((aropen.aropen_id = aropenalloc.aropenalloc_aropen_id))) LEFT JOIN public.custinfo ON ((custinfo.cust_id = aropen.aropen_cust_id))) LEFT JOIN public.cohead ON (((aropenalloc.aropenalloc_doctype = 'S'::bpchar) AND (cohead.cohead_id = aropenalloc.aropenalloc_doc_id)))) LEFT JOIN public.curr_symbol curr ON ((curr.curr_id = aropenalloc.aropenalloc_curr_id))) WHERE (aropenalloc.aropenalloc_doctype = 'S'::bpchar);


ALTER TABLE api.salescredit OWNER TO admin;

--
-- TOC entry 9389 (class 0 OID 0)
-- Dependencies: 375
-- Name: VIEW salescredit; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW salescredit IS 'Payments (credit memos) pre-applied to sales orders';


SET search_path = public, pg_catalog;

--
-- TOC entry 376 (class 1259 OID 146568097)
-- Dependencies: 6254 6255 6256 8
-- Name: cohist; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE cohist (
    cohist_id integer DEFAULT nextval(('cohist_cohist_id_seq'::text)::regclass) NOT NULL,
    cohist_cust_id integer,
    cohist_itemsite_id integer,
    cohist_shipdate date,
    cohist_shipvia text,
    cohist_ordernumber text,
    cohist_orderdate date,
    cohist_invcnumber text,
    cohist_invcdate date,
    cohist_qtyshipped numeric(18,6),
    cohist_unitprice numeric(16,4),
    cohist_shipto_id integer,
    cohist_salesrep_id integer,
    cohist_duedate date,
    cohist_imported boolean DEFAULT false,
    cohist_billtoname text,
    cohist_billtoaddress1 text,
    cohist_billtoaddress2 text,
    cohist_billtoaddress3 text,
    cohist_billtocity text,
    cohist_billtostate text,
    cohist_billtozip text,
    cohist_shiptoname text,
    cohist_shiptoaddress1 text,
    cohist_shiptoaddress2 text,
    cohist_shiptoaddress3 text,
    cohist_shiptocity text,
    cohist_shiptostate text,
    cohist_shiptozip text,
    cohist_commission numeric(16,4),
    cohist_commissionpaid boolean,
    cohist_unitcost numeric(18,6),
    cohist_misc_type character(1),
    cohist_misc_descrip text,
    cohist_misc_id integer,
    cohist_doctype text,
    cohist_promisedate date,
    cohist_ponumber text,
    cohist_curr_id integer DEFAULT basecurrid(),
    cohist_sequence integer,
    cohist_taxtype_id integer,
    cohist_taxzone_id integer,
    cohist_cohead_ccpay_id integer,
    cohist_saletype_id integer,
    cohist_shipzone_id integer
);


ALTER TABLE public.cohist OWNER TO admin;

--
-- TOC entry 377 (class 1259 OID 146568106)
-- Dependencies: 8
-- Name: taxhist; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE taxhist (
    taxhist_id integer NOT NULL,
    taxhist_parent_id integer NOT NULL,
    taxhist_taxtype_id integer,
    taxhist_tax_id integer NOT NULL,
    taxhist_basis numeric(16,2) NOT NULL,
    taxhist_basis_tax_id integer,
    taxhist_sequence integer,
    taxhist_percent numeric(10,6) NOT NULL,
    taxhist_amount numeric(16,2) NOT NULL,
    taxhist_tax numeric(16,6) NOT NULL,
    taxhist_docdate date NOT NULL,
    taxhist_distdate date,
    taxhist_curr_id integer,
    taxhist_curr_rate numeric,
    taxhist_journalnumber integer
);


ALTER TABLE public.taxhist OWNER TO admin;


--
-- TOC entry 379 (class 1259 OID 146568114)
-- Dependencies: 377 8
-- Name: cohisttax; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE cohisttax (
)
INHERITS (taxhist);


ALTER TABLE public.cohisttax OWNER TO admin;

SET search_path = api, pg_catalog;

--
-- TOC entry 380 (class 1259 OID 146568120)
-- Dependencies: 8553 6
-- Name: saleshistory; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW saleshistory AS
    SELECT custinfo.cust_number AS customer_number, item.item_number, whsinfo.warehous_code AS site_code, cohist.cohist_shipdate AS ship_date, cohist.cohist_shipvia AS ship_via, cohist.cohist_ordernumber AS order_number, cohist.cohist_ponumber AS purchase_order_number, cohist.cohist_orderdate AS order_date, cohist.cohist_invcnumber AS invoice_number, cohist.cohist_invcdate AS invoice_date, cohist.cohist_qtyshipped AS quantity_shipped, cohist.cohist_unitprice AS unit_price, shiptoinfo.shipto_num AS shipto_number, salesrep.salesrep_number AS sales_rep, cohist.cohist_duedate AS due_date, cohist.cohist_promisedate AS promise_date, cohist.cohist_imported AS imported, cohist.cohist_billtoname AS billto_name, cohist.cohist_billtoaddress1 AS billto_address1, cohist.cohist_billtoaddress2 AS billto_address2, cohist.cohist_billtoaddress3 AS billto_address3, cohist.cohist_billtocity AS billto_city, cohist.cohist_billtostate AS billto_state, cohist.cohist_billtozip AS billto_zip, cohist.cohist_shiptoname AS shipto_name, cohist.cohist_shiptoaddress1 AS shipto_address1, cohist.cohist_shiptoaddress2 AS shipto_address2, cohist.cohist_shiptoaddress3 AS shipto_address3, cohist.cohist_shiptocity AS shipto_city, cohist.cohist_shiptostate AS shipto_state, cohist.cohist_shiptozip AS shipto_zip, cohist.cohist_commission AS commission, cohist.cohist_commissionpaid AS commission_paid, cohist.cohist_unitcost AS unit_cost, CASE WHEN (cohist.cohist_misc_type IS NULL) THEN ''::text WHEN (cohist.cohist_misc_type = 'M'::bpchar) THEN 'Misc. Charge'::text WHEN (cohist.cohist_misc_type = 'F'::bpchar) THEN 'Freight'::text ELSE 'Unknown'::text END AS misc_type, cohist.cohist_misc_descrip AS misc_description, CASE WHEN (cohist.cohist_misc_id IS NULL) THEN ''::text WHEN (cohist.cohist_misc_type = 'M'::bpchar) THEN public.formatglaccount(cohist.cohist_misc_id) ELSE 'Unknown'::text END AS misc_info, taxzone.taxzone_code AS tax_zone, taxtype.taxtype_name AS tax_type, CASE WHEN (cohist.cohist_doctype = 'I'::text) THEN 'Invoice'::text WHEN (cohist.cohist_doctype = 'C'::text) THEN 'Credit Memo'::text ELSE 'Unknown'::text END AS document_type, curr_symbol.curr_abbr AS currency, cohist.cohist_sequence AS gl_sequence, (SELECT sum(cohisttax.taxhist_tax) AS sum FROM public.cohisttax WHERE (cohisttax.taxhist_parent_id = cohist.cohist_id)) AS tax FROM (((((((((public.cohist LEFT JOIN public.custinfo ON ((cohist.cohist_cust_id = custinfo.cust_id))) LEFT JOIN public.shiptoinfo ON ((cohist.cohist_shipto_id = shiptoinfo.shipto_id))) LEFT JOIN public.taxzone ON ((cohist.cohist_taxzone_id = taxzone.taxzone_id))) LEFT JOIN public.taxtype ON ((cohist.cohist_taxtype_id = taxtype.taxtype_id))) LEFT JOIN public.salesrep ON ((cohist.cohist_salesrep_id = salesrep.salesrep_id))) LEFT JOIN public.itemsite ON ((cohist.cohist_itemsite_id = itemsite.itemsite_id))) LEFT JOIN public.item ON ((itemsite.itemsite_item_id = item.item_id))) LEFT JOIN public.whsinfo ON ((itemsite.itemsite_warehous_id = whsinfo.warehous_id))) LEFT JOIN public.curr_symbol ON ((cohist.cohist_curr_id = curr_symbol.curr_id)));


ALTER TABLE api.saleshistory OWNER TO admin;

--
-- TOC entry 9409 (class 0 OID 0)
-- Dependencies: 380
-- Name: VIEW saleshistory; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW saleshistory IS 'Sales History';


--
-- TOC entry 381 (class 1259 OID 146568125)
-- Dependencies: 8554 6
-- Name: saleslinechar; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW saleslinechar AS
    SELECT (data.order_number)::character varying AS order_number, data.line_number, data.characteristic, COALESCE(si.charass_value, i3.charass_value) AS value, (COALESCE(si.charass_price, public.itemcharprice(data.item_id, data.char_id, COALESCE(si.charass_value, i3.charass_value), data.cohead_cust_id, data.cohead_shipto_id, data.coitem_qtyord, data.cohead_curr_id, data.cohead_orderdate), (0)::numeric))::numeric(16,4) AS price FROM (((((SELECT DISTINCT cohead.cohead_cust_id, cohead.cohead_shipto_id, cohead.cohead_curr_id, cohead.cohead_orderdate, coitem.coitem_id, coitem.coitem_itemsite_id, coitem.coitem_qtyord, "char".char_id, item.item_id, cohead.cohead_number AS order_number, CASE WHEN (coitem.coitem_subnumber = 0) THEN ((coitem.coitem_linenumber)::character varying)::text ELSE ((((coitem.coitem_linenumber)::character varying)::text || ('.'::character varying)::text) || ((coitem.coitem_subnumber)::character varying)::text) END AS line_number, "char".char_name AS characteristic FROM public.cohead, public.coitem, public.itemsite, public.item, public.charass, public."char" WHERE ((((((cohead.cohead_id = coitem.coitem_cohead_id) AND (coitem.coitem_itemsite_id = itemsite.itemsite_id)) AND (itemsite.itemsite_item_id = item.item_id)) AND (charass.charass_char_id = "char".char_id)) AND (charass.charass_target_type = 'I'::text)) AND (charass.charass_target_id = item.item_id))) data LEFT JOIN public.charass si ON ((((data.coitem_id = si.charass_target_id) AND ('SI'::text = si.charass_target_type)) AND (si.charass_char_id = data.char_id)))) LEFT JOIN public.itemsite i1 ON ((data.coitem_itemsite_id = i1.itemsite_id))) LEFT JOIN public.item i2 ON ((i1.itemsite_item_id = i2.item_id))) LEFT JOIN public.charass i3 ON (((((i2.item_id = i3.charass_target_id) AND ('I'::text = i3.charass_target_type)) AND (i3.charass_char_id = data.char_id)) AND i3.charass_default))) ORDER BY (data.order_number)::character varying, data.line_number, data.characteristic;


ALTER TABLE api.saleslinechar OWNER TO admin;

--
-- TOC entry 9411 (class 0 OID 0)
-- Dependencies: 381
-- Name: VIEW saleslinechar; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW saleslinechar IS 'Sales Order Line Item Characteristic';


--
-- TOC entry 382 (class 1259 OID 146568130)
-- Dependencies: 8555 6
-- Name: saleslinecomment; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW saleslinecomment AS
    SELECT (cohead.cohead_number)::character varying AS order_number, CASE WHEN (coitem.coitem_subnumber = 0) THEN ((coitem.coitem_linenumber)::character varying)::text ELSE ((((coitem.coitem_linenumber)::character varying)::text || ('.'::character varying)::text) || ((coitem.coitem_subnumber)::character varying)::text) END AS line_number, cmnttype.cmnttype_name AS type, comment.comment_date AS date, comment.comment_user AS username, comment.comment_text AS text FROM public.cohead, public.coitem, public.cmnttype, public.comment WHERE ((((cohead.cohead_id = coitem.coitem_cohead_id) AND (comment.comment_source = 'SI'::text)) AND (comment.comment_source_id = coitem.coitem_id)) AND (comment.comment_cmnttype_id = cmnttype.cmnttype_id)) ORDER BY cohead.cohead_number, coitem.coitem_linenumber, comment.comment_date DESC;


ALTER TABLE api.saleslinecomment OWNER TO admin;

--
-- TOC entry 9413 (class 0 OID 0)
-- Dependencies: 382
-- Name: VIEW saleslinecomment; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW saleslinecomment IS 'Sales Order Line Item Comment';


--
-- TOC entry 383 (class 1259 OID 146568135)
-- Dependencies: 8556 6
-- Name: salesorder; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW salesorder AS
    SELECT (cohead.cohead_number)::character varying AS order_number, whsinfo.warehous_code AS site, cohead.cohead_orderdate AS order_date, cohead.cohead_packdate AS pack_date, saletype.saletype_code AS sale_type, salesrep.salesrep_number AS sales_rep, cohead.cohead_commission AS commission, COALESCE(taxzone.taxzone_code, 'None'::text) AS tax_zone, terms.terms_code AS terms, prj.prj_number AS project_number, custinfo.cust_number AS customer_number, bc.cntct_number AS billto_contact_number, cohead.cohead_billto_cntct_honorific AS billto_contact_name, cohead.cohead_billto_cntct_first_name AS billto_contact_first, cohead.cohead_billto_cntct_middle AS billto_contact_middle, cohead.cohead_billto_cntct_last_name AS billto_contact_last, cohead.cohead_billto_cntct_suffix AS billto_contact_suffix, cohead.cohead_billto_cntct_phone AS billto_contact_phone, cohead.cohead_billto_cntct_title AS billto_contact_title, cohead.cohead_billto_cntct_fax AS billto_contct_fax, cohead.cohead_billto_cntct_email AS billto_contact_email, cohead.cohead_billtoname AS billto_name, cohead.cohead_billtoaddress1 AS billto_address1, cohead.cohead_billtoaddress2 AS billto_address2, cohead.cohead_billtoaddress3 AS billto_address3, cohead.cohead_billtocity AS billto_city, cohead.cohead_billtostate AS billto_state, cohead.cohead_billtozipcode AS billto_postal_code, cohead.cohead_billtocountry AS billto_country, shiptoinfo.shipto_num AS shipto_number, sc.cntct_number AS shipto_contact_number, cohead.cohead_shipto_cntct_honorific AS shipto_contact_honorific, cohead.cohead_shipto_cntct_first_name AS shipto_contact_first, cohead.cohead_shipto_cntct_middle AS shipto_contact_middle, cohead.cohead_shipto_cntct_last_name AS shipto_contact_last, cohead.cohead_shipto_cntct_suffix AS shipto_contact_suffix, cohead.cohead_shipto_cntct_phone AS shipto_contact_phone, cohead.cohead_shipto_cntct_title AS shipto_contact_title, cohead.cohead_shipto_cntct_fax AS shipto_contact_fax, cohead.cohead_shipto_cntct_email AS shipto_contact_email, cohead.cohead_shiptoname AS shipto_name, cohead.cohead_shiptophone AS shipto_phone, cohead.cohead_shiptoaddress1 AS shipto_address1, cohead.cohead_shiptoaddress2 AS shipto_address2, cohead.cohead_shiptoaddress3 AS shipto_address3, cohead.cohead_shiptocity AS shipto_city, cohead.cohead_shiptostate AS shipto_state, cohead.cohead_shiptozipcode AS shipto_postal_code, cohead.cohead_shiptocountry AS shipto_country, shipzone.shipzone_name AS shipto_shipzone, cohead.cohead_custponumber AS cust_po_number, cohead.cohead_fob AS fob, cohead.cohead_shipvia AS ship_via, CASE WHEN (cohead.cohead_holdtype = 'N'::bpchar) THEN 'None'::text WHEN (cohead.cohead_holdtype = 'C'::bpchar) THEN 'Credit'::text WHEN (cohead.cohead_holdtype = 'S'::bpchar) THEN 'Shipping'::text WHEN (cohead.cohead_holdtype = 'P'::bpchar) THEN 'Packing'::text WHEN (cohead.cohead_holdtype = 'R'::bpchar) THEN 'Return'::text ELSE 'Error'::text END AS hold_type, shipchrg.shipchrg_name AS shipping_chgs, shipform.shipform_name AS shipping_form, cohead.cohead_shipcomplete AS ship_complete, curr_symbol.curr_abbr AS currency, cohead.cohead_misc_descrip AS misc_charge_description, CASE WHEN (cohead.cohead_misc_accnt_id IS NULL) THEN NULL::text ELSE public.formatglaccount(cohead.cohead_misc_accnt_id) END AS misc_account_number, cohead.cohead_misc AS misc_charge, cohead.cohead_freight AS freight, cohead.cohead_calcfreight AS calculate_freight, cohead.cohead_ordercomments AS order_notes, cohead.cohead_shipcomments AS shipping_notes, false AS add_to_packing_list_batch FROM (((((((((public.cohead LEFT JOIN public.cntct bc ON ((cohead.cohead_billto_cntct_id = bc.cntct_id))) LEFT JOIN public.cntct sc ON ((cohead.cohead_shipto_cntct_id = sc.cntct_id))) LEFT JOIN public.whsinfo ON ((cohead.cohead_warehous_id = whsinfo.warehous_id))) LEFT JOIN public.prj ON ((cohead.cohead_prj_id = prj.prj_id))) LEFT JOIN public.shiptoinfo ON ((cohead.cohead_shipto_id = shiptoinfo.shipto_id))) LEFT JOIN public.shipchrg ON ((cohead.cohead_shipchrg_id = shipchrg.shipchrg_id))) LEFT JOIN public.taxzone ON ((cohead.cohead_taxzone_id = taxzone.taxzone_id))) LEFT JOIN public.saletype ON ((cohead.cohead_saletype_id = saletype.saletype_id))) LEFT JOIN public.shipzone ON ((cohead.cohead_shipzone_id = shipzone.shipzone_id))), public.custinfo, public.shipform, public.salesrep, public.terms, public.curr_symbol WHERE (((((cohead.cohead_cust_id = custinfo.cust_id) AND (cohead.cohead_shipform_id = shipform.shipform_id)) AND (cohead.cohead_salesrep_id = salesrep.salesrep_id)) AND (cohead.cohead_terms_id = terms.terms_id)) AND (cohead.cohead_curr_id = curr_symbol.curr_id));


ALTER TABLE api.salesorder OWNER TO admin;

--
-- TOC entry 9415 (class 0 OID 0)
-- Dependencies: 383
-- Name: VIEW salesorder; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW salesorder IS 'Sales Order';


--
-- TOC entry 384 (class 1259 OID 146568140)
-- Dependencies: 8557 6
-- Name: salesordercomment; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW salesordercomment AS
    SELECT (cohead.cohead_number)::character varying AS order_number, cmnttype.cmnttype_name AS type, comment.comment_date AS date, comment.comment_user AS username, comment.comment_text AS text FROM public.cohead, public.cmnttype, public.comment WHERE (((comment.comment_source = 'S'::text) AND (comment.comment_source_id = cohead.cohead_id)) AND (comment.comment_cmnttype_id = cmnttype.cmnttype_id));


ALTER TABLE api.salesordercomment OWNER TO admin;

--
-- TOC entry 9417 (class 0 OID 0)
-- Dependencies: 384
-- Name: VIEW salesordercomment; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW salesordercomment IS 'Sales Order Comment';


--
-- TOC entry 385 (class 1259 OID 146568145)
-- Dependencies: 8558 6
-- Name: salesrep; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW salesrep AS
    SELECT (salesrep.salesrep_number)::character varying AS number, salesrep.salesrep_active AS active, salesrep.salesrep_name AS name, (salesrep.salesrep_commission * (100)::numeric) AS commission_percent, emp.emp_number AS employee FROM (public.salesrep LEFT JOIN public.emp ON ((emp.emp_id = salesrep.salesrep_emp_id))) ORDER BY salesrep.salesrep_number;


ALTER TABLE api.salesrep OWNER TO admin;

--
-- TOC entry 9419 (class 0 OID 0)
-- Dependencies: 385
-- Name: VIEW salesrep; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW salesrep IS 'Sales Rep';


SET search_path = public, pg_catalog;

--
-- TOC entry 386 (class 1259 OID 146568150)
-- Dependencies: 6259 6260 8
-- Name: shipvia; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE shipvia (
    shipvia_id integer DEFAULT nextval(('shipvia_shipvia_id_seq'::text)::regclass) NOT NULL,
    shipvia_code text NOT NULL,
    shipvia_descrip text,
    CONSTRAINT shipvia_shipvia_code_check CHECK ((shipvia_code <> ''::text))
);


ALTER TABLE public.shipvia OWNER TO admin;

--
-- TOC entry 9421 (class 0 OID 0)
-- Dependencies: 386
-- Name: TABLE shipvia; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE shipvia IS 'Ship Via information';


--
-- TOC entry 387 (class 1259 OID 146568158)
-- Dependencies: 6262 8
-- Name: sitetype; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE sitetype (
    sitetype_id integer NOT NULL,
    sitetype_name text NOT NULL,
    sitetype_descrip text,
    CONSTRAINT sitetype_sitetype_name_check CHECK ((sitetype_name <> ''::text))
);


ALTER TABLE public.sitetype OWNER TO admin;

--
-- TOC entry 9423 (class 0 OID 0)
-- Dependencies: 387
-- Name: TABLE sitetype; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE sitetype IS 'This table is the different types of sites.';


SET search_path = api, pg_catalog;

--
-- TOC entry 388 (class 1259 OID 146568165)
-- Dependencies: 8559 6
-- Name: site; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW site AS
    SELECT (whsinfo.warehous_code)::character varying AS code, st.sitetype_name AS type, whsinfo.warehous_active AS active, whsinfo.warehous_descrip AS description, m.addr_number AS address_number, m.addr_line1 AS address1, m.addr_line2 AS address2, m.addr_line3 AS address3, m.addr_city AS city, m.addr_state AS state, m.addr_postalcode AS postal_code, m.addr_country AS country, ''::text AS address_change, c.cntct_number AS contact_number, c.cntct_honorific AS honorific, c.cntct_first_name AS first, c.cntct_middle AS middle, c.cntct_last_name AS last, c.cntct_suffix AS suffix, c.cntct_title AS job_title, c.cntct_phone AS phone, c.cntct_fax AS fax, c.cntct_email AS email, ''::text AS contact_change, public.formatglaccount(a.accnt_id) AS post_unassigned_transactions_to, a.accnt_descrip AS post_unassigned_transactions_to_description, whsinfo.warehous_transit AS transit_type, CASE WHEN whsinfo.warehous_transit THEN false ELSE true END AS inventory_type, CASE WHEN whsinfo.warehous_transit THEN ''::text ELSE whsinfo.warehous_bol_prefix END AS next_bill_of_lading_prefix, CASE WHEN whsinfo.warehous_transit THEN 0 ELSE whsinfo.warehous_bol_number END AS next_bill_of_lading_number, CASE WHEN whsinfo.warehous_transit THEN false ELSE whsinfo.warehous_shipping END AS shipping_site, CASE WHEN whsinfo.warehous_transit THEN ''::text ELSE whsinfo.warehous_counttag_prefix END AS next_count_tag_prefix, CASE WHEN whsinfo.warehous_transit THEN 0 ELSE whsinfo.warehous_counttag_number END AS next_count_tag_number, CASE WHEN whsinfo.warehous_transit THEN false ELSE whsinfo.warehous_useslips END AS force_the_use_of_count_slips, CASE WHEN whsinfo.warehous_transit THEN false ELSE whsinfo.warehous_usezones END AS force_the_use_of_zones, CASE WHEN whsinfo.warehous_transit THEN 0 ELSE whsinfo.warehous_sequence END AS scheduling_sequence, CASE WHEN whsinfo.warehous_transit THEN (0)::numeric ELSE (whsinfo.warehous_shipping_commission * 100.0) END AS shipping_commission, CASE WHEN whsinfo.warehous_transit THEN ''::text ELSE t.taxzone_code END AS tax_zone, CASE WHEN whsinfo.warehous_transit THEN ''::text ELSE whsinfo.warehous_fob END AS default_fob, CASE WHEN whsinfo.warehous_transit THEN s.shipvia_code ELSE ''::text END AS default_ship_via, CASE WHEN whsinfo.warehous_transit THEN f.shipform_name ELSE ''::text END AS default_shipping_form, CASE WHEN whsinfo.warehous_transit THEN cc.costcat_code ELSE ''::text END AS default_cost_category, CASE WHEN whsinfo.warehous_transit THEN whsinfo.warehous_shipcomments ELSE ''::text END AS shipping_comments, CASE WHEN whsinfo.warehous_transit THEN false ELSE whsinfo.warehous_enforcearbl END AS enforce_arbl_naming_convention, CASE WHEN whsinfo.warehous_transit THEN 0 WHEN whsinfo.warehous_enforcearbl THEN whsinfo.warehous_aislesize ELSE 0 END AS aisle_size, CASE WHEN whsinfo.warehous_transit THEN false WHEN (whsinfo.warehous_enforcearbl AND whsinfo.warehous_aislealpha) THEN true ELSE false END AS aisle_allow_alpha_characters, CASE WHEN whsinfo.warehous_transit THEN 0 WHEN whsinfo.warehous_enforcearbl THEN whsinfo.warehous_racksize ELSE 0 END AS rack_size, CASE WHEN whsinfo.warehous_transit THEN false WHEN (whsinfo.warehous_enforcearbl AND whsinfo.warehous_rackalpha) THEN true ELSE false END AS rack_allow_alpha_characters, CASE WHEN whsinfo.warehous_transit THEN 0 WHEN whsinfo.warehous_enforcearbl THEN whsinfo.warehous_binsize ELSE 0 END AS bin_size, CASE WHEN whsinfo.warehous_transit THEN false WHEN (whsinfo.warehous_enforcearbl AND whsinfo.warehous_binalpha) THEN true ELSE false END AS bin_allow_alpha_characters, CASE WHEN whsinfo.warehous_transit THEN 0 WHEN whsinfo.warehous_enforcearbl THEN whsinfo.warehous_locationsize ELSE 0 END AS location_size, CASE WHEN whsinfo.warehous_transit THEN false WHEN (whsinfo.warehous_enforcearbl AND whsinfo.warehous_locationalpha) THEN true ELSE false END AS location_allow_alpha_characters FROM ((((((((public.whsinfo LEFT JOIN public.addr m ON ((whsinfo.warehous_addr_id = m.addr_id))) LEFT JOIN public.cntct c ON ((whsinfo.warehous_cntct_id = c.cntct_id))) LEFT JOIN public.accnt a ON ((whsinfo.warehous_default_accnt_id = a.accnt_id))) LEFT JOIN public.taxzone t ON ((whsinfo.warehous_taxzone_id = t.taxzone_id))) LEFT JOIN public.shipvia s ON ((whsinfo.warehous_shipvia_id = s.shipvia_id))) LEFT JOIN public.shipform f ON ((whsinfo.warehous_shipform_id = f.shipform_id))) LEFT JOIN public.costcat cc ON ((whsinfo.warehous_costcat_id = cc.costcat_id))) LEFT JOIN public.sitetype st ON ((whsinfo.warehous_sitetype_id = st.sitetype_id))) ORDER BY whsinfo.warehous_code;


ALTER TABLE api.site OWNER TO admin;

--
-- TOC entry 9425 (class 0 OID 0)
-- Dependencies: 388
-- Name: VIEW site; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW site IS 'Site';


--
-- TOC entry 389 (class 1259 OID 146568170)
-- Dependencies: 8560 6
-- Name: sitezone; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW sitezone AS
    SELECT (whsinfo.warehous_code)::character varying AS site, (whsezone.whsezone_name)::character varying AS name, whsezone.whsezone_descrip AS description FROM (public.whsezone LEFT JOIN public.whsinfo ON ((whsinfo.warehous_id = whsezone.whsezone_warehous_id)));


ALTER TABLE api.sitezone OWNER TO admin;

--
-- TOC entry 9427 (class 0 OID 0)
-- Dependencies: 389
-- Name: VIEW sitezone; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW sitezone IS 'Site Zone';


--
-- TOC entry 390 (class 1259 OID 146568175)
-- Dependencies: 8561 6
-- Name: task; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW task AS
    SELECT prj.prj_number AS project_number, prjtask.prjtask_number AS number, CASE WHEN (prjtask.prjtask_status = 'P'::bpchar) THEN 'Concept'::text WHEN (prjtask.prjtask_status = 'O'::bpchar) THEN 'In-Process'::text WHEN (prjtask.prjtask_status = 'C'::bpchar) THEN 'Closed'::text ELSE 'Error'::text END AS status, prjtask.prjtask_name AS name, prjtask.prjtask_descrip AS description, prjtask.prjtask_owner_username AS owner, prjtask.prjtask_username AS assigned_to, prjtask.prjtask_hours_budget AS hours_budgeted, prjtask.prjtask_hours_actual AS hours_actual, prjtask.prjtask_exp_budget AS expenses_budgeted, prjtask.prjtask_exp_actual AS expenses_actual, prjtask.prjtask_due_date AS due, prjtask.prjtask_assigned_date AS assigned, prjtask.prjtask_start_date AS started, prjtask.prjtask_completed_date AS completed FROM (public.prjtask JOIN public.prj ON ((prj.prj_id = prjtask.prjtask_prj_id)));


ALTER TABLE api.task OWNER TO admin;

--
-- TOC entry 9429 (class 0 OID 0)
-- Dependencies: 390
-- Name: VIEW task; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW task IS 'Task';


--
-- TOC entry 391 (class 1259 OID 146568180)
-- Dependencies: 8562 6
-- Name: taskcomment; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW taskcomment AS
    SELECT (prj.prj_number)::character varying AS project_number, (prjtask.prjtask_number)::character varying AS task_number, cmnttype.cmnttype_name AS type, comment.comment_date AS date, comment.comment_user AS username, comment.comment_text AS text FROM public.prj, public.prjtask, public.cmnttype, public.comment WHERE ((((comment.comment_source = 'TA'::text) AND (prj.prj_id = prjtask.prjtask_prj_id)) AND (comment.comment_source_id = prjtask.prjtask_id)) AND (comment.comment_cmnttype_id = cmnttype.cmnttype_id));


ALTER TABLE api.taskcomment OWNER TO admin;

--
-- TOC entry 9431 (class 0 OID 0)
-- Dependencies: 391
-- Name: VIEW taskcomment; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW taskcomment IS 'Task Comment';


--
-- TOC entry 392 (class 1259 OID 146568184)
-- Dependencies: 8563 6
-- Name: todo; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW todo AS
    SELECT todoitem.todoitem_id AS task_number, todoitem.todoitem_owner_username AS owner, todoitem.todoitem_username AS assigned_to, todoitem.todoitem_name AS task_name, incdtpriority.incdtpriority_name AS priority, incdt.incdt_number AS incident, ophead.ophead_name AS opportunity, crmacct.crmacct_number AS account, public.formatdate(todoitem.todoitem_due_date) AS date_due, public.formatdate(todoitem.todoitem_assigned_date) AS date_assigned, public.formatdate(todoitem.todoitem_start_date) AS date_started, public.formatdate(todoitem.todoitem_completed_date) AS date_completed, CASE WHEN (todoitem.todoitem_status = 'P'::bpchar) THEN 'Pending Input'::text WHEN (todoitem.todoitem_status = 'D'::bpchar) THEN 'Deferred'::text ELSE 'Neither'::text END AS status, todoitem.todoitem_active AS active, todoitem.todoitem_description AS description, todoitem.todoitem_notes AS notes FROM ((((public.todoitem LEFT JOIN public.incdt ON ((incdt.incdt_id = todoitem.todoitem_incdt_id))) LEFT JOIN public.ophead ON ((ophead.ophead_id = todoitem.todoitem_ophead_id))) LEFT JOIN public.crmacct ON ((crmacct.crmacct_id = todoitem.todoitem_crmacct_id))) LEFT JOIN public.incdtpriority ON ((incdtpriority.incdtpriority_id = todoitem.todoitem_priority_id)));


ALTER TABLE api.todo OWNER TO admin;

--
-- TOC entry 9433 (class 0 OID 0)
-- Dependencies: 392
-- Name: VIEW todo; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW todo IS 'To-Do List';


SET search_path = public, pg_catalog;

--
-- TOC entry 393 (class 1259 OID 146568189)
-- Dependencies: 6264 8
-- Name: vendtype; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE vendtype (
    vendtype_id integer NOT NULL,
    vendtype_code text NOT NULL,
    vendtype_descrip text,
    CONSTRAINT vendtype_vendtype_code_check CHECK ((vendtype_code <> ''::text))
);


ALTER TABLE public.vendtype OWNER TO admin;

--
-- TOC entry 9435 (class 0 OID 0)
-- Dependencies: 393
-- Name: TABLE vendtype; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE vendtype IS 'Vendor Type information';


SET search_path = api, pg_catalog;

--
-- TOC entry 394 (class 1259 OID 146568196)
-- Dependencies: 8564 6
-- Name: vendor; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW vendor AS
    SELECT (vendinfo.vend_number)::character varying AS vendor_number, vendtype.vendtype_code AS vendor_type, vendinfo.vend_name AS vendor_name, vendinfo.vend_active AS active, vendinfo.vend_accntnum AS account_number, addr.addr_number AS address_number, addr.addr_line1 AS address1, addr.addr_line2 AS address2, addr.addr_line3 AS address3, addr.addr_city AS city, addr.addr_state AS state, addr.addr_postalcode AS postalcode, addr.addr_country AS country, ''::text AS address_change, terms.terms_code AS default_terms, vendinfo.vend_shipvia AS ship_via, curr_symbol.curr_abbr AS default_currency, CASE WHEN (vendinfo.vend_fobsource = 'W'::bpchar) THEN 'Receiving Site'::text ELSE vendinfo.vend_fob END AS default_fob, vendinfo.vend_po AS sells_purchase_order_items, vendinfo.vend_restrictpurch AS may_only_sell_item_source, vendinfo.vend_qualified AS qualified, vendinfo.vend_match AS matching_vo_po_amounts, vendinfo.vend_1099 AS receives_1099, taxzone.taxzone_code AS default_tax_zone, CASE WHEN (accnt.accnt_id IS NULL) THEN 'N/A'::text ELSE public.formatglaccount(accnt.accnt_id) END AS default_dist_gl_account, CASE WHEN (expcat.expcat_id IS NULL) THEN 'N/A'::text ELSE expcat.expcat_code END AS default_dist_expense_category, CASE WHEN (tax.tax_id IS NULL) THEN 'N/A'::text ELSE tax.tax_code END AS default_dist_tax_code, c1.cntct_number AS contact1_number, c1.cntct_honorific AS contact1_honorific, c1.cntct_first_name AS contact1_first, c1.cntct_middle AS contact1_middle, c1.cntct_last_name AS contact1_last, c1.cntct_suffix AS contact1_suffix, c1.cntct_title AS contact1_job_title, c1.cntct_phone AS contact1_voice, c1.cntct_phone2 AS contact1_alternate, c1.cntct_fax AS contact1_fax, c1.cntct_email AS contact1_email, c1.cntct_webaddr AS contact1_web, ''::text AS contact1_change, c2.cntct_number AS contact2_number, c2.cntct_honorific AS contact2_honorific, c2.cntct_first_name AS contact2_first, c2.cntct_middle AS contact2_middle, c2.cntct_last_name AS contact2_last, c2.cntct_suffix AS contact2_suffix, c2.cntct_title AS contact2_job_title, c2.cntct_phone AS contact2_voice, c2.cntct_phone2 AS contact2_alternate, c2.cntct_fax AS contact2_fax, c2.cntct_email AS contact2_email, c2.cntct_webaddr AS contact2_web, ''::text AS contact2_change, vendinfo.vend_comments AS notes, vendinfo.vend_pocomments AS po_comments, vendinfo.vend_emailpodelivery AS allow_email_po_delivery, vendinfo.vend_ediemail AS po_edi_email, vendinfo.vend_edicc AS po_edi_cc, vendinfo.vend_edisubject AS po_edi_subject, vendinfo.vend_edifilename AS po_edi_filename, vendinfo.vend_ediemailbody AS po_edi_emailbody FROM ((((((((((public.vendinfo LEFT JOIN public.addr ON ((vendinfo.vend_addr_id = addr.addr_id))) LEFT JOIN public.cntct c1 ON ((vendinfo.vend_cntct1_id = c1.cntct_id))) LEFT JOIN public.cntct c2 ON ((vendinfo.vend_cntct2_id = c2.cntct_id))) LEFT JOIN public.taxzone ON ((vendinfo.vend_taxzone_id = taxzone.taxzone_id))) LEFT JOIN public.curr_symbol ON ((vendinfo.vend_curr_id = curr_symbol.curr_id))) LEFT JOIN public.terms ON ((vendinfo.vend_terms_id = terms.terms_id))) LEFT JOIN public.vendtype ON ((vendinfo.vend_vendtype_id = vendtype.vendtype_id))) LEFT JOIN public.accnt ON ((vendinfo.vend_accnt_id = accnt.accnt_id))) LEFT JOIN public.expcat ON ((vendinfo.vend_expcat_id = expcat.expcat_id))) LEFT JOIN public.tax ON ((vendinfo.vend_tax_id = tax.tax_id))) ORDER BY vendinfo.vend_number;


ALTER TABLE api.vendor OWNER TO admin;

--
-- TOC entry 9437 (class 0 OID 0)
-- Dependencies: 394
-- Name: VIEW vendor; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW vendor IS 'vendor';


--
-- TOC entry 395 (class 1259 OID 146568201)
-- Dependencies: 8565 6
-- Name: vendoraddress; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW vendoraddress AS
    SELECT (vendinfo.vend_number)::character varying AS vendor_number, vendinfo.vend_name AS vendor_name, (vendaddrinfo.vendaddr_code)::character varying AS vendor_address_number, vendaddrinfo.vendaddr_name AS vendor_address_name, addr.addr_number AS address_number, addr.addr_line1 AS address1, addr.addr_line2 AS address2, addr.addr_line3 AS address3, addr.addr_city AS city, addr.addr_state AS state, addr.addr_postalcode AS postalcode, addr.addr_country AS country, ''::text AS address_change, cntct.cntct_number AS contact_number, cntct.cntct_honorific AS contact_honorific, cntct.cntct_first_name AS contact_first, cntct.cntct_middle AS contact_middle, cntct.cntct_last_name AS contact_last, cntct.cntct_suffix AS contact_suffix, cntct.cntct_title AS contact_job_title, cntct.cntct_phone AS contact_voice, cntct.cntct_phone2 AS contact_alternate, cntct.cntct_fax AS contact_fax, cntct.cntct_email AS contact_email, cntct.cntct_webaddr AS contact_web, ''::text AS contact_change, vendaddrinfo.vendaddr_comments AS notes FROM (((public.vendaddrinfo LEFT JOIN public.vendinfo ON ((vendinfo.vend_id = vendaddrinfo.vendaddr_vend_id))) LEFT JOIN public.addr ON ((vendaddrinfo.vendaddr_addr_id = addr.addr_id))) LEFT JOIN public.cntct ON ((vendaddrinfo.vendaddr_cntct_id = cntct.cntct_id))) ORDER BY vendaddrinfo.vendaddr_code;


ALTER TABLE api.vendoraddress OWNER TO admin;

--
-- TOC entry 9439 (class 0 OID 0)
-- Dependencies: 395
-- Name: VIEW vendoraddress; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW vendoraddress IS 'vendor address';


--
-- TOC entry 396 (class 1259 OID 146568206)
-- Dependencies: 8566 6
-- Name: vendortype; Type: VIEW; Schema: api; Owner: admin
--

CREATE VIEW vendortype AS
    SELECT (vendtype.vendtype_code)::character varying AS code, vendtype.vendtype_descrip AS description FROM public.vendtype ORDER BY vendtype.vendtype_code;


ALTER TABLE api.vendortype OWNER TO admin;

--
-- TOC entry 9441 (class 0 OID 0)
-- Dependencies: 396
-- Name: VIEW vendortype; Type: COMMENT; Schema: api; Owner: admin
--

COMMENT ON VIEW vendortype IS 'Vendor Type';


SET search_path = public, pg_catalog;

--
-- TOC entry 397 (class 1259 OID 146568210)
-- Dependencies: 8
-- Name: cmd; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE cmd (
    cmd_id integer NOT NULL,
    cmd_module text NOT NULL,
    cmd_title text NOT NULL,
    cmd_descrip text,
    cmd_privname text,
    cmd_executable text NOT NULL,
    cmd_name text
);


ALTER TABLE public.cmd OWNER TO admin;

--
-- TOC entry 9443 (class 0 OID 0)
-- Dependencies: 397
-- Name: TABLE cmd; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE cmd IS 'Custom menu command table.';


--
-- TOC entry 398 (class 1259 OID 146568216)
-- Dependencies: 397 8
-- Name: cmd_cmd_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE cmd_cmd_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cmd_cmd_id_seq OWNER TO admin;

--
-- TOC entry 9445 (class 0 OID 0)
-- Dependencies: 398
-- Name: cmd_cmd_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE cmd_cmd_id_seq OWNED BY cmd.cmd_id;


SET search_path = public, pg_catalog;

--
-- TOC entry 400 (class 1259 OID 146568226)
-- Dependencies: 8
-- Name: cmdarg; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE cmdarg (
    cmdarg_id integer NOT NULL,
    cmdarg_cmd_id integer NOT NULL,
    cmdarg_order integer NOT NULL,
    cmdarg_arg text NOT NULL
);


ALTER TABLE public.cmdarg OWNER TO admin;

--
-- TOC entry 9448 (class 0 OID 0)
-- Dependencies: 400
-- Name: TABLE cmdarg; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE cmdarg IS 'Command argument for custom menu command table.';


--
-- TOC entry 401 (class 1259 OID 146568232)
-- Dependencies: 400 8
-- Name: cmdarg_cmdarg_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE cmdarg_cmdarg_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cmdarg_cmdarg_id_seq OWNER TO admin;

--
-- TOC entry 9450 (class 0 OID 0)
-- Dependencies: 401
-- Name: cmdarg_cmdarg_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE cmdarg_cmdarg_id_seq OWNED BY cmdarg.cmdarg_id;


SET search_path = public, pg_catalog;

--
-- TOC entry 403 (class 1259 OID 146568242)
-- Dependencies: 8
-- Name: image_image_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE image_image_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.image_image_id_seq OWNER TO admin;

SET search_path = public, pg_catalog;

--
-- TOC entry 405 (class 1259 OID 146568251)
-- Dependencies: 6271 8
-- Name: metasql; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE metasql (
    metasql_id integer NOT NULL,
    metasql_group text,
    metasql_name text,
    metasql_notes text,
    metasql_query text,
    metasql_lastuser text,
    metasql_lastupdate date,
    metasql_grade integer DEFAULT 0 NOT NULL
);


ALTER TABLE public.metasql OWNER TO admin;

--
-- TOC entry 9455 (class 0 OID 0)
-- Dependencies: 405
-- Name: TABLE metasql; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE metasql IS 'MetaSQL Table';


--
-- TOC entry 406 (class 1259 OID 146568258)
-- Dependencies: 405 8
-- Name: metasql_metasql_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE metasql_metasql_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.metasql_metasql_id_seq OWNER TO admin;

--
-- TOC entry 9457 (class 0 OID 0)
-- Dependencies: 406
-- Name: metasql_metasql_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE metasql_metasql_id_seq OWNED BY metasql.metasql_id;

SET search_path = public, pg_catalog;

--
-- TOC entry 408 (class 1259 OID 146568269)
-- Dependencies: 6274 8
-- Name: priv; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE priv (
    priv_id integer DEFAULT nextval(('priv_priv_id_seq'::text)::regclass) NOT NULL,
    priv_module text,
    priv_name text,
    priv_descrip text,
    priv_seq integer
);


ALTER TABLE public.priv OWNER TO admin;


--
-- TOC entry 409 (class 1259 OID 146568276)
-- Dependencies: 8
-- Name: priv_priv_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE priv_priv_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.priv_priv_id_seq OWNER TO admin;

SET search_path = public, pg_catalog;

--
-- TOC entry 411 (class 1259 OID 146568285)
-- Dependencies: 6276 8
-- Name: report; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE report (
    report_id integer DEFAULT nextval(('report_report_id_seq'::text)::regclass) NOT NULL,
    report_name text,
    report_sys boolean,
    report_source text,
    report_descrip text,
    report_grade integer NOT NULL,
    report_loaddate timestamp without time zone
);


ALTER TABLE public.report OWNER TO admin;

--
-- TOC entry 9464 (class 0 OID 0)
-- Dependencies: 411
-- Name: TABLE report; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE report IS 'Report definition information';


--
-- TOC entry 412 (class 1259 OID 146568292)
-- Dependencies: 8
-- Name: report_report_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE report_report_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.report_report_id_seq OWNER TO admin;

SET search_path = public, pg_catalog;

--
-- TOC entry 414 (class 1259 OID 146568301)
-- Dependencies: 6279 8
-- Name: script; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE script (
    script_id integer NOT NULL,
    script_name text NOT NULL,
    script_order integer NOT NULL,
    script_enabled boolean DEFAULT false NOT NULL,
    script_source text NOT NULL,
    script_notes text
);


ALTER TABLE public.script OWNER TO admin;

--
-- TOC entry 415 (class 1259 OID 146568308)
-- Dependencies: 414 8
-- Name: script_script_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE script_script_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.script_script_id_seq OWNER TO admin;

--
-- TOC entry 9469 (class 0 OID 0)
-- Dependencies: 415
-- Name: script_script_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE script_script_id_seq OWNED BY script.script_id;

SET search_path = public, pg_catalog;

--
-- TOC entry 417 (class 1259 OID 146568319)
-- Dependencies: 6283 8
-- Name: uiform; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE uiform (
    uiform_id integer NOT NULL,
    uiform_name text NOT NULL,
    uiform_order integer NOT NULL,
    uiform_enabled boolean DEFAULT false NOT NULL,
    uiform_source text NOT NULL,
    uiform_notes text
);


ALTER TABLE public.uiform OWNER TO admin;

--
-- TOC entry 418 (class 1259 OID 146568326)
-- Dependencies: 417 8
-- Name: uiform_uiform_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE uiform_uiform_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.uiform_uiform_id_seq OWNER TO admin;

--
-- TOC entry 9473 (class 0 OID 0)
-- Dependencies: 418
-- Name: uiform_uiform_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE uiform_uiform_id_seq OWNED BY uiform.uiform_id;


SET search_path = public, pg_catalog;

--
-- TOC entry 420 (class 1259 OID 146568337)
-- Dependencies: 6286 8
-- Name: acalitem; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE acalitem (
    acalitem_id integer DEFAULT nextval(('"xcalitem_xcalitem_id_seq"'::text)::regclass) NOT NULL,
    acalitem_calhead_id integer,
    acalitem_periodstart date,
    acalitem_periodlength integer,
    acalitem_name text
);


ALTER TABLE public.acalitem OWNER TO admin;

--
-- TOC entry 9476 (class 0 OID 0)
-- Dependencies: 420
-- Name: TABLE acalitem; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE acalitem IS 'Absolute Calendar Item information';


--
-- TOC entry 421 (class 1259 OID 146568344)
-- Dependencies: 8
-- Name: accnt_accnt_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE accnt_accnt_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.accnt_accnt_id_seq OWNER TO admin;

--
-- TOC entry 422 (class 1259 OID 146568346)
-- Dependencies: 234 8
-- Name: addr_addr_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE addr_addr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.addr_addr_id_seq OWNER TO admin;

--
-- TOC entry 9479 (class 0 OID 0)
-- Dependencies: 422
-- Name: addr_addr_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE addr_addr_id_seq OWNED BY addr.addr_id;


--
-- TOC entry 423 (class 1259 OID 146568348)
-- Dependencies: 8567 8
-- Name: address; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW address AS
    SELECT addresses.addr_id, addresses.addr_active, addresses.addr_line1, addresses.addr_line2, addresses.addr_line3, addresses.addr_city, addresses.addr_state, addresses.addr_postalcode, addresses.addr_country, addresses.addr_notes, addresses.addr_number, addresses.crmacct_id, addresses.crmacct_number, addresses.crmacct_name FROM ((((SELECT base.addr_id, base.addr_active, base.addr_line1, base.addr_line2, base.addr_line3, base.addr_city, base.addr_state, base.addr_postalcode, base.addr_country, base.addr_notes, base.addr_number, base.crmacct_id, base.crmacct_number, base.crmacct_name FROM ((((SELECT addr.addr_id, addr.addr_active, addr.addr_line1, addr.addr_line2, addr.addr_line3, addr.addr_city, addr.addr_state, addr.addr_postalcode, addr.addr_country, addr.addr_notes, addr.addr_number, COALESCE(crmacct.crmacct_id, (-1)) AS crmacct_id, crmacct.crmacct_number, crmacct.crmacct_name FROM ((addr LEFT JOIN cntct ON ((cntct.cntct_addr_id = addr.addr_id))) LEFT JOIN crmacct ON ((crmacct.crmacct_id = cntct.cntct_crmacct_id))) EXCEPT SELECT addr.addr_id, addr.addr_active, addr.addr_line1, addr.addr_line2, addr.addr_line3, addr.addr_city, addr.addr_state, addr.addr_postalcode, addr.addr_country, addr.addr_notes, addr.addr_number, (-1), NULL::text AS unknown, NULL::text AS unknown FROM ((addr JOIN vendinfo ON ((vendinfo.vend_addr_id = addr.addr_id))) JOIN crmacct ON ((vendinfo.vend_id = crmacct.crmacct_vend_id)))) EXCEPT SELECT addr.addr_id, addr.addr_active, addr.addr_line1, addr.addr_line2, addr.addr_line3, addr.addr_city, addr.addr_state, addr.addr_postalcode, addr.addr_country, addr.addr_notes, addr.addr_number, (-1), NULL::text AS unknown, NULL::text AS unknown FROM ((addr JOIN vendaddrinfo ON ((vendaddrinfo.vendaddr_addr_id = addr.addr_id))) JOIN crmacct ON ((vendaddrinfo.vendaddr_vend_id = crmacct.crmacct_vend_id)))) EXCEPT SELECT addr.addr_id, addr.addr_active, addr.addr_line1, addr.addr_line2, addr.addr_line3, addr.addr_city, addr.addr_state, addr.addr_postalcode, addr.addr_country, addr.addr_notes, addr.addr_number, (-1), NULL::text AS unknown, NULL::text AS unknown FROM ((addr JOIN taxauth ON ((taxauth.taxauth_addr_id = addr.addr_id))) JOIN crmacct ON ((taxauth.taxauth_id = crmacct.crmacct_taxauth_id)))) EXCEPT SELECT addr.addr_id, addr.addr_active, addr.addr_line1, addr.addr_line2, addr.addr_line3, addr.addr_city, addr.addr_state, addr.addr_postalcode, addr.addr_country, addr.addr_notes, addr.addr_number, (-1), NULL::text AS unknown, NULL::text AS unknown FROM ((addr JOIN shiptoinfo ON ((shiptoinfo.shipto_addr_id = addr.addr_id))) JOIN crmacct ON ((shiptoinfo.shipto_cust_id = crmacct.crmacct_cust_id)))) base UNION SELECT addr.addr_id, addr.addr_active, addr.addr_line1, addr.addr_line2, addr.addr_line3, addr.addr_city, addr.addr_state, addr.addr_postalcode, addr.addr_country, addr.addr_notes, addr.addr_number, crmacct.crmacct_id, crmacct.crmacct_number, crmacct.crmacct_name FROM ((addr JOIN vendinfo ON ((vendinfo.vend_addr_id = addr.addr_id))) JOIN crmacct ON ((vendinfo.vend_id = crmacct.crmacct_vend_id)))) UNION SELECT addr.addr_id, addr.addr_active, addr.addr_line1, addr.addr_line2, addr.addr_line3, addr.addr_city, addr.addr_state, addr.addr_postalcode, addr.addr_country, addr.addr_notes, addr.addr_number, crmacct.crmacct_id, crmacct.crmacct_number, crmacct.crmacct_name FROM ((addr JOIN vendaddrinfo ON ((vendaddrinfo.vendaddr_addr_id = addr.addr_id))) JOIN crmacct ON ((vendaddrinfo.vendaddr_vend_id = crmacct.crmacct_vend_id)))) UNION SELECT addr.addr_id, addr.addr_active, addr.addr_line1, addr.addr_line2, addr.addr_line3, addr.addr_city, addr.addr_state, addr.addr_postalcode, addr.addr_country, addr.addr_notes, addr.addr_number, crmacct.crmacct_id, crmacct.crmacct_number, crmacct.crmacct_name FROM ((addr JOIN taxauth ON ((taxauth.taxauth_addr_id = addr.addr_id))) JOIN crmacct ON ((taxauth.taxauth_id = crmacct.crmacct_taxauth_id)))) UNION SELECT addr.addr_id, addr.addr_active, addr.addr_line1, addr.addr_line2, addr.addr_line3, addr.addr_city, addr.addr_state, addr.addr_postalcode, addr.addr_country, addr.addr_notes, addr.addr_number, crmacct.crmacct_id, crmacct.crmacct_number, crmacct.crmacct_name FROM ((addr JOIN shiptoinfo ON ((shiptoinfo.shipto_addr_id = addr.addr_id))) JOIN crmacct ON ((shiptoinfo.shipto_cust_id = crmacct.crmacct_cust_id)))) addresses ORDER BY addresses.addr_country, addresses.addr_state, addresses.addr_postalcode, addresses.addr_line1, addresses.addr_line2, addresses.addr_line3;


ALTER TABLE public.address OWNER TO admin;

--
-- TOC entry 424 (class 1259 OID 146568353)
-- Dependencies: 6287 6288 6289 8
-- Name: alarm; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE alarm (
    alarm_id integer NOT NULL,
    alarm_number text NOT NULL,
    alarm_event boolean DEFAULT false NOT NULL,
    alarm_email boolean DEFAULT false NOT NULL,
    alarm_sysmsg boolean DEFAULT false NOT NULL,
    alarm_trigger timestamp with time zone,
    alarm_time timestamp with time zone,
    alarm_time_offset integer,
    alarm_time_qualifier text,
    alarm_creator text,
    alarm_event_recipient text,
    alarm_email_recipient text,
    alarm_sysmsg_recipient text,
    alarm_source text,
    alarm_source_id integer
);


ALTER TABLE public.alarm OWNER TO admin;

--
-- TOC entry 9482 (class 0 OID 0)
-- Dependencies: 424
-- Name: TABLE alarm; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE alarm IS 'This table is the open alarms.';


--
-- TOC entry 425 (class 1259 OID 146568362)
-- Dependencies: 424 8
-- Name: alarm_alarm_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE alarm_alarm_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.alarm_alarm_id_seq OWNER TO admin;

--
-- TOC entry 9484 (class 0 OID 0)
-- Dependencies: 425
-- Name: alarm_alarm_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE alarm_alarm_id_seq OWNED BY alarm.alarm_id;


--
-- TOC entry 426 (class 1259 OID 146568364)
-- Dependencies: 8
-- Name: apaccnt; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE apaccnt (
    apaccnt_id integer NOT NULL,
    apaccnt_vendtype_id integer,
    apaccnt_vendtype text,
    apaccnt_ap_accnt_id integer NOT NULL,
    apaccnt_prepaid_accnt_id integer,
    apaccnt_discount_accnt_id integer
);


ALTER TABLE public.apaccnt OWNER TO admin;

--
-- TOC entry 9486 (class 0 OID 0)
-- Dependencies: 426
-- Name: TABLE apaccnt; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE apaccnt IS 'Accounts Payable (A/P) Account assignment information';


--
-- TOC entry 427 (class 1259 OID 146568370)
-- Dependencies: 426 8
-- Name: apaccnt_apaccnt_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE apaccnt_apaccnt_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.apaccnt_apaccnt_id_seq OWNER TO admin;

--
-- TOC entry 9488 (class 0 OID 0)
-- Dependencies: 427
-- Name: apaccnt_apaccnt_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE apaccnt_apaccnt_id_seq OWNED BY apaccnt.apaccnt_id;


--
-- TOC entry 428 (class 1259 OID 146568372)
-- Dependencies: 6293 8
-- Name: apapply; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE apapply (
    apapply_id integer NOT NULL,
    apapply_vend_id integer,
    apapply_postdate date,
    apapply_username text,
    apapply_source_apopen_id integer,
    apapply_source_doctype text,
    apapply_source_docnumber text,
    apapply_target_apopen_id integer,
    apapply_target_doctype text,
    apapply_target_docnumber text,
    apapply_journalnumber integer,
    apapply_amount numeric(20,2),
    apapply_curr_id integer DEFAULT basecurrid(),
    apapply_target_paid numeric(20,2),
    apapply_checkhead_id integer
);


ALTER TABLE public.apapply OWNER TO admin;


--
-- TOC entry 429 (class 1259 OID 146568379)
-- Dependencies: 428 8
-- Name: apapply_apapply_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE apapply_apapply_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.apapply_apapply_id_seq OWNER TO admin;

--
-- TOC entry 9493 (class 0 OID 0)
-- Dependencies: 429
-- Name: apapply_apapply_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE apapply_apapply_id_seq OWNED BY apapply.apapply_id;


--
-- TOC entry 430 (class 1259 OID 146568381)
-- Dependencies: 6294 6295 6296 6297 6298 6299 6300 6301 6303 6304 8
-- Name: checkhead; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE checkhead (
    checkhead_id integer NOT NULL,
    checkhead_recip_id integer NOT NULL,
    checkhead_recip_type text NOT NULL,
    checkhead_bankaccnt_id integer NOT NULL,
    checkhead_printed boolean DEFAULT false NOT NULL,
    checkhead_checkdate date NOT NULL,
    checkhead_number integer NOT NULL,
    checkhead_amount numeric(20,2) NOT NULL,
    checkhead_void boolean DEFAULT false NOT NULL,
    checkhead_replaced boolean DEFAULT false NOT NULL,
    checkhead_posted boolean DEFAULT false NOT NULL,
    checkhead_rec boolean DEFAULT false NOT NULL,
    checkhead_misc boolean DEFAULT false NOT NULL,
    checkhead_expcat_id integer,
    checkhead_for text NOT NULL,
    checkhead_notes text NOT NULL,
    checkhead_journalnumber integer,
    checkhead_curr_id integer DEFAULT basecurrid() NOT NULL,
    checkhead_deleted boolean DEFAULT false NOT NULL,
    checkhead_ach_batch text,
    checkhead_curr_rate numeric NOT NULL,
    CONSTRAINT checkhead_checkhead_amount_check CHECK ((checkhead_amount > (0)::numeric)),
    CONSTRAINT checkhead_checkhead_recip_type_check CHECK ((((checkhead_recip_type = 'C'::text) OR (checkhead_recip_type = 'V'::text)) OR (checkhead_recip_type = 'T'::text)))
);


ALTER TABLE public.checkhead OWNER TO admin;


--
-- TOC entry 431 (class 1259 OID 146568397)
-- Dependencies: 8568 8
-- Name: apchk; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW apchk AS
    SELECT checkhead.checkhead_id AS apchk_id, checkhead.checkhead_recip_id AS apchk_vend_id, checkhead.checkhead_bankaccnt_id AS apchk_bankaccnt_id, checkhead.checkhead_printed AS apchk_printed, checkhead.checkhead_checkdate AS apchk_checkdate, checkhead.checkhead_number AS apchk_number, checkhead.checkhead_amount AS apchk_amount, checkhead.checkhead_void AS apchk_void, checkhead.checkhead_replaced AS apchk_replaced, checkhead.checkhead_posted AS apchk_posted, checkhead.checkhead_rec AS apchk_rec, checkhead.checkhead_misc AS apchk_misc, checkhead.checkhead_expcat_id AS apchk_expcat_id, checkhead.checkhead_for AS apchk_for, checkhead.checkhead_notes AS apchk_notes, checkhead.checkhead_journalnumber AS apchk_journalnumber, checkhead.checkhead_curr_id AS apchk_curr_id, checkhead.checkhead_deleted AS apchk_deleted FROM checkhead WHERE (checkhead.checkhead_recip_type = 'V'::text);


ALTER TABLE public.apchk OWNER TO admin;

--
-- TOC entry 432 (class 1259 OID 146568401)
-- Dependencies: 6305 6306 6307 6309 8
-- Name: checkitem; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE checkitem (
    checkitem_id integer NOT NULL,
    checkitem_checkhead_id integer NOT NULL,
    checkitem_amount numeric(20,2) DEFAULT 0.0 NOT NULL,
    checkitem_discount numeric(20,2) DEFAULT 0.0 NOT NULL,
    checkitem_ponumber text,
    checkitem_vouchernumber text,
    checkitem_invcnumber text,
    checkitem_apopen_id integer,
    checkitem_aropen_id integer,
    checkitem_docdate date,
    checkitem_curr_id integer DEFAULT basecurrid() NOT NULL,
    checkitem_cmnumber text,
    checkitem_ranumber text,
    checkitem_curr_rate numeric,
    CONSTRAINT checkitem_check CHECK ((NOT ((checkitem_apopen_id IS NOT NULL) AND (checkitem_aropen_id IS NOT NULL))))
);


ALTER TABLE public.checkitem OWNER TO admin;

--
-- TOC entry 9498 (class 0 OID 0)
-- Dependencies: 432
-- Name: TABLE checkitem; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE checkitem IS 'Accounts Payable Check Line Item Information';


--
-- TOC entry 433 (class 1259 OID 146568411)
-- Dependencies: 8569 8
-- Name: apchkitem; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW apchkitem AS
    SELECT checkitem.checkitem_id AS apchkitem_id, checkitem.checkitem_checkhead_id AS apchkitem_apchk_id, checkitem.checkitem_vouchernumber AS apchkitem_vouchernumber, checkitem.checkitem_ponumber AS apchkitem_ponumber, checkitem.checkitem_amount AS apchkitem_amount, checkitem.checkitem_invcnumber AS apchkitem_invcnumber, checkitem.checkitem_apopen_id AS apchkitem_apopen_id, checkitem.checkitem_docdate AS apchkitem_docdate, checkitem.checkitem_curr_id AS apchkitem_curr_id, checkitem.checkitem_discount AS apchkitem_discount FROM checkhead, checkitem WHERE ((checkitem.checkitem_checkhead_id = checkhead.checkhead_id) AND (checkhead.checkhead_recip_type = 'V'::text));


ALTER TABLE public.apchkitem OWNER TO admin;

--
-- TOC entry 434 (class 1259 OID 146568415)
-- Dependencies: 6311 8
-- Name: apcreditapply; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE apcreditapply (
    apcreditapply_id integer NOT NULL,
    apcreditapply_source_apopen_id integer,
    apcreditapply_target_apopen_id integer,
    apcreditapply_amount numeric(20,2),
    apcreditapply_curr_id integer DEFAULT basecurrid()
);


ALTER TABLE public.apcreditapply OWNER TO admin;

--
-- TOC entry 9501 (class 0 OID 0)
-- Dependencies: 434
-- Name: TABLE apcreditapply; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE apcreditapply IS 'Temporary table for storing details of Accounts Payable (A/P) Credit Memo applications before those applications are posted';


--
-- TOC entry 435 (class 1259 OID 146568419)
-- Dependencies: 434 8
-- Name: apcreditapply_apcreditapply_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE apcreditapply_apcreditapply_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.apcreditapply_apcreditapply_id_seq OWNER TO admin;

--
-- TOC entry 9503 (class 0 OID 0)
-- Dependencies: 435
-- Name: apcreditapply_apcreditapply_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE apcreditapply_apcreditapply_id_seq OWNED BY apcreditapply.apcreditapply_id;


--
-- TOC entry 436 (class 1259 OID 146568421)
-- Dependencies: 8570 8
-- Name: apmemo; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW apmemo AS
    SELECT apopen.apopen_id, apopen.apopen_docnumber FROM apopen WHERE (apopen.apopen_doctype = ANY (ARRAY['D'::bpchar, 'C'::bpchar]));


ALTER TABLE public.apmemo OWNER TO admin;

--
-- TOC entry 437 (class 1259 OID 146568425)
-- Dependencies: 8
-- Name: apopen_apopen_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE apopen_apopen_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.apopen_apopen_id_seq OWNER TO admin;

--
-- TOC entry 438 (class 1259 OID 146568427)
-- Dependencies: 377 8
-- Name: apopentax; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE apopentax (
)
INHERITS (taxhist);


ALTER TABLE public.apopentax OWNER TO admin;

--
-- TOC entry 439 (class 1259 OID 146568433)
-- Dependencies: 6314 6315 8
-- Name: apselect; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE apselect (
    apselect_id integer NOT NULL,
    apselect_apopen_id integer NOT NULL,
    apselect_amount numeric(20,2) NOT NULL,
    apselect_bankaccnt_id integer,
    apselect_curr_id integer DEFAULT basecurrid(),
    apselect_date date,
    apselect_discount numeric(20,2) DEFAULT 0.0 NOT NULL
);


ALTER TABLE public.apselect OWNER TO admin;

--
-- TOC entry 9508 (class 0 OID 0)
-- Dependencies: 439
-- Name: TABLE apselect; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE apselect IS 'Temporary table for storing details of Accounts Payable (A/P) Payment selections';


--
-- TOC entry 440 (class 1259 OID 146568438)
-- Dependencies: 439 8
-- Name: apselect_apselect_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE apselect_apselect_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.apselect_apselect_id_seq OWNER TO admin;

--
-- TOC entry 9510 (class 0 OID 0)
-- Dependencies: 440
-- Name: apselect_apselect_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE apselect_apselect_id_seq OWNED BY apselect.apselect_id;


--
-- TOC entry 441 (class 1259 OID 146568440)
-- Dependencies: 6316 8
-- Name: araccnt; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE araccnt (
    araccnt_id integer DEFAULT nextval(('araccnt_araccnt_id_seq'::text)::regclass) NOT NULL,
    araccnt_custtype_id integer,
    araccnt_custtype text,
    araccnt_freight_accnt_id integer,
    araccnt_ar_accnt_id integer,
    araccnt_prepaid_accnt_id integer,
    araccnt_deferred_accnt_id integer,
    araccnt_discount_accnt_id integer
);


ALTER TABLE public.araccnt OWNER TO admin;

--
-- TOC entry 9512 (class 0 OID 0)
-- Dependencies: 441
-- Name: TABLE araccnt; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE araccnt IS 'Accounts Receivable (A/R) Account assignment information';


--
-- TOC entry 442 (class 1259 OID 146568447)
-- Dependencies: 8
-- Name: araccnt_araccnt_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE araccnt_araccnt_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.araccnt_araccnt_id_seq OWNER TO admin;

--
-- TOC entry 443 (class 1259 OID 146568449)
-- Dependencies: 6318 8
-- Name: arapply; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE arapply (
    arapply_id integer NOT NULL,
    arapply_postdate date,
    arapply_cust_id integer,
    arapply_source_doctype text,
    arapply_source_docnumber text,
    arapply_target_doctype text,
    arapply_target_docnumber text,
    arapply_fundstype text,
    arapply_refnumber text,
    arapply_applied numeric(20,2),
    arapply_closed boolean,
    arapply_journalnumber text,
    arapply_source_aropen_id integer,
    arapply_target_aropen_id integer,
    arapply_username text,
    arapply_curr_id integer DEFAULT basecurrid(),
    arapply_distdate date NOT NULL,
    arapply_target_paid numeric(20,2),
    arapply_reftype text,
    arapply_ref_id integer
);


ALTER TABLE public.arapply OWNER TO admin;


--
-- TOC entry 444 (class 1259 OID 146568456)
-- Dependencies: 443 8
-- Name: arapply_arapply_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE arapply_arapply_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.arapply_arapply_id_seq OWNER TO admin;

--
-- TOC entry 9517 (class 0 OID 0)
-- Dependencies: 444
-- Name: arapply_arapply_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE arapply_arapply_id_seq OWNED BY arapply.arapply_id;


--
-- TOC entry 445 (class 1259 OID 146568458)
-- Dependencies: 269 8
-- Name: cashrcptitem_cashrcptitem_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE cashrcptitem_cashrcptitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cashrcptitem_cashrcptitem_id_seq OWNER TO admin;

--
-- TOC entry 9519 (class 0 OID 0)
-- Dependencies: 445
-- Name: cashrcptitem_cashrcptitem_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE cashrcptitem_cashrcptitem_id_seq OWNED BY cashrcptitem.cashrcptitem_id;


--
-- TOC entry 446 (class 1259 OID 146568460)
-- Dependencies: 6319 6320 8
-- Name: arcreditapply; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE arcreditapply (
    arcreditapply_id integer DEFAULT nextval('cashrcptitem_cashrcptitem_id_seq'::regclass) NOT NULL,
    arcreditapply_source_aropen_id integer,
    arcreditapply_target_aropen_id integer,
    arcreditapply_amount numeric(20,2),
    arcreditapply_curr_id integer DEFAULT basecurrid(),
    arcreditapply_reftype text,
    arcreditapply_ref_id integer
);


ALTER TABLE public.arcreditapply OWNER TO admin;

--
-- TOC entry 9521 (class 0 OID 0)
-- Dependencies: 446
-- Name: TABLE arcreditapply; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE arcreditapply IS 'Temporary table for storing details of Accounts Receivable (A/R) Credit Memo applications before those applications are posted';


--
-- TOC entry 447 (class 1259 OID 146568468)
-- Dependencies: 446 8
-- Name: arcreditapply_arcreditapply_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE arcreditapply_arcreditapply_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.arcreditapply_arcreditapply_id_seq OWNER TO admin;

--
-- TOC entry 9523 (class 0 OID 0)
-- Dependencies: 447
-- Name: arcreditapply_arcreditapply_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE arcreditapply_arcreditapply_id_seq OWNED BY arcreditapply.arcreditapply_id;


--
-- TOC entry 448 (class 1259 OID 146568470)
-- Dependencies: 8571 8
-- Name: armemo; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW armemo AS
    SELECT aropen.aropen_id, aropen.aropen_docnumber FROM aropen WHERE (aropen.aropen_doctype = ANY (ARRAY['D'::bpchar, 'C'::bpchar, 'R'::bpchar])) UNION SELECT cmhead.cmhead_id AS aropen_id, cmhead.cmhead_number AS aropen_docnumber FROM cmhead;


ALTER TABLE public.armemo OWNER TO admin;

--
-- TOC entry 449 (class 1259 OID 146568474)
-- Dependencies: 8
-- Name: aropen_aropen_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE aropen_aropen_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.aropen_aropen_id_seq OWNER TO admin;

--
-- TOC entry 450 (class 1259 OID 146568476)
-- Dependencies: 377 8
-- Name: aropentax; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE aropentax (
)
INHERITS (taxhist);


ALTER TABLE public.aropentax OWNER TO admin;

--
-- TOC entry 451 (class 1259 OID 146568482)
-- Dependencies: 6323 8
-- Name: asohist; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE asohist (
    asohist_id integer NOT NULL,
    asohist_cust_id integer,
    asohist_itemsite_id integer,
    asohist_shipdate date,
    asohist_invcdate date,
    asohist_duedate date,
    asohist_promisedate date,
    asohist_ordernumber text,
    asohist_invcnumber text,
    asohist_qtyshipped numeric(18,6),
    asohist_unitprice numeric(16,4),
    asohist_unitcost numeric(16,6),
    asohist_billtoname text,
    asohist_billtoaddress1 text,
    asohist_billtoaddress2 text,
    asohist_billtoaddress3 text,
    asohist_billtocity text,
    asohist_billtostate text,
    asohist_billtozip text,
    asohist_shiptoname text,
    asohist_shiptoaddress1 text,
    asohist_shiptoaddress2 text,
    asohist_shiptoaddress3 text,
    asohist_shiptocity text,
    asohist_shiptostate text,
    asohist_shiptozip text,
    asohist_shipto_id integer,
    asohist_shipvia text,
    asohist_salesrep_id integer,
    asohist_misc_type character(1),
    asohist_misc_descrip text,
    asohist_misc_id integer,
    asohist_commission numeric(16,4),
    asohist_commissionpaid boolean,
    asohist_doctype text,
    asohist_orderdate date,
    asohist_imported boolean,
    asohist_ponumber text,
    asohist_curr_id integer DEFAULT basecurrid(),
    asohist_taxtype_id integer,
    asohist_taxzone_id integer
);


ALTER TABLE public.asohist OWNER TO admin;


--
-- TOC entry 452 (class 1259 OID 146568489)
-- Dependencies: 451 8
-- Name: asohist_asohist_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE asohist_asohist_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.asohist_asohist_id_seq OWNER TO admin;

--
-- TOC entry 9530 (class 0 OID 0)
-- Dependencies: 452
-- Name: asohist_asohist_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE asohist_asohist_id_seq OWNED BY asohist.asohist_id;


--
-- TOC entry 453 (class 1259 OID 146568491)
-- Dependencies: 377 8
-- Name: asohisttax; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE asohisttax (
)
INHERITS (taxhist);


ALTER TABLE public.asohisttax OWNER TO admin;

--
-- TOC entry 454 (class 1259 OID 146568497)
-- Dependencies: 6326 6327 8
-- Name: atlasmap; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE atlasmap (
    atlasmap_id integer NOT NULL,
    atlasmap_name text NOT NULL,
    atlasmap_filter text NOT NULL,
    atlasmap_filtertype text NOT NULL,
    atlasmap_atlas text NOT NULL,
    atlasmap_map text NOT NULL,
    atlasmap_headerline boolean DEFAULT false NOT NULL,
    CONSTRAINT atlasmap_atlasmap_name_check CHECK ((atlasmap_name <> ''::text))
);


ALTER TABLE public.atlasmap OWNER TO admin;

--
-- TOC entry 9533 (class 0 OID 0)
-- Dependencies: 454
-- Name: TABLE atlasmap; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE atlasmap IS 'Describes heuristics for finding a CSVImp atlas for a given CSV file. When looking for a CSV Atlas to use when importing a CSV file, the first atlasmap record found that matches the CSV file is used to select the Atlas file and Map in that Atlas to import the CSV file.';


--
-- TOC entry 9534 (class 0 OID 0)
-- Dependencies: 454
-- Name: COLUMN atlasmap.atlasmap_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN atlasmap.atlasmap_id IS 'The internal id of this CSVImp atlas mapping.';


--
-- TOC entry 9535 (class 0 OID 0)
-- Dependencies: 454
-- Name: COLUMN atlasmap.atlasmap_name; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN atlasmap.atlasmap_name IS 'The human-readable name of this atlas mapping.';


--
-- TOC entry 9536 (class 0 OID 0)
-- Dependencies: 454
-- Name: COLUMN atlasmap.atlasmap_filter; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN atlasmap.atlasmap_filter IS 'A regular expression that should match the CSV file. Which part of the file that matches is determined by the filter type.';


--
-- TOC entry 9537 (class 0 OID 0)
-- Dependencies: 454
-- Name: COLUMN atlasmap.atlasmap_filtertype; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN atlasmap.atlasmap_filtertype IS 'A description of what aspect of the CSV file the filter should be compared with. Handled values are: ''filename'' - the filter is matched against the name of the file; and ''firstline'' - the filter is matched against the first line of the file contents.';


--
-- TOC entry 9538 (class 0 OID 0)
-- Dependencies: 454
-- Name: COLUMN atlasmap.atlasmap_atlas; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN atlasmap.atlasmap_atlas IS 'The name of the CSVImp Atlas file. This should be a simple pathname, not an absolute or relative name if possible. The full path will be determined by concatenating the operating-system-specific CSV Atlas default directory with the value here unless this is an absolute pathname.';


--
-- TOC entry 9539 (class 0 OID 0)
-- Dependencies: 454
-- Name: COLUMN atlasmap.atlasmap_map; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN atlasmap.atlasmap_map IS 'The name of the Map inside the Atlas to use if the filter and filter type match the CVS file.';


--
-- TOC entry 9540 (class 0 OID 0)
-- Dependencies: 454
-- Name: COLUMN atlasmap.atlasmap_headerline; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN atlasmap.atlasmap_headerline IS 'An indicator of whether the first line of the CSV file should be treated as a header line or as data.';


--
-- TOC entry 455 (class 1259 OID 146568505)
-- Dependencies: 454 8
-- Name: atlasmap_atlasmap_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE atlasmap_atlasmap_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.atlasmap_atlasmap_id_seq OWNER TO admin;

--
-- TOC entry 9542 (class 0 OID 0)
-- Dependencies: 455
-- Name: atlasmap_atlasmap_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE atlasmap_atlasmap_id_seq OWNED BY atlasmap.atlasmap_id;


--
-- TOC entry 456 (class 1259 OID 146568507)
-- Dependencies: 8
-- Name: backup_usr; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE backup_usr (
    usr_id integer,
    usr_username text,
    usr_propername text,
    usr_passwd text,
    usr_locale_id integer,
    usr_initials text,
    usr_agent boolean,
    usr_active boolean,
    usr_email text,
    usr_dept_id integer,
    usr_shift_id integer,
    usr_window text
);


ALTER TABLE public.backup_usr OWNER TO admin;

--
-- TOC entry 457 (class 1259 OID 146568513)
-- Dependencies: 266 8
-- Name: bankaccnt_bankaccnt_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE bankaccnt_bankaccnt_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.bankaccnt_bankaccnt_id_seq OWNER TO admin;

--
-- TOC entry 9545 (class 0 OID 0)
-- Dependencies: 457
-- Name: bankaccnt_bankaccnt_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE bankaccnt_bankaccnt_id_seq OWNED BY bankaccnt.bankaccnt_id;


--
-- TOC entry 458 (class 1259 OID 146568515)
-- Dependencies: 6328 6329 6330 6331 8
-- Name: bankadj; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE bankadj (
    bankadj_id integer NOT NULL,
    bankadj_bankaccnt_id integer NOT NULL,
    bankadj_bankadjtype_id integer NOT NULL,
    bankadj_created timestamp without time zone DEFAULT now() NOT NULL,
    bankadj_username text DEFAULT geteffectivextuser() NOT NULL,
    bankadj_date date NOT NULL,
    bankadj_docnumber text,
    bankadj_amount numeric(10,2) NOT NULL,
    bankadj_notes text,
    bankadj_sequence integer,
    bankadj_posted boolean DEFAULT false NOT NULL,
    bankadj_curr_id integer DEFAULT basecurrid(),
    bankadj_curr_rate numeric
);


ALTER TABLE public.bankadj OWNER TO admin;

--
-- TOC entry 9547 (class 0 OID 0)
-- Dependencies: 458
-- Name: TABLE bankadj; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE bankadj IS 'Bank Adjustments information';


--
-- TOC entry 459 (class 1259 OID 146568525)
-- Dependencies: 458 8
-- Name: bankadj_bankadj_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE bankadj_bankadj_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.bankadj_bankadj_id_seq OWNER TO admin;

--
-- TOC entry 9549 (class 0 OID 0)
-- Dependencies: 459
-- Name: bankadj_bankadj_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE bankadj_bankadj_id_seq OWNED BY bankadj.bankadj_id;


--
-- TOC entry 460 (class 1259 OID 146568527)
-- Dependencies: 6334 6335 8
-- Name: bankadjtype; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE bankadjtype (
    bankadjtype_id integer NOT NULL,
    bankadjtype_name text NOT NULL,
    bankadjtype_descrip text,
    bankadjtype_accnt_id integer NOT NULL,
    bankadjtype_iscredit boolean DEFAULT false NOT NULL,
    CONSTRAINT bankadjtype_bankadjtype_name_check CHECK ((bankadjtype_name <> ''::text))
);


ALTER TABLE public.bankadjtype OWNER TO admin;

--
-- TOC entry 9551 (class 0 OID 0)
-- Dependencies: 460
-- Name: TABLE bankadjtype; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE bankadjtype IS 'Bank Adjustment Types information';


--
-- TOC entry 461 (class 1259 OID 146568535)
-- Dependencies: 460 8
-- Name: bankadjtype_bankadjtype_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE bankadjtype_bankadjtype_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.bankadjtype_bankadjtype_id_seq OWNER TO admin;

--
-- TOC entry 9553 (class 0 OID 0)
-- Dependencies: 461
-- Name: bankadjtype_bankadjtype_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE bankadjtype_bankadjtype_id_seq OWNED BY bankadjtype.bankadjtype_id;


--
-- TOC entry 462 (class 1259 OID 146568537)
-- Dependencies: 6336 6337 6338 8
-- Name: bankrec; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE bankrec (
    bankrec_id integer NOT NULL,
    bankrec_created timestamp without time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL,
    bankrec_username text DEFAULT geteffectivextuser() NOT NULL,
    bankrec_bankaccnt_id integer,
    bankrec_opendate date,
    bankrec_enddate date,
    bankrec_openbal numeric(20,2),
    bankrec_endbal numeric(20,2),
    bankrec_posted boolean DEFAULT false,
    bankrec_postdate timestamp without time zone
);


ALTER TABLE public.bankrec OWNER TO admin;

--
-- TOC entry 9555 (class 0 OID 0)
-- Dependencies: 462
-- Name: TABLE bankrec; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE bankrec IS 'Bank Reconciliation posting history';


--
-- TOC entry 463 (class 1259 OID 146568546)
-- Dependencies: 462 8
-- Name: bankrec_bankrec_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE bankrec_bankrec_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.bankrec_bankrec_id_seq OWNER TO admin;

--
-- TOC entry 9557 (class 0 OID 0)
-- Dependencies: 463
-- Name: bankrec_bankrec_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE bankrec_bankrec_id_seq OWNED BY bankrec.bankrec_id;


--
-- TOC entry 464 (class 1259 OID 146568548)
-- Dependencies: 6341 8
-- Name: bankrecitem; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE bankrecitem (
    bankrecitem_id integer NOT NULL,
    bankrecitem_bankrec_id integer NOT NULL,
    bankrecitem_source text NOT NULL,
    bankrecitem_source_id integer NOT NULL,
    bankrecitem_cleared boolean DEFAULT false,
    bankrecitem_curr_rate numeric,
    bankrecitem_amount numeric
);


ALTER TABLE public.bankrecitem OWNER TO admin;


--
-- TOC entry 465 (class 1259 OID 146568555)
-- Dependencies: 464 8
-- Name: bankrecitem_bankrecitem_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE bankrecitem_bankrecitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.bankrecitem_bankrecitem_id_seq OWNER TO admin;

--
-- TOC entry 9561 (class 0 OID 0)
-- Dependencies: 465
-- Name: bankrecitem_bankrecitem_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE bankrecitem_bankrecitem_id_seq OWNED BY bankrecitem.bankrecitem_id;


--
-- TOC entry 466 (class 1259 OID 146568557)
-- Dependencies: 8
-- Name: bomhead_bomhead_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE bomhead_bomhead_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.bomhead_bomhead_id_seq OWNER TO admin;

--
-- TOC entry 467 (class 1259 OID 146568559)
-- Dependencies: 8
-- Name: bomitem_bomitem_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE bomitem_bomitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.bomitem_bomitem_id_seq OWNER TO admin;

--
-- TOC entry 468 (class 1259 OID 146568561)
-- Dependencies: 6342 6343 6344 6345 8
-- Name: bomitemcost; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE bomitemcost (
    bomitemcost_id integer NOT NULL,
    bomitemcost_bomitem_id integer NOT NULL,
    bomitemcost_costelem_id integer NOT NULL,
    bomitemcost_lowlevel boolean DEFAULT false NOT NULL,
    bomitemcost_stdcost numeric(16,6) DEFAULT 0 NOT NULL,
    bomitemcost_posted date,
    bomitemcost_actcost numeric(16,6) DEFAULT 0 NOT NULL,
    bomitemcost_updated date,
    bomitemcost_curr_id integer DEFAULT basecurrid() NOT NULL
);


ALTER TABLE public.bomitemcost OWNER TO admin;

--
-- TOC entry 9565 (class 0 OID 0)
-- Dependencies: 468
-- Name: TABLE bomitemcost; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE bomitemcost IS 'Bomitem Cost information';


--
-- TOC entry 469 (class 1259 OID 146568568)
-- Dependencies: 468 8
-- Name: bomitemcost_bomitemcost_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE bomitemcost_bomitemcost_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.bomitemcost_bomitemcost_id_seq OWNER TO admin;

--
-- TOC entry 9567 (class 0 OID 0)
-- Dependencies: 469
-- Name: bomitemcost_bomitemcost_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE bomitemcost_bomitemcost_id_seq OWNED BY bomitemcost.bomitemcost_id;


--
-- TOC entry 470 (class 1259 OID 146568570)
-- Dependencies: 258 8
-- Name: bomitemsub_bomitemsub_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE bomitemsub_bomitemsub_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.bomitemsub_bomitemsub_id_seq OWNER TO admin;

--
-- TOC entry 9569 (class 0 OID 0)
-- Dependencies: 470
-- Name: bomitemsub_bomitemsub_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE bomitemsub_bomitemsub_id_seq OWNED BY bomitemsub.bomitemsub_id;


--
-- TOC entry 471 (class 1259 OID 146568572)
-- Dependencies: 6348 6349 8
-- Name: bomwork; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE bomwork (
    bomwork_id integer NOT NULL,
    bomwork_set_id integer,
    bomwork_seqnumber integer,
    bomwork_item_id integer,
    bomwork_item_type character(1),
    bomwork_qtyper numeric(20,8),
    bomwork_scrap numeric(20,10),
    bomwork_status character(1),
    bomwork_level integer,
    bomwork_parent_id integer,
    bomwork_effective date,
    bomwork_expires date,
    bomwork_stdunitcost numeric(16,6),
    bomwork_actunitcost numeric(16,6),
    bomwork_parent_seqnumber integer,
    bomwork_createwo boolean,
    bomwork_issuemethod character(1),
    bomwork_char_id integer,
    bomwork_value text,
    bomwork_notes text,
    bomwork_ref text,
    bomwork_bomitem_id integer,
    bomwork_ecn text,
    bomwork_qtyfxd numeric(20,8) DEFAULT 0 NOT NULL,
    bomwork_qtyreq numeric(20,8) DEFAULT 0 NOT NULL
);


ALTER TABLE public.bomwork OWNER TO admin;

--
-- TOC entry 9571 (class 0 OID 0)
-- Dependencies: 471
-- Name: TABLE bomwork; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE bomwork IS 'Temporary table for storing information requested by Bill of Materials (BOM) displays and reports';


--
-- TOC entry 9572 (class 0 OID 0)
-- Dependencies: 471
-- Name: COLUMN bomwork.bomwork_qtyfxd; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN bomwork.bomwork_qtyfxd IS 'The fixed quantity required';


--
-- TOC entry 9573 (class 0 OID 0)
-- Dependencies: 471
-- Name: COLUMN bomwork.bomwork_qtyreq; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN bomwork.bomwork_qtyreq IS 'The total quantity required';


--
-- TOC entry 472 (class 1259 OID 146568580)
-- Dependencies: 471 8
-- Name: bomwork_bomwork_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE bomwork_bomwork_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.bomwork_bomwork_id_seq OWNER TO admin;

--
-- TOC entry 9575 (class 0 OID 0)
-- Dependencies: 472
-- Name: bomwork_bomwork_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE bomwork_bomwork_id_seq OWNED BY bomwork.bomwork_id;


--
-- TOC entry 473 (class 1259 OID 146568582)
-- Dependencies: 8572 8
-- Name: budget; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW budget AS
    SELECT budgitem.budgitem_id AS budget_id, budgitem.budgitem_period_id AS budget_period_id, budgitem.budgitem_accnt_id AS budget_accnt_id, budgitem.budgitem_amount AS budget_amount FROM budgitem;


ALTER TABLE public.budget OWNER TO admin;

--
-- TOC entry 474 (class 1259 OID 146568586)
-- Dependencies: 260 8
-- Name: budghead_budghead_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE budghead_budghead_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.budghead_budghead_id_seq OWNER TO admin;

--
-- TOC entry 9578 (class 0 OID 0)
-- Dependencies: 474
-- Name: budghead_budghead_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE budghead_budghead_id_seq OWNED BY budghead.budghead_id;


--
-- TOC entry 475 (class 1259 OID 146568588)
-- Dependencies: 263 8
-- Name: budgitem_budgitem_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE budgitem_budgitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.budgitem_budgitem_id_seq OWNER TO admin;

--
-- TOC entry 9580 (class 0 OID 0)
-- Dependencies: 475
-- Name: budgitem_budgitem_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE budgitem_budgitem_id_seq OWNED BY budgitem.budgitem_id;


--
-- TOC entry 476 (class 1259 OID 146568590)
-- Dependencies: 6350 6351 8
-- Name: calhead; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE calhead (
    calhead_id integer DEFAULT nextval(('"calhead_calhead_id_seq"'::text)::regclass) NOT NULL,
    calhead_type character(1),
    calhead_name text NOT NULL,
    calhead_descrip text,
    calhead_origin character(1),
    CONSTRAINT calhead_calhead_name_check CHECK ((calhead_name <> ''::text))
);


ALTER TABLE public.calhead OWNER TO admin;

--
-- TOC entry 9582 (class 0 OID 0)
-- Dependencies: 476
-- Name: TABLE calhead; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE calhead IS 'Calendar header information';


--
-- TOC entry 477 (class 1259 OID 146568598)
-- Dependencies: 8
-- Name: calhead_calhead_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE calhead_calhead_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.calhead_calhead_id_seq OWNER TO admin;

--
-- TOC entry 478 (class 1259 OID 146568600)
-- Dependencies: 8
-- Name: carrier_carrier_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE carrier_carrier_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.carrier_carrier_id_seq OWNER TO admin;

--
-- TOC entry 479 (class 1259 OID 146568602)
-- Dependencies: 267 8
-- Name: cashrcpt_cashrcpt_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE cashrcpt_cashrcpt_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cashrcpt_cashrcpt_id_seq OWNER TO admin;

--
-- TOC entry 9586 (class 0 OID 0)
-- Dependencies: 479
-- Name: cashrcpt_cashrcpt_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE cashrcpt_cashrcpt_id_seq OWNED BY cashrcpt.cashrcpt_id;


--
-- TOC entry 480 (class 1259 OID 146568604)
-- Dependencies: 271 8
-- Name: cashrcptmisc_cashrcptmisc_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE cashrcptmisc_cashrcptmisc_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cashrcptmisc_cashrcptmisc_id_seq OWNER TO admin;

--
-- TOC entry 9588 (class 0 OID 0)
-- Dependencies: 480
-- Name: cashrcptmisc_cashrcptmisc_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE cashrcptmisc_cashrcptmisc_id_seq OWNED BY cashrcptmisc.cashrcptmisc_id;


--
-- TOC entry 481 (class 1259 OID 146568606)
-- Dependencies: 278 8
-- Name: ccard_ccard_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE ccard_ccard_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ccard_ccard_id_seq OWNER TO admin;

--
-- TOC entry 9590 (class 0 OID 0)
-- Dependencies: 481
-- Name: ccard_ccard_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE ccard_ccard_id_seq OWNED BY ccard.ccard_id;


--
-- TOC entry 482 (class 1259 OID 146568608)
-- Dependencies: 6353 6354 8
-- Name: ccardaud; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE ccardaud (
    ccardaud_id integer NOT NULL,
    ccardaud_ccard_id integer,
    ccardaud_ccard_seq_old integer,
    ccardaud_ccard_seq_new integer,
    ccardaud_ccard_cust_id_old integer,
    ccardaud_ccard_cust_id_new integer,
    ccardaud_ccard_active_old boolean,
    ccardaud_ccard_active_new boolean,
    ccardaud_ccard_name_old bytea,
    ccardaud_ccard_name_new bytea,
    ccardaud_ccard_address1_old bytea,
    ccardaud_ccard_address1_new bytea,
    ccardaud_ccard_address2_old bytea,
    ccardaud_ccard_address2_new bytea,
    ccardaud_ccard_city_old bytea,
    ccardaud_ccard_city_new bytea,
    ccardaud_ccard_state_old bytea,
    ccardaud_ccard_state_new bytea,
    ccardaud_ccard_zip_old bytea,
    ccardaud_ccard_zip_new bytea,
    ccardaud_ccard_country_old bytea,
    ccardaud_ccard_country_new bytea,
    ccardaud_ccard_number_old bytea,
    ccardaud_ccard_number_new bytea,
    ccardaud_ccard_debit_old boolean,
    ccardaud_ccard_debit_new boolean,
    ccardaud_ccard_month_expired_old bytea,
    ccardaud_ccard_month_expired_new bytea,
    ccardaud_ccard_year_expired_old bytea,
    ccardaud_ccard_year_expired_new bytea,
    ccardaud_ccard_type_old character(1),
    ccardaud_ccard_type_new character(1),
    ccardaud_ccard_last_updated timestamp without time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL,
    ccardaud_ccard_last_updated_by_username text DEFAULT geteffectivextuser() NOT NULL
);


ALTER TABLE public.ccardaud OWNER TO admin;

--
-- TOC entry 9592 (class 0 OID 0)
-- Dependencies: 482
-- Name: TABLE ccardaud; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE ccardaud IS 'Credit Card Information tracking data';


--
-- TOC entry 483 (class 1259 OID 146568616)
-- Dependencies: 482 8
-- Name: ccardaud_ccardaud_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE ccardaud_ccardaud_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ccardaud_ccardaud_id_seq OWNER TO admin;

--
-- TOC entry 9594 (class 0 OID 0)
-- Dependencies: 483
-- Name: ccardaud_ccardaud_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE ccardaud_ccardaud_id_seq OWNED BY ccardaud.ccardaud_id;


--
-- TOC entry 484 (class 1259 OID 146568618)
-- Dependencies: 6356 8
-- Name: ccbank; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE ccbank (
    ccbank_id integer NOT NULL,
    ccbank_ccard_type text NOT NULL,
    ccbank_bankaccnt_id integer,
    CONSTRAINT ccbank_ccbank_ccard_type_check CHECK ((ccbank_ccard_type = ANY (ARRAY['A'::text, 'D'::text, 'M'::text, 'P'::text, 'V'::text])))
);


ALTER TABLE public.ccbank OWNER TO admin;

--
-- TOC entry 485 (class 1259 OID 146568625)
-- Dependencies: 484 8
-- Name: ccbank_ccbank_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE ccbank_ccbank_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ccbank_ccbank_id_seq OWNER TO admin;

--
-- TOC entry 9597 (class 0 OID 0)
-- Dependencies: 485
-- Name: ccbank_ccbank_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE ccbank_ccbank_id_seq OWNED BY ccbank.ccbank_id;


--
-- TOC entry 486 (class 1259 OID 146568627)
-- Dependencies: 6357 6358 6359 6360 6361 8
-- Name: ccpay; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE ccpay (
    ccpay_id integer NOT NULL,
    ccpay_ccard_id integer,
    ccpay_cust_id integer,
    ccpay_amount numeric(20,2) DEFAULT 0.00 NOT NULL,
    ccpay_auth boolean DEFAULT true NOT NULL,
    ccpay_status character(1) NOT NULL,
    ccpay_type character(1) NOT NULL,
    ccpay_auth_charge character(1) NOT NULL,
    ccpay_order_number text,
    ccpay_order_number_seq integer,
    ccpay_r_avs text,
    ccpay_r_ordernum text,
    ccpay_r_error text,
    ccpay_r_approved text,
    ccpay_r_code text,
    ccpay_r_message text,
    ccpay_yp_r_time timestamp without time zone,
    ccpay_r_ref text,
    ccpay_yp_r_tdate text,
    ccpay_r_tax text,
    ccpay_r_shipping text,
    ccpay_yp_r_score integer,
    ccpay_transaction_datetime timestamp without time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL,
    ccpay_by_username text DEFAULT geteffectivextuser() NOT NULL,
    ccpay_curr_id integer DEFAULT basecurrid(),
    ccpay_ccpay_id integer
);


ALTER TABLE public.ccpay OWNER TO admin;


--
-- TOC entry 487 (class 1259 OID 146568638)
-- Dependencies: 486 8
-- Name: ccpay_ccpay_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE ccpay_ccpay_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ccpay_ccpay_id_seq OWNER TO admin;

--
-- TOC entry 9627 (class 0 OID 0)
-- Dependencies: 487
-- Name: ccpay_ccpay_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE ccpay_ccpay_id_seq OWNED BY ccpay.ccpay_id;


--
-- TOC entry 488 (class 1259 OID 146568640)
-- Dependencies: 236 8
-- Name: char_char_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE char_char_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.char_char_id_seq OWNER TO admin;

--
-- TOC entry 9629 (class 0 OID 0)
-- Dependencies: 488
-- Name: char_char_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE char_char_id_seq OWNED BY "char".char_id;


--
-- TOC entry 489 (class 1259 OID 146568642)
-- Dependencies: 237 8
-- Name: charass_charass_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE charass_charass_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.charass_charass_id_seq OWNER TO admin;

--
-- TOC entry 9631 (class 0 OID 0)
-- Dependencies: 489
-- Name: charass_charass_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE charass_charass_id_seq OWNED BY charass.charass_id;


--
-- TOC entry 490 (class 1259 OID 146568644)
-- Dependencies: 6364 8
-- Name: charopt; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE charopt (
    charopt_id integer NOT NULL,
    charopt_char_id integer,
    charopt_value text NOT NULL,
    charopt_order integer DEFAULT 0 NOT NULL
);


ALTER TABLE public.charopt OWNER TO admin;

--
-- TOC entry 9633 (class 0 OID 0)
-- Dependencies: 490
-- Name: TABLE charopt; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE charopt IS 'Stores list options for characteristics';


--
-- TOC entry 9634 (class 0 OID 0)
-- Dependencies: 490
-- Name: COLUMN charopt.charopt_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN charopt.charopt_id IS 'Primary key';


--
-- TOC entry 9635 (class 0 OID 0)
-- Dependencies: 490
-- Name: COLUMN charopt.charopt_char_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN charopt.charopt_char_id IS 'Reference to char table';


--
-- TOC entry 9636 (class 0 OID 0)
-- Dependencies: 490
-- Name: COLUMN charopt.charopt_value; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN charopt.charopt_value IS 'Option value';


--
-- TOC entry 9637 (class 0 OID 0)
-- Dependencies: 490
-- Name: COLUMN charopt.charopt_order; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN charopt.charopt_order IS 'Option sort order';


--
-- TOC entry 491 (class 1259 OID 146568651)
-- Dependencies: 490 8
-- Name: charopt_charopt_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE charopt_charopt_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.charopt_charopt_id_seq OWNER TO admin;

--
-- TOC entry 9639 (class 0 OID 0)
-- Dependencies: 491
-- Name: charopt_charopt_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE charopt_charopt_id_seq OWNED BY charopt.charopt_id;


--
-- TOC entry 492 (class 1259 OID 146568653)
-- Dependencies: 430 8
-- Name: checkhead_checkhead_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE checkhead_checkhead_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.checkhead_checkhead_id_seq OWNER TO admin;

--
-- TOC entry 9641 (class 0 OID 0)
-- Dependencies: 492
-- Name: checkhead_checkhead_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE checkhead_checkhead_id_seq OWNED BY checkhead.checkhead_id;


--
-- TOC entry 493 (class 1259 OID 146568655)
-- Dependencies: 432 8
-- Name: checkitem_checkitem_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE checkitem_checkitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.checkitem_checkitem_id_seq OWNER TO admin;

--
-- TOC entry 9643 (class 0 OID 0)
-- Dependencies: 493
-- Name: checkitem_checkitem_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE checkitem_checkitem_id_seq OWNED BY checkitem.checkitem_id;


--
-- TOC entry 494 (class 1259 OID 146568657)
-- Dependencies: 8573 8
-- Name: checkrecip; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW checkrecip AS
    (SELECT custinfo.cust_id AS checkrecip_id, 'C'::text AS checkrecip_type, custinfo.cust_number AS checkrecip_number, custinfo.cust_name AS checkrecip_name, 'A/R'::text AS checkrecip_gltrans_source, findaraccount(custinfo.cust_id) AS checkrecip_accnt_id, cntct.cntct_addr_id AS checkrecip_addr_id FROM (custinfo LEFT JOIN cntct ON ((custinfo.cust_cntct_id = cntct.cntct_id))) UNION ALL SELECT taxauth.taxauth_id AS checkrecip_id, 'T'::text AS checkrecip_type, taxauth.taxauth_code AS checkrecip_number, taxauth.taxauth_name AS checkrecip_name, 'G/L'::text AS checkrecip_gltrans_source, taxauth.taxauth_accnt_id AS checkrecip_accnt_id, taxauth.taxauth_addr_id AS checkrecip_addr_id FROM taxauth) UNION ALL SELECT vendinfo.vend_id AS checkrecip_id, 'V'::text AS checkrecip_type, vendinfo.vend_number AS checkrecip_number, vendinfo.vend_name AS checkrecip_name, 'A/P'::text AS checkrecip_gltrans_source, findapaccount(vendinfo.vend_id) AS checkrecip_accnt_id, vendaddrinfo.vendaddr_addr_id AS checkrecip_addr_id FROM (vendinfo LEFT JOIN vendaddrinfo ON (((vendinfo.vend_id = vendaddrinfo.vendaddr_vend_id) AND (upper(vendaddrinfo.vendaddr_code) = 'REMIT'::text))));


ALTER TABLE public.checkrecip OWNER TO admin;

--
-- TOC entry 495 (class 1259 OID 146568662)
-- Dependencies: 8
-- Name: classcode_classcode_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE classcode_classcode_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.classcode_classcode_id_seq OWNER TO admin;

--
-- TOC entry 496 (class 1259 OID 146568664)
-- Dependencies: 8
-- Name: cmhead_cmhead_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE cmhead_cmhead_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.cmhead_cmhead_id_seq OWNER TO admin;

--
-- TOC entry 497 (class 1259 OID 146568666)
-- Dependencies: 377 8
-- Name: cmheadtax; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE cmheadtax (
)
INHERITS (taxhist);


ALTER TABLE public.cmheadtax OWNER TO admin;

--
-- TOC entry 498 (class 1259 OID 146568672)
-- Dependencies: 8
-- Name: cmitem_cmitem_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE cmitem_cmitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.cmitem_cmitem_id_seq OWNER TO admin;

--
-- TOC entry 499 (class 1259 OID 146568674)
-- Dependencies: 377 8
-- Name: cmitemtax; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE cmitemtax (
)
INHERITS (taxhist);


ALTER TABLE public.cmitemtax OWNER TO admin;

--
-- TOC entry 500 (class 1259 OID 146568680)
-- Dependencies: 239 8
-- Name: cmnttype_cmnttype_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE cmnttype_cmnttype_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cmnttype_cmnttype_id_seq OWNER TO admin;

--
-- TOC entry 9651 (class 0 OID 0)
-- Dependencies: 500
-- Name: cmnttype_cmnttype_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE cmnttype_cmnttype_id_seq OWNED BY cmnttype.cmnttype_id;


--
-- TOC entry 501 (class 1259 OID 146568682)
-- Dependencies: 8
-- Name: cmnttypesource; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE cmnttypesource (
    cmnttypesource_id integer NOT NULL,
    cmnttypesource_cmnttype_id integer,
    cmnttypesource_source_id integer
);


ALTER TABLE public.cmnttypesource OWNER TO admin;


--
-- TOC entry 502 (class 1259 OID 146568685)
-- Dependencies: 501 8
-- Name: cmnttypesource_cmnttypesource_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE cmnttypesource_cmnttypesource_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cmnttypesource_cmnttypesource_id_seq OWNER TO admin;

--
-- TOC entry 9655 (class 0 OID 0)
-- Dependencies: 502
-- Name: cmnttypesource_cmnttypesource_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE cmnttypesource_cmnttypesource_id_seq OWNED BY cmnttypesource.cmnttypesource_id;


--
-- TOC entry 503 (class 1259 OID 146568687)
-- Dependencies: 204 8
-- Name: cntct_cntct_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE cntct_cntct_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cntct_cntct_id_seq OWNER TO admin;

--
-- TOC entry 9657 (class 0 OID 0)
-- Dependencies: 503
-- Name: cntct_cntct_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE cntct_cntct_id_seq OWNED BY cntct.cntct_id;


--
-- TOC entry 504 (class 1259 OID 146568689)
-- Dependencies: 8
-- Name: cntctaddr; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE cntctaddr (
    cntctaddr_id integer NOT NULL,
    cntctaddr_cntct_id integer,
    cntctaddr_primary boolean NOT NULL,
    cntctaddr_addr_id integer NOT NULL,
    cntctaddr_type character(2) NOT NULL
);


ALTER TABLE public.cntctaddr OWNER TO admin;

--
-- TOC entry 505 (class 1259 OID 146568692)
-- Dependencies: 504 8
-- Name: cntctaddr_cntctaddr_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE cntctaddr_cntctaddr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cntctaddr_cntctaddr_id_seq OWNER TO admin;

--
-- TOC entry 9660 (class 0 OID 0)
-- Dependencies: 505
-- Name: cntctaddr_cntctaddr_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE cntctaddr_cntctaddr_id_seq OWNED BY cntctaddr.cntctaddr_id;


--
-- TOC entry 506 (class 1259 OID 146568694)
-- Dependencies: 8
-- Name: cntctdata; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE cntctdata (
    cntctdata_id integer NOT NULL,
    cntctdata_cntct_id integer,
    cntctdata_primary boolean NOT NULL,
    cntctdata_text text NOT NULL,
    cntctdata_type character(2) NOT NULL
);


ALTER TABLE public.cntctdata OWNER TO admin;

--
-- TOC entry 507 (class 1259 OID 146568700)
-- Dependencies: 506 8
-- Name: cntctdata_cntctdata_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE cntctdata_cntctdata_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cntctdata_cntctdata_id_seq OWNER TO admin;

--
-- TOC entry 9663 (class 0 OID 0)
-- Dependencies: 507
-- Name: cntctdata_cntctdata_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE cntctdata_cntctdata_id_seq OWNED BY cntctdata.cntctdata_id;


--
-- TOC entry 508 (class 1259 OID 146568702)
-- Dependencies: 6371 8
-- Name: cntcteml; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE cntcteml (
    cntcteml_id integer NOT NULL,
    cntcteml_cntct_id integer,
    cntcteml_primary boolean DEFAULT false NOT NULL,
    cntcteml_email text NOT NULL
);


ALTER TABLE public.cntcteml OWNER TO admin;

--
-- TOC entry 9665 (class 0 OID 0)
-- Dependencies: 508
-- Name: TABLE cntcteml; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE cntcteml IS 'Stores email addresses for contacts';


--
-- TOC entry 9666 (class 0 OID 0)
-- Dependencies: 508
-- Name: COLUMN cntcteml.cntcteml_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN cntcteml.cntcteml_id IS 'Primary key';


--
-- TOC entry 9667 (class 0 OID 0)
-- Dependencies: 508
-- Name: COLUMN cntcteml.cntcteml_cntct_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN cntcteml.cntcteml_cntct_id IS 'Reference to contact table';


--
-- TOC entry 9668 (class 0 OID 0)
-- Dependencies: 508
-- Name: COLUMN cntcteml.cntcteml_primary; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN cntcteml.cntcteml_primary IS 'Flags whether this is the primary email address';


--
-- TOC entry 9669 (class 0 OID 0)
-- Dependencies: 508
-- Name: COLUMN cntcteml.cntcteml_email; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN cntcteml.cntcteml_email IS 'Alternate information';


--
-- TOC entry 509 (class 1259 OID 146568709)
-- Dependencies: 508 8
-- Name: cntcteml_cntcteml_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE cntcteml_cntcteml_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.cntcteml_cntcteml_id_seq OWNER TO admin;

--
-- TOC entry 9671 (class 0 OID 0)
-- Dependencies: 509
-- Name: cntcteml_cntcteml_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE cntcteml_cntcteml_id_seq OWNED BY cntcteml.cntcteml_id;


--
-- TOC entry 510 (class 1259 OID 146568711)
-- Dependencies: 6372 8
-- Name: cntctmrgd; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE cntctmrgd (
    cntctmrgd_cntct_id integer NOT NULL,
    cntctmrgd_error boolean DEFAULT false
);


ALTER TABLE public.cntctmrgd OWNER TO admin;

--
-- TOC entry 511 (class 1259 OID 146568715)
-- Dependencies: 6373 6374 6375 6376 6377 6378 6379 6380 6381 6382 6383 6384 6385 6386 6387 6388 8
-- Name: cntctsel; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE cntctsel (
    cntctsel_cntct_id integer NOT NULL,
    cntctsel_target boolean,
    cntctsel_mrg_crmacct_id boolean DEFAULT false,
    cntctsel_mrg_addr_id boolean DEFAULT false,
    cntctsel_mrg_first_name boolean DEFAULT false,
    cntctsel_mrg_last_name boolean DEFAULT false,
    cntctsel_mrg_honorific boolean DEFAULT false,
    cntctsel_mrg_initials boolean DEFAULT false,
    cntctsel_mrg_phone boolean DEFAULT false,
    cntctsel_mrg_phone2 boolean DEFAULT false,
    cntctsel_mrg_fax boolean DEFAULT false,
    cntctsel_mrg_email boolean DEFAULT false,
    cntctsel_mrg_webaddr boolean DEFAULT false,
    cntctsel_mrg_notes boolean DEFAULT false,
    cntctsel_mrg_title boolean DEFAULT false,
    cntctsel_mrg_middle boolean DEFAULT false,
    cntctsel_mrg_suffix boolean DEFAULT false,
    cntctsel_mrg_owner_username boolean DEFAULT false
);


ALTER TABLE public.cntctsel OWNER TO admin;

--
-- TOC entry 512 (class 1259 OID 146568734)
-- Dependencies: 8
-- Name: cntslip_cntslip_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE cntslip_cntslip_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.cntslip_cntslip_id_seq OWNER TO admin;

--
-- TOC entry 513 (class 1259 OID 146568736)
-- Dependencies: 6389 8
-- Name: cobill; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE cobill (
    cobill_id integer DEFAULT nextval(('cobill_cobill_id_seq'::text)::regclass) NOT NULL,
    cobill_coitem_id integer,
    cobill_selectdate timestamp with time zone,
    cobill_qty numeric(18,6),
    cobill_invcnum integer,
    cobill_toclose boolean,
    cobill_cobmisc_id integer,
    cobill_select_username text,
    cobill_invcitem_id integer,
    cobill_taxtype_id integer
);


ALTER TABLE public.cobill OWNER TO admin;

--
-- TOC entry 9676 (class 0 OID 0)
-- Dependencies: 513
-- Name: TABLE cobill; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE cobill IS 'Billing Selection Line Item information';


--
-- TOC entry 514 (class 1259 OID 146568743)
-- Dependencies: 8
-- Name: cobill_cobill_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE cobill_cobill_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.cobill_cobill_id_seq OWNER TO admin;

--
-- TOC entry 515 (class 1259 OID 146568745)
-- Dependencies: 377 8
-- Name: cobilltax; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE cobilltax (
)
INHERITS (taxhist);


ALTER TABLE public.cobilltax OWNER TO admin;

--
-- TOC entry 516 (class 1259 OID 146568751)
-- Dependencies: 6391 6392 8
-- Name: cobmisc; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE cobmisc (
    cobmisc_id integer DEFAULT nextval(('cobmisc_cobmisc_id_seq'::text)::regclass) NOT NULL,
    cobmisc_cohead_id integer,
    cobmisc_shipvia text,
    cobmisc_freight numeric(16,4),
    cobmisc_misc numeric(16,4),
    cobmisc_payment numeric(16,4),
    cobmisc_paymentref text,
    cobmisc_notes text,
    cobmisc_shipdate date,
    cobmisc_invcnumber integer,
    cobmisc_invcdate date,
    cobmisc_posted boolean,
    cobmisc_misc_accnt_id integer,
    cobmisc_misc_descrip text,
    cobmisc_closeorder boolean,
    cobmisc_curr_id integer DEFAULT basecurrid(),
    cobmisc_invchead_id integer,
    cobmisc_taxzone_id integer,
    cobmisc_taxtype_id integer
);


ALTER TABLE public.cobmisc OWNER TO admin;

--
-- TOC entry 9680 (class 0 OID 0)
-- Dependencies: 516
-- Name: TABLE cobmisc; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE cobmisc IS 'General information about Billing Selections';


--
-- TOC entry 517 (class 1259 OID 146568759)
-- Dependencies: 8
-- Name: cobmisc_cobmisc_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE cobmisc_cobmisc_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.cobmisc_cobmisc_id_seq OWNER TO admin;

--
-- TOC entry 518 (class 1259 OID 146568761)
-- Dependencies: 377 8
-- Name: cobmisctax; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE cobmisctax (
)
INHERITS (taxhist);


ALTER TABLE public.cobmisctax OWNER TO admin;

--
-- TOC entry 519 (class 1259 OID 146568767)
-- Dependencies: 8
-- Name: cohead_cohead_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE cohead_cohead_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.cohead_cohead_id_seq OWNER TO admin;

--
-- TOC entry 520 (class 1259 OID 146568769)
-- Dependencies: 8
-- Name: cohist_cohist_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE cohist_cohist_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.cohist_cohist_id_seq OWNER TO admin;

--
-- TOC entry 521 (class 1259 OID 146568771)
-- Dependencies: 8
-- Name: coitem_coitem_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE coitem_coitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.coitem_coitem_id_seq OWNER TO admin;

--
-- TOC entry 522 (class 1259 OID 146568773)
-- Dependencies: 8
-- Name: comment_comment_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE comment_comment_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.comment_comment_id_seq OWNER TO admin;

--
-- TOC entry 523 (class 1259 OID 146568775)
-- Dependencies: 6395 6396 8
-- Name: company; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE company (
    company_id integer NOT NULL,
    company_number text NOT NULL,
    company_descrip text,
    company_external boolean DEFAULT false NOT NULL,
    company_server text,
    company_port integer,
    company_database text,
    company_curr_id integer,
    company_yearend_accnt_id integer,
    company_gainloss_accnt_id integer,
    company_dscrp_accnt_id integer,
    company_unrlzgainloss_accnt_id integer,
    CONSTRAINT company_company_number_check CHECK ((company_number <> ''::text))
);


ALTER TABLE public.company OWNER TO admin;


--
-- TOC entry 524 (class 1259 OID 146568783)
-- Dependencies: 523 8
-- Name: company_company_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE company_company_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.company_company_id_seq OWNER TO admin;

--
-- TOC entry 9690 (class 0 OID 0)
-- Dependencies: 524
-- Name: company_company_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE company_company_id_seq OWNED BY company.company_id;


--
-- TOC entry 525 (class 1259 OID 146568785)
-- Dependencies: 329 8
-- Name: contrct_contrct_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE contrct_contrct_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.contrct_contrct_id_seq OWNER TO admin;

--
-- TOC entry 9692 (class 0 OID 0)
-- Dependencies: 525
-- Name: contrct_contrct_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE contrct_contrct_id_seq OWNED BY contrct.contrct_id;


--
-- TOC entry 526 (class 1259 OID 146568787)
-- Dependencies: 6397 6398 6399 6401 6402 6403 8
-- Name: shiphead; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE shiphead (
    shiphead_id integer NOT NULL,
    shiphead_order_id integer NOT NULL,
    shiphead_order_type text NOT NULL,
    shiphead_number text NOT NULL,
    shiphead_shipvia text,
    shiphead_freight numeric(16,4) DEFAULT 0.0 NOT NULL,
    shiphead_freight_curr_id integer DEFAULT basecurrid() NOT NULL,
    shiphead_notes text,
    shiphead_shipped boolean DEFAULT false NOT NULL,
    shiphead_shipdate date,
    shiphead_shipchrg_id integer,
    shiphead_shipform_id integer,
    shiphead_sfstatus character(1) NOT NULL,
    shiphead_tracknum text,
    CONSTRAINT shiphead_shiphead_number_check CHECK ((shiphead_number <> ''::text)),
    CONSTRAINT shiphead_shiphead_order_type_check CHECK (((shiphead_order_type = 'SO'::text) OR (shiphead_order_type = 'TO'::text))),
    CONSTRAINT shiphead_shiphead_sfstatus_check CHECK ((((shiphead_sfstatus = 'D'::bpchar) OR (shiphead_sfstatus = 'N'::bpchar)) OR (shiphead_sfstatus = 'P'::bpchar)))
);


ALTER TABLE public.shiphead OWNER TO admin;


--
-- TOC entry 527 (class 1259 OID 146568799)
-- Dependencies: 6405 6406 8
-- Name: shipitem; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE shipitem (
    shipitem_id integer NOT NULL,
    shipitem_orderitem_id integer NOT NULL,
    shipitem_shiphead_id integer NOT NULL,
    shipitem_qty numeric(18,6) NOT NULL,
    shipitem_shipped boolean DEFAULT false NOT NULL,
    shipitem_shipdate timestamp with time zone,
    shipitem_transdate timestamp with time zone,
    shipitem_trans_username text,
    shipitem_invoiced boolean DEFAULT false NOT NULL,
    shipitem_invcitem_id integer,
    shipitem_value numeric(18,6),
    shipitem_invhist_id integer
);


ALTER TABLE public.shipitem OWNER TO admin;

--
-- TOC entry 9696 (class 0 OID 0)
-- Dependencies: 527
-- Name: TABLE shipitem; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE shipitem IS 'Information about Shipment Line Items';


--
-- TOC entry 528 (class 1259 OID 146568807)
-- Dependencies: 8574 8
-- Name: coship; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW coship AS
    SELECT shipitem.shipitem_id AS coship_id, shipitem.shipitem_orderitem_id AS coship_coitem_id, shipitem.shipitem_shipdate AS coship_shipdate, shipitem.shipitem_qty AS coship_qty, shipitem.shipitem_transdate AS coship_transdate, shipitem.shipitem_shipped AS coship_shipped, shipitem.shipitem_invoiced AS coship_invoiced, shipitem.shipitem_shiphead_id AS coship_cosmisc_id, shipitem.shipitem_trans_username AS coship_trans_username, shipitem.shipitem_invcitem_id AS coship_invcitem_id FROM shipitem, shiphead WHERE ((shipitem.shipitem_shiphead_id = shiphead.shiphead_id) AND (shiphead.shiphead_order_type = 'SO'::text));


ALTER TABLE public.coship OWNER TO admin;

--
-- TOC entry 529 (class 1259 OID 146568811)
-- Dependencies: 8
-- Name: coship_coship_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE coship_coship_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.coship_coship_id_seq OWNER TO admin;

--
-- TOC entry 530 (class 1259 OID 146568813)
-- Dependencies: 8575 8
-- Name: cosmisc; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW cosmisc AS
    SELECT shiphead.shiphead_id AS cosmisc_id, shiphead.shiphead_order_id AS cosmisc_cohead_id, shiphead.shiphead_shipvia AS cosmisc_shipvia, shiphead.shiphead_freight AS cosmisc_freight, shiphead.shiphead_notes AS cosmisc_notes, shiphead.shiphead_shipdate AS cosmisc_shipdate, shiphead.shiphead_shipchrg_id AS cosmisc_shipchrg_id, shiphead.shiphead_shipform_id AS cosmisc_shipform_id, shiphead.shiphead_shipped AS cosmisc_shipped, shiphead.shiphead_sfstatus AS cosmisc_sfstatus, shiphead.shiphead_tracknum AS cosmisc_tracknum, shiphead.shiphead_number AS cosmisc_number FROM shiphead WHERE (shiphead.shiphead_order_type = 'SO'::text);


ALTER TABLE public.cosmisc OWNER TO admin;

--
-- TOC entry 531 (class 1259 OID 146568817)
-- Dependencies: 8
-- Name: cosmisc_cosmisc_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE cosmisc_cosmisc_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.cosmisc_cosmisc_id_seq OWNER TO admin;

--
-- TOC entry 532 (class 1259 OID 146568819)
-- Dependencies: 8
-- Name: cosrc_cosrc_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE cosrc_cosrc_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.cosrc_cosrc_id_seq OWNER TO admin;

--
-- TOC entry 533 (class 1259 OID 146568821)
-- Dependencies: 8
-- Name: costcat_costcat_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE costcat_costcat_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.costcat_costcat_id_seq OWNER TO admin;

--
-- TOC entry 534 (class 1259 OID 146568823)
-- Dependencies: 8
-- Name: costelem_costelem_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE costelem_costelem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.costelem_costelem_id_seq OWNER TO admin;

--
-- TOC entry 535 (class 1259 OID 146568825)
-- Dependencies: 6407 6408 6409 8
-- Name: costhist; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE costhist (
    costhist_id integer DEFAULT nextval(('"costhist_costhist_id_seq"'::text)::regclass) NOT NULL,
    costhist_item_id integer,
    costhist_costelem_id integer,
    costhist_type character(1),
    costhist_date timestamp with time zone,
    costhist_oldcost numeric(16,6),
    costhist_newcost numeric(16,6),
    costhist_lowlevel boolean,
    costhist_oldcurr_id integer DEFAULT basecurrid(),
    costhist_newcurr_id integer DEFAULT basecurrid(),
    costhist_username text
);


ALTER TABLE public.costhist OWNER TO admin;

--
-- TOC entry 9705 (class 0 OID 0)
-- Dependencies: 535
-- Name: TABLE costhist; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE costhist IS 'Item Cost history';


--
-- TOC entry 536 (class 1259 OID 146568834)
-- Dependencies: 8
-- Name: costhist_costhist_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE costhist_costhist_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.costhist_costhist_id_seq OWNER TO admin;

--
-- TOC entry 537 (class 1259 OID 146568836)
-- Dependencies: 6410 8
-- Name: costupdate; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE costupdate (
    costupdate_item_id integer,
    costupdate_lowlevel_code integer DEFAULT 1 NOT NULL,
    costupdate_item_type character(1)
);


ALTER TABLE public.costupdate OWNER TO admin;

--
-- TOC entry 9708 (class 0 OID 0)
-- Dependencies: 537
-- Name: TABLE costupdate; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE costupdate IS 'Scratch area for sequencing the updating of item costs';


--
-- TOC entry 538 (class 1259 OID 146568840)
-- Dependencies: 6412 6413 8
-- Name: country; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE country (
    country_id integer NOT NULL,
    country_abbr character(2),
    country_name text,
    country_curr_abbr character(3),
    country_curr_name text,
    country_curr_number character(3),
    country_curr_symbol character varying(9),
    country_qt_number integer,
    CONSTRAINT country_country_abbr_check CHECK ((country_abbr <> ''::bpchar)),
    CONSTRAINT country_country_name_check CHECK ((country_name <> ''::text))
);


ALTER TABLE public.country OWNER TO admin;

--
-- TOC entry 9710 (class 0 OID 0)
-- Dependencies: 538
-- Name: TABLE country; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE country IS 'Basic information and properties about countries.';


--
-- TOC entry 539 (class 1259 OID 146568848)
-- Dependencies: 538 8
-- Name: country_country_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE country_country_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.country_country_id_seq OWNER TO admin;

--
-- TOC entry 9712 (class 0 OID 0)
-- Dependencies: 539
-- Name: country_country_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE country_country_id_seq OWNED BY country.country_id;


--
-- TOC entry 540 (class 1259 OID 146568850)
-- Dependencies: 6414 8
-- Name: salesaccnt; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE salesaccnt (
    salesaccnt_id integer DEFAULT nextval(('"salesaccnt_salesaccnt_id_seq"'::text)::regclass) NOT NULL,
    salesaccnt_custtype_id integer,
    salesaccnt_prodcat_id integer,
    salesaccnt_warehous_id integer,
    salesaccnt_sales_accnt_id integer,
    salesaccnt_credit_accnt_id integer,
    salesaccnt_cos_accnt_id integer,
    salesaccnt_custtype text,
    salesaccnt_prodcat text,
    salesaccnt_returns_accnt_id integer,
    salesaccnt_cor_accnt_id integer,
    salesaccnt_cow_accnt_id integer,
    salesaccnt_saletype_id integer,
    salesaccnt_shipzone_id integer
);


ALTER TABLE public.salesaccnt OWNER TO admin;

--
-- TOC entry 9714 (class 0 OID 0)
-- Dependencies: 540
-- Name: TABLE salesaccnt; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE salesaccnt IS 'Sales Account assignment information';


--
-- TOC entry 9715 (class 0 OID 0)
-- Dependencies: 540
-- Name: COLUMN salesaccnt.salesaccnt_saletype_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN salesaccnt.salesaccnt_saletype_id IS 'Associated sale type for sales account.';


--
-- TOC entry 9716 (class 0 OID 0)
-- Dependencies: 540
-- Name: COLUMN salesaccnt.salesaccnt_shipzone_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN salesaccnt.salesaccnt_shipzone_id IS 'Associated shipping zone for sales account.';


--
-- TOC entry 541 (class 1259 OID 146568857)
-- Dependencies: 8576 8
-- Name: creditmemoeditlist; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW creditmemoeditlist AS
    ((((SELECT cmhead.cmhead_id AS orderid, (-2) AS itemid, ('C/M-'::text || formatcreditmemonumber(cmhead.cmhead_id)) AS documentnumber, custinfo.cust_number, cmhead.cmhead_billtoname AS billtoname, cmhead.cmhead_number AS ordernumber, (-1) AS linenumber, ''::text AS item, ''::text AS itemdescrip, ''::text AS iteminvuom, ''::text AS qtytobill, ''::text AS price, formatmoney((((calccmheadamt(cmhead.cmhead_id) + cmhead.cmhead_freight) + cmhead.cmhead_misc) + calccmheadtax(cmhead.cmhead_id))) AS extprice, 'Credit'::text AS sence, COALESCE((SELECT formatglaccountlong(accnt.accnt_id) AS formatglaccountlong FROM accnt WHERE (accnt.accnt_id = findaraccount(custinfo.cust_id))), 'Not Assigned'::text) AS account FROM custinfo, cmhead WHERE ((((cmhead.cmhead_cust_id = custinfo.cust_id) AND (cmhead.cmhead_cust_id = custinfo.cust_id)) AND (NOT cmhead.cmhead_posted)) AND (NOT cmhead.cmhead_hold)) UNION SELECT cmhead.cmhead_id AS orderid, (-1) AS itemid, ''::text AS documentnumber, ''::text AS cust_number, ''::text AS billtoname, cmhead.cmhead_number AS ordernumber, (-1) AS linenumber, 'Freight'::text AS item, 'Freight Charge'::text AS itemdescrip, ''::text AS iteminvuom, ''::text AS qtytobill, formatmoney(cmhead.cmhead_freight) AS price, formatmoney(cmhead.cmhead_freight) AS extprice, 'Debit'::text AS sence, CASE WHEN (accnt.accnt_id IS NULL) THEN 'Not Assigned'::text ELSE formatglaccountlong(accnt.accnt_id) END AS account FROM (cmhead LEFT JOIN accnt ON ((accnt.accnt_id = findfreightaccount(cmhead.cmhead_cust_id)))) WHERE (((NOT cmhead.cmhead_posted) AND (NOT cmhead.cmhead_hold)) AND (cmhead.cmhead_freight <> (0)::numeric))) UNION SELECT cmhead.cmhead_id AS orderid, (-1) AS itemid, ''::text AS documentnumber, ''::text AS cust_number, ''::text AS billtoname, cmhead.cmhead_number AS ordernumber, (-1) AS linenumber, 'Misc. Charge'::text AS item, cmhead.cmhead_misc_descrip AS itemdescrip, ''::text AS iteminvuom, ''::text AS qtytobill, formatmoney(cmhead.cmhead_misc) AS price, formatmoney(cmhead.cmhead_misc) AS extprice, 'Debit'::text AS sence, formatglaccountlong(cmhead.cmhead_misc_accnt_id) AS account FROM cmhead WHERE (((NOT cmhead.cmhead_posted) AND (NOT cmhead.cmhead_hold)) AND (cmhead.cmhead_misc <> (0)::numeric))) UNION SELECT cmhead.cmhead_id AS orderid, (-1) AS itemid, ''::text AS documentnumber, ''::text AS cust_number, ''::text AS billtoname, cmhead.cmhead_number AS ordernumber, (-1) AS linenumber, 'Sales Tax'::text AS item, tax.tax_descrip AS itemdescrip, ''::text AS iteminvuom, ''::text AS qtytobill, formatmoney((cmheadtax.taxhist_tax * (-1.0))) AS price, formatmoney((cmheadtax.taxhist_tax * (-1.0))) AS extprice, 'Debit'::text AS sence, CASE WHEN (accnt.accnt_id IS NULL) THEN 'Not Assigned'::text ELSE ((formatglaccountlong(accnt.accnt_id) || ' - '::text) || accnt.accnt_descrip) END AS account FROM (((cmhead JOIN cmheadtax ON ((cmheadtax.taxhist_parent_id = cmhead.cmhead_id))) JOIN tax ON ((tax.tax_id = cmheadtax.taxhist_tax_id))) LEFT JOIN accnt ON ((accnt.accnt_id = tax.tax_sales_accnt_id))) WHERE ((NOT cmhead.cmhead_posted) AND (NOT cmhead.cmhead_hold))) UNION SELECT cmhead.cmhead_id AS orderid, (-1) AS itemid, ''::text AS documentnumber, ''::text AS cust_number, ''::text AS billtoname, cmhead.cmhead_number AS ordernumber, (-1) AS linenumber, 'Sales Tax'::text AS item, tax.tax_descrip AS itemdescrip, ''::text AS iteminvuom, ''::text AS qtytobill, formatmoney((cmitemtax.taxhist_tax * (-1.0))) AS price, formatmoney((cmitemtax.taxhist_tax * (-1.0))) AS extprice, 'Debit'::text AS sence, CASE WHEN (accnt.accnt_id IS NULL) THEN 'Not Assigned'::text ELSE ((formatglaccountlong(accnt.accnt_id) || ' - '::text) || accnt.accnt_descrip) END AS account FROM ((((cmhead JOIN cmitem ON ((cmitem.cmitem_cmhead_id = cmhead.cmhead_id))) JOIN cmitemtax ON ((cmitemtax.taxhist_parent_id = cmitem.cmitem_id))) JOIN tax ON ((tax.tax_id = cmitemtax.taxhist_tax_id))) LEFT JOIN accnt ON ((accnt.accnt_id = tax.tax_sales_accnt_id))) WHERE ((NOT cmhead.cmhead_posted) AND (NOT cmhead.cmhead_hold))) UNION SELECT cmhead.cmhead_id AS orderid, cmitem.cmitem_id AS itemid, ''::text AS documentnumber, ''::text AS cust_number, ''::text AS billtoname, cmhead.cmhead_number AS ordernumber, cmitem.cmitem_linenumber AS linenumber, item.item_number AS item, item.item_descrip1 AS itemdescrip, uom.uom_name AS iteminvuom, formatqty(COALESCE((cmitem.cmitem_qtycredit * cmitem.cmitem_qty_invuomratio), (0)::numeric)) AS qtytobill, formatprice(COALESCE((cmitem.cmitem_unitprice / cmitem.cmitem_price_invuomratio), (0)::numeric)) AS price, formatmoney(COALESCE(round(((cmitem.cmitem_qtycredit * cmitem.cmitem_qty_invuomratio) * (cmitem.cmitem_unitprice / cmitem.cmitem_price_invuomratio)), 2), (0)::numeric)) AS extprice, 'Debit'::text AS sence, COALESCE((SELECT formatglaccountlong(accnt.accnt_id) AS formatglaccountlong FROM accnt, salesaccnt WHERE ((salesaccnt.salesaccnt_sales_accnt_id = accnt.accnt_id) AND (salesaccnt.salesaccnt_id = findsalesaccnt(cmitem.cmitem_itemsite_id, 'IS'::text, cmhead.cmhead_cust_id, cmhead.cmhead_saletype_id, cmhead.cmhead_shipzone_id)))), 'Not Assigned'::text) AS account FROM item, itemsite, cmhead, cmitem, uom WHERE ((((((cmitem.cmitem_cmhead_id = cmhead.cmhead_id) AND (cmitem.cmitem_itemsite_id = itemsite.itemsite_id)) AND (itemsite.itemsite_item_id = item.item_id)) AND (item.item_inv_uom_id = uom.uom_id)) AND (NOT cmhead.cmhead_posted)) AND (NOT cmhead.cmhead_hold)) ORDER BY 6, 7;


ALTER TABLE public.creditmemoeditlist OWNER TO admin;

--
-- TOC entry 542 (class 1259 OID 146568862)
-- Dependencies: 8577 8
-- Name: creditmemoitem; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW creditmemoitem AS
    SELECT cmitem.cmitem_id, cmitem.cmitem_cmhead_id, cmitem.cmitem_linenumber, cmitem.cmitem_itemsite_id, cmitem.cmitem_qtycredit, cmitem.cmitem_qtyreturned, cmitem.cmitem_unitprice, cmitem.cmitem_comments, cmitem.cmitem_rsncode_id, cmitem.cmitem_taxtype_id, cmitem.cmitem_qty_uom_id, cmitem.cmitem_qty_invuomratio, cmitem.cmitem_price_uom_id, cmitem.cmitem_price_invuomratio, cmitem.cmitem_raitem_id, cmitem.cmitem_updateinv, itemsite.itemsite_item_id AS item_id, COALESCE((cmitem.cmitem_qtycredit * cmitem.cmitem_qty_invuomratio), (0)::numeric) AS qty, COALESCE((cmitem.cmitem_unitprice / cmitem.cmitem_price_invuomratio), (0)::numeric) AS unitprice, COALESCE(round(((cmitem.cmitem_qtycredit * cmitem.cmitem_qty_invuomratio) * (cmitem.cmitem_unitprice / cmitem.cmitem_price_invuomratio)), 2), (0)::numeric) AS extprice, currtobase(cmhead.cmhead_curr_id, COALESCE(round(((cmitem.cmitem_qtycredit * cmitem.cmitem_qty_invuomratio) * (cmitem.cmitem_unitprice / cmitem.cmitem_price_invuomratio)), 2), (0)::numeric), cmhead.cmhead_docdate) AS baseextprice, (SELECT COALESCE(sum(cmitemtax.taxhist_tax), (0)::numeric) AS "coalesce" FROM cmitemtax WHERE (cmitemtax.taxhist_parent_id = cmitem.cmitem_id)) AS tax, CASE WHEN (itemsite.itemsite_costmethod = 'A'::bpchar) THEN avgcost(itemsite.itemsite_id) ELSE stdcost(itemsite.itemsite_item_id) END AS unitcost FROM ((cmitem JOIN cmhead ON ((cmhead.cmhead_id = cmitem.cmitem_cmhead_id))) LEFT JOIN itemsite ON ((itemsite.itemsite_id = cmitem.cmitem_itemsite_id)));


ALTER TABLE public.creditmemoitem OWNER TO admin;

--
-- TOC entry 9719 (class 0 OID 0)
-- Dependencies: 542
-- Name: VIEW creditmemoitem; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON VIEW creditmemoitem IS 'Single point for credit memo item (cmitem) calculations.';


--
-- TOC entry 543 (class 1259 OID 146568867)
-- Dependencies: 205 8
-- Name: crmacct_crmacct_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE crmacct_crmacct_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.crmacct_crmacct_id_seq OWNER TO admin;

--
-- TOC entry 9721 (class 0 OID 0)
-- Dependencies: 543
-- Name: crmacct_crmacct_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE crmacct_crmacct_id_seq OWNED BY crmacct.crmacct_id;


--
-- TOC entry 544 (class 1259 OID 146568869)
-- Dependencies: 6415 6416 6417 6418 6419 6420 6421 6422 6423 6424 6425 6426 6427 6428 6429 6430 6431 6432 8
-- Name: crmacctsel; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE crmacctsel (
    crmacctsel_src_crmacct_id integer NOT NULL,
    crmacctsel_dest_crmacct_id integer,
    crmacctsel_mrg_crmacct_active boolean DEFAULT false NOT NULL,
    crmacctsel_mrg_crmacct_cntct_id_1 boolean DEFAULT false NOT NULL,
    crmacctsel_mrg_crmacct_cntct_id_2 boolean DEFAULT false NOT NULL,
    crmacctsel_mrg_crmacct_competitor_id boolean DEFAULT false NOT NULL,
    crmacctsel_mrg_crmacct_cust_id boolean DEFAULT false NOT NULL,
    crmacctsel_mrg_crmacct_emp_id boolean DEFAULT false NOT NULL,
    crmacctsel_mrg_crmacct_name boolean DEFAULT false NOT NULL,
    crmacctsel_mrg_crmacct_notes boolean DEFAULT false NOT NULL,
    crmacctsel_mrg_crmacct_owner_username boolean DEFAULT false NOT NULL,
    crmacctsel_mrg_crmacct_parent_id boolean DEFAULT false NOT NULL,
    crmacctsel_mrg_crmacct_partner_id boolean DEFAULT false NOT NULL,
    crmacctsel_mrg_crmacct_prospect_id boolean DEFAULT false NOT NULL,
    crmacctsel_mrg_crmacct_salesrep_id boolean DEFAULT false NOT NULL,
    crmacctsel_mrg_crmacct_taxauth_id boolean DEFAULT false NOT NULL,
    crmacctsel_mrg_crmacct_type boolean DEFAULT false NOT NULL,
    crmacctsel_mrg_crmacct_usr_username boolean DEFAULT false NOT NULL,
    crmacctsel_mrg_crmacct_vend_id boolean DEFAULT false NOT NULL,
    crmacctsel_mrg_crmacct_number boolean DEFAULT false NOT NULL
);


ALTER TABLE public.crmacctsel OWNER TO admin;

--
-- TOC entry 9723 (class 0 OID 0)
-- Dependencies: 544
-- Name: TABLE crmacctsel; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE crmacctsel IS 'This table records the proposed conditions of a CRM Account merge. When this merge is performed, the BOOLEAN columns in this table indicate which values in the crmacct table will be copied to the target record. Data in this table are temporary and will be removed by a purge.';


--
-- TOC entry 9724 (class 0 OID 0)
-- Dependencies: 544
-- Name: COLUMN crmacctsel.crmacctsel_src_crmacct_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN crmacctsel.crmacctsel_src_crmacct_id IS 'This is the internal ID of the CRM Account record the data will come from during the merge.';


--
-- TOC entry 9725 (class 0 OID 0)
-- Dependencies: 544
-- Name: COLUMN crmacctsel.crmacctsel_dest_crmacct_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN crmacctsel.crmacctsel_dest_crmacct_id IS 'This is the internal ID of the CRM Account record the data will go to during the merge. If crmacctsel_src_crmacct_id = crmacctsel_dest_crmacct_id, they indicate which crmacct record is the destination of the merge, meaning this is the record that will remain in the database after the merge has been completed and the intermediate data have been purged.';


--
-- TOC entry 545 (class 1259 OID 146568890)
-- Dependencies: 6434 8
-- Name: curr_rate; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE curr_rate (
    curr_rate_id integer NOT NULL,
    curr_id integer NOT NULL,
    curr_rate numeric(16,8) NOT NULL,
    curr_effective date NOT NULL,
    curr_expires date NOT NULL,
    CONSTRAINT curr_rate_curr_rate_check CHECK ((curr_rate > (0)::numeric))
);


ALTER TABLE public.curr_rate OWNER TO admin;


--
-- TOC entry 546 (class 1259 OID 146568894)
-- Dependencies: 545 8
-- Name: curr_rate_curr_rate_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE curr_rate_curr_rate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.curr_rate_curr_rate_id_seq OWNER TO admin;

--
-- TOC entry 9729 (class 0 OID 0)
-- Dependencies: 546
-- Name: curr_rate_curr_rate_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE curr_rate_curr_rate_id_seq OWNED BY curr_rate.curr_rate_id;


--
-- TOC entry 547 (class 1259 OID 146568896)
-- Dependencies: 208 8
-- Name: curr_symbol_curr_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE curr_symbol_curr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.curr_symbol_curr_id_seq OWNER TO admin;

--
-- TOC entry 9731 (class 0 OID 0)
-- Dependencies: 547
-- Name: curr_symbol_curr_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE curr_symbol_curr_id_seq OWNED BY curr_symbol.curr_id;


--
-- TOC entry 548 (class 1259 OID 146568898)
-- Dependencies: 8578 8
-- Name: cust; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW cust AS
    SELECT custinfo.cust_id, custinfo.cust_active, custinfo.cust_custtype_id, custinfo.cust_salesrep_id, custinfo.cust_commprcnt, custinfo.cust_name, m.addr_line1 AS cust_address1, m.addr_line2 AS cust_address2, m.addr_line3 AS cust_address3, m.addr_city AS cust_city, m.addr_state AS cust_state, m.addr_postalcode AS cust_zipcode, btrim(((mc.cntct_first_name || ' '::text) || mc.cntct_last_name)) AS cust_contact, mc.cntct_phone AS cust_phone, mc.cntct_fax AS cust_fax, mc.cntct_email AS cust_email, c.addr_line1 AS cust_corraddress1, c.addr_line2 AS cust_corraddress2, c.addr_line3 AS cust_corraddress3, c.addr_city AS cust_corrcity, c.addr_state AS cust_corrstate, c.addr_postalcode AS cust_corrzipcode, btrim(((cc.cntct_first_name || ' '::text) || cc.cntct_last_name)) AS cust_corrcontact, cc.cntct_phone AS cust_corrphone, cc.cntct_fax AS cust_corrfax, cc.cntct_email AS cust_corremail, custinfo.cust_creditlmt, custinfo.cust_creditrating, custinfo.cust_financecharge, custinfo.cust_backorder, custinfo.cust_partialship, custinfo.cust_terms_id, custinfo.cust_discntprcnt, custinfo.cust_taxzone_id, custinfo.cust_balmethod, custinfo.cust_ffshipto, custinfo.cust_shipform_id, custinfo.cust_shipvia, custinfo.cust_blanketpos, custinfo.cust_shipchrg_id, custinfo.cust_creditstatus, custinfo.cust_comments, custinfo.cust_ffbillto, m.addr_country AS cust_country, c.addr_country AS cust_corrcountry, custinfo.cust_usespos, custinfo.cust_number, custinfo.cust_dateadded, custinfo.cust_exported, custinfo.cust_emaildelivery, custinfo.cust_ediemail, custinfo.cust_edisubject, custinfo.cust_edifilename, custinfo.cust_ediemailbody, custinfo.cust_autoupdatestatus, custinfo.cust_autoholdorders, custinfo.cust_edicc, custinfo.cust_ediprofile_id, custinfo.cust_preferred_warehous_id, custinfo.cust_curr_id, custinfo.cust_creditlmt_curr_id FROM ((((custinfo LEFT JOIN cntct mc ON ((custinfo.cust_cntct_id = mc.cntct_id))) LEFT JOIN addr m ON ((mc.cntct_addr_id = m.addr_id))) LEFT JOIN cntct cc ON ((custinfo.cust_corrcntct_id = cc.cntct_id))) LEFT JOIN addr c ON ((cc.cntct_addr_id = c.addr_id)));


ALTER TABLE public.cust OWNER TO admin;

--
-- TOC entry 549 (class 1259 OID 146568903)
-- Dependencies: 8
-- Name: cust_serial_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE cust_serial_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.cust_serial_seq OWNER TO admin;

--
-- TOC entry 550 (class 1259 OID 146568905)
-- Dependencies: 6435 8
-- Name: custform; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE custform (
    custform_id integer DEFAULT nextval(('"custform_custform_id_seq"'::text)::regclass) NOT NULL,
    custform_custtype_id integer,
    custform_custtype text,
    custform_invoice_report_id integer,
    custform_creditmemo_report_id integer,
    custform_quote_report_id integer,
    custform_packinglist_report_id integer,
    custform_statement_report_id integer,
    custform_sopicklist_report_id integer,
    custform_invoice_report_name text,
    custform_creditmemo_report_name text,
    custform_quote_report_name text,
    custform_packinglist_report_name text,
    custform_statement_report_name text,
    custform_sopicklist_report_name text
);


ALTER TABLE public.custform OWNER TO admin;

--
-- TOC entry 9735 (class 0 OID 0)
-- Dependencies: 550
-- Name: TABLE custform; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE custform IS 'Customer Form assignment information';


--
-- TOC entry 9736 (class 0 OID 0)
-- Dependencies: 550
-- Name: COLUMN custform.custform_invoice_report_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN custform.custform_invoice_report_id IS 'Obsolete -- reference custform_invoice_report_name instead.';


--
-- TOC entry 9737 (class 0 OID 0)
-- Dependencies: 550
-- Name: COLUMN custform.custform_creditmemo_report_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN custform.custform_creditmemo_report_id IS 'Obsolete -- reference custform_creditmemo_report_name instead.';


--
-- TOC entry 9738 (class 0 OID 0)
-- Dependencies: 550
-- Name: COLUMN custform.custform_quote_report_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN custform.custform_quote_report_id IS 'Obsolete -- reference custform_quote_report_name instead.';


--
-- TOC entry 9739 (class 0 OID 0)
-- Dependencies: 550
-- Name: COLUMN custform.custform_packinglist_report_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN custform.custform_packinglist_report_id IS 'Obsolete -- reference custform_packinglist_report_name instead.';


--
-- TOC entry 9740 (class 0 OID 0)
-- Dependencies: 550
-- Name: COLUMN custform.custform_statement_report_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN custform.custform_statement_report_id IS 'Obsolete -- reference custform_statement_report_name instead.';


--
-- TOC entry 9741 (class 0 OID 0)
-- Dependencies: 550
-- Name: COLUMN custform.custform_sopicklist_report_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN custform.custform_sopicklist_report_id IS 'Obsolete -- reference custform_sopicklist_report_name instead.';


--
-- TOC entry 551 (class 1259 OID 146568912)
-- Dependencies: 8
-- Name: custform_custform_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE custform_custform_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.custform_custform_id_seq OWNER TO admin;

--
-- TOC entry 552 (class 1259 OID 146568914)
-- Dependencies: 6436 6437 8
-- Name: custgrp; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE custgrp (
    custgrp_id integer DEFAULT nextval(('"custgrp_custgrp_id_seq"'::text)::regclass) NOT NULL,
    custgrp_name text NOT NULL,
    custgrp_descrip text,
    CONSTRAINT custgrp_custgrp_name_check CHECK ((custgrp_name <> ''::text))
);


ALTER TABLE public.custgrp OWNER TO admin;

--
-- TOC entry 9744 (class 0 OID 0)
-- Dependencies: 552
-- Name: TABLE custgrp; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE custgrp IS 'Customer Group information';


--
-- TOC entry 553 (class 1259 OID 146568922)
-- Dependencies: 8
-- Name: custgrp_custgrp_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE custgrp_custgrp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.custgrp_custgrp_id_seq OWNER TO admin;

--
-- TOC entry 554 (class 1259 OID 146568924)
-- Dependencies: 6438 8
-- Name: custgrpitem; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE custgrpitem (
    custgrpitem_id integer DEFAULT nextval(('"custgrpitem_custgrpitem_id_seq"'::text)::regclass) NOT NULL,
    custgrpitem_custgrp_id integer,
    custgrpitem_cust_id integer
);


ALTER TABLE public.custgrpitem OWNER TO admin;

--
-- TOC entry 9747 (class 0 OID 0)
-- Dependencies: 554
-- Name: TABLE custgrpitem; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE custgrpitem IS 'Customer Group Item information';


--
-- TOC entry 555 (class 1259 OID 146568928)
-- Dependencies: 8
-- Name: custgrpitem_custgrpitem_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE custgrpitem_custgrpitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.custgrpitem_custgrpitem_id_seq OWNER TO admin;

--
-- TOC entry 556 (class 1259 OID 146568930)
-- Dependencies: 8
-- Name: custtype_custtype_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE custtype_custtype_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.custtype_custtype_id_seq OWNER TO admin;

--
-- TOC entry 557 (class 1259 OID 146568932)
-- Dependencies: 291 8
-- Name: dept_dept_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE dept_dept_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.dept_dept_id_seq OWNER TO admin;

--
-- TOC entry 9751 (class 0 OID 0)
-- Dependencies: 557
-- Name: dept_dept_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE dept_dept_id_seq OWNED BY dept.dept_id;


--
-- TOC entry 558 (class 1259 OID 146568934)
-- Dependencies: 6439 8
-- Name: destination; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE destination (
    destination_id integer DEFAULT nextval(('"destination_destination_id_seq"'::text)::regclass) NOT NULL,
    destination_name text,
    destination_city text,
    destination_state text,
    destination_comments text
);


ALTER TABLE public.destination OWNER TO admin;

--
-- TOC entry 9753 (class 0 OID 0)
-- Dependencies: 558
-- Name: TABLE destination; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE destination IS 'Destination information';


--
-- TOC entry 559 (class 1259 OID 146568941)
-- Dependencies: 8
-- Name: destination_destination_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE destination_destination_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.destination_destination_id_seq OWNER TO admin;

--
-- TOC entry 560 (class 1259 OID 146568943)
-- Dependencies: 6440 6441 6442 6443 6444 6445 6446 6447 6448 8
-- Name: wo; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE wo (
    wo_id integer DEFAULT nextval(('wo_wo_id_seq'::text)::regclass) NOT NULL,
    wo_number integer,
    wo_subnumber integer,
    wo_status character(1),
    wo_itemsite_id integer,
    wo_startdate date,
    wo_duedate date,
    wo_ordtype character(1),
    wo_ordid integer,
    wo_qtyord numeric(18,6),
    wo_qtyrcv numeric(18,6),
    wo_adhoc boolean,
    wo_itemcfg_series integer,
    wo_imported boolean,
    wo_wipvalue numeric(16,6) DEFAULT 0,
    wo_postedvalue numeric(16,6) DEFAULT 0,
    wo_prodnotes text,
    wo_prj_id integer,
    wo_priority integer DEFAULT 1 NOT NULL,
    wo_brdvalue numeric(16,6) DEFAULT 0,
    wo_bom_rev_id integer DEFAULT (-1),
    wo_boo_rev_id integer DEFAULT (-1),
    wo_cosmethod character(1),
    wo_womatl_id integer,
    wo_username text DEFAULT geteffectivextuser(),
    CONSTRAINT chk_wo_cosmethod CHECK ((((wo_cosmethod = NULL::bpchar) OR (wo_cosmethod = 'D'::bpchar)) OR (wo_cosmethod = 'P'::bpchar)))
);


ALTER TABLE public.wo OWNER TO admin;


--
-- TOC entry 561 (class 1259 OID 146568958)
-- Dependencies: 8579 8
-- Name: docinfo; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW docinfo AS
    (((((((((((((((((((((((((((((SELECT imageass.imageass_id AS id, (image.image_id)::text AS target_number, 'IMG'::text AS target_type, imageass.imageass_image_id AS target_id, imageass.imageass_source AS source_type, imageass.imageass_source_id AS source_id, image.image_name AS name, image.image_descrip AS description, imageass.imageass_purpose AS purpose FROM imageass, image WHERE (imageass.imageass_image_id = image.image_id) UNION ALL SELECT url.url_id AS id, (url.url_id)::text AS target_number, 'URL'::text AS target_type, url.url_id AS target_id, url.url_source AS source_type, url.url_source_id AS source_id, url.url_title AS name, url.url_url AS description, 'S'::bpchar AS purpose FROM url WHERE (url.url_stream IS NULL)) UNION ALL SELECT url.url_id AS id, (url.url_id)::text AS target_number, 'FILE'::text AS target_type, url.url_id AS target_id, url.url_source AS source_type, url.url_source_id AS source_id, url.url_title AS name, url.url_url AS description, 'S'::bpchar AS purpose FROM url WHERE (url.url_stream IS NOT NULL)) UNION ALL SELECT docass.docass_id AS id, (incdt.incdt_number)::text AS target_number, docass.docass_target_type AS target_type, docass.docass_target_id AS target_id, docass.docass_source_type AS source_type, docass.docass_source_id AS source_id, incdt.incdt_summary AS name, firstline(incdt.incdt_descrip) AS description, docass.docass_purpose AS purpose FROM docass, incdt WHERE ((docass.docass_target_type = 'INCDT'::text) AND (docass.docass_target_id = incdt.incdt_id))) UNION ALL SELECT docass.docass_id AS id, (incdt.incdt_number)::text AS target_number, docass.docass_source_type AS target_type, docass.docass_source_id AS target_id, docass.docass_target_type AS source_type, docass.docass_target_id AS source_id, incdt.incdt_summary AS name, firstline(incdt.incdt_descrip) AS description, CASE WHEN (docass.docass_purpose = 'A'::bpchar) THEN 'C'::bpchar WHEN (docass.docass_purpose = 'C'::bpchar) THEN 'A'::bpchar ELSE docass.docass_purpose END AS purpose FROM docass, incdt WHERE ((docass.docass_source_type = 'INCDT'::text) AND (docass.docass_source_id = incdt.incdt_id))) UNION ALL SELECT docass.docass_id AS id, (todoitem.todoitem_id)::text AS target_number, docass.docass_target_type AS target_type, docass.docass_target_id AS target_id, docass.docass_source_type AS source_type, docass.docass_source_id AS source_id, todoitem.todoitem_name AS name, firstline(todoitem.todoitem_description) AS description, docass.docass_purpose AS purpose FROM docass, todoitem WHERE ((docass.docass_target_type = 'TODO'::text) AND (docass.docass_target_id = todoitem.todoitem_id))) UNION ALL SELECT docass.docass_id AS id, (todoitem.todoitem_id)::text AS target_number, docass.docass_source_type AS target_type, docass.docass_source_id AS target_id, docass.docass_target_type AS source_type, docass.docass_target_id AS source_id, todoitem.todoitem_name AS name, firstline(todoitem.todoitem_description) AS description, CASE WHEN (docass.docass_purpose = 'A'::bpchar) THEN 'C'::bpchar WHEN (docass.docass_purpose = 'C'::bpchar) THEN 'A'::bpchar ELSE docass.docass_purpose END AS purpose FROM docass, todoitem WHERE ((docass.docass_source_type = 'TODO'::text) AND (docass.docass_source_id = todoitem.todoitem_id))) UNION ALL SELECT docass.docass_id AS id, prj.prj_number AS target_number, docass.docass_target_type AS target_type, docass.docass_target_id AS target_id, docass.docass_source_type AS source_type, docass.docass_source_id AS source_id, prj.prj_name AS name, firstline(prj.prj_descrip) AS description, docass.docass_purpose AS purpose FROM docass, prj WHERE ((docass.docass_target_type = 'J'::text) AND (docass.docass_target_id = prj.prj_id))) UNION ALL SELECT docass.docass_id AS id, prj.prj_number AS target_number, docass.docass_source_type AS target_type, docass.docass_source_id AS target_id, docass.docass_target_type AS source_type, docass.docass_target_id AS source_id, prj.prj_name AS name, firstline(prj.prj_descrip) AS description, CASE WHEN (docass.docass_purpose = 'A'::bpchar) THEN 'C'::bpchar WHEN (docass.docass_purpose = 'C'::bpchar) THEN 'A'::bpchar ELSE docass.docass_purpose END AS purpose FROM docass, prj WHERE ((docass.docass_source_type = 'J'::text) AND (docass.docass_source_id = prj.prj_id))) UNION ALL SELECT docass.docass_id AS id, item.item_number AS target_number, docass.docass_target_type AS target_type, docass.docass_target_id AS target_id, docass.docass_source_type AS source_type, docass.docass_source_id AS source_id, firstline(item.item_descrip1) AS name, firstline(item.item_descrip2) AS description, docass.docass_purpose AS purpose FROM docass, item WHERE ((docass.docass_target_type = 'I'::text) AND (docass.docass_target_id = item.item_id))) UNION ALL SELECT docass.docass_id AS id, item.item_number AS target_number, docass.docass_source_type AS target_type, docass.docass_source_id AS target_id, docass.docass_target_type AS source_type, docass.docass_target_id AS source_id, firstline(item.item_descrip1) AS name, firstline(item.item_descrip2) AS description, CASE WHEN (docass.docass_purpose = 'A'::bpchar) THEN 'C'::bpchar WHEN (docass.docass_purpose = 'C'::bpchar) THEN 'A'::bpchar ELSE docass.docass_purpose END AS purpose FROM docass, item WHERE ((docass.docass_source_type = 'I'::text) AND (docass.docass_source_id = item.item_id))) UNION ALL SELECT docass.docass_id AS id, crmacct.crmacct_number AS target_number, docass.docass_target_type AS target_type, docass.docass_target_id AS target_id, docass.docass_source_type AS source_type, docass.docass_source_id AS source_id, crmacct.crmacct_name AS name, firstline(crmacct.crmacct_notes) AS description, docass.docass_purpose AS purpose FROM docass, crmacct WHERE ((docass.docass_target_type = 'CRMA'::text) AND (docass.docass_target_id = crmacct.crmacct_id))) UNION ALL SELECT docass.docass_id AS id, crmacct.crmacct_number AS target_number, docass.docass_source_type AS target_type, docass.docass_source_id AS target_id, docass.docass_target_type AS source_type, docass.docass_target_id AS source_id, crmacct.crmacct_name AS name, firstline(crmacct.crmacct_notes) AS description, CASE WHEN (docass.docass_purpose = 'A'::bpchar) THEN 'C'::bpchar WHEN (docass.docass_purpose = 'C'::bpchar) THEN 'A'::bpchar ELSE docass.docass_purpose END AS purpose FROM docass, crmacct WHERE ((docass.docass_source_type = 'CRMA'::text) AND (docass.docass_source_id = crmacct.crmacct_id))) UNION SELECT docass.docass_id AS id, custinfo.cust_number AS target_number, docass.docass_target_type AS target_type, docass.docass_target_id AS target_id, docass.docass_source_type AS source_type, docass.docass_source_id AS source_id, custinfo.cust_name AS name, firstline(custinfo.cust_comments) AS description, docass.docass_purpose AS purpose FROM docass, custinfo WHERE ((docass.docass_target_type = 'C'::text) AND (docass.docass_target_id = custinfo.cust_id))) UNION ALL SELECT docass.docass_id AS id, custinfo.cust_number AS target_number, docass.docass_source_type AS target_type, docass.docass_source_id AS target_id, docass.docass_target_type AS source_type, docass.docass_target_id AS source_id, custinfo.cust_name AS name, firstline(custinfo.cust_comments) AS description, CASE WHEN (docass.docass_purpose = 'A'::bpchar) THEN 'C'::bpchar WHEN (docass.docass_purpose = 'C'::bpchar) THEN 'A'::bpchar ELSE docass.docass_purpose END AS purpose FROM docass, custinfo WHERE ((docass.docass_source_type = 'C'::text) AND (docass.docass_source_id = custinfo.cust_id))) UNION ALL SELECT docass.docass_id AS id, vendinfo.vend_number AS target_number, docass.docass_target_type AS target_type, docass.docass_target_id AS target_id, docass.docass_source_type AS source_type, docass.docass_source_id AS source_id, vendinfo.vend_name AS name, firstline(vendinfo.vend_comments) AS description, docass.docass_purpose AS purpose FROM docass, vendinfo WHERE ((docass.docass_target_type = 'V'::text) AND (docass.docass_target_id = vendinfo.vend_id))) UNION ALL SELECT docass.docass_id AS id, vendinfo.vend_number AS target_number, docass.docass_source_type AS target_type, docass.docass_source_id AS target_id, docass.docass_target_type AS source_type, docass.docass_target_id AS source_id, vendinfo.vend_name AS name, firstline(vendinfo.vend_comments) AS description, CASE WHEN (docass.docass_purpose = 'A'::bpchar) THEN 'C'::bpchar WHEN (docass.docass_purpose = 'C'::bpchar) THEN 'A'::bpchar ELSE docass.docass_purpose END AS purpose FROM docass, vendinfo WHERE ((docass.docass_source_type = 'V'::text) AND (docass.docass_source_id = vendinfo.vend_id))) UNION ALL SELECT docass.docass_id AS id, cntct.cntct_number AS target_number, docass.docass_target_type AS target_type, docass.docass_target_id AS target_id, docass.docass_source_type AS source_type, docass.docass_source_id AS source_id, cntct.cntct_name AS name, cntct.cntct_title AS description, docass.docass_purpose AS purpose FROM docass, cntct WHERE ((docass.docass_target_type = 'T'::text) AND (docass.docass_target_id = cntct.cntct_id))) UNION ALL SELECT docass.docass_id AS id, cntct.cntct_number AS target_number, docass.docass_source_type AS target_type, docass.docass_source_id AS target_id, docass.docass_target_type AS source_type, docass.docass_target_id AS source_id, cntct.cntct_name AS name, cntct.cntct_title AS description, CASE WHEN (docass.docass_purpose = 'A'::bpchar) THEN 'C'::bpchar WHEN (docass.docass_purpose = 'C'::bpchar) THEN 'A'::bpchar ELSE docass.docass_purpose END AS purpose FROM docass, cntct WHERE ((docass.docass_source_type = 'T'::text) AND (docass.docass_source_id = cntct.cntct_id))) UNION ALL SELECT docass.docass_id AS id, (ophead.ophead_id)::text AS target_number, docass.docass_target_type AS target_type, docass.docass_target_id AS target_id, docass.docass_source_type AS source_type, docass.docass_source_id AS source_id, ophead.ophead_name AS name, firstline(ophead.ophead_notes) AS description, docass.docass_purpose AS purpose FROM docass, ophead WHERE ((docass.docass_target_type = 'OPP'::text) AND (docass.docass_target_id = ophead.ophead_id))) UNION ALL SELECT docass.docass_id AS id, (ophead.ophead_id)::text AS target_number, docass.docass_source_type AS target_type, docass.docass_source_id AS target_id, docass.docass_target_type AS source_type, docass.docass_target_id AS source_id, ophead.ophead_name AS name, firstline(ophead.ophead_notes) AS description, CASE WHEN (docass.docass_purpose = 'A'::bpchar) THEN 'C'::bpchar WHEN (docass.docass_purpose = 'C'::bpchar) THEN 'A'::bpchar ELSE docass.docass_purpose END AS purpose FROM docass, ophead WHERE ((docass.docass_source_type = 'OPP'::text) AND (docass.docass_source_id = ophead.ophead_id))) UNION ALL SELECT docass.docass_id AS id, quhead.quhead_number AS target_number, docass.docass_target_type AS target_type, docass.docass_target_id AS target_id, docass.docass_source_type AS source_type, docass.docass_source_id AS source_id, custinfo.cust_name AS name, firstline(quhead.quhead_ordercomments) AS description, docass.docass_purpose AS purpose FROM docass, quhead, custinfo WHERE (((docass.docass_target_type = 'Q'::text) AND (docass.docass_target_id = quhead.quhead_id)) AND (custinfo.cust_id = quhead.quhead_cust_id))) UNION ALL SELECT docass.docass_id AS id, quhead.quhead_number AS target_number, docass.docass_source_type AS target_type, docass.docass_source_id AS target_id, docass.docass_target_type AS source_type, docass.docass_target_id AS source_id, custinfo.cust_name AS name, firstline(quhead.quhead_ordercomments) AS description, CASE WHEN (docass.docass_purpose = 'A'::bpchar) THEN 'C'::bpchar WHEN (docass.docass_purpose = 'C'::bpchar) THEN 'A'::bpchar ELSE docass.docass_purpose END AS purpose FROM docass, quhead, custinfo WHERE (((docass.docass_source_type = 'Q'::text) AND (docass.docass_source_id = quhead.quhead_id)) AND (custinfo.cust_id = quhead.quhead_cust_id))) UNION ALL SELECT docass.docass_id AS id, cohead.cohead_number AS target_number, docass.docass_target_type AS target_type, docass.docass_target_id AS target_id, docass.docass_source_type AS source_type, docass.docass_source_id AS source_id, custinfo.cust_name AS name, firstline(cohead.cohead_ordercomments) AS description, docass.docass_purpose AS purpose FROM docass, cohead, custinfo WHERE (((docass.docass_target_type = 'S'::text) AND (docass.docass_target_id = cohead.cohead_id)) AND (custinfo.cust_id = cohead.cohead_cust_id))) UNION ALL SELECT docass.docass_id AS id, cohead.cohead_number AS target_number, docass.docass_source_type AS target_type, docass.docass_source_id AS target_id, docass.docass_target_type AS source_type, docass.docass_target_id AS source_id, custinfo.cust_name AS name, firstline(cohead.cohead_ordercomments) AS description, CASE WHEN (docass.docass_purpose = 'A'::bpchar) THEN 'C'::bpchar WHEN (docass.docass_purpose = 'C'::bpchar) THEN 'A'::bpchar ELSE docass.docass_purpose END AS purpose FROM docass, cohead, custinfo WHERE (((docass.docass_source_type = 'S'::text) AND (docass.docass_source_id = cohead.cohead_id)) AND (custinfo.cust_id = cohead.cohead_cust_id))) UNION ALL SELECT docass.docass_id AS id, pohead.pohead_number AS target_number, docass.docass_target_type AS target_type, docass.docass_target_id AS target_id, docass.docass_source_type AS source_type, docass.docass_source_id AS source_id, vendinfo.vend_name AS name, firstline(pohead.pohead_comments) AS description, docass.docass_purpose AS purpose FROM docass, pohead, vendinfo WHERE (((docass.docass_target_type = 'P'::text) AND (docass.docass_target_id = pohead.pohead_id)) AND (vendinfo.vend_id = pohead.pohead_vend_id))) UNION ALL SELECT docass.docass_id AS id, pohead.pohead_number AS target_number, docass.docass_source_type AS target_type, docass.docass_source_id AS target_id, docass.docass_target_type AS source_type, docass.docass_target_id AS source_id, vendinfo.vend_name AS name, firstline(pohead.pohead_comments) AS description, CASE WHEN (docass.docass_purpose = 'A'::bpchar) THEN 'C'::bpchar WHEN (docass.docass_purpose = 'C'::bpchar) THEN 'A'::bpchar ELSE docass.docass_purpose END AS purpose FROM docass, pohead, vendinfo WHERE (((docass.docass_source_type = 'P'::text) AND (docass.docass_source_id = pohead.pohead_id)) AND (vendinfo.vend_id = pohead.pohead_vend_id))) UNION ALL SELECT docass.docass_id AS id, formatwonumber(wo.wo_id) AS target_number, docass.docass_target_type AS target_type, docass.docass_target_id AS target_id, docass.docass_source_type AS source_type, docass.docass_source_id AS source_id, item.item_descrip1 AS name, item.item_descrip2 AS description, docass.docass_purpose AS purpose FROM docass, wo, itemsite, item WHERE ((((docass.docass_target_type = 'W'::text) AND (docass.docass_target_id = wo.wo_id)) AND (wo.wo_itemsite_id = itemsite.itemsite_id)) AND (itemsite.itemsite_item_id = item.item_id))) UNION ALL SELECT docass.docass_id AS id, formatwonumber(wo.wo_id) AS target_number, docass.docass_source_type AS target_type, docass.docass_source_id AS target_id, docass.docass_target_type AS source_type, docass.docass_target_id AS source_id, item.item_descrip1 AS name, item.item_descrip2 AS description, CASE WHEN (docass.docass_purpose = 'A'::bpchar) THEN 'C'::bpchar WHEN (docass.docass_purpose = 'C'::bpchar) THEN 'A'::bpchar ELSE docass.docass_purpose END AS purpose FROM docass, wo, itemsite, item WHERE ((((docass.docass_source_type = 'W'::text) AND (docass.docass_source_id = wo.wo_id)) AND (wo.wo_itemsite_id = itemsite.itemsite_id)) AND (itemsite.itemsite_item_id = item.item_id))) UNION ALL SELECT docass.docass_id AS id, emp.emp_number AS target_number, docass.docass_target_type AS target_type, docass.docass_target_id AS target_id, docass.docass_source_type AS source_type, docass.docass_source_id AS source_id, cntct.cntct_name AS name, cntct.cntct_title AS description, docass.docass_purpose AS purpose FROM docass, (emp LEFT JOIN cntct ON ((emp.emp_cntct_id = cntct.cntct_id))) WHERE ((docass.docass_target_type = 'EMP'::text) AND (docass.docass_target_id = emp.emp_id))) UNION ALL SELECT docass.docass_id AS id, emp.emp_number AS target_number, docass.docass_source_type AS target_type, docass.docass_source_id AS target_id, docass.docass_target_type AS source_type, docass.docass_target_id AS source_id, cntct.cntct_name AS name, cntct.cntct_title AS description, CASE WHEN (docass.docass_purpose = 'A'::bpchar) THEN 'C'::bpchar WHEN (docass.docass_purpose = 'C'::bpchar) THEN 'A'::bpchar ELSE docass.docass_purpose END AS purpose FROM docass, (emp LEFT JOIN cntct ON ((emp.emp_cntct_id = cntct.cntct_id))) WHERE ((docass.docass_source_type = 'EMP'::text) AND (docass.docass_source_id = emp.emp_id));


ALTER TABLE public.docinfo OWNER TO admin;

--
-- TOC entry 562 (class 1259 OID 146568963)
-- Dependencies: 292 8
-- Name: emp_emp_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE emp_emp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.emp_emp_id_seq OWNER TO admin;

--
-- TOC entry 9759 (class 0 OID 0)
-- Dependencies: 562
-- Name: emp_emp_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE emp_emp_id_seq OWNED BY emp.emp_id;


--
-- TOC entry 563 (class 1259 OID 146568965)
-- Dependencies: 6450 8
-- Name: empgrp; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE empgrp (
    empgrp_id integer NOT NULL,
    empgrp_name text NOT NULL,
    empgrp_descrip text NOT NULL,
    CONSTRAINT empgrp_empgrp_name_check CHECK ((empgrp_name <> ''::text))
);


ALTER TABLE public.empgrp OWNER TO admin;

--
-- TOC entry 564 (class 1259 OID 146568972)
-- Dependencies: 563 8
-- Name: empgrp_empgrp_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE empgrp_empgrp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.empgrp_empgrp_id_seq OWNER TO admin;

--
-- TOC entry 9762 (class 0 OID 0)
-- Dependencies: 564
-- Name: empgrp_empgrp_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE empgrp_empgrp_id_seq OWNED BY empgrp.empgrp_id;


--
-- TOC entry 565 (class 1259 OID 146568974)
-- Dependencies: 8
-- Name: empgrpitem; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE empgrpitem (
    empgrpitem_id integer NOT NULL,
    empgrpitem_empgrp_id integer NOT NULL,
    empgrpitem_emp_id integer NOT NULL
);


ALTER TABLE public.empgrpitem OWNER TO admin;

--
-- TOC entry 566 (class 1259 OID 146568977)
-- Dependencies: 565 8
-- Name: empgrpitem_empgrpitem_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE empgrpitem_empgrpitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.empgrpitem_empgrpitem_id_seq OWNER TO admin;

--
-- TOC entry 9765 (class 0 OID 0)
-- Dependencies: 566
-- Name: empgrpitem_empgrpitem_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE empgrpitem_empgrpitem_id_seq OWNED BY empgrpitem.empgrpitem_id;


--
-- TOC entry 567 (class 1259 OID 146568979)
-- Dependencies: 6452 8
-- Name: evntlog; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE evntlog (
    evntlog_id integer DEFAULT nextval(('evntlog_evntlog_id_seq'::text)::regclass) NOT NULL,
    evntlog_evnttime timestamp with time zone,
    evntlog_evnttype_id integer,
    evntlog_ord_id integer,
    evntlog_dispatched timestamp with time zone,
    evntlog_action text,
    evntlog_warehous_id integer,
    evntlog_number text,
    evntlog_newvalue numeric(20,10),
    evntlog_oldvalue numeric(20,10),
    evntlog_newdate date,
    evntlog_olddate date,
    evntlog_ordtype character(2),
    evntlog_username text
);


ALTER TABLE public.evntlog OWNER TO admin;

--
-- TOC entry 9767 (class 0 OID 0)
-- Dependencies: 567
-- Name: TABLE evntlog; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE evntlog IS 'Event Notification history';


--
-- TOC entry 568 (class 1259 OID 146568986)
-- Dependencies: 8
-- Name: evntlog_evntlog_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE evntlog_evntlog_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.evntlog_evntlog_id_seq OWNER TO admin;

--
-- TOC entry 569 (class 1259 OID 146568988)
-- Dependencies: 6453 8
-- Name: evntnot; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE evntnot (
    evntnot_id integer DEFAULT nextval(('evntnot_evntnot_id_seq'::text)::regclass) NOT NULL,
    evntnot_evnttype_id integer,
    evntnot_warehous_id integer,
    evntnot_username text
);


ALTER TABLE public.evntnot OWNER TO admin;

--
-- TOC entry 9770 (class 0 OID 0)
-- Dependencies: 569
-- Name: TABLE evntnot; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE evntnot IS 'Temporary table for storing information about user Event Notification selections';


--
-- TOC entry 570 (class 1259 OID 146568995)
-- Dependencies: 8
-- Name: evntnot_evntnot_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE evntnot_evntnot_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.evntnot_evntnot_id_seq OWNER TO admin;

--
-- TOC entry 571 (class 1259 OID 146568997)
-- Dependencies: 6454 6455 8
-- Name: evnttype; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE evnttype (
    evnttype_id integer DEFAULT nextval(('evnttype_evnttype_id_seq'::text)::regclass) NOT NULL,
    evnttype_name text NOT NULL,
    evnttype_descrip text,
    evnttype_module text,
    CONSTRAINT evnttype_evnttype_name_check CHECK ((evnttype_name <> ''::text))
);


ALTER TABLE public.evnttype OWNER TO admin;

--
-- TOC entry 9773 (class 0 OID 0)
-- Dependencies: 571
-- Name: TABLE evnttype; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE evnttype IS 'Event Type information';


--
-- TOC entry 572 (class 1259 OID 146569005)
-- Dependencies: 8
-- Name: evnttype_evnttype_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE evnttype_evnttype_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.evnttype_evnttype_id_seq OWNER TO admin;

--
-- TOC entry 573 (class 1259 OID 146569007)
-- Dependencies: 358 8
-- Name: expcat_expcat_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE expcat_expcat_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.expcat_expcat_id_seq OWNER TO admin;

--
-- TOC entry 9776 (class 0 OID 0)
-- Dependencies: 573
-- Name: expcat_expcat_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE expcat_expcat_id_seq OWNED BY expcat.expcat_id;


--
-- TOC entry 574 (class 1259 OID 146569009)
-- Dependencies: 243 8
-- Name: file_file_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE file_file_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.file_file_id_seq OWNER TO admin;

--
-- TOC entry 9778 (class 0 OID 0)
-- Dependencies: 574
-- Name: file_file_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE file_file_id_seq OWNED BY file.file_id;


--
-- TOC entry 575 (class 1259 OID 146569011)
-- Dependencies: 6457 8
-- Name: filter; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE filter (
    filter_id integer NOT NULL,
    filter_screen text NOT NULL,
    filter_value text NOT NULL,
    filter_username text,
    filter_name text NOT NULL,
    filter_selected boolean DEFAULT false
);


ALTER TABLE public.filter OWNER TO admin;

--
-- TOC entry 576 (class 1259 OID 146569018)
-- Dependencies: 575 8
-- Name: filter_filter_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE filter_filter_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.filter_filter_id_seq OWNER TO admin;

--
-- TOC entry 9781 (class 0 OID 0)
-- Dependencies: 576
-- Name: filter_filter_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE filter_filter_id_seq OWNED BY filter.filter_id;


--
-- TOC entry 577 (class 1259 OID 146569020)
-- Dependencies: 8
-- Name: fincharg; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE fincharg (
    fincharg_id integer NOT NULL,
    fincharg_mincharg numeric NOT NULL,
    fincharg_graceperiod integer NOT NULL,
    fincharg_assessoverdue boolean NOT NULL,
    fincharg_calcfrom integer NOT NULL,
    fincharg_markoninvoice text NOT NULL,
    fincharg_air numeric NOT NULL,
    fincharg_accnt_id integer NOT NULL,
    fincharg_salescat_id integer NOT NULL,
    fincharg_lastfc_statementcyclefrom text,
    fincharg_lastfc_custidfrom text,
    fincharg_lastfc_custidto text,
    fincharg_lastfc_statementcycleto text
);


ALTER TABLE public.fincharg OWNER TO admin;

--
-- TOC entry 9783 (class 0 OID 0)
-- Dependencies: 577
-- Name: TABLE fincharg; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE fincharg IS 'Finance Charge configuration information';


--
-- TOC entry 578 (class 1259 OID 146569026)
-- Dependencies: 577 8
-- Name: fincharg_fincharg_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE fincharg_fincharg_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.fincharg_fincharg_id_seq OWNER TO admin;

--
-- TOC entry 9785 (class 0 OID 0)
-- Dependencies: 578
-- Name: fincharg_fincharg_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE fincharg_fincharg_id_seq OWNED BY fincharg.fincharg_id;


--
-- TOC entry 579 (class 1259 OID 146569028)
-- Dependencies: 6459 6460 6461 6462 6463 6464 6465 6466 6467 6468 6469 6470 6471 6472 6473 6474 6475 6476 6478 8
-- Name: flhead; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE flhead (
    flhead_id integer NOT NULL,
    flhead_name text NOT NULL,
    flhead_descrip text,
    flhead_showtotal boolean DEFAULT false NOT NULL,
    flhead_showstart boolean DEFAULT true NOT NULL,
    flhead_showend boolean DEFAULT true NOT NULL,
    flhead_showdelta boolean DEFAULT true NOT NULL,
    flhead_showbudget boolean DEFAULT true NOT NULL,
    flhead_showdiff boolean DEFAULT false NOT NULL,
    flhead_showcustom boolean DEFAULT false NOT NULL,
    flhead_custom_label text,
    flhead_usealttotal boolean DEFAULT false NOT NULL,
    flhead_alttotal text,
    flhead_usealtbegin boolean DEFAULT false NOT NULL,
    flhead_altbegin text,
    flhead_usealtend boolean DEFAULT false NOT NULL,
    flhead_altend text,
    flhead_usealtdebits boolean DEFAULT false NOT NULL,
    flhead_altdebits text,
    flhead_usealtcredits boolean DEFAULT false NOT NULL,
    flhead_altcredits text,
    flhead_usealtbudget boolean DEFAULT false NOT NULL,
    flhead_altbudget text,
    flhead_usealtdiff boolean DEFAULT false NOT NULL,
    flhead_altdiff text,
    flhead_type character(1) DEFAULT 'A'::bpchar NOT NULL,
    flhead_active boolean DEFAULT true NOT NULL,
    flhead_sys boolean DEFAULT false,
    flhead_notes text DEFAULT ''::text,
    CONSTRAINT flhead_flhead_name_check CHECK ((flhead_name <> ''::text))
);


ALTER TABLE public.flhead OWNER TO admin;

--
-- TOC entry 9787 (class 0 OID 0)
-- Dependencies: 579
-- Name: TABLE flhead; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE flhead IS 'Financial Layout header information';


--
-- TOC entry 580 (class 1259 OID 146569053)
-- Dependencies: 6479 6480 6481 6482 6483 6484 6485 6486 6487 6488 6489 8
-- Name: flitem; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE flitem (
    flitem_id integer NOT NULL,
    flitem_flhead_id integer,
    flitem_flgrp_id integer,
    flitem_order integer,
    flitem_accnt_id integer,
    flitem_showstart boolean,
    flitem_showend boolean,
    flitem_showdelta boolean,
    flitem_showbudget boolean DEFAULT false NOT NULL,
    flitem_subtract boolean DEFAULT false NOT NULL,
    flitem_showstartprcnt boolean DEFAULT false NOT NULL,
    flitem_showendprcnt boolean DEFAULT false NOT NULL,
    flitem_showdeltaprcnt boolean DEFAULT false NOT NULL,
    flitem_showbudgetprcnt boolean DEFAULT false NOT NULL,
    flitem_prcnt_flgrp_id integer DEFAULT (-1) NOT NULL,
    flitem_showdiff boolean DEFAULT false NOT NULL,
    flitem_showdiffprcnt boolean DEFAULT false NOT NULL,
    flitem_showcustom boolean DEFAULT false NOT NULL,
    flitem_showcustomprcnt boolean DEFAULT false NOT NULL,
    flitem_custom_source character(1),
    flitem_company text,
    flitem_profit text,
    flitem_number text,
    flitem_sub text,
    flitem_type character(1),
    flitem_subaccnttype_code text
);


ALTER TABLE public.flitem OWNER TO admin;

--
-- TOC entry 9789 (class 0 OID 0)
-- Dependencies: 580
-- Name: TABLE flitem; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE flitem IS 'Financial Layout Account information';


--
-- TOC entry 581 (class 1259 OID 146569070)
-- Dependencies: 8580 8
-- Name: flaccnt; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW flaccnt AS
    SELECT flhead.flhead_type, flitem.flitem_id, flitem.flitem_flhead_id, flitem.flitem_flgrp_id, flitem.flitem_order, flitem.flitem_accnt_id, flitem.flitem_showstart, flitem.flitem_showend, flitem.flitem_showdelta, flitem.flitem_showbudget, flitem.flitem_subtract, flitem.flitem_showstartprcnt, flitem.flitem_showendprcnt, flitem.flitem_showdeltaprcnt, flitem.flitem_showbudgetprcnt, flitem.flitem_prcnt_flgrp_id, flitem.flitem_showdiff, flitem.flitem_showdiffprcnt, flitem.flitem_showcustom, flitem.flitem_showcustomprcnt, flitem.flitem_custom_source, flitem.flitem_company, flitem.flitem_profit, flitem.flitem_number, flitem.flitem_sub, flitem.flitem_type, flitem.flitem_subaccnttype_code, accnt.accnt_id, accnt.accnt_type, accnt.accnt_company, accnt.accnt_profit, accnt.accnt_number, accnt.accnt_sub, (-1) AS prj_id FROM ((flhead JOIN flitem ON ((flhead.flhead_id = flitem.flitem_flhead_id))) JOIN accnt ON ((flitem.flitem_accnt_id = accnt.accnt_id))) UNION ALL SELECT flhead.flhead_type, flitem.flitem_id, flitem.flitem_flhead_id, flitem.flitem_flgrp_id, flitem.flitem_order, flitem.flitem_accnt_id, flitem.flitem_showstart, flitem.flitem_showend, flitem.flitem_showdelta, flitem.flitem_showbudget, flitem.flitem_subtract, flitem.flitem_showstartprcnt, flitem.flitem_showendprcnt, flitem.flitem_showdeltaprcnt, flitem.flitem_showbudgetprcnt, flitem.flitem_prcnt_flgrp_id, flitem.flitem_showdiff, flitem.flitem_showdiffprcnt, flitem.flitem_showcustom, flitem.flitem_showcustomprcnt, flitem.flitem_custom_source, flitem.flitem_company, flitem.flitem_profit, flitem.flitem_number, flitem.flitem_sub, flitem.flitem_type, flitem.flitem_subaccnttype_code, accnt.accnt_id, accnt.accnt_type, accnt.accnt_company, accnt.accnt_profit, accnt.accnt_number, accnt.accnt_sub, (-1) AS prj_id FROM (flhead JOIN flitem ON ((flhead.flhead_id = flitem.flitem_flhead_id))), accnt WHERE (((((((flitem.flitem_accnt_id = (-1)) AND ((flitem.flitem_type = ''::bpchar) OR (accnt.accnt_type = flitem.flitem_type))) AND ((flitem.flitem_company = 'All'::text) OR (accnt.accnt_company = flitem.flitem_company))) AND ((flitem.flitem_profit = 'All'::text) OR (accnt.accnt_profit = flitem.flitem_profit))) AND ((flitem.flitem_number = 'All'::text) OR (accnt.accnt_number = flitem.flitem_number))) AND ((flitem.flitem_sub = 'All'::text) OR (accnt.accnt_sub = flitem.flitem_sub))) AND ((flitem.flitem_subaccnttype_code = 'All'::text) OR (accnt.accnt_subaccnttype_code = flitem.flitem_subaccnttype_code))) ORDER BY 30, 31, 32, 33;


ALTER TABLE public.flaccnt OWNER TO admin;

--
-- TOC entry 582 (class 1259 OID 146569075)
-- Dependencies: 8
-- Name: flcol; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE flcol (
    flcol_id integer NOT NULL,
    flcol_flhead_id integer NOT NULL,
    flcol_name text,
    flcol_descrip text,
    flcol_report_id integer,
    flcol_month boolean,
    flcol_quarter boolean,
    flcol_year boolean,
    flcol_showdb boolean,
    flcol_prcnt boolean,
    flcol_priortype character(1),
    flcol_priormonth boolean,
    flcol_priorquarter boolean,
    flcol_prioryear character(1),
    flcol_priorprcnt boolean,
    flcol_priordiff boolean,
    flcol_priordiffprcnt boolean,
    flcol_budget boolean,
    flcol_budgetprcnt boolean,
    flcol_budgetdiff boolean,
    flcol_budgetdiffprcnt boolean
);


ALTER TABLE public.flcol OWNER TO admin;

--
-- TOC entry 583 (class 1259 OID 146569081)
-- Dependencies: 582 8
-- Name: flcol_flcol_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE flcol_flcol_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.flcol_flcol_id_seq OWNER TO admin;

--
-- TOC entry 9793 (class 0 OID 0)
-- Dependencies: 583
-- Name: flcol_flcol_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE flcol_flcol_id_seq OWNED BY flcol.flcol_id;


--
-- TOC entry 584 (class 1259 OID 146569083)
-- Dependencies: 6492 6493 6494 6495 6496 6497 6498 6499 6500 6501 6502 6503 6504 6505 6506 6507 6508 8
-- Name: flgrp; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE flgrp (
    flgrp_id integer NOT NULL,
    flgrp_flhead_id integer,
    flgrp_flgrp_id integer,
    flgrp_order integer,
    flgrp_name text,
    flgrp_descrip text,
    flgrp_subtotal boolean DEFAULT false NOT NULL,
    flgrp_summarize boolean DEFAULT false NOT NULL,
    flgrp_subtract boolean DEFAULT false NOT NULL,
    flgrp_showstart boolean DEFAULT true NOT NULL,
    flgrp_showend boolean DEFAULT true NOT NULL,
    flgrp_showdelta boolean DEFAULT true NOT NULL,
    flgrp_showbudget boolean DEFAULT true NOT NULL,
    flgrp_showstartprcnt boolean DEFAULT false NOT NULL,
    flgrp_showendprcnt boolean DEFAULT false NOT NULL,
    flgrp_showdeltaprcnt boolean DEFAULT false NOT NULL,
    flgrp_showbudgetprcnt boolean DEFAULT false NOT NULL,
    flgrp_prcnt_flgrp_id integer DEFAULT (-1) NOT NULL,
    flgrp_showdiff boolean DEFAULT false NOT NULL,
    flgrp_showdiffprcnt boolean DEFAULT false NOT NULL,
    flgrp_showcustom boolean DEFAULT false NOT NULL,
    flgrp_showcustomprcnt boolean DEFAULT false NOT NULL,
    flgrp_usealtsubtotal boolean DEFAULT false NOT NULL,
    flgrp_altsubtotal text
);


ALTER TABLE public.flgrp OWNER TO admin;

--
-- TOC entry 9795 (class 0 OID 0)
-- Dependencies: 584
-- Name: TABLE flgrp; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE flgrp IS 'Financial Layout Group information';


--
-- TOC entry 585 (class 1259 OID 146569106)
-- Dependencies: 584 8
-- Name: flgrp_flgrp_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE flgrp_flgrp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.flgrp_flgrp_id_seq OWNER TO admin;

--
-- TOC entry 9797 (class 0 OID 0)
-- Dependencies: 585
-- Name: flgrp_flgrp_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE flgrp_flgrp_id_seq OWNED BY flgrp.flgrp_id;


--
-- TOC entry 586 (class 1259 OID 146569108)
-- Dependencies: 579 8
-- Name: flhead_flhead_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE flhead_flhead_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.flhead_flhead_id_seq OWNER TO admin;

--
-- TOC entry 9799 (class 0 OID 0)
-- Dependencies: 586
-- Name: flhead_flhead_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE flhead_flhead_id_seq OWNED BY flhead.flhead_id;


--
-- TOC entry 587 (class 1259 OID 146569110)
-- Dependencies: 580 8
-- Name: flitem_flitem_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE flitem_flitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.flitem_flitem_id_seq OWNER TO admin;

--
-- TOC entry 9801 (class 0 OID 0)
-- Dependencies: 587
-- Name: flitem_flitem_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE flitem_flitem_id_seq OWNED BY flitem.flitem_id;


--
-- TOC entry 588 (class 1259 OID 146569112)
-- Dependencies: 6511 8
-- Name: flnotes; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE flnotes (
    flnotes_id integer NOT NULL,
    flnotes_flhead_id integer,
    flnotes_period_id integer,
    flnotes_notes text DEFAULT ''::text
);


ALTER TABLE public.flnotes OWNER TO admin;

--
-- TOC entry 589 (class 1259 OID 146569119)
-- Dependencies: 588 8
-- Name: flnotes_flnotes_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE flnotes_flnotes_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.flnotes_flnotes_id_seq OWNER TO admin;

--
-- TOC entry 9804 (class 0 OID 0)
-- Dependencies: 589
-- Name: flnotes_flnotes_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE flnotes_flnotes_id_seq OWNED BY flnotes.flnotes_id;


--
-- TOC entry 590 (class 1259 OID 146569121)
-- Dependencies: 8
-- Name: flrpt; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE flrpt (
    flrpt_flhead_id integer NOT NULL,
    flrpt_period_id integer NOT NULL,
    flrpt_username text NOT NULL,
    flrpt_order integer NOT NULL,
    flrpt_level integer NOT NULL,
    flrpt_type text NOT NULL,
    flrpt_type_id integer NOT NULL,
    flrpt_beginning numeric,
    flrpt_ending numeric,
    flrpt_debits numeric,
    flrpt_credits numeric,
    flrpt_budget numeric,
    flrpt_beginningprcnt numeric,
    flrpt_endingprcnt numeric,
    flrpt_debitsprcnt numeric,
    flrpt_creditsprcnt numeric,
    flrpt_budgetprcnt numeric,
    flrpt_parent_id integer,
    flrpt_diff numeric,
    flrpt_diffprcnt numeric,
    flrpt_custom numeric,
    flrpt_customprcnt numeric,
    flrpt_altname text,
    flrpt_accnt_id integer,
    flrpt_interval character(1),
    flrpt_id integer NOT NULL
);


ALTER TABLE public.flrpt OWNER TO admin;

--
-- TOC entry 9806 (class 0 OID 0)
-- Dependencies: 590
-- Name: TABLE flrpt; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE flrpt IS 'Scratch table where financial reporting information is processed before being displayed.';


--
-- TOC entry 591 (class 1259 OID 146569127)
-- Dependencies: 590 8
-- Name: flrpt_flrpt_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE flrpt_flrpt_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.flrpt_flrpt_id_seq OWNER TO admin;

--
-- TOC entry 9808 (class 0 OID 0)
-- Dependencies: 591
-- Name: flrpt_flrpt_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE flrpt_flrpt_id_seq OWNED BY flrpt.flrpt_id;


--
-- TOC entry 592 (class 1259 OID 146569129)
-- Dependencies: 6513 6514 6515 6516 6517 6518 6519 6520 6521 6522 6523 6524 6525 6526 8
-- Name: flspec; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE flspec (
    flspec_id integer NOT NULL,
    flspec_flhead_id integer NOT NULL,
    flspec_flgrp_id integer NOT NULL,
    flspec_order integer NOT NULL,
    flspec_name text,
    flspec_type text,
    flspec_showstart boolean DEFAULT true NOT NULL,
    flspec_showend boolean DEFAULT true NOT NULL,
    flspec_showdelta boolean DEFAULT true NOT NULL,
    flspec_showbudget boolean DEFAULT false NOT NULL,
    flspec_subtract boolean DEFAULT false NOT NULL,
    flspec_showstartprcnt boolean DEFAULT false NOT NULL,
    flspec_showendprcnt boolean DEFAULT false NOT NULL,
    flspec_showdeltaprcnt boolean DEFAULT false NOT NULL,
    flspec_showbudgetprcnt boolean DEFAULT false NOT NULL,
    flspec_showdiff boolean DEFAULT false NOT NULL,
    flspec_showdiffprcnt boolean DEFAULT false NOT NULL,
    flspec_prcnt_flgrp_id integer DEFAULT (-1) NOT NULL,
    flspec_showcustom boolean DEFAULT false NOT NULL,
    flspec_showcustomprcnt boolean DEFAULT false NOT NULL,
    flspec_custom_source character(1)
);


ALTER TABLE public.flspec OWNER TO admin;

--
-- TOC entry 9810 (class 0 OID 0)
-- Dependencies: 592
-- Name: TABLE flspec; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE flspec IS 'Financial Layout Special entries.';


--
-- TOC entry 593 (class 1259 OID 146569149)
-- Dependencies: 592 8
-- Name: flspec_flspec_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE flspec_flspec_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.flspec_flspec_id_seq OWNER TO admin;

--
-- TOC entry 9812 (class 0 OID 0)
-- Dependencies: 593
-- Name: flspec_flspec_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE flspec_flspec_id_seq OWNED BY flspec.flspec_id;


--
-- TOC entry 594 (class 1259 OID 146569151)
-- Dependencies: 6528 6529 8
-- Name: form; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE form (
    form_id integer DEFAULT nextval(('"form_form_id_seq"'::text)::regclass) NOT NULL,
    form_name text NOT NULL,
    form_descrip text,
    form_report_id integer,
    form_key character varying(4),
    form_report_name text,
    CONSTRAINT form_form_name_check CHECK ((form_name <> ''::text))
);


ALTER TABLE public.form OWNER TO admin;

--
-- TOC entry 9814 (class 0 OID 0)
-- Dependencies: 594
-- Name: TABLE form; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE form IS 'Form information';


--
-- TOC entry 9815 (class 0 OID 0)
-- Dependencies: 594
-- Name: COLUMN form.form_report_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN form.form_report_id IS 'Obsolete -- reference form_report_name instead.';


--
-- TOC entry 595 (class 1259 OID 146569159)
-- Dependencies: 8
-- Name: form_form_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE form_form_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.form_form_id_seq OWNER TO admin;

--
-- TOC entry 596 (class 1259 OID 146569161)
-- Dependencies: 299 8
-- Name: freightclass_freightclass_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE freightclass_freightclass_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.freightclass_freightclass_id_seq OWNER TO admin;

--
-- TOC entry 9818 (class 0 OID 0)
-- Dependencies: 596
-- Name: freightclass_freightclass_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE freightclass_freightclass_id_seq OWNED BY freightclass.freightclass_id;


--
-- TOC entry 597 (class 1259 OID 146569163)
-- Dependencies: 6530 8
-- Name: glseries; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE glseries (
    glseries_id integer DEFAULT nextval(('"glseries_glseries_id_seq"'::text)::regclass) NOT NULL,
    glseries_sequence integer,
    glseries_doctype character(2),
    glseries_docnumber text,
    glseries_accnt_id integer,
    glseries_amount numeric(20,2),
    glseries_source text,
    glseries_distdate date,
    glseries_notes text,
    glseries_misc_id integer
);


ALTER TABLE public.glseries OWNER TO admin;

--
-- TOC entry 9820 (class 0 OID 0)
-- Dependencies: 597
-- Name: TABLE glseries; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE glseries IS 'Temporary table for storing information about General Ledger (G/L) Series Entries before Series Entries are posted';


--
-- TOC entry 598 (class 1259 OID 146569170)
-- Dependencies: 8
-- Name: glseries_glseries_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE glseries_glseries_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.glseries_glseries_id_seq OWNER TO admin;

--
-- TOC entry 599 (class 1259 OID 146569172)
-- Dependencies: 8
-- Name: gltrans_gltrans_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE gltrans_gltrans_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.gltrans_gltrans_id_seq OWNER TO admin;

--
-- TOC entry 600 (class 1259 OID 146569174)
-- Dependencies: 8
-- Name: gltrans_sequence_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE gltrans_sequence_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.gltrans_sequence_seq OWNER TO admin;

--
-- TOC entry 601 (class 1259 OID 146569176)
-- Dependencies: 6532 8
-- Name: grp; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE grp (
    grp_id integer NOT NULL,
    grp_name text NOT NULL,
    grp_descrip text,
    CONSTRAINT grp_grp_name_check CHECK ((grp_name <> ''::text))
);


ALTER TABLE public.grp OWNER TO admin;

--
-- TOC entry 9825 (class 0 OID 0)
-- Dependencies: 601
-- Name: TABLE grp; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE grp IS 'This table is the basic group information.';


--
-- TOC entry 602 (class 1259 OID 146569183)
-- Dependencies: 601 8
-- Name: grp_grp_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE grp_grp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.grp_grp_id_seq OWNER TO admin;

--
-- TOC entry 9827 (class 0 OID 0)
-- Dependencies: 602
-- Name: grp_grp_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE grp_grp_id_seq OWNED BY grp.grp_id;


--
-- TOC entry 603 (class 1259 OID 146569185)
-- Dependencies: 8
-- Name: grppriv; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE grppriv (
    grppriv_id integer NOT NULL,
    grppriv_grp_id integer NOT NULL,
    grppriv_priv_id integer NOT NULL
);


ALTER TABLE public.grppriv OWNER TO admin;

--
-- TOC entry 9829 (class 0 OID 0)
-- Dependencies: 603
-- Name: TABLE grppriv; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE grppriv IS 'This is a specific priv for a specific group.';


--
-- TOC entry 604 (class 1259 OID 146569188)
-- Dependencies: 603 8
-- Name: grppriv_grppriv_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE grppriv_grppriv_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.grppriv_grppriv_id_seq OWNER TO admin;

--
-- TOC entry 9831 (class 0 OID 0)
-- Dependencies: 604
-- Name: grppriv_grppriv_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE grppriv_grppriv_id_seq OWNED BY grppriv.grppriv_id;


--
-- TOC entry 605 (class 1259 OID 146569190)
-- Dependencies: 6535 8
-- Name: hnfc; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE hnfc (
    hnfc_id integer NOT NULL,
    hnfc_code text NOT NULL,
    CONSTRAINT hnfc_hnfc_code_check CHECK ((hnfc_code <> ''::text))
);


ALTER TABLE public.hnfc OWNER TO admin;

--
-- TOC entry 9833 (class 0 OID 0)
-- Dependencies: 605
-- Name: TABLE hnfc; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE hnfc IS 'List of personal titles/honorifics used in cntct table.';


--
-- TOC entry 606 (class 1259 OID 146569197)
-- Dependencies: 605 8
-- Name: hnfc_hnfc_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE hnfc_hnfc_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.hnfc_hnfc_id_seq OWNER TO admin;

--
-- TOC entry 9835 (class 0 OID 0)
-- Dependencies: 606
-- Name: hnfc_hnfc_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE hnfc_hnfc_id_seq OWNED BY hnfc.hnfc_id;


--
-- TOC entry 607 (class 1259 OID 146569199)
-- Dependencies: 206 8
-- Name: incdt_incdt_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE incdt_incdt_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.incdt_incdt_id_seq OWNER TO admin;

--
-- TOC entry 9837 (class 0 OID 0)
-- Dependencies: 607
-- Name: incdt_incdt_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE incdt_incdt_id_seq OWNED BY incdt.incdt_id;


--
-- TOC entry 608 (class 1259 OID 146569201)
-- Dependencies: 304 8
-- Name: incdtcat_incdtcat_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE incdtcat_incdtcat_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.incdtcat_incdtcat_id_seq OWNER TO admin;

--
-- TOC entry 9839 (class 0 OID 0)
-- Dependencies: 608
-- Name: incdtcat_incdtcat_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE incdtcat_incdtcat_id_seq OWNED BY incdtcat.incdtcat_id;


--
-- TOC entry 609 (class 1259 OID 146569203)
-- Dependencies: 6537 6538 8
-- Name: incdthist; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE incdthist (
    incdthist_id integer NOT NULL,
    incdthist_incdt_id integer NOT NULL,
    incdthist_change character(1),
    incdthist_target_id integer,
    incdthist_timestamp timestamp without time zone DEFAULT now() NOT NULL,
    incdthist_username text DEFAULT geteffectivextuser() NOT NULL,
    incdthist_descrip text
);


ALTER TABLE public.incdthist OWNER TO admin;

--
-- TOC entry 9841 (class 0 OID 0)
-- Dependencies: 609
-- Name: TABLE incdthist; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE incdthist IS 'Incident history changes';


--
-- TOC entry 610 (class 1259 OID 146569211)
-- Dependencies: 609 8
-- Name: incdthist_incdthist_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE incdthist_incdthist_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.incdthist_incdthist_id_seq OWNER TO admin;

--
-- TOC entry 9843 (class 0 OID 0)
-- Dependencies: 610
-- Name: incdthist_incdthist_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE incdthist_incdthist_id_seq OWNED BY incdthist.incdthist_id;


--
-- TOC entry 611 (class 1259 OID 146569213)
-- Dependencies: 305 8
-- Name: incdtpriority_incdtpriority_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE incdtpriority_incdtpriority_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.incdtpriority_incdtpriority_id_seq OWNER TO admin;

--
-- TOC entry 9845 (class 0 OID 0)
-- Dependencies: 611
-- Name: incdtpriority_incdtpriority_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE incdtpriority_incdtpriority_id_seq OWNED BY incdtpriority.incdtpriority_id;


--
-- TOC entry 612 (class 1259 OID 146569215)
-- Dependencies: 306 8
-- Name: incdtresolution_incdtresolution_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE incdtresolution_incdtresolution_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.incdtresolution_incdtresolution_id_seq OWNER TO admin;

--
-- TOC entry 9847 (class 0 OID 0)
-- Dependencies: 612
-- Name: incdtresolution_incdtresolution_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE incdtresolution_incdtresolution_id_seq OWNED BY incdtresolution.incdtresolution_id;


--
-- TOC entry 613 (class 1259 OID 146569217)
-- Dependencies: 307 8
-- Name: incdtseverity_incdtseverity_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE incdtseverity_incdtseverity_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.incdtseverity_incdtseverity_id_seq OWNER TO admin;

--
-- TOC entry 9849 (class 0 OID 0)
-- Dependencies: 613
-- Name: incdtseverity_incdtseverity_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE incdtseverity_incdtseverity_id_seq OWNED BY incdtseverity.incdtseverity_id;


--
-- TOC entry 614 (class 1259 OID 146569219)
-- Dependencies: 202 8
-- Name: invbal_invbal_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE invbal_invbal_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.invbal_invbal_id_seq OWNER TO admin;

--
-- TOC entry 9851 (class 0 OID 0)
-- Dependencies: 614
-- Name: invbal_invbal_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE invbal_invbal_id_seq OWNED BY invbal.invbal_id;


--
-- TOC entry 615 (class 1259 OID 146569221)
-- Dependencies: 8
-- Name: invc_invc_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE invc_invc_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.invc_invc_id_seq OWNER TO admin;

--
-- TOC entry 616 (class 1259 OID 146569223)
-- Dependencies: 224 8
-- Name: invchead_invchead_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE invchead_invchead_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.invchead_invchead_id_seq OWNER TO admin;

--
-- TOC entry 9854 (class 0 OID 0)
-- Dependencies: 616
-- Name: invchead_invchead_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE invchead_invchead_id_seq OWNED BY invchead.invchead_id;


--
-- TOC entry 617 (class 1259 OID 146569225)
-- Dependencies: 377 8
-- Name: invcheadtax; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE invcheadtax (
)
INHERITS (taxhist);


ALTER TABLE public.invcheadtax OWNER TO admin;

--
-- TOC entry 618 (class 1259 OID 146569231)
-- Dependencies: 229 8
-- Name: invcitem_invcitem_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE invcitem_invcitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.invcitem_invcitem_id_seq OWNER TO admin;

--
-- TOC entry 9857 (class 0 OID 0)
-- Dependencies: 618
-- Name: invcitem_invcitem_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE invcitem_invcitem_id_seq OWNED BY invcitem.invcitem_id;


--
-- TOC entry 619 (class 1259 OID 146569233)
-- Dependencies: 377 8
-- Name: invcitemtax; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE invcitemtax (
)
INHERITS (taxhist);


ALTER TABLE public.invcitemtax OWNER TO admin;

--
-- TOC entry 620 (class 1259 OID 146569239)
-- Dependencies: 8
-- Name: invcnt_invcnt_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE invcnt_invcnt_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.invcnt_invcnt_id_seq OWNER TO admin;

--
-- TOC entry 621 (class 1259 OID 146569241)
-- Dependencies: 6541 8
-- Name: invdetail; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE invdetail (
    invdetail_id integer DEFAULT nextval(('"invdetail_invdetail_id_seq"'::text)::regclass) NOT NULL,
    invdetail_transtype character(2),
    invdetail_invhist_id integer,
    invdetail_location_id integer,
    invdetail_qty numeric(18,6),
    invdetail_comments text,
    invdetail_qty_before numeric(18,6),
    invdetail_qty_after numeric(18,6),
    invdetail_invcitem_id integer,
    invdetail_expiration date,
    invdetail_warrpurc date,
    invdetail_ls_id integer
);


ALTER TABLE public.invdetail OWNER TO admin;

--
-- TOC entry 9861 (class 0 OID 0)
-- Dependencies: 621
-- Name: TABLE invdetail; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE invdetail IS 'Detailed Inventory transaction information for Lot/Serial and Multiple Location Control (MLC) Items';


--
-- TOC entry 622 (class 1259 OID 146569248)
-- Dependencies: 8
-- Name: invdetail_invdetail_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE invdetail_invdetail_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.invdetail_invdetail_id_seq OWNER TO admin;

--
-- TOC entry 623 (class 1259 OID 146569250)
-- Dependencies: 6542 6543 6544 6545 6546 6547 6548 8
-- Name: invhist; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE invhist (
    invhist_id integer DEFAULT nextval(('invhist_invhist_id_seq'::text)::regclass) NOT NULL,
    invhist_itemsite_id integer,
    invhist_transdate timestamp with time zone DEFAULT ('now'::text)::timestamp(6) with time zone,
    invhist_transtype character(2),
    invhist_invqty numeric(18,6),
    invhist_invuom text,
    invhist_ordnumber text,
    invhist_docnumber text,
    invhist_qoh_before numeric(18,6),
    invhist_qoh_after numeric(18,6),
    invhist_unitcost numeric(16,6),
    invhist_acct_id integer,
    invhist_xfer_warehous_id integer,
    invhist_comments text,
    invhist_posted boolean DEFAULT true,
    invhist_imported boolean,
    invhist_hasdetail boolean DEFAULT false,
    invhist_ordtype text,
    invhist_analyze boolean DEFAULT true,
    invhist_user text DEFAULT geteffectivextuser(),
    invhist_created timestamp with time zone DEFAULT now() NOT NULL,
    invhist_costmethod character(1) NOT NULL,
    invhist_value_before numeric(12,2) NOT NULL,
    invhist_value_after numeric(12,2) NOT NULL,
    invhist_series integer
);


ALTER TABLE public.invhist OWNER TO admin;

--
-- TOC entry 9864 (class 0 OID 0)
-- Dependencies: 623
-- Name: TABLE invhist; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE invhist IS 'Inventory transaction history';


--
-- TOC entry 624 (class 1259 OID 146569263)
-- Dependencies: 8
-- Name: invhist_invhist_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE invhist_invhist_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.invhist_invhist_id_seq OWNER TO admin;

--
-- TOC entry 625 (class 1259 OID 146569265)
-- Dependencies: 8
-- Name: invhistexpcat; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE invhistexpcat (
    invhistexpcat_id integer NOT NULL,
    invhistexpcat_invhist_id integer NOT NULL,
    invhistexpcat_expcat_id integer NOT NULL
);


ALTER TABLE public.invhistexpcat OWNER TO admin;

--
-- TOC entry 9867 (class 0 OID 0)
-- Dependencies: 625
-- Name: TABLE invhistexpcat; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE invhistexpcat IS 'Track the relationship between an EX transaction in the invhist table and the corresponding Expense Category.';


--
-- TOC entry 626 (class 1259 OID 146569268)
-- Dependencies: 625 8
-- Name: invhistexpcat_invhistexpcat_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE invhistexpcat_invhistexpcat_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.invhistexpcat_invhistexpcat_id_seq OWNER TO admin;

--
-- TOC entry 9869 (class 0 OID 0)
-- Dependencies: 626
-- Name: invhistexpcat_invhistexpcat_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE invhistexpcat_invhistexpcat_id_seq OWNED BY invhistexpcat.invhistexpcat_id;


--
-- TOC entry 627 (class 1259 OID 146569270)
-- Dependencies: 8581 8
-- Name: invoiceitem; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW invoiceitem AS
    SELECT invcitem.invcitem_id, invcitem.invcitem_invchead_id, invcitem.invcitem_linenumber, invcitem.invcitem_item_id, invcitem.invcitem_warehous_id, invcitem.invcitem_custpn, invcitem.invcitem_number, invcitem.invcitem_descrip, invcitem.invcitem_ordered, invcitem.invcitem_billed, invcitem.invcitem_custprice, invcitem.invcitem_price, invcitem.invcitem_notes, invcitem.invcitem_salescat_id, invcitem.invcitem_taxtype_id, invcitem.invcitem_qty_uom_id, invcitem.invcitem_qty_invuomratio, invcitem.invcitem_price_uom_id, invcitem.invcitem_price_invuomratio, invcitem.invcitem_coitem_id, invcitem.invcitem_updateinv, invcitem.invcitem_rev_accnt_id, itemsite.itemsite_id, cohead.cohead_number, COALESCE((invcitem.invcitem_billed * invcitem.invcitem_qty_invuomratio), (0)::numeric) AS qty, COALESCE((invcitem.invcitem_price / invcitem.invcitem_price_invuomratio), (0)::numeric) AS unitprice, COALESCE(round(((invcitem.invcitem_billed * invcitem.invcitem_qty_invuomratio) * (invcitem.invcitem_price / invcitem.invcitem_price_invuomratio)), 2), (0)::numeric) AS extprice, currtobase(invchead.invchead_curr_id, COALESCE(round(((invcitem.invcitem_billed * invcitem.invcitem_qty_invuomratio) * (invcitem.invcitem_price / invcitem.invcitem_price_invuomratio)), 2), (0)::numeric), invchead.invchead_invcdate) AS baseextprice, (SELECT COALESCE(sum(invcitemtax.taxhist_tax), (0)::numeric) AS "coalesce" FROM invcitemtax WHERE (invcitemtax.taxhist_parent_id = invcitem.invcitem_id)) AS tax, ((SELECT COALESCE(sum(shipitem.shipitem_value), (itemcost(itemsite.itemsite_id) * invcitem.invcitem_billed), (0)::numeric) AS "coalesce" FROM shipitem WHERE (shipitem.shipitem_invcitem_id = invcitem.invcitem_id)) / CASE WHEN (invcitem.invcitem_billed <> (0)::numeric) THEN (invcitem.invcitem_billed * invcitem.invcitem_qty_invuomratio) ELSE (1)::numeric END) AS unitcost FROM ((((invcitem JOIN invchead ON ((invchead.invchead_id = invcitem.invcitem_invchead_id))) LEFT JOIN coitem ON ((coitem.coitem_id = invcitem.invcitem_coitem_id))) LEFT JOIN cohead ON ((cohead.cohead_id = coitem.coitem_cohead_id))) LEFT JOIN itemsite ON (((itemsite.itemsite_item_id = invcitem.invcitem_item_id) AND (itemsite.itemsite_warehous_id = invcitem.invcitem_warehous_id))));


ALTER TABLE public.invoiceitem OWNER TO admin;

--
-- TOC entry 9871 (class 0 OID 0)
-- Dependencies: 627
-- Name: VIEW invoiceitem; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON VIEW invoiceitem IS 'Single point for invoice item (invcitem) calculations.';


--
-- TOC entry 628 (class 1259 OID 146569275)
-- Dependencies: 347 8
-- Name: ipsass_ipsass_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE ipsass_ipsass_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ipsass_ipsass_id_seq OWNER TO admin;

--
-- TOC entry 9873 (class 0 OID 0)
-- Dependencies: 628
-- Name: ipsass_ipsass_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE ipsass_ipsass_id_seq OWNED BY ipsass.ipsass_id;


--
-- TOC entry 629 (class 1259 OID 146569277)
-- Dependencies: 8
-- Name: ipsctyp_ipsctyp_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE ipsctyp_ipsctyp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ipsctyp_ipsctyp_id_seq OWNER TO admin;

--
-- TOC entry 630 (class 1259 OID 146569279)
-- Dependencies: 8
-- Name: ipscust_ipscust_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE ipscust_ipscust_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ipscust_ipscust_id_seq OWNER TO admin;

--
-- TOC entry 631 (class 1259 OID 146569281)
-- Dependencies: 300 8
-- Name: ipsfreight_ipsfreight_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE ipsfreight_ipsfreight_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ipsfreight_ipsfreight_id_seq OWNER TO admin;

--
-- TOC entry 9877 (class 0 OID 0)
-- Dependencies: 631
-- Name: ipsfreight_ipsfreight_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE ipsfreight_ipsfreight_id_seq OWNED BY ipsfreight.ipsfreight_id;


--
-- TOC entry 632 (class 1259 OID 146569283)
-- Dependencies: 8
-- Name: ipshead_ipshead_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE ipshead_ipshead_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ipshead_ipshead_id_seq OWNER TO admin;

--
-- TOC entry 633 (class 1259 OID 146569285)
-- Dependencies: 8
-- Name: ipsitem_ipsitem_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE ipsitem_ipsitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ipsitem_ipsitem_id_seq OWNER TO admin;

--
-- TOC entry 634 (class 1259 OID 146569287)
-- Dependencies: 351 8
-- Name: ipsitemchar_ipsitemchar_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE ipsitemchar_ipsitemchar_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ipsitemchar_ipsitemchar_id_seq OWNER TO admin;

--
-- TOC entry 9881 (class 0 OID 0)
-- Dependencies: 634
-- Name: ipsitemchar_ipsitemchar_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE ipsitemchar_ipsitemchar_id_seq OWNED BY ipsitemchar.ipsitemchar_id;


--
-- TOC entry 635 (class 1259 OID 146569289)
-- Dependencies: 8582 8
-- Name: ipsprice; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW ipsprice AS
    SELECT ipsiteminfo.ipsitem_id AS ipsprice_id, 'I'::text AS ipsprice_source, ipsiteminfo.ipsitem_ipshead_id AS ipsprice_ipshead_id, ipsiteminfo.ipsitem_item_id AS ipsprice_item_id, itemuomtouom(ipsiteminfo.ipsitem_item_id, ipsiteminfo.ipsitem_qty_uom_id, NULL::integer, ipsiteminfo.ipsitem_qtybreak) AS ipsprice_qtybreak, CASE WHEN (ipsiteminfo.ipsitem_type = 'N'::bpchar) THEN ((ipsiteminfo.ipsitem_price * itemuomtouomratio(ipsiteminfo.ipsitem_item_id, NULL::integer, ipsiteminfo.ipsitem_price_uom_id)) * iteminvpricerat(ipsiteminfo.ipsitem_item_id)) WHEN (ipsiteminfo.ipsitem_type = 'D'::bpchar) THEN ((item.item_listprice - (item.item_listprice * ipsiteminfo.ipsitem_discntprcnt)) - ipsiteminfo.ipsitem_fixedamtdiscount) WHEN ((ipsiteminfo.ipsitem_type = 'M'::bpchar) AND fetchmetricbool('Long30Markups'::text)) THEN ((stdcost(item.item_id) / (1.0 - ipsiteminfo.ipsitem_discntprcnt)) + ipsiteminfo.ipsitem_fixedamtdiscount) WHEN (ipsiteminfo.ipsitem_type = 'M'::bpchar) THEN ((item.item_listcost + (item.item_listcost * ipsiteminfo.ipsitem_discntprcnt)) + ipsiteminfo.ipsitem_fixedamtdiscount) ELSE NULL::numeric END AS ipsprice_price, ipsiteminfo.ipsitem_qtybreak AS ipsprice_uomqtybreak, ipsiteminfo.ipsitem_qty_uom_id AS ipsprice_uomqtybreak_uom_id, CASE WHEN (ipsiteminfo.ipsitem_type = 'N'::bpchar) THEN ipsiteminfo.ipsitem_price WHEN (ipsiteminfo.ipsitem_type = 'D'::bpchar) THEN ((item.item_listprice - (item.item_listprice * ipsiteminfo.ipsitem_discntprcnt)) - ipsiteminfo.ipsitem_fixedamtdiscount) WHEN ((ipsiteminfo.ipsitem_type = 'M'::bpchar) AND fetchmetricbool('Long30Markups'::text)) THEN ((stdcost(item.item_id) / (1.0 - ipsiteminfo.ipsitem_discntprcnt)) + ipsiteminfo.ipsitem_fixedamtdiscount) WHEN (ipsiteminfo.ipsitem_type = 'M'::bpchar) THEN ((item.item_listcost + (item.item_listcost * ipsiteminfo.ipsitem_discntprcnt)) + ipsiteminfo.ipsitem_fixedamtdiscount) ELSE NULL::numeric END AS ipsprice_uomprice, ipsiteminfo.ipsitem_price_uom_id AS ipsprice_uomprice_uom_id, ipsiteminfo.ipsitem_discntprcnt AS ipsprice_discountpercent, ipsiteminfo.ipsitem_fixedamtdiscount AS ipsprice_discountfixed, ipsiteminfo.ipsitem_type AS ipsprice_type FROM (ipsiteminfo JOIN item ON ((item.item_id = ipsiteminfo.ipsitem_item_id))) UNION SELECT ipsiteminfo.ipsitem_id AS ipsprice_id, 'P'::text AS ipsprice_source, ipsiteminfo.ipsitem_ipshead_id AS ipsprice_ipshead_id, item.item_id AS ipsprice_item_id, ipsiteminfo.ipsitem_qtybreak AS ipsprice_qtybreak, CASE WHEN (ipsiteminfo.ipsitem_type = 'D'::bpchar) THEN ((item.item_listprice - (item.item_listprice * ipsiteminfo.ipsitem_discntprcnt)) - ipsiteminfo.ipsitem_fixedamtdiscount) WHEN ((ipsiteminfo.ipsitem_type = 'M'::bpchar) AND fetchmetricbool('Long30Markups'::text)) THEN ((stdcost(item.item_id) / (1.0 - ipsiteminfo.ipsitem_discntprcnt)) + ipsiteminfo.ipsitem_fixedamtdiscount) WHEN (ipsiteminfo.ipsitem_type = 'M'::bpchar) THEN ((item.item_listcost + (item.item_listcost * ipsiteminfo.ipsitem_discntprcnt)) + ipsiteminfo.ipsitem_fixedamtdiscount) ELSE NULL::numeric END AS ipsprice_price, ipsiteminfo.ipsitem_qtybreak AS ipsprice_uomqtybreak, item.item_inv_uom_id AS ipsprice_uomqtybreak_uom_id, CASE WHEN (ipsiteminfo.ipsitem_type = 'D'::bpchar) THEN ((item.item_listprice - (item.item_listprice * ipsiteminfo.ipsitem_discntprcnt)) - ipsiteminfo.ipsitem_fixedamtdiscount) WHEN ((ipsiteminfo.ipsitem_type = 'M'::bpchar) AND fetchmetricbool('Long30Markups'::text)) THEN ((stdcost(item.item_id) / (1.0 - ipsiteminfo.ipsitem_discntprcnt)) + ipsiteminfo.ipsitem_fixedamtdiscount) WHEN (ipsiteminfo.ipsitem_type = 'M'::bpchar) THEN ((item.item_listcost + (item.item_listcost * ipsiteminfo.ipsitem_discntprcnt)) + ipsiteminfo.ipsitem_fixedamtdiscount) ELSE NULL::numeric END AS ipsprice_uomprice, item.item_price_uom_id AS ipsprice_uomprice_uom_id, ipsiteminfo.ipsitem_discntprcnt AS ipsprice_discountpercent, ipsiteminfo.ipsitem_fixedamtdiscount AS ipsprice_discountfixed, ipsiteminfo.ipsitem_type AS ipsprice_type FROM (ipsiteminfo JOIN item ON ((ipsiteminfo.ipsitem_prodcat_id = item.item_prodcat_id)));


ALTER TABLE public.ipsprice OWNER TO admin;

--
-- TOC entry 636 (class 1259 OID 146569294)
-- Dependencies: 6551 8
-- Name: ipsprodcat_bak; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE ipsprodcat_bak (
    ipsprodcat_id integer NOT NULL,
    ipsprodcat_ipshead_id integer NOT NULL,
    ipsprodcat_prodcat_id integer NOT NULL,
    ipsprodcat_qtybreak numeric(18,6) NOT NULL,
    ipsprodcat_discntprcnt numeric(10,6) NOT NULL,
    ipsprodcat_fixedamtdiscount numeric(16,4) DEFAULT 0.00 NOT NULL
);


ALTER TABLE public.ipsprodcat_bak OWNER TO admin;

--
-- TOC entry 9884 (class 0 OID 0)
-- Dependencies: 636
-- Name: TABLE ipsprodcat_bak; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE ipsprodcat_bak IS 'Pricing Schedule Product Category information.';


--
-- TOC entry 637 (class 1259 OID 146569298)
-- Dependencies: 636 8
-- Name: ipsprodcat_ipsprodcat_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE ipsprodcat_ipsprodcat_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ipsprodcat_ipsprodcat_id_seq OWNER TO admin;

--
-- TOC entry 9886 (class 0 OID 0)
-- Dependencies: 637
-- Name: ipsprodcat_ipsprodcat_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE ipsprodcat_ipsprodcat_id_seq OWNED BY ipsprodcat_bak.ipsprodcat_id;


--
-- TOC entry 638 (class 1259 OID 146569300)
-- Dependencies: 8
-- Name: item_item_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE item_item_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.item_item_id_seq OWNER TO admin;

--
-- TOC entry 639 (class 1259 OID 146569302)
-- Dependencies: 8
-- Name: itemalias_itemalias_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE itemalias_itemalias_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.itemalias_itemalias_id_seq OWNER TO admin;

--
-- TOC entry 640 (class 1259 OID 146569304)
-- Dependencies: 8
-- Name: itematr_itematr_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE itematr_itematr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.itematr_itematr_id_seq OWNER TO admin;

--
-- TOC entry 641 (class 1259 OID 146569306)
-- Dependencies: 8
-- Name: itemcost_itemcost_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE itemcost_itemcost_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.itemcost_itemcost_id_seq OWNER TO admin;

--
-- TOC entry 642 (class 1259 OID 146569308)
-- Dependencies: 8
-- Name: itemfrez_itemfrez_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE itemfrez_itemfrez_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.itemfrez_itemfrez_seq OWNER TO admin;

--
-- TOC entry 643 (class 1259 OID 146569310)
-- Dependencies: 6552 6553 6554 8
-- Name: itemgrp; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE itemgrp (
    itemgrp_id integer DEFAULT nextval(('"itemgrp_itemgrp_id_seq"'::text)::regclass) NOT NULL,
    itemgrp_name text NOT NULL,
    itemgrp_descrip text,
    itemgrp_catalog boolean DEFAULT false NOT NULL,
    CONSTRAINT itemgrp_itemgrp_name_check CHECK ((itemgrp_name <> ''::text))
);


ALTER TABLE public.itemgrp OWNER TO admin;

--
-- TOC entry 9893 (class 0 OID 0)
-- Dependencies: 643
-- Name: TABLE itemgrp; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE itemgrp IS 'Item Group information';


--
-- TOC entry 644 (class 1259 OID 146569319)
-- Dependencies: 8
-- Name: itemgrp_itemgrp_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE itemgrp_itemgrp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.itemgrp_itemgrp_id_seq OWNER TO admin;

--
-- TOC entry 645 (class 1259 OID 146569321)
-- Dependencies: 6555 6556 6557 8
-- Name: itemgrpitem; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE itemgrpitem (
    itemgrpitem_id integer DEFAULT nextval(('"itemgrpitem_itemgrpitem_id_seq"'::text)::regclass) NOT NULL,
    itemgrpitem_itemgrp_id integer,
    itemgrpitem_item_id integer,
    itemgrpitem_item_type character(1) DEFAULT 'I'::bpchar NOT NULL,
    CONSTRAINT itemgrpitem_valid_item_type CHECK ((itemgrpitem_item_type = ANY (ARRAY['I'::bpchar, 'G'::bpchar])))
);


ALTER TABLE public.itemgrpitem OWNER TO admin;

--
-- TOC entry 9896 (class 0 OID 0)
-- Dependencies: 645
-- Name: TABLE itemgrpitem; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE itemgrpitem IS 'Item Group Item information';


--
-- TOC entry 646 (class 1259 OID 146569327)
-- Dependencies: 8
-- Name: itemgrpitem_itemgrpitem_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE itemgrpitem_itemgrpitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.itemgrpitem_itemgrpitem_id_seq OWNER TO admin;

--
-- TOC entry 647 (class 1259 OID 146569329)
-- Dependencies: 8583 8
-- Name: itemimage; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW itemimage AS
    SELECT imageass.imageass_id AS itemimage_id, imageass.imageass_source_id AS itemimage_item_id, imageass.imageass_image_id AS itemimage_image_id, imageass.imageass_purpose AS itemimage_purpose FROM imageass WHERE (imageass.imageass_source = 'I'::text);


ALTER TABLE public.itemimage OWNER TO admin;

--
-- TOC entry 9899 (class 0 OID 0)
-- Dependencies: 647
-- Name: VIEW itemimage; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON VIEW itemimage IS 'Itemimage view for legacy support. Use of itemimage is deprecated. Use imageass table for future development';


--
-- TOC entry 648 (class 1259 OID 146569333)
-- Dependencies: 8
-- Name: itemimage_itemimage_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE itemimage_itemimage_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.itemimage_itemimage_id_seq OWNER TO admin;

--
-- TOC entry 649 (class 1259 OID 146569335)
-- Dependencies: 6558 8
-- Name: itemloc; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE itemloc (
    itemloc_id integer DEFAULT nextval(('"itemloc_itemloc_id_seq"'::text)::regclass) NOT NULL,
    itemloc_itemsite_id integer NOT NULL,
    itemloc_location_id integer NOT NULL,
    itemloc_qty numeric(18,6) NOT NULL,
    itemloc_expiration date NOT NULL,
    itemloc_consolflag boolean,
    itemloc_ls_id integer,
    itemloc_warrpurc date
);


ALTER TABLE public.itemloc OWNER TO admin;

--
-- TOC entry 9902 (class 0 OID 0)
-- Dependencies: 649
-- Name: TABLE itemloc; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE itemloc IS 'Detailed Location information for Lot/Serial and Multiple Location Control (MLC) Items';


--
-- TOC entry 650 (class 1259 OID 146569339)
-- Dependencies: 8
-- Name: itemloc_itemloc_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE itemloc_itemloc_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.itemloc_itemloc_id_seq OWNER TO admin;

--
-- TOC entry 651 (class 1259 OID 146569341)
-- Dependencies: 8
-- Name: itemloc_series_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE itemloc_series_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.itemloc_series_seq OWNER TO admin;

--
-- TOC entry 652 (class 1259 OID 146569343)
-- Dependencies: 6559 6560 6561 8
-- Name: itemlocdist; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE itemlocdist (
    itemlocdist_id integer DEFAULT nextval(('"itemlocdist_itemlocdist_id_seq"'::text)::regclass) NOT NULL,
    itemlocdist_itemlocdist_id integer,
    itemlocdist_source_type character(1),
    itemlocdist_source_id integer,
    itemlocdist_qty numeric(18,6),
    itemlocdist_series integer,
    itemlocdist_invhist_id integer,
    itemlocdist_itemsite_id integer,
    itemlocdist_reqlotserial boolean DEFAULT false,
    itemlocdist_flush boolean DEFAULT false,
    itemlocdist_expiration date,
    itemlocdist_distlotserial boolean,
    itemlocdist_warranty date,
    itemlocdist_ls_id integer,
    itemlocdist_order_type text,
    itemlocdist_order_id integer
);


ALTER TABLE public.itemlocdist OWNER TO admin;


--
-- TOC entry 653 (class 1259 OID 146569352)
-- Dependencies: 8
-- Name: itemlocdist_itemlocdist_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE itemlocdist_itemlocdist_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.itemlocdist_itemlocdist_id_seq OWNER TO admin;

--
-- TOC entry 654 (class 1259 OID 146569354)
-- Dependencies: 8
-- Name: itemlocpost; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE itemlocpost (
    itemlocpost_id integer NOT NULL,
    itemlocpost_itemlocseries integer,
    itemlocpost_glseq integer
);


ALTER TABLE public.itemlocpost OWNER TO admin;

--
-- TOC entry 9909 (class 0 OID 0)
-- Dependencies: 654
-- Name: TABLE itemlocpost; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE itemlocpost IS 'Temporary table for storing information about Inventory distribution G/L postings involving Lot/Serial and Multiple Location Control (MLC) Items';


--
-- TOC entry 655 (class 1259 OID 146569357)
-- Dependencies: 654 8
-- Name: itemlocpost_itemlocpost_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE itemlocpost_itemlocpost_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.itemlocpost_itemlocpost_id_seq OWNER TO admin;

--
-- TOC entry 9911 (class 0 OID 0)
-- Dependencies: 655
-- Name: itemlocpost_itemlocpost_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE itemlocpost_itemlocpost_id_seq OWNED BY itemlocpost.itemlocpost_id;


--
-- TOC entry 656 (class 1259 OID 146569359)
-- Dependencies: 8
-- Name: itemopn_itemopn_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE itemopn_itemopn_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.itemopn_itemopn_id_seq OWNER TO admin;

--
-- TOC entry 657 (class 1259 OID 146569361)
-- Dependencies: 8
-- Name: itemsite_itemsite_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE itemsite_itemsite_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.itemsite_itemsite_id_seq OWNER TO admin;

--
-- TOC entry 658 (class 1259 OID 146569363)
-- Dependencies: 8
-- Name: itemsrc_itemsrc_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE itemsrc_itemsrc_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.itemsrc_itemsrc_id_seq OWNER TO admin;

--
-- TOC entry 659 (class 1259 OID 146569365)
-- Dependencies: 8
-- Name: itemsrcp_itemsrcp_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE itemsrcp_itemsrcp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.itemsrcp_itemsrcp_id_seq OWNER TO admin;

--
-- TOC entry 660 (class 1259 OID 146569367)
-- Dependencies: 8
-- Name: itemsub_itemsub_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE itemsub_itemsub_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.itemsub_itemsub_id_seq OWNER TO admin;

--
-- TOC entry 661 (class 1259 OID 146569369)
-- Dependencies: 336 8
-- Name: itemtax_itemtax_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE itemtax_itemtax_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.itemtax_itemtax_id_seq OWNER TO admin;

--
-- TOC entry 9918 (class 0 OID 0)
-- Dependencies: 661
-- Name: itemtax_itemtax_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE itemtax_itemtax_id_seq OWNED BY itemtax.itemtax_id;


--
-- TOC entry 662 (class 1259 OID 146569371)
-- Dependencies: 8
-- Name: itemtrans; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE itemtrans (
    itemtrans_id integer NOT NULL,
    itemtrans_source_item_id integer,
    itemtrans_target_item_id integer
);


ALTER TABLE public.itemtrans OWNER TO admin;

--
-- TOC entry 9920 (class 0 OID 0)
-- Dependencies: 662
-- Name: TABLE itemtrans; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE itemtrans IS 'Item Transformation information';


--
-- TOC entry 663 (class 1259 OID 146569374)
-- Dependencies: 662 8
-- Name: itemtrans_itemtrans_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE itemtrans_itemtrans_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.itemtrans_itemtrans_id_seq OWNER TO admin;

--
-- TOC entry 9922 (class 0 OID 0)
-- Dependencies: 663
-- Name: itemtrans_itemtrans_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE itemtrans_itemtrans_id_seq OWNED BY itemtrans.itemtrans_id;


--
-- TOC entry 664 (class 1259 OID 146569376)
-- Dependencies: 8
-- Name: itemuom; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE itemuom (
    itemuom_id integer NOT NULL,
    itemuom_itemuomconv_id integer NOT NULL,
    itemuom_uomtype_id integer NOT NULL
);


ALTER TABLE public.itemuom OWNER TO admin;

--
-- TOC entry 9924 (class 0 OID 0)
-- Dependencies: 664
-- Name: TABLE itemuom; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE itemuom IS 'A UOM type relation for a specific conversion.';


--
-- TOC entry 665 (class 1259 OID 146569379)
-- Dependencies: 664 8
-- Name: itemuom_itemuom_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE itemuom_itemuom_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.itemuom_itemuom_id_seq OWNER TO admin;

--
-- TOC entry 9926 (class 0 OID 0)
-- Dependencies: 665
-- Name: itemuom_itemuom_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE itemuom_itemuom_id_seq OWNED BY itemuom.itemuom_id;


--
-- TOC entry 666 (class 1259 OID 146569381)
-- Dependencies: 338 8
-- Name: itemuomconv_itemuomconv_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE itemuomconv_itemuomconv_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.itemuomconv_itemuomconv_id_seq OWNER TO admin;

--
-- TOC entry 9928 (class 0 OID 0)
-- Dependencies: 666
-- Name: itemuomconv_itemuomconv_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE itemuomconv_itemuomconv_id_seq OWNED BY itemuomconv.itemuomconv_id;


--
-- TOC entry 667 (class 1259 OID 146569383)
-- Dependencies: 8
-- Name: journal_number_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE journal_number_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.journal_number_seq OWNER TO admin;

--
-- TOC entry 668 (class 1259 OID 146569385)
-- Dependencies: 6565 8
-- Name: jrnluse; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE jrnluse (
    jrnluse_id integer DEFAULT nextval(('"jrnluse_jrnluse_id_seq"'::text)::regclass) NOT NULL,
    jrnluse_date timestamp without time zone,
    jrnluse_number integer,
    jrnluse_use text
);


ALTER TABLE public.jrnluse OWNER TO admin;

--
-- TOC entry 9931 (class 0 OID 0)
-- Dependencies: 668
-- Name: TABLE jrnluse; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE jrnluse IS 'Journal entry and use information';


--
-- TOC entry 669 (class 1259 OID 146569392)
-- Dependencies: 8
-- Name: jrnluse_jrnluse_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE jrnluse_jrnluse_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.jrnluse_jrnluse_id_seq OWNER TO admin;

--
-- TOC entry 670 (class 1259 OID 146569394)
-- Dependencies: 8
-- Name: labeldef; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE labeldef (
    labeldef_id integer NOT NULL,
    labeldef_name text NOT NULL,
    labeldef_papersize text NOT NULL,
    labeldef_columns integer NOT NULL,
    labeldef_rows integer NOT NULL,
    labeldef_width integer NOT NULL,
    labeldef_height integer NOT NULL,
    labeldef_start_offset_x integer NOT NULL,
    labeldef_start_offset_y integer NOT NULL,
    labeldef_horizontal_gap integer NOT NULL,
    labeldef_vertical_gap integer NOT NULL
);


ALTER TABLE public.labeldef OWNER TO admin;

--
-- TOC entry 671 (class 1259 OID 146569400)
-- Dependencies: 670 8
-- Name: labeldef_labeldef_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE labeldef_labeldef_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.labeldef_labeldef_id_seq OWNER TO admin;

--
-- TOC entry 9935 (class 0 OID 0)
-- Dependencies: 671
-- Name: labeldef_labeldef_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE labeldef_labeldef_id_seq OWNED BY labeldef.labeldef_id;


--
-- TOC entry 672 (class 1259 OID 146569402)
-- Dependencies: 6567 6568 8
-- Name: labelform; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE labelform (
    labelform_id integer DEFAULT nextval(('"labelform_labelform_id_seq"'::text)::regclass) NOT NULL,
    labelform_name text NOT NULL,
    labelform_report_id integer,
    labelform_perpage integer,
    labelform_report_name text,
    CONSTRAINT labelform_labelform_name_check CHECK ((labelform_name <> ''::text))
);


ALTER TABLE public.labelform OWNER TO admin;

--
-- TOC entry 9937 (class 0 OID 0)
-- Dependencies: 672
-- Name: TABLE labelform; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE labelform IS 'Label Form information';


--
-- TOC entry 9938 (class 0 OID 0)
-- Dependencies: 672
-- Name: COLUMN labelform.labelform_report_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN labelform.labelform_report_id IS 'Obsolete -- reference labelform_report_name instead.';


--
-- TOC entry 673 (class 1259 OID 146569410)
-- Dependencies: 8
-- Name: labelform_labelform_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE labelform_labelform_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.labelform_labelform_id_seq OWNER TO admin;

--
-- TOC entry 674 (class 1259 OID 146569412)
-- Dependencies: 8
-- Name: lang; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE lang (
    lang_id integer NOT NULL,
    lang_qt_number integer,
    lang_abbr3 text,
    lang_abbr2 text,
    lang_name text NOT NULL
);


ALTER TABLE public.lang OWNER TO admin;

--
-- TOC entry 9941 (class 0 OID 0)
-- Dependencies: 674
-- Name: TABLE lang; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE lang IS 'Table mapping ISO 639-1 and 639-2 language codes to Qt''s enum QLocale::Language integer values. See http://www.loc.gov/standards/iso639-2/php/code_list.php and the QLocale documentation..';


--
-- TOC entry 9942 (class 0 OID 0)
-- Dependencies: 674
-- Name: COLUMN lang.lang_abbr3; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN lang.lang_abbr3 IS 'ISO 639-2 code for language. Where there is a choice between bibliographic (B) and terminology (T) usage, this value is the T code';


--
-- TOC entry 9943 (class 0 OID 0)
-- Dependencies: 674
-- Name: COLUMN lang.lang_abbr2; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN lang.lang_abbr2 IS 'ISO 639-1 code for language';


--
-- TOC entry 9944 (class 0 OID 0)
-- Dependencies: 674
-- Name: COLUMN lang.lang_name; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN lang.lang_name IS 'Name of a human language, taken from the ISO 639-2 documentation';


--
-- TOC entry 675 (class 1259 OID 146569418)
-- Dependencies: 674 8
-- Name: lang_lang_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE lang_lang_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.lang_lang_id_seq OWNER TO admin;

--
-- TOC entry 9946 (class 0 OID 0)
-- Dependencies: 675
-- Name: lang_lang_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE lang_lang_id_seq OWNED BY lang.lang_id;


--
-- TOC entry 676 (class 1259 OID 146569420)
-- Dependencies: 6570 6571 6572 6573 8
-- Name: locale; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE locale (
    locale_id integer DEFAULT nextval(('locale_locale_id_seq'::text)::regclass) NOT NULL,
    locale_code text NOT NULL,
    locale_descrip text,
    locale_lang_file text,
    locale_dateformat text,
    locale_currformat text,
    locale_qtyformat text,
    locale_comments text,
    locale_qtyperformat text,
    locale_salespriceformat text,
    locale_extpriceformat text,
    locale_timeformat text,
    locale_timestampformat text,
    local_costformat text,
    locale_costformat text,
    locale_purchpriceformat text,
    locale_uomratioformat text,
    locale_intervalformat text,
    locale_lang_id integer,
    locale_country_id integer,
    locale_error_color text,
    locale_warning_color text,
    locale_emphasis_color text,
    locale_altemphasis_color text,
    locale_expired_color text,
    locale_future_color text,
    locale_curr_scale integer,
    locale_salesprice_scale integer,
    locale_purchprice_scale integer,
    locale_extprice_scale integer,
    locale_cost_scale integer,
    locale_qty_scale integer,
    locale_qtyper_scale integer,
    locale_uomratio_scale integer,
    locale_percent_scale integer DEFAULT 2,
    locale_weight_scale integer DEFAULT 2 NOT NULL,
    CONSTRAINT locale_locale_code_check CHECK ((locale_code <> ''::text))
);


ALTER TABLE public.locale OWNER TO admin;

--
-- TOC entry 9948 (class 0 OID 0)
-- Dependencies: 676
-- Name: TABLE locale; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE locale IS 'The locale table holds information required to show data to the user in a localized format. Colors are either names documented by the WWW Consortium or RGB colors. Format for RGB colors is #RGB, #RRGGBB, or #RRRGGGBBB, where the letters R, G, and B stand for hexidecimal digits.';


--
-- TOC entry 9949 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_lang_file; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_lang_file IS 'Deprecated';


--
-- TOC entry 9950 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_dateformat; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_dateformat IS 'Deprecated';


--
-- TOC entry 9951 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_currformat; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_currformat IS 'Deprecated';


--
-- TOC entry 9952 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_qtyformat; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_qtyformat IS 'Deprecated';


--
-- TOC entry 9953 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_qtyperformat; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_qtyperformat IS 'Deprecated';


--
-- TOC entry 9954 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_salespriceformat; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_salespriceformat IS 'Deprecated';


--
-- TOC entry 9955 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_extpriceformat; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_extpriceformat IS 'Deprecated';


--
-- TOC entry 9956 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_timeformat; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_timeformat IS 'Deprecated';


--
-- TOC entry 9957 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_timestampformat; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_timestampformat IS 'Deprecated';


--
-- TOC entry 9958 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.local_costformat; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.local_costformat IS 'Deprecated';


--
-- TOC entry 9959 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_costformat; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_costformat IS 'Deprecated';


--
-- TOC entry 9960 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_purchpriceformat; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_purchpriceformat IS 'Deprecated';


--
-- TOC entry 9961 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_uomratioformat; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_uomratioformat IS 'Deprecated';


--
-- TOC entry 9962 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_intervalformat; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_intervalformat IS 'Deprecated';


--
-- TOC entry 9963 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_error_color; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_error_color IS 'Color to use to mark data that require immediate attention.';


--
-- TOC entry 9964 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_warning_color; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_warning_color IS 'Color to use to mark data that require attention soon.';


--
-- TOC entry 9965 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_emphasis_color; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_emphasis_color IS 'Color to use to mark data that need to stand out but are not in error.';


--
-- TOC entry 9966 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_altemphasis_color; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_altemphasis_color IS 'Color to use to mark data that need to stand out and be differentiated from other emphasized data.';


--
-- TOC entry 9967 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_expired_color; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_expired_color IS 'Color to use to mark data that are no longer current.';


--
-- TOC entry 9968 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_future_color; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_future_color IS 'Color to use to mark data that will not be effective until some point in the future.';


--
-- TOC entry 9969 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_curr_scale; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_curr_scale IS 'Number of decimal places to show when displaying Currency values.';


--
-- TOC entry 9970 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_salesprice_scale; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_salesprice_scale IS 'Number of decimal places to show when displaying Sales Prices.';


--
-- TOC entry 9971 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_purchprice_scale; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_purchprice_scale IS 'Number of decimal places to show when displaying Purchase Prices.';


--
-- TOC entry 9972 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_extprice_scale; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_extprice_scale IS 'Number of decimal places to show when displaying Extended Prices.';


--
-- TOC entry 9973 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_cost_scale; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_cost_scale IS 'Number of decimal places to show when displaying Costs.';


--
-- TOC entry 9974 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_qty_scale; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_qty_scale IS 'Number of decimal places to show when displaying Quantities.';


--
-- TOC entry 9975 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_qtyper_scale; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_qtyper_scale IS 'Number of decimal places to show when displaying Quantities Per.';


--
-- TOC entry 9976 (class 0 OID 0)
-- Dependencies: 676
-- Name: COLUMN locale.locale_uomratio_scale; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN locale.locale_uomratio_scale IS 'Number of decimal places to show when displaying UOM Ratios.';


--
-- TOC entry 677 (class 1259 OID 146569430)
-- Dependencies: 8
-- Name: locale_locale_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE locale_locale_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.locale_locale_id_seq OWNER TO admin;

--
-- TOC entry 678 (class 1259 OID 146569432)
-- Dependencies: 8
-- Name: location_location_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE location_location_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.location_location_id_seq OWNER TO admin;

--
-- TOC entry 679 (class 1259 OID 146569434)
-- Dependencies: 6574 8
-- Name: locitem; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE locitem (
    locitem_id integer DEFAULT nextval(('"locitem_locitem_id_seq"'::text)::regclass) NOT NULL,
    locitem_location_id integer,
    locitem_item_id integer
);


ALTER TABLE public.locitem OWNER TO admin;

--
-- TOC entry 9980 (class 0 OID 0)
-- Dependencies: 679
-- Name: TABLE locitem; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE locitem IS 'Restricted Warehouse Location Allowable Items information';


--
-- TOC entry 680 (class 1259 OID 146569438)
-- Dependencies: 8
-- Name: locitem_locitem_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE locitem_locitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.locitem_locitem_id_seq OWNER TO admin;

--
-- TOC entry 681 (class 1259 OID 146569440)
-- Dependencies: 8
-- Name: log_log_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE log_log_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.log_log_id_seq OWNER TO admin;

--
-- TOC entry 682 (class 1259 OID 146569442)
-- Dependencies: 6575 6576 8
-- Name: metric; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE metric (
    metric_id integer DEFAULT nextval(('metric_metric_id_seq'::text)::regclass) NOT NULL,
    metric_name text NOT NULL,
    metric_value text,
    metric_module text,
    CONSTRAINT metric_metric_name_check CHECK ((metric_name <> ''::text))
);


ALTER TABLE public.metric OWNER TO admin;

--
-- TOC entry 9984 (class 0 OID 0)
-- Dependencies: 682
-- Name: TABLE metric; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE metric IS 'Application-wide settings information';


--
-- TOC entry 683 (class 1259 OID 146569450)
-- Dependencies: 8
-- Name: metric_metric_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE metric_metric_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.metric_metric_id_seq OWNER TO admin;

--
-- TOC entry 684 (class 1259 OID 146569452)
-- Dependencies: 6578 8
-- Name: metricenc; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE metricenc (
    metricenc_id integer NOT NULL,
    metricenc_name text NOT NULL,
    metricenc_value bytea,
    metricenc_module text,
    CONSTRAINT metricenc_metricenc_name_check CHECK ((metricenc_name <> ''::text))
);


ALTER TABLE public.metricenc OWNER TO admin;

--
-- TOC entry 9987 (class 0 OID 0)
-- Dependencies: 684
-- Name: TABLE metricenc; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE metricenc IS 'Application-wide settings information encrypted data';


--
-- TOC entry 685 (class 1259 OID 146569459)
-- Dependencies: 684 8
-- Name: metricenc_metricenc_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE metricenc_metricenc_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.metricenc_metricenc_id_seq OWNER TO admin;

--
-- TOC entry 9989 (class 0 OID 0)
-- Dependencies: 685
-- Name: metricenc_metricenc_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE metricenc_metricenc_id_seq OWNED BY metricenc.metricenc_id;


--
-- TOC entry 686 (class 1259 OID 146569461)
-- Dependencies: 8
-- Name: misc_index_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE misc_index_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.misc_index_seq OWNER TO admin;

--
-- TOC entry 687 (class 1259 OID 146569463)
-- Dependencies: 8
-- Name: mrghist; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE mrghist (
    mrghist_cntct_id integer NOT NULL,
    mrghist_table text NOT NULL,
    mrghist_pkey_col text NOT NULL,
    mrghist_pkey_id integer NOT NULL,
    mrghist_cntct_col text NOT NULL
);


ALTER TABLE public.mrghist OWNER TO admin;

--
-- TOC entry 688 (class 1259 OID 146569469)
-- Dependencies: 8
-- Name: mrgundo; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE mrgundo (
    mrgundo_base_schema text,
    mrgundo_base_table text,
    mrgundo_base_id integer,
    mrgundo_schema text,
    mrgundo_table text,
    mrgundo_pkey_col text,
    mrgundo_pkey_id integer,
    mrgundo_col text,
    mrgundo_value text,
    mrgundo_type text
);


ALTER TABLE public.mrgundo OWNER TO admin;

--
-- TOC entry 9993 (class 0 OID 0)
-- Dependencies: 688
-- Name: TABLE mrgundo; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE mrgundo IS 'This table keeps track of the original values of changes made while merging two records. It is a generalization of mrghist and trgthist, which are specific to merging contacts. The schema, table, and pkey_id columns uniquely identify the record that was changed while the _base_ columns identify the merge target. The _base_ columns are required to allow finding all of the records that pertain to a particular merge (e.g. find changes to the comment table that pertain to a crmacct merge).';


--
-- TOC entry 9994 (class 0 OID 0)
-- Dependencies: 688
-- Name: COLUMN mrgundo.mrgundo_base_schema; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN mrgundo.mrgundo_base_schema IS 'The schema in which the merge target resides.';


--
-- TOC entry 9995 (class 0 OID 0)
-- Dependencies: 688
-- Name: COLUMN mrgundo.mrgundo_base_table; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN mrgundo.mrgundo_base_table IS 'The table in which the merge target resides.';


--
-- TOC entry 9996 (class 0 OID 0)
-- Dependencies: 688
-- Name: COLUMN mrgundo.mrgundo_base_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN mrgundo.mrgundo_base_id IS 'The internal id of the merge target record.';


--
-- TOC entry 9997 (class 0 OID 0)
-- Dependencies: 688
-- Name: COLUMN mrgundo.mrgundo_schema; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN mrgundo.mrgundo_schema IS 'The name of the schema in which the modified table resides.';


--
-- TOC entry 9998 (class 0 OID 0)
-- Dependencies: 688
-- Name: COLUMN mrgundo.mrgundo_table; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN mrgundo.mrgundo_table IS 'The name of the table that was modified during a merge.';


--
-- TOC entry 9999 (class 0 OID 0)
-- Dependencies: 688
-- Name: COLUMN mrgundo.mrgundo_pkey_col; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN mrgundo.mrgundo_pkey_col IS 'The name of the primary key column in the modified table. This could be derived during the undo processing but it is simpler just to store it during the merge.';


--
-- TOC entry 10000 (class 0 OID 0)
-- Dependencies: 688
-- Name: COLUMN mrgundo.mrgundo_pkey_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN mrgundo.mrgundo_pkey_id IS 'The primary key of the modified record.';


--
-- TOC entry 10001 (class 0 OID 0)
-- Dependencies: 688
-- Name: COLUMN mrgundo.mrgundo_col; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN mrgundo.mrgundo_col IS 'The column that was modified.';


--
-- TOC entry 10002 (class 0 OID 0)
-- Dependencies: 688
-- Name: COLUMN mrgundo.mrgundo_value; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN mrgundo.mrgundo_value IS 'The value of the column before the change.';


--
-- TOC entry 10003 (class 0 OID 0)
-- Dependencies: 688
-- Name: COLUMN mrgundo.mrgundo_type; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN mrgundo.mrgundo_type IS 'The data type of the modified column. This could be derived during the undo processing but it is simpler just to store it during the merge.';


--
-- TOC entry 689 (class 1259 OID 146569475)
-- Dependencies: 6579 8
-- Name: msg; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE msg (
    msg_id integer DEFAULT nextval(('"msg_msg_id_seq"'::text)::regclass) NOT NULL,
    msg_posted timestamp with time zone,
    msg_scheduled timestamp with time zone,
    msg_text text,
    msg_expires timestamp with time zone,
    msg_username text
);


ALTER TABLE public.msg OWNER TO admin;

--
-- TOC entry 10005 (class 0 OID 0)
-- Dependencies: 689
-- Name: TABLE msg; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE msg IS 'System Message information';


--
-- TOC entry 690 (class 1259 OID 146569482)
-- Dependencies: 8
-- Name: msg_msg_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE msg_msg_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.msg_msg_id_seq OWNER TO admin;

--
-- TOC entry 691 (class 1259 OID 146569484)
-- Dependencies: 6580 8
-- Name: msguser; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE msguser (
    msguser_id integer DEFAULT nextval(('"msguser_msguser_id_seq"'::text)::regclass) NOT NULL,
    msguser_msg_id integer,
    msguser_viewed timestamp with time zone,
    msguser_username text
);


ALTER TABLE public.msguser OWNER TO admin;

--
-- TOC entry 10008 (class 0 OID 0)
-- Dependencies: 691
-- Name: TABLE msguser; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE msguser IS 'System Message user information';


--
-- TOC entry 692 (class 1259 OID 146569491)
-- Dependencies: 8
-- Name: msguser_msguser_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE msguser_msguser_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.msguser_msguser_id_seq OWNER TO admin;

--
-- TOC entry 693 (class 1259 OID 146569493)
-- Dependencies: 8
-- Name: nvend_nvend_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE nvend_nvend_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.nvend_nvend_id_seq OWNER TO admin;


--
-- TOC entry 695 (class 1259 OID 146569504)
-- Dependencies: 231 8
-- Name: ophead_ophead_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE ophead_ophead_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.ophead_ophead_id_seq OWNER TO admin;

--
-- TOC entry 10015 (class 0 OID 0)
-- Dependencies: 695
-- Name: ophead_ophead_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE ophead_ophead_id_seq OWNED BY ophead.ophead_id;


--
-- TOC entry 696 (class 1259 OID 146569506)
-- Dependencies: 6585 8
-- Name: opsource; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE opsource (
    opsource_id integer NOT NULL,
    opsource_name text NOT NULL,
    opsource_descrip text,
    CONSTRAINT opsource_opsource_name_check CHECK ((opsource_name <> ''::text))
);


ALTER TABLE public.opsource OWNER TO admin;

--
-- TOC entry 10017 (class 0 OID 0)
-- Dependencies: 696
-- Name: TABLE opsource; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE opsource IS 'Opportunity Lead Source values.';


--
-- TOC entry 697 (class 1259 OID 146569513)
-- Dependencies: 696 8
-- Name: opsource_opsource_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE opsource_opsource_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.opsource_opsource_id_seq OWNER TO admin;

--
-- TOC entry 10019 (class 0 OID 0)
-- Dependencies: 697
-- Name: opsource_opsource_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE opsource_opsource_id_seq OWNED BY opsource.opsource_id;


--
-- TOC entry 698 (class 1259 OID 146569515)
-- Dependencies: 6587 6588 6589 8
-- Name: opstage; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE opstage (
    opstage_id integer NOT NULL,
    opstage_name text NOT NULL,
    opstage_descrip text,
    opstage_order integer DEFAULT 0 NOT NULL,
    opstage_opinactive boolean DEFAULT false,
    CONSTRAINT opstage_opstage_name_check CHECK ((opstage_name <> ''::text))
);


ALTER TABLE public.opstage OWNER TO admin;

--
-- TOC entry 10021 (class 0 OID 0)
-- Dependencies: 698
-- Name: TABLE opstage; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE opstage IS 'Opportunity stage values.';


--
-- TOC entry 699 (class 1259 OID 146569524)
-- Dependencies: 698 8
-- Name: opstage_opstage_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE opstage_opstage_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.opstage_opstage_id_seq OWNER TO admin;

--
-- TOC entry 10023 (class 0 OID 0)
-- Dependencies: 699
-- Name: opstage_opstage_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE opstage_opstage_id_seq OWNED BY opstage.opstage_id;


--
-- TOC entry 700 (class 1259 OID 146569526)
-- Dependencies: 6591 8
-- Name: optype; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE optype (
    optype_id integer NOT NULL,
    optype_name text NOT NULL,
    optype_descrip text,
    CONSTRAINT optype_optype_name_check CHECK ((optype_name <> ''::text))
);


ALTER TABLE public.optype OWNER TO admin;

--
-- TOC entry 10025 (class 0 OID 0)
-- Dependencies: 700
-- Name: TABLE optype; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE optype IS 'Opportunity Type values.';


--
-- TOC entry 701 (class 1259 OID 146569533)
-- Dependencies: 700 8
-- Name: optype_optype_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE optype_optype_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.optype_optype_id_seq OWNER TO admin;

--
-- TOC entry 10027 (class 0 OID 0)
-- Dependencies: 701
-- Name: optype_optype_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE optype_optype_id_seq OWNED BY optype.optype_id;


--
-- TOC entry 702 (class 1259 OID 146569535)
-- Dependencies: 8584 8
-- Name: orderhead; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW orderhead AS
    SELECT DISTINCT data.orderhead_id, data.orderhead_type, data.orderhead_number, data.orderhead_status, data.orderhead_orderdate, data.orderhead_linecount, data.orderhead_from_id, data.orderhead_from, data.orderhead_to_id, data.orderhead_to, data.orderhead_curr_id, data.orderhead_agent_username, data.orderhead_shipvia FROM (SELECT pohead.pohead_id AS orderhead_id, 'PO'::text AS orderhead_type, pohead.pohead_number AS orderhead_number, pohead.pohead_status AS orderhead_status, pohead.pohead_orderdate AS orderhead_orderdate, (SELECT count(*) AS count FROM poitem WHERE (poitem.poitem_pohead_id = pohead.pohead_id)) AS orderhead_linecount, pohead.pohead_vend_id AS orderhead_from_id, vendinfo.vend_name AS orderhead_from, NULL::integer AS orderhead_to_id, ''::text AS orderhead_to, pohead.pohead_curr_id AS orderhead_curr_id, pohead.pohead_agent_username AS orderhead_agent_username, pohead.pohead_shipvia AS orderhead_shipvia FROM (pohead LEFT JOIN vendinfo ON ((pohead.pohead_vend_id = vendinfo.vend_id))) UNION ALL SELECT cohead.cohead_id AS orderhead_id, 'SO'::text AS orderhead_type, cohead.cohead_number AS orderhead_number, cohead.cohead_status AS orderhead_status, cohead.cohead_orderdate AS orderhead_orderdate, (SELECT count(*) AS count FROM coitem WHERE (coitem.coitem_cohead_id = cohead.cohead_id)) AS orderhead_linecount, NULL::integer AS orderhead_from_id, ''::text AS orderhead_from, cohead.cohead_cust_id AS orderhead_to_id, CASE WHEN (length(cohead.cohead_shiptoname) > 0) THEN cohead.cohead_shiptoname ELSE cohead.cohead_billtoname END AS orderhead_to, cohead.cohead_curr_id AS orderhead_curr_id, ''::text AS orderhead_agent_username, cohead.cohead_shipvia AS orderhead_shipvia FROM cohead) data;


ALTER TABLE public.orderhead OWNER TO admin;

--
-- TOC entry 10029 (class 0 OID 0)
-- Dependencies: 702
-- Name: VIEW orderhead; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON VIEW orderhead IS 'Union of all orders for use by widgets and stored procedures which process multiple types of order';


--
-- TOC entry 703 (class 1259 OID 146569540)
-- Dependencies: 8585 8
-- Name: orderitem; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW orderitem AS
    (SELECT poitem.poitem_id AS orderitem_id, 'PO'::text AS orderitem_orderhead_type, poitem.poitem_pohead_id AS orderitem_orderhead_id, poitem.poitem_linenumber AS orderitem_linenumber, poitem.poitem_status AS orderitem_status, poitem.poitem_itemsite_id AS orderitem_itemsite_id, poitem.poitem_duedate AS orderitem_scheddate, poitem.poitem_qty_ordered AS orderitem_qty_ordered, poitem.poitem_qty_returned AS orderitem_qty_shipped, poitem.poitem_qty_received AS orderitem_qty_received, uom.uom_id AS orderitem_qty_uom_id, poitem.poitem_invvenduomratio AS orderitem_qty_invuomratio, poitem.poitem_unitprice AS orderitem_unitcost, pohead.pohead_curr_id AS orderitem_unitcost_curr_id, poitem.poitem_freight AS orderitem_freight, poitem.poitem_freight_received AS orderitem_freight_received, pohead.pohead_curr_id AS orderitem_freight_curr_id FROM ((poitem LEFT JOIN pohead ON ((poitem.poitem_pohead_id = pohead.pohead_id))) LEFT JOIN uom ON ((uom.uom_name = poitem.poitem_vend_uom))) UNION ALL SELECT coitem.coitem_id AS orderitem_id, 'SO'::text AS orderitem_orderhead_type, coitem.coitem_cohead_id AS orderitem_orderhead_id, coitem.coitem_linenumber AS orderitem_linenumber, coitem.coitem_status AS orderitem_status, coitem.coitem_itemsite_id AS orderitem_itemsite_id, coitem.coitem_scheddate AS orderitem_scheddate, coitem.coitem_qtyord AS orderitem_qty_ordered, coitem.coitem_qtyshipped AS orderitem_qty_shipped, coitem.coitem_qtyreturned AS orderitem_qty_received, coitem.coitem_qty_uom_id AS orderitem_qty_uom_id, coitem.coitem_qty_invuomratio AS orderitem_qty_invuomratio, coitem.coitem_unitcost AS orderitem_unitcost, basecurrid() AS orderitem_unitcost_curr_id, NULL::numeric AS orderitem_freight, NULL::numeric AS orderitem_freight_received, basecurrid() AS orderitem_freight_curr_id FROM coitem) UNION ALL SELECT quitem.quitem_id AS orderitem_id, 'QU'::text AS orderitem_orderhead_type, quitem.quitem_quhead_id AS orderitem_orderhead_id, quitem.quitem_linenumber AS orderitem_linenumber, 'O'::bpchar AS orderitem_status, quitem.quitem_itemsite_id AS orderitem_itemsite_id, quitem.quitem_scheddate AS orderitem_scheddate, quitem.quitem_qtyord AS orderitem_qty_ordered, 0 AS orderitem_qty_shipped, 0 AS orderitem_qty_received, quitem.quitem_qty_uom_id AS orderitem_qty_uom_id, quitem.quitem_qty_invuomratio AS orderitem_qty_invuomratio, quitem.quitem_unitcost AS orderitem_unitcost, basecurrid() AS orderitem_unitcost_curr_id, NULL::numeric AS orderitem_freight, NULL::numeric AS orderitem_freight_received, basecurrid() AS orderitem_freight_curr_id FROM quitem;


ALTER TABLE public.orderitem OWNER TO admin;

--
-- TOC entry 10031 (class 0 OID 0)
-- Dependencies: 703
-- Name: VIEW orderitem; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON VIEW orderitem IS 'Union of all order line items for use by widgets and stored procedures which process multiple types of order';


--
-- TOC entry 704 (class 1259 OID 146569545)
-- Dependencies: 6592 6593 8 2700
-- Name: orderseq; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE orderseq (
    orderseq_id integer DEFAULT nextval(('orderseq_orderseq_id_seq'::text)::regclass) NOT NULL,
    orderseq_name text NOT NULL,
    orderseq_number integer,
    orderseq_table text,
    orderseq_numcol text,
    orderseq_seqiss seqiss[],
    CONSTRAINT orderseq_orderseq_name_check CHECK ((orderseq_name <> ''::text))
);


ALTER TABLE public.orderseq OWNER TO admin;

--
-- TOC entry 10033 (class 0 OID 0)
-- Dependencies: 704
-- Name: TABLE orderseq; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE orderseq IS 'Configuration information for common numbering sequences';


--
-- TOC entry 705 (class 1259 OID 146569553)
-- Dependencies: 8
-- Name: orderseq_orderseq_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE orderseq_orderseq_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.orderseq_orderseq_id_seq OWNER TO admin;

--
-- TOC entry 706 (class 1259 OID 146569555)
-- Dependencies: 6595 6596 8
-- Name: pack; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE pack (
    pack_id integer NOT NULL,
    pack_head_id integer NOT NULL,
    pack_head_type text NOT NULL,
    pack_shiphead_id integer,
    pack_printed boolean DEFAULT false NOT NULL,
    CONSTRAINT pack_pack_head_type_check CHECK (((pack_head_type = 'SO'::text) OR (pack_head_type = 'TO'::text)))
);


ALTER TABLE public.pack OWNER TO admin;


--
-- TOC entry 707 (class 1259 OID 146569563)
-- Dependencies: 706 8
-- Name: pack_pack_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE pack_pack_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.pack_pack_id_seq OWNER TO admin;

--
-- TOC entry 10038 (class 0 OID 0)
-- Dependencies: 707
-- Name: pack_pack_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE pack_pack_id_seq OWNED BY pack.pack_id;


--
-- TOC entry 708 (class 1259 OID 146569565)
-- Dependencies: 6597 6598 8
-- Name: payaropen; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE payaropen (
    payaropen_ccpay_id integer NOT NULL,
    payaropen_aropen_id integer NOT NULL,
    payaropen_amount numeric(20,2) DEFAULT 0.00 NOT NULL,
    payaropen_curr_id integer DEFAULT basecurrid()
);


ALTER TABLE public.payaropen OWNER TO admin;

--
-- TOC entry 10040 (class 0 OID 0)
-- Dependencies: 708
-- Name: TABLE payaropen; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE payaropen IS 'Credit Card payment to credit memo join table';


--
-- TOC entry 709 (class 1259 OID 146569570)
-- Dependencies: 6599 6600 8
-- Name: payco; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE payco (
    payco_ccpay_id integer NOT NULL,
    payco_cohead_id integer NOT NULL,
    payco_amount numeric(20,2) DEFAULT 0.00 NOT NULL,
    payco_curr_id integer DEFAULT basecurrid()
);


ALTER TABLE public.payco OWNER TO admin;


--
-- TOC entry 710 (class 1259 OID 146569575)
-- Dependencies: 264 8
-- Name: period_period_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE period_period_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.period_period_id_seq OWNER TO admin;

--
-- TOC entry 10044 (class 0 OID 0)
-- Dependencies: 710
-- Name: period_period_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE period_period_id_seq OWNED BY period.period_id;


--
-- TOC entry 717 (class 1259 OID 146569601)
-- Dependencies: 8
-- Name: plancode_plancode_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE plancode_plancode_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.plancode_plancode_id_seq OWNER TO admin;

--
-- TOC entry 718 (class 1259 OID 146569603)
-- Dependencies: 8
-- Name: planord_planord_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE planord_planord_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.planord_planord_id_seq OWNER TO admin;

--
-- TOC entry 719 (class 1259 OID 146569605)
-- Dependencies: 8
-- Name: pohead_pohead_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE pohead_pohead_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.pohead_pohead_id_seq OWNER TO admin;

--
-- TOC entry 720 (class 1259 OID 146569607)
-- Dependencies: 8
-- Name: poitem_poitem_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE poitem_poitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.poitem_poitem_id_seq OWNER TO admin;

--
-- TOC entry 721 (class 1259 OID 146569609)
-- Dependencies: 6607 6608 6609 6611 8
-- Name: recv; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE recv (
    recv_id integer NOT NULL,
    recv_order_type text NOT NULL,
    recv_order_number text NOT NULL,
    recv_orderitem_id integer NOT NULL,
    recv_agent_username text,
    recv_itemsite_id integer,
    recv_vend_id integer,
    recv_vend_item_number text,
    recv_vend_item_descrip text,
    recv_vend_uom text,
    recv_purchcost numeric(16,6),
    recv_purchcost_curr_id integer,
    recv_duedate date,
    recv_qty numeric(18,6),
    recv_recvcost numeric(16,6),
    recv_recvcost_curr_id integer,
    recv_freight numeric(16,4),
    recv_freight_curr_id integer,
    recv_date timestamp with time zone,
    recv_value numeric(18,6),
    recv_posted boolean DEFAULT false NOT NULL,
    recv_invoiced boolean DEFAULT false NOT NULL,
    recv_vohead_id integer,
    recv_voitem_id integer,
    recv_trans_usr_name text DEFAULT geteffectivextuser() NOT NULL,
    recv_notes text,
    recv_gldistdate date,
    recv_splitfrom_id integer,
    recv_rlsd_duedate date,
    CONSTRAINT recv_recv_order_type_check CHECK ((((recv_order_type = 'PO'::text) OR (recv_order_type = 'RA'::text)) OR (recv_order_type = 'TO'::text)))
);


ALTER TABLE public.recv OWNER TO admin;

--
-- TOC entry 10065 (class 0 OID 0)
-- Dependencies: 721
-- Name: TABLE recv; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE recv IS 'Information about Received Orders.';


--
-- TOC entry 722 (class 1259 OID 146569619)
-- Dependencies: 8586 8
-- Name: porecv; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW porecv AS
    SELECT recv.recv_id AS porecv_id, recv.recv_date AS porecv_date, recv.recv_rlsd_duedate AS porecv_rlsd_duedate, pohead.pohead_orderdate AS porecv_orderdate, pohead.pohead_released AS porecv_released, recv.recv_order_number AS porecv_ponumber, recv.recv_itemsite_id AS porecv_itemsite_id, recv.recv_vend_id AS porecv_vend_id, item.item_number AS porecv_item_number, recv.recv_vend_item_number AS porecv_vend_item_number, COALESCE(item.item_descrip1, recv.recv_vend_item_descrip) AS porecv_vend_item_descrip, recv.recv_vend_uom AS porecv_vend_uom, recv.recv_qty AS porecv_qty, recv.recv_posted AS porecv_posted, recv.recv_invoiced AS porecv_invoiced, (pg_user.usesysid)::integer AS porecv_trans_usr_id, recv.recv_orderitem_id AS porecv_poitem_id, NULL::integer AS porecv_linenumber, recv.recv_purchcost AS porecv_purchcost, recv.recv_vohead_id AS porecv_vohead_id, recv.recv_recvcost AS porecv_recvcost, recv.recv_duedate AS porecv_duedate, recv.recv_agent_username AS porecv_agent_username, recv.recv_notes AS porecv_notes, recv.recv_freight AS porecv_freight, recv.recv_freight_curr_id AS porecv_curr_id, recv.recv_gldistdate AS porecv_gldistdate, recv.recv_voitem_id AS porecv_voitem_id, recv.recv_value AS porecv_value FROM ((((recv LEFT JOIN pg_user ON ((recv.recv_trans_usr_name = (pg_user.usename)::text))) LEFT JOIN pohead ON ((recv.recv_order_number = pohead.pohead_number))) LEFT JOIN itemsite ON ((recv.recv_itemsite_id = itemsite.itemsite_id))) LEFT JOIN item ON ((itemsite.itemsite_item_id = item.item_id))) WHERE (recv.recv_order_type = 'PO'::text);


ALTER TABLE public.porecv OWNER TO admin;

--
-- TOC entry 723 (class 1259 OID 146569624)
-- Dependencies: 8
-- Name: porecv_porecv_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE porecv_porecv_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.porecv_porecv_id_seq OWNER TO admin;

--
-- TOC entry 724 (class 1259 OID 146569626)
-- Dependencies: 6612 8
-- Name: poreject; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE poreject (
    poreject_id integer DEFAULT nextval(('"poreject_poreject_id_seq"'::text)::regclass) NOT NULL,
    poreject_date timestamp with time zone,
    poreject_ponumber text,
    poreject_itemsite_id integer,
    poreject_vend_id integer,
    poreject_vend_item_number text,
    poreject_vend_item_descrip text,
    poreject_vend_uom text,
    poreject_qty numeric(18,6),
    poreject_posted boolean,
    poreject_rjctcode_id integer,
    poreject_poitem_id integer,
    poreject_invoiced boolean,
    poreject_vohead_id integer,
    poreject_agent_username text,
    poreject_voitem_id integer,
    poreject_value numeric(18,6),
    poreject_trans_username text,
    poreject_recv_id integer
);


ALTER TABLE public.poreject OWNER TO admin;


--
-- TOC entry 725 (class 1259 OID 146569633)
-- Dependencies: 8
-- Name: poreject_poreject_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE poreject_poreject_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.poreject_poreject_id_seq OWNER TO admin;

CREATE TABLE pr (
    pr_id integer DEFAULT nextval(('"pr_pr_id_seq"'::text)::regclass) NOT NULL,
    pr_number integer,
    pr_subnumber integer,
    pr_status character(1),
    pr_order_type character(1),
    pr_order_id integer,
    pr_poitem_id integer,
    pr_duedate date,
    pr_itemsite_id integer,
    pr_qtyreq numeric(18,6),
    pr_prj_id integer,
    pr_releasenote text,
    pr_createdate timestamp without time zone DEFAULT now()
);


ALTER TABLE public.pr OWNER TO admin;

--
-- TOC entry 10094 (class 0 OID 0)
-- Dependencies: 728
-- Name: TABLE pr; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE pr IS 'Purchase Request information';


--
-- TOC entry 729 (class 1259 OID 146569651)
-- Dependencies: 8
-- Name: pr_pr_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE pr_pr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.pr_pr_id_seq OWNER TO admin;

--
-- TOC entry 730 (class 1259 OID 146569653)
-- Dependencies: 6617 8
-- Name: prftcntr; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE prftcntr (
    prftcntr_id integer NOT NULL,
    prftcntr_number text NOT NULL,
    prftcntr_descrip text,
    CONSTRAINT prftcntr_prftcntr_number_check CHECK ((prftcntr_number <> ''::text))
);


ALTER TABLE public.prftcntr OWNER TO admin;

--
-- TOC entry 10097 (class 0 OID 0)
-- Dependencies: 730
-- Name: TABLE prftcntr; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE prftcntr IS 'Profit Center information';


--
-- TOC entry 731 (class 1259 OID 146569660)
-- Dependencies: 730 8
-- Name: prftcntr_prftcntr_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE prftcntr_prftcntr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.prftcntr_prftcntr_id_seq OWNER TO admin;

--
-- TOC entry 10099 (class 0 OID 0)
-- Dependencies: 731
-- Name: prftcntr_prftcntr_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE prftcntr_prftcntr_id_seq OWNED BY prftcntr.prftcntr_id;


--
-- TOC entry 732 (class 1259 OID 146569662)
-- Dependencies: 8
-- Name: usrgrp; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE usrgrp (
    usrgrp_id integer NOT NULL,
    usrgrp_grp_id integer NOT NULL,
    usrgrp_username text NOT NULL
);


ALTER TABLE public.usrgrp OWNER TO admin;

--
-- TOC entry 10101 (class 0 OID 0)
-- Dependencies: 732
-- Name: TABLE usrgrp; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE usrgrp IS 'This is which group a user belongs to.';


--
-- TOC entry 733 (class 1259 OID 146569668)
-- Dependencies: 6619 8
-- Name: usrpriv; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE usrpriv (
    usrpriv_id integer DEFAULT nextval(('usrpriv_usrpriv_id_seq'::text)::regclass) NOT NULL,
    usrpriv_priv_id integer,
    usrpriv_username text
);


ALTER TABLE public.usrpriv OWNER TO admin;

--
-- TOC entry 10103 (class 0 OID 0)
-- Dependencies: 733
-- Name: TABLE usrpriv; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE usrpriv IS 'User Privileges information';


--
-- TOC entry 734 (class 1259 OID 146569675)
-- Dependencies: 8587 8
-- Name: privgranted; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW privgranted AS
    SELECT priv.priv_name AS privilege, (COALESCE(usrpriv.usrpriv_priv_id, grppriv.grppriv_priv_id, (-1)) > 0) AS granted, priv.priv_seq AS sequence FROM ((priv LEFT JOIN usrpriv ON (((priv.priv_id = usrpriv.usrpriv_priv_id) AND (usrpriv.usrpriv_username = geteffectivextuser())))) LEFT JOIN (SELECT DISTINCT grppriv.grppriv_priv_id FROM (grppriv JOIN usrgrp ON (((grppriv.grppriv_grp_id = usrgrp.usrgrp_grp_id) AND (usrgrp.usrgrp_username = geteffectivextuser()))))) grppriv ON ((grppriv.grppriv_priv_id = priv.priv_id)));


ALTER TABLE public.privgranted OWNER TO admin;

--
-- TOC entry 735 (class 1259 OID 146569680)
-- Dependencies: 225 8
-- Name: prj_prj_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE prj_prj_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.prj_prj_id_seq OWNER TO admin;

--
-- TOC entry 10106 (class 0 OID 0)
-- Dependencies: 735
-- Name: prj_prj_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE prj_prj_id_seq OWNED BY prj.prj_id;


--
-- TOC entry 736 (class 1259 OID 146569682)
-- Dependencies: 232 8
-- Name: prjtask_prjtask_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE prjtask_prjtask_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.prjtask_prjtask_id_seq OWNER TO admin;

--
-- TOC entry 10108 (class 0 OID 0)
-- Dependencies: 736
-- Name: prjtask_prjtask_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE prjtask_prjtask_id_seq OWNED BY prjtask.prjtask_id;


--
-- TOC entry 737 (class 1259 OID 146569684)
-- Dependencies: 8
-- Name: prjtaskuser; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE prjtaskuser (
    prjtaskuser_id integer NOT NULL,
    prjtaskuser_prjtask_id integer,
    prjtaskuser_username text
);


ALTER TABLE public.prjtaskuser OWNER TO admin;

--
-- TOC entry 10110 (class 0 OID 0)
-- Dependencies: 737
-- Name: TABLE prjtaskuser; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE prjtaskuser IS 'Project Task user information';


--
-- TOC entry 738 (class 1259 OID 146569690)
-- Dependencies: 737 8
-- Name: prjtaskuser_prjtaskuser_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE prjtaskuser_prjtaskuser_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.prjtaskuser_prjtaskuser_id_seq OWNER TO admin;

--
-- TOC entry 10112 (class 0 OID 0)
-- Dependencies: 738
-- Name: prjtaskuser_prjtaskuser_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE prjtaskuser_prjtaskuser_id_seq OWNED BY prjtaskuser.prjtaskuser_id;


--
-- TOC entry 739 (class 1259 OID 146569692)
-- Dependencies: 6622 8
-- Name: prjtype; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE prjtype (
    prjtype_id integer NOT NULL,
    prjtype_code text,
    prjtype_descr text,
    prjtype_active boolean DEFAULT true
);


ALTER TABLE public.prjtype OWNER TO admin;

--
-- TOC entry 740 (class 1259 OID 146569699)
-- Dependencies: 739 8
-- Name: prjtype_prjtype_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE prjtype_prjtype_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.prjtype_prjtype_id_seq OWNER TO admin;

--
-- TOC entry 10115 (class 0 OID 0)
-- Dependencies: 740
-- Name: prjtype_prjtype_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE prjtype_prjtype_id_seq OWNED BY prjtype.prjtype_id;


--
-- TOC entry 741 (class 1259 OID 146569701)
-- Dependencies: 8
-- Name: prodcat_prodcat_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE prodcat_prodcat_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.prodcat_prodcat_id_seq OWNER TO admin;

--
-- TOC entry 742 (class 1259 OID 146569703)
-- Dependencies: 6624 6625 6626 8
-- Name: qryhead; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE qryhead (
    qryhead_id integer NOT NULL,
    qryhead_name text NOT NULL,
    qryhead_descrip text,
    qryhead_notes text,
    qryhead_username text DEFAULT geteffectivextuser() NOT NULL,
    qryhead_updated date DEFAULT ('now'::text)::date NOT NULL,
    CONSTRAINT qryhead_qryhead_name_check CHECK ((qryhead_name <> ''::text))
);


ALTER TABLE public.qryhead OWNER TO admin;

--
-- TOC entry 10117 (class 0 OID 0)
-- Dependencies: 742
-- Name: TABLE qryhead; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE qryhead IS 'A header record for a set of queries to be run sequentially. One use is for data export.';


--
-- TOC entry 10118 (class 0 OID 0)
-- Dependencies: 742
-- Name: COLUMN qryhead.qryhead_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN qryhead.qryhead_id IS 'The primary key, holding an internal value used to cross-reference this table.';


--
-- TOC entry 10119 (class 0 OID 0)
-- Dependencies: 742
-- Name: COLUMN qryhead.qryhead_name; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN qryhead.qryhead_name IS 'The user-assigned short name for this set of queries.';


--
-- TOC entry 10120 (class 0 OID 0)
-- Dependencies: 742
-- Name: COLUMN qryhead.qryhead_descrip; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN qryhead.qryhead_descrip IS 'A long description of the purpose of this set of queries.';


--
-- TOC entry 10121 (class 0 OID 0)
-- Dependencies: 742
-- Name: COLUMN qryhead.qryhead_notes; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN qryhead.qryhead_notes IS 'General information about this queryset.';


--
-- TOC entry 10122 (class 0 OID 0)
-- Dependencies: 742
-- Name: COLUMN qryhead.qryhead_username; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN qryhead.qryhead_username IS 'The name of the user who last modified this qryhead record.';


--
-- TOC entry 10123 (class 0 OID 0)
-- Dependencies: 742
-- Name: COLUMN qryhead.qryhead_updated; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN qryhead.qryhead_updated IS 'The date this qryhead was last modified.';


--
-- TOC entry 743 (class 1259 OID 146569712)
-- Dependencies: 742 8
-- Name: qryhead_qryhead_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE qryhead_qryhead_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.qryhead_qryhead_id_seq OWNER TO admin;

--
-- TOC entry 10125 (class 0 OID 0)
-- Dependencies: 743
-- Name: qryhead_qryhead_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE qryhead_qryhead_id_seq OWNED BY qryhead.qryhead_id;


--
-- TOC entry 744 (class 1259 OID 146569714)
-- Dependencies: 6627 6628 6629 6631 6632 8
-- Name: qryitem; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE qryitem (
    qryitem_id integer NOT NULL,
    qryitem_qryhead_id integer NOT NULL,
    qryitem_name text NOT NULL,
    qryitem_order integer NOT NULL,
    qryitem_src text NOT NULL,
    qryitem_group text,
    qryitem_detail text NOT NULL,
    qryitem_notes text DEFAULT ''::text NOT NULL,
    qryitem_username text DEFAULT geteffectivextuser() NOT NULL,
    qryitem_updated date DEFAULT ('now'::text)::date NOT NULL,
    CONSTRAINT qryitem_qryitem_detail_check CHECK ((btrim(qryitem_detail) <> ''::text)),
    CONSTRAINT qryitem_qryitem_src_check CHECK ((qryitem_src = ANY (ARRAY['REL'::text, 'MQL'::text, 'CUSTOM'::text])))
);


ALTER TABLE public.qryitem OWNER TO admin;

--
-- TOC entry 10127 (class 0 OID 0)
-- Dependencies: 744
-- Name: TABLE qryitem; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE qryitem IS 'The description of a query to be run as part of a set (see qryhead).';


--
-- TOC entry 10128 (class 0 OID 0)
-- Dependencies: 744
-- Name: COLUMN qryitem.qryitem_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN qryitem.qryitem_id IS 'The primary key, holding an internal value used to cross-reference this table.';


--
-- TOC entry 10129 (class 0 OID 0)
-- Dependencies: 744
-- Name: COLUMN qryitem.qryitem_qryhead_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN qryitem.qryitem_qryhead_id IS 'The primary key of the query set to which this individual query belongs.';


--
-- TOC entry 10130 (class 0 OID 0)
-- Dependencies: 744
-- Name: COLUMN qryitem.qryitem_order; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN qryitem.qryitem_order IS 'The order in which query items within a query set should be run.';


--
-- TOC entry 10131 (class 0 OID 0)
-- Dependencies: 744
-- Name: COLUMN qryitem.qryitem_src; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN qryitem.qryitem_src IS 'The source of the query. If the qryitem_src is "REL" then the qryitem_group and _detail name a particular table or view and all rows will be returned. If the source is "MQL" then the qryitem_group and _detail name a pre-defined MetaSQL query in the metasql table. If the source is "CUSTOM" then the qryitem_detail contains the full MetaSQL text of the query to run.';


--
-- TOC entry 10132 (class 0 OID 0)
-- Dependencies: 744
-- Name: COLUMN qryitem.qryitem_group; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN qryitem.qryitem_group IS 'Information to help find the query to run. If the qryitem_src is "REL" then this is the schema in which to find the table or view to query and all rows will be returned (the qryitem_detail names the table or view). If the qryitem_src is "MQL" then this is the group of the query in the metasql table to run (the name is in qryitem_detail). If the qryitem_src IS "CUSTOM" then this ignored.';


--
-- TOC entry 10133 (class 0 OID 0)
-- Dependencies: 744
-- Name: COLUMN qryitem.qryitem_detail; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN qryitem.qryitem_detail IS 'The particular query to run. If the qryitem_src is "REL" then this is the name of the table or view to query and all rows will be returned. If the qryitem_src is "MQL" then this is the name of the query in the metasql table to run. If the qryitem_src IS "CUSTOM" then this is the actual MetaSQL query text to be parsed and run.';


--
-- TOC entry 10134 (class 0 OID 0)
-- Dependencies: 744
-- Name: COLUMN qryitem.qryitem_notes; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN qryitem.qryitem_notes IS 'General information about this query.';


--
-- TOC entry 10135 (class 0 OID 0)
-- Dependencies: 744
-- Name: COLUMN qryitem.qryitem_username; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN qryitem.qryitem_username IS 'The name of the user who last modified this qryitem record.';


--
-- TOC entry 10136 (class 0 OID 0)
-- Dependencies: 744
-- Name: COLUMN qryitem.qryitem_updated; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN qryitem.qryitem_updated IS 'The date this qryitem was last modified.';


--
-- TOC entry 745 (class 1259 OID 146569725)
-- Dependencies: 744 8
-- Name: qryitem_qryitem_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE qryitem_qryitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.qryitem_qryitem_id_seq OWNER TO admin;

--
-- TOC entry 10138 (class 0 OID 0)
-- Dependencies: 745
-- Name: qryitem_qryitem_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE qryitem_qryitem_id_seq OWNED BY qryitem.qryitem_id;


--
-- TOC entry 746 (class 1259 OID 146569727)
-- Dependencies: 8
-- Name: quhead_quhead_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE quhead_quhead_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.quhead_quhead_id_seq OWNER TO admin;

--
-- TOC entry 747 (class 1259 OID 146569729)
-- Dependencies: 8
-- Name: quitem_quitem_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE quitem_quitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.quitem_quitem_id_seq OWNER TO admin;

--
-- TOC entry 748 (class 1259 OID 146569731)
-- Dependencies: 6633 8
-- Name: rcalitem; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE rcalitem (
    rcalitem_id integer DEFAULT nextval(('"xcalitem_xcalitem_id_seq"'::text)::regclass) NOT NULL,
    rcalitem_calhead_id integer,
    rcalitem_offsettype character(1),
    rcalitem_offsetcount integer,
    rcalitem_periodtype character(1),
    rcalitem_periodcount integer,
    rcalitem_name text
);


ALTER TABLE public.rcalitem OWNER TO admin;

--
-- TOC entry 10142 (class 0 OID 0)
-- Dependencies: 748
-- Name: TABLE rcalitem; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE rcalitem IS 'Relative Calendar Item information';

--
-- TOC entry 751 (class 1259 OID 146569749)
-- Dependencies: 8
-- Name: recurtype; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE recurtype (
    recurtype_id integer NOT NULL,
    recurtype_type text NOT NULL,
    recurtype_table text NOT NULL,
    recurtype_donecheck text NOT NULL,
    recurtype_schedcol text NOT NULL,
    recurtype_limit text,
    recurtype_copyfunc text NOT NULL,
    recurtype_copyargs text[] NOT NULL,
    recurtype_delfunc text
);


ALTER TABLE public.recurtype OWNER TO admin;

--
-- TOC entry 10157 (class 0 OID 0)
-- Dependencies: 751
-- Name: TABLE recurtype; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE recurtype IS 'Describes the properties of recurring items/events in way that can be used by stored procedures to maintain the recurrence.';


--
-- TOC entry 10158 (class 0 OID 0)
-- Dependencies: 751
-- Name: COLUMN recurtype.recurtype_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN recurtype.recurtype_id IS 'The internal id of this recurrence description.';


--
-- TOC entry 10159 (class 0 OID 0)
-- Dependencies: 751
-- Name: COLUMN recurtype.recurtype_type; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN recurtype.recurtype_type IS 'A code value used by the RecurrenceWidget and the code that uses it to describe the item/event that will recur. Examples include "INCDT" for CRM Incidents and "J" for Projects.';


--
-- TOC entry 10160 (class 0 OID 0)
-- Dependencies: 751
-- Name: COLUMN recurtype.recurtype_table; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN recurtype.recurtype_table IS 'The table that holds the item/event that will recur.';


--
-- TOC entry 10161 (class 0 OID 0)
-- Dependencies: 751
-- Name: COLUMN recurtype.recurtype_donecheck; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN recurtype.recurtype_donecheck IS 'A boolean expression that returns TRUE if an individual item/event record in the recurtype_table has already been completed.';


--
-- TOC entry 10162 (class 0 OID 0)
-- Dependencies: 751
-- Name: COLUMN recurtype.recurtype_schedcol; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN recurtype.recurtype_schedcol IS 'The name of the column in the recurtype_table holding the date or timestamp by which the item is scheduled to be completed or at which the event is supposed to occur.';


--
-- TOC entry 10163 (class 0 OID 0)
-- Dependencies: 751
-- Name: COLUMN recurtype.recurtype_limit; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN recurtype.recurtype_limit IS 'A boolean expression that returns TRUE if the current user should see the row in the recurtype_table. NULL indicates there is no specific limitation. For example, the maintainance of recurring TODO items should restricted to those items belonging to the user unless s/he has been granted the privilege to modify other people''s todo lists.';


--
-- TOC entry 10164 (class 0 OID 0)
-- Dependencies: 751
-- Name: COLUMN recurtype.recurtype_copyfunc; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN recurtype.recurtype_copyfunc IS 'The name of the function to copy an existing item/event record. The copy function is expected to take at least 2 arguments: the id of the item to copy and the new date/timestamp. If the function accepts more than 2, it must be able to accept NULL values for the 3rd and following arguments.';


--
-- TOC entry 10165 (class 0 OID 0)
-- Dependencies: 751
-- Name: COLUMN recurtype.recurtype_copyargs; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN recurtype.recurtype_copyargs IS 'An abbreviated argument list for the copy function. This is used to determine whether the second argument must be cast to a date or a timestamp, and to figure out how many additional arguments to pass.';


--
-- TOC entry 10166 (class 0 OID 0)
-- Dependencies: 751
-- Name: COLUMN recurtype.recurtype_delfunc; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN recurtype.recurtype_delfunc IS 'The name of the function to delete an existing item/event record. The function is expected to take exactly one argument: the id of the item to delete. NULL indicates there is no delete function and that an SQL DELETE statement can be used. In this case, the id column name will be built as the recurtype_table concatenated with the "_id" suffix.';


--
-- TOC entry 752 (class 1259 OID 146569755)
-- Dependencies: 751 8
-- Name: recurtype_recurtype_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE recurtype_recurtype_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.recurtype_recurtype_id_seq OWNER TO admin;

--
-- TOC entry 10168 (class 0 OID 0)
-- Dependencies: 752
-- Name: recurtype_recurtype_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE recurtype_recurtype_id_seq OWNED BY recurtype.recurtype_id;


--
-- TOC entry 753 (class 1259 OID 146569757)
-- Dependencies: 721 8
-- Name: recv_recv_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE recv_recv_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.recv_recv_id_seq OWNER TO admin;

--
-- TOC entry 10170 (class 0 OID 0)
-- Dependencies: 753
-- Name: recv_recv_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE recv_recv_id_seq OWNED BY recv.recv_id;


--
-- TOC entry 754 (class 1259 OID 146569759)
-- Dependencies: 8588 8
-- Name: remitto; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW remitto AS
    SELECT (SELECT metric.metric_value FROM metric WHERE (metric.metric_name = 'remitto_name'::text)) AS remitto_name, (SELECT metric.metric_value FROM metric WHERE (metric.metric_name = 'remitto_address1'::text)) AS remitto_address1, (SELECT metric.metric_value FROM metric WHERE (metric.metric_name = 'remitto_address2'::text)) AS remitto_address2, (SELECT metric.metric_value FROM metric WHERE (metric.metric_name = 'remitto_address3'::text)) AS remitto_address3, (((((SELECT metric.metric_value FROM metric WHERE (metric.metric_name = 'remitto_city'::text)) || '  '::text) || (SELECT metric.metric_value FROM metric WHERE (metric.metric_name = 'remitto_state'::text))) || '  '::text) || (SELECT metric.metric_value FROM metric WHERE (metric.metric_name = 'remitto_zipcode'::text))) AS remitto_citystatezip, (SELECT metric.metric_value FROM metric WHERE (metric.metric_name = 'remitto_country'::text)) AS remitto_country, (SELECT metric.metric_value FROM metric WHERE (metric.metric_name = 'remitto_phone'::text)) AS remitto_phone;


ALTER TABLE public.remitto OWNER TO admin;

--
-- TOC entry 755 (class 1259 OID 146569763)
-- Dependencies: 6639 6640 8
-- Name: rjctcode; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE rjctcode (
    rjctcode_id integer DEFAULT nextval(('"rjctcode_rjctcode_id_seq"'::text)::regclass) NOT NULL,
    rjctcode_code text NOT NULL,
    rjctcode_descrip text,
    CONSTRAINT rjctcode_rjctcode_code_check CHECK ((rjctcode_code <> ''::text))
);


ALTER TABLE public.rjctcode OWNER TO admin;

--
-- TOC entry 10173 (class 0 OID 0)
-- Dependencies: 755
-- Name: TABLE rjctcode; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE rjctcode IS 'Reject Code information';


--
-- TOC entry 756 (class 1259 OID 146569771)
-- Dependencies: 8
-- Name: rjctcode_rjctcode_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE rjctcode_rjctcode_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.rjctcode_rjctcode_id_seq OWNER TO admin;

--
-- TOC entry 757 (class 1259 OID 146569773)
-- Dependencies: 214 8
-- Name: rsncode_rsncode_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE rsncode_rsncode_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.rsncode_rsncode_id_seq OWNER TO admin;

--
-- TOC entry 10176 (class 0 OID 0)
-- Dependencies: 757
-- Name: rsncode_rsncode_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE rsncode_rsncode_id_seq OWNED BY rsncode.rsncode_id;


--
-- TOC entry 758 (class 1259 OID 146569775)
-- Dependencies: 6641 6642 8
-- Name: sale; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE sale (
    sale_id integer DEFAULT nextval(('"sale_sale_id_seq"'::text)::regclass) NOT NULL,
    sale_name text NOT NULL,
    sale_descrip text,
    sale_ipshead_id integer,
    sale_startdate date,
    sale_enddate date,
    CONSTRAINT sale_sale_name_check CHECK ((sale_name <> ''::text))
);


ALTER TABLE public.sale OWNER TO admin;

--
-- TOC entry 10178 (class 0 OID 0)
-- Dependencies: 758
-- Name: TABLE sale; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE sale IS 'Sale information';


--
-- TOC entry 759 (class 1259 OID 146569783)
-- Dependencies: 8
-- Name: sale_sale_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE sale_sale_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.sale_sale_id_seq OWNER TO admin;

--
-- TOC entry 760 (class 1259 OID 146569785)
-- Dependencies: 8
-- Name: salesaccnt_salesaccnt_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE salesaccnt_salesaccnt_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.salesaccnt_salesaccnt_id_seq OWNER TO admin;

--
-- TOC entry 761 (class 1259 OID 146569787)
-- Dependencies: 215 8
-- Name: salescat_salescat_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE salescat_salescat_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.salescat_salescat_id_seq OWNER TO admin;

--
-- TOC entry 10182 (class 0 OID 0)
-- Dependencies: 761
-- Name: salescat_salescat_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE salescat_salescat_id_seq OWNED BY salescat.salescat_id;


--
-- TOC entry 762 (class 1259 OID 146569789)
-- Dependencies: 8589 8
-- Name: saleshistory; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW saleshistory AS
    SELECT cohist.cohist_id, cohist.cohist_cust_id, cohist.cohist_itemsite_id, cohist.cohist_shipdate, cohist.cohist_shipvia, cohist.cohist_ordernumber, cohist.cohist_orderdate, cohist.cohist_invcnumber, cohist.cohist_invcdate, cohist.cohist_qtyshipped, cohist.cohist_unitprice, cohist.cohist_shipto_id, cohist.cohist_salesrep_id, cohist.cohist_duedate, cohist.cohist_imported, cohist.cohist_billtoname, cohist.cohist_billtoaddress1, cohist.cohist_billtoaddress2, cohist.cohist_billtoaddress3, cohist.cohist_billtocity, cohist.cohist_billtostate, cohist.cohist_billtozip, cohist.cohist_shiptoname, cohist.cohist_shiptoaddress1, cohist.cohist_shiptoaddress2, cohist.cohist_shiptoaddress3, cohist.cohist_shiptocity, cohist.cohist_shiptostate, cohist.cohist_shiptozip, cohist.cohist_commission, cohist.cohist_commissionpaid, cohist.cohist_unitcost, cohist.cohist_misc_type, cohist.cohist_misc_descrip, cohist.cohist_misc_id, cohist.cohist_doctype, cohist.cohist_promisedate, cohist.cohist_ponumber, cohist.cohist_curr_id, cohist.cohist_sequence, cohist.cohist_taxtype_id, cohist.cohist_taxzone_id, cohist.cohist_cohead_ccpay_id, cohist.cohist_saletype_id, cohist.cohist_shipzone_id, CASE WHEN (cohist.cohist_invcnumber = '-1'::text) THEN 'Credit'::text ELSE cohist.cohist_invcnumber END AS invoicenumber, custinfo.cust_id, custinfo.cust_number, custinfo.cust_name, custinfo.cust_curr_id, custinfo.cust_custtype_id, custtype.custtype_code, custtype.custtype_descrip, salesrep.salesrep_number, salesrep.salesrep_name, shipzone.shipzone_id, shipzone.shipzone_name, shipzone.shipzone_descrip, itemsite.itemsite_warehous_id, itemsite.itemsite_item_id, item.item_id, item.item_number, item.item_descrip1, ((item.item_descrip1 || ' '::text) || item.item_descrip2) AS itemdescription, item.item_prodcat_id, site.warehous_code, site.warehous_descrip, prodcat.prodcat_code, currtobase(cohist.cohist_curr_id, cohist.cohist_commission, cohist.cohist_invcdate) AS basecommission, currtobase(cohist.cohist_curr_id, cohist.cohist_unitprice, cohist.cohist_invcdate) AS baseunitprice, currtocurr(cohist.cohist_curr_id, custinfo.cust_curr_id, cohist.cohist_unitprice, cohist.cohist_invcdate) AS custunitprice, round((cohist.cohist_qtyshipped * cohist.cohist_unitprice), 2) AS extprice, round((cohist.cohist_qtyshipped * currtobase(cohist.cohist_curr_id, cohist.cohist_unitprice, cohist.cohist_invcdate)), 2) AS baseextprice, round((cohist.cohist_qtyshipped * currtocurr(cohist.cohist_curr_id, custinfo.cust_curr_id, cohist.cohist_unitprice, cohist.cohist_invcdate)), 2) AS custextprice, round((cohist.cohist_qtyshipped * cohist.cohist_unitcost), 4) AS extcost, currconcat(cohist.cohist_curr_id) AS currabbr, 'Return'::text AS cohist_invcdate_xtnullrole, 'qty'::text AS cohist_qtyshipped_xtnumericrole, 'salesprice'::text AS cohist_unitprice_xtnumericrole, 'salesprice'::text AS baseunitprice_xtnumericrole, 'curr'::text AS custunitprice_xtnumericrole, 'curr'::text AS custextprice_xtnumericrole, 'curr'::text AS extprice_xtnumericrole, 'curr'::text AS baseextprice_xtnumericrole, 'cost'::text AS cohist_unitcost_xtnumericrole, 'curr'::text AS extcost_xtnumericrole, 'curr'::text AS cohist_commission_xtnumericrole, 'curr'::text AS basecommission_xtnumericrole, 0 AS cohist_qtyshipped_xttotalrole, 0 AS custextprice_xttotalrole, 0 AS baseextprice_xttotalrole, 0 AS extcost_xttotalrole, 0 AS basecommission_xttotalrole FROM (((((((((cohist JOIN custinfo ON ((custinfo.cust_id = cohist.cohist_cust_id))) JOIN custtype ON ((custtype.custtype_id = custinfo.cust_custtype_id))) JOIN salesrep ON ((salesrep.salesrep_id = cohist.cohist_salesrep_id))) JOIN itemsite ON ((itemsite.itemsite_id = cohist.cohist_itemsite_id))) JOIN site() site(warehous_id, warehous_code, warehous_descrip, warehous_fob, warehous_active, warehous_counttag_prefix, warehous_counttag_number, warehous_bol_prefix, warehous_bol_number, warehous_shipping, warehous_useslips, warehous_usezones, warehous_aislesize, warehous_aislealpha, warehous_racksize, warehous_rackalpha, warehous_binsize, warehous_binalpha, warehous_locationsize, warehous_locationalpha, warehous_enforcearbl, warehous_default_accnt_id, warehous_shipping_commission, warehous_cntct_id, warehous_addr_id, warehous_transit, warehous_shipform_id, warehous_shipvia_id, warehous_shipcomments, warehous_costcat_id, warehous_sitetype_id, warehous_taxzone_id, warehous_sequence) ON ((site.warehous_id = itemsite.itemsite_warehous_id))) JOIN item ON ((item.item_id = itemsite.itemsite_item_id))) JOIN prodcat ON ((prodcat.prodcat_id = item.item_prodcat_id))) LEFT JOIN shiptoinfo ON ((shiptoinfo.shipto_id = cohist.cohist_shipto_id))) LEFT JOIN shipzone ON ((shipzone.shipzone_id = shiptoinfo.shipto_shipzone_id)));


ALTER TABLE public.saleshistory OWNER TO admin;

--
-- TOC entry 10184 (class 0 OID 0)
-- Dependencies: 762
-- Name: VIEW saleshistory; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON VIEW saleshistory IS 'Single point for sales history calculations.';


--
-- TOC entry 763 (class 1259 OID 146569794)
-- Dependencies: 8590 8
-- Name: saleshistorymisc; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW saleshistorymisc AS
    SELECT cohist.cohist_id, cohist.cohist_cust_id, cohist.cohist_itemsite_id, cohist.cohist_shipdate, cohist.cohist_shipvia, cohist.cohist_ordernumber, cohist.cohist_orderdate, cohist.cohist_invcnumber, cohist.cohist_invcdate, cohist.cohist_qtyshipped, cohist.cohist_unitprice, cohist.cohist_shipto_id, cohist.cohist_salesrep_id, cohist.cohist_duedate, cohist.cohist_imported, cohist.cohist_billtoname, cohist.cohist_billtoaddress1, cohist.cohist_billtoaddress2, cohist.cohist_billtoaddress3, cohist.cohist_billtocity, cohist.cohist_billtostate, cohist.cohist_billtozip, cohist.cohist_shiptoname, cohist.cohist_shiptoaddress1, cohist.cohist_shiptoaddress2, cohist.cohist_shiptoaddress3, cohist.cohist_shiptocity, cohist.cohist_shiptostate, cohist.cohist_shiptozip, cohist.cohist_commission, cohist.cohist_commissionpaid, cohist.cohist_unitcost, cohist.cohist_misc_type, cohist.cohist_misc_descrip, cohist.cohist_misc_id, cohist.cohist_doctype, cohist.cohist_promisedate, cohist.cohist_ponumber, cohist.cohist_curr_id, cohist.cohist_sequence, cohist.cohist_taxtype_id, cohist.cohist_taxzone_id, cohist.cohist_cohead_ccpay_id, cohist.cohist_saletype_id, cohist.cohist_shipzone_id, CASE WHEN (cohist.cohist_invcnumber = '-1'::text) THEN 'Credit'::text ELSE cohist.cohist_invcnumber END AS invoicenumber, custinfo.cust_id, custinfo.cust_number, custinfo.cust_name, custinfo.cust_curr_id, custinfo.cust_custtype_id, custtype.custtype_code, salesrep.salesrep_number, salesrep.salesrep_name, shipzone.shipzone_id, shipzone.shipzone_name, itemsite.itemsite_warehous_id, itemsite.itemsite_item_id, item.item_number, item.item_descrip1, ((item.item_descrip1 || ' '::text) || item.item_descrip2) AS itemdescription, item.item_prodcat_id, site.warehous_code, prodcat.prodcat_code, currtobase(cohist.cohist_curr_id, cohist.cohist_commission, cohist.cohist_invcdate) AS basecommission, currtobase(cohist.cohist_curr_id, cohist.cohist_unitprice, cohist.cohist_invcdate) AS baseunitprice, currtocurr(cohist.cohist_curr_id, custinfo.cust_curr_id, cohist.cohist_unitprice, cohist.cohist_invcdate) AS custunitprice, round((cohist.cohist_qtyshipped * cohist.cohist_unitprice), 2) AS extprice, round((cohist.cohist_qtyshipped * currtobase(cohist.cohist_curr_id, cohist.cohist_unitprice, cohist.cohist_invcdate)), 2) AS baseextprice, round((cohist.cohist_qtyshipped * currtocurr(cohist.cohist_curr_id, custinfo.cust_curr_id, cohist.cohist_unitprice, cohist.cohist_invcdate)), 2) AS custextprice, round((cohist.cohist_qtyshipped * cohist.cohist_unitcost), 4) AS extcost, currconcat(cohist.cohist_curr_id) AS currabbr, 'Return'::text AS cohist_invcdate_xtnullrole, 'qty'::text AS cohist_qtyshipped_xtnumericrole, 'salesprice'::text AS cohist_unitprice_xtnumericrole, 'salesprice'::text AS baseunitprice_xtnumericrole, 'curr'::text AS custunitprice_xtnumericrole, 'curr'::text AS custextprice_xtnumericrole, 'curr'::text AS extprice_xtnumericrole, 'curr'::text AS baseextprice_xtnumericrole, 'cost'::text AS cohist_unitcost_xtnumericrole, 'curr'::text AS extcost_xtnumericrole, 'curr'::text AS cohist_commission_xtnumericrole, 'curr'::text AS basecommission_xtnumericrole, 0 AS cohist_qtyshipped_xttotalrole, 0 AS custextprice_xttotalrole, 0 AS baseextprice_xttotalrole, 0 AS extcost_xttotalrole, 0 AS basecommission_xttotalrole FROM (((((((((cohist JOIN custinfo ON ((custinfo.cust_id = cohist.cohist_cust_id))) JOIN custtype ON ((custtype.custtype_id = custinfo.cust_custtype_id))) JOIN salesrep ON ((salesrep.salesrep_id = cohist.cohist_salesrep_id))) LEFT JOIN itemsite ON ((itemsite.itemsite_id = cohist.cohist_itemsite_id))) LEFT JOIN site() site(warehous_id, warehous_code, warehous_descrip, warehous_fob, warehous_active, warehous_counttag_prefix, warehous_counttag_number, warehous_bol_prefix, warehous_bol_number, warehous_shipping, warehous_useslips, warehous_usezones, warehous_aislesize, warehous_aislealpha, warehous_racksize, warehous_rackalpha, warehous_binsize, warehous_binalpha, warehous_locationsize, warehous_locationalpha, warehous_enforcearbl, warehous_default_accnt_id, warehous_shipping_commission, warehous_cntct_id, warehous_addr_id, warehous_transit, warehous_shipform_id, warehous_shipvia_id, warehous_shipcomments, warehous_costcat_id, warehous_sitetype_id, warehous_taxzone_id, warehous_sequence) ON ((site.warehous_id = itemsite.itemsite_warehous_id))) LEFT JOIN item ON ((item.item_id = itemsite.itemsite_item_id))) LEFT JOIN prodcat ON ((prodcat.prodcat_id = item.item_prodcat_id))) LEFT JOIN shiptoinfo ON ((shiptoinfo.shipto_id = cohist.cohist_shipto_id))) LEFT JOIN shipzone ON ((shipzone.shipzone_id = shiptoinfo.shipto_shipzone_id)));


ALTER TABLE public.saleshistorymisc OWNER TO admin;

--
-- TOC entry 10186 (class 0 OID 0)
-- Dependencies: 763
-- Name: VIEW saleshistorymisc; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON VIEW saleshistorymisc IS 'Single point for sales history (including misc. items) calculations.';


--
-- TOC entry 764 (class 1259 OID 146569799)
-- Dependencies: 8
-- Name: salesrep_salesrep_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE salesrep_salesrep_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.salesrep_salesrep_id_seq OWNER TO admin;

--
-- TOC entry 765 (class 1259 OID 146569801)
-- Dependencies: 226 8
-- Name: saletype_saletype_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE saletype_saletype_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.saletype_saletype_id_seq OWNER TO admin;

--
-- TOC entry 10189 (class 0 OID 0)
-- Dependencies: 765
-- Name: saletype_saletype_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE saletype_saletype_id_seq OWNED BY saletype.saletype_id;


--
-- TOC entry 766 (class 1259 OID 146569803)
-- Dependencies: 6644 6645 8
-- Name: schemaord; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE schemaord (
    schemaord_id integer NOT NULL,
    schemaord_name text NOT NULL,
    schemaord_order integer NOT NULL,
    CONSTRAINT schemaord_schemaord_name_check CHECK ((length(schemaord_name) > 0)),
    CONSTRAINT schemaord_schemaord_name_check1 CHECK ((schemaord_name <> ''::text))
);


ALTER TABLE public.schemaord OWNER TO admin;

--
-- TOC entry 10191 (class 0 OID 0)
-- Dependencies: 766
-- Name: TABLE schemaord; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE schemaord IS 'Set the order in which db schemas will appear in the search path after login';


--
-- TOC entry 767 (class 1259 OID 146569811)
-- Dependencies: 766 8
-- Name: schemaord_schemaord_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE schemaord_schemaord_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.schemaord_schemaord_id_seq OWNER TO admin;

--
-- TOC entry 10193 (class 0 OID 0)
-- Dependencies: 767
-- Name: schemaord_schemaord_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE schemaord_schemaord_id_seq OWNED BY schemaord.schemaord_id;


--
-- TOC entry 768 (class 1259 OID 146569813)
-- Dependencies: 8
-- Name: sequence; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE sequence (
    sequence_value integer
);


ALTER TABLE public.sequence OWNER TO admin;

--
-- TOC entry 10195 (class 0 OID 0)
-- Dependencies: 768
-- Name: TABLE sequence; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE sequence IS 'Pre-populated list of sequence numbers (1-1000) used for printing Labels and other uses';


--
-- TOC entry 769 (class 1259 OID 146569816)
-- Dependencies: 293 8
-- Name: shift_shift_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE shift_shift_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.shift_shift_id_seq OWNER TO admin;

--
-- TOC entry 10197 (class 0 OID 0)
-- Dependencies: 769
-- Name: shift_shift_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE shift_shift_id_seq OWNED BY shift.shift_id;


--
-- TOC entry 770 (class 1259 OID 146569818)
-- Dependencies: 281 8
-- Name: shipchrg_shipchrg_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE shipchrg_shipchrg_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.shipchrg_shipchrg_id_seq OWNER TO admin;

--
-- TOC entry 10199 (class 0 OID 0)
-- Dependencies: 770
-- Name: shipchrg_shipchrg_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE shipchrg_shipchrg_id_seq OWNED BY shipchrg.shipchrg_id;


--
-- TOC entry 771 (class 1259 OID 146569820)
-- Dependencies: 6646 6647 6648 6649 6650 8
-- Name: shipdatasum; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE shipdatasum (
    shipdatasum_cohead_number text NOT NULL,
    shipdatasum_cosmisc_tracknum text NOT NULL,
    shipdatasum_cosmisc_packnum_tracknum text NOT NULL,
    shipdatasum_weight numeric(16,4),
    shipdatasum_base_freight numeric(16,4),
    shipdatasum_total_freight numeric(16,4),
    shipdatasum_shipper text DEFAULT 'UPS'::text,
    shipdatasum_billing_option text,
    shipdatasum_package_type text,
    shipdatasum_lastupdated timestamp without time zone DEFAULT ('now'::text)::timestamp(6) with time zone NOT NULL,
    shipdatasum_shipped boolean DEFAULT false,
    shipdatasum_shiphead_number text,
    shipdatasum_base_freight_curr_id integer DEFAULT basecurrid(),
    shipdatasum_total_freight_curr_id integer DEFAULT basecurrid()
);


ALTER TABLE public.shipdatasum OWNER TO admin;

--
-- TOC entry 10201 (class 0 OID 0)
-- Dependencies: 771
-- Name: TABLE shipdatasum; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE shipdatasum IS 'Shipping Interface information.';


--
-- TOC entry 772 (class 1259 OID 146569831)
-- Dependencies: 8
-- Name: shipform_shipform_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE shipform_shipform_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.shipform_shipform_id_seq OWNER TO admin;

--
-- TOC entry 773 (class 1259 OID 146569833)
-- Dependencies: 526 8
-- Name: shiphead_shiphead_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE shiphead_shiphead_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.shiphead_shiphead_id_seq OWNER TO admin;

--
-- TOC entry 10204 (class 0 OID 0)
-- Dependencies: 773
-- Name: shiphead_shiphead_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE shiphead_shiphead_id_seq OWNED BY shiphead.shiphead_id;


--
-- TOC entry 774 (class 1259 OID 146569835)
-- Dependencies: 527 8
-- Name: shipitem_shipitem_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE shipitem_shipitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.shipitem_shipitem_id_seq OWNER TO admin;

--
-- TOC entry 10206 (class 0 OID 0)
-- Dependencies: 774
-- Name: shipitem_shipitem_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE shipitem_shipitem_id_seq OWNED BY shipitem.shipitem_id;


--
-- TOC entry 775 (class 1259 OID 146569837)
-- Dependencies: 8
-- Name: shipment_number_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE shipment_number_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.shipment_number_seq OWNER TO admin;

--
-- TOC entry 776 (class 1259 OID 146569839)
-- Dependencies: 8591 8
-- Name: shipto; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW shipto AS
    SELECT shiptoinfo.shipto_id, shiptoinfo.shipto_cust_id, shiptoinfo.shipto_name, m.addr_line1 AS shipto_address1, m.addr_line2 AS shipto_address2, m.addr_line3 AS shipto_address3, m.addr_city AS shipto_city, m.addr_state AS shipto_state, m.addr_postalcode AS shipto_zipcode, shiptoinfo.shipto_taxzone_id, shiptoinfo.shipto_salesrep_id, c1.cntct_phone AS shipto_phone, shiptoinfo.shipto_comments, shiptoinfo.shipto_shipcomments, btrim(((c1.cntct_first_name || ' '::text) || c1.cntct_last_name)) AS shipto_contact, c1.cntct_fax AS shipto_fax, c1.cntct_email AS shipto_email, shiptoinfo.shipto_shipzone_id, shiptoinfo.shipto_shipvia, shiptoinfo.shipto_commission, shiptoinfo.shipto_shipform_id, shiptoinfo.shipto_shipchrg_id, shiptoinfo.shipto_active, shiptoinfo.shipto_default, shiptoinfo.shipto_num, shiptoinfo.shipto_ediprofile_id, m.addr_country AS shipto_country FROM ((shiptoinfo LEFT JOIN cntct c1 ON ((shiptoinfo.shipto_cntct_id = c1.cntct_id))) LEFT JOIN addr m ON ((shiptoinfo.shipto_addr_id = m.addr_id)));


ALTER TABLE public.shipto OWNER TO admin;

--
-- TOC entry 777 (class 1259 OID 146569844)
-- Dependencies: 8
-- Name: shipto_shipto_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE shipto_shipto_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.shipto_shipto_id_seq OWNER TO admin;

--
-- TOC entry 778 (class 1259 OID 146569846)
-- Dependencies: 8
-- Name: shipvia_shipvia_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE shipvia_shipvia_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.shipvia_shipvia_id_seq OWNER TO admin;

--
-- TOC entry 779 (class 1259 OID 146569848)
-- Dependencies: 8
-- Name: shipzone_shipzone_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE shipzone_shipzone_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.shipzone_shipzone_id_seq OWNER TO admin;

--
-- TOC entry 780 (class 1259 OID 146569850)
-- Dependencies: 387 8
-- Name: sitetype_sitetype_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE sitetype_sitetype_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.sitetype_sitetype_id_seq OWNER TO admin;

--
-- TOC entry 10213 (class 0 OID 0)
-- Dependencies: 780
-- Name: sitetype_sitetype_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE sitetype_sitetype_id_seq OWNED BY sitetype.sitetype_id;


--
-- TOC entry 781 (class 1259 OID 146569852)
-- Dependencies: 6651 6652 6653 8
-- Name: sltrans; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE sltrans (
    sltrans_id integer DEFAULT nextval('gltrans_gltrans_id_seq'::regclass) NOT NULL,
    sltrans_created timestamp with time zone,
    sltrans_date date NOT NULL,
    sltrans_sequence integer,
    sltrans_accnt_id integer NOT NULL,
    sltrans_source text,
    sltrans_docnumber text,
    sltrans_misc_id integer,
    sltrans_amount numeric(20,2) NOT NULL,
    sltrans_notes text,
    sltrans_journalnumber integer,
    sltrans_posted boolean NOT NULL,
    sltrans_doctype text,
    sltrans_username text DEFAULT geteffectivextuser() NOT NULL,
    sltrans_gltrans_journalnumber integer,
    sltrans_rec boolean DEFAULT false NOT NULL
);


ALTER TABLE public.sltrans OWNER TO admin;

--
-- TOC entry 10215 (class 0 OID 0)
-- Dependencies: 781
-- Name: TABLE sltrans; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE sltrans IS 'Journal transaction information';


--
-- TOC entry 782 (class 1259 OID 146569861)
-- Dependencies: 8
-- Name: sltrans_backup; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE sltrans_backup (
    sltrans_old_id integer,
    sltrans_new_id integer
);


ALTER TABLE public.sltrans_backup OWNER TO admin;

--
-- TOC entry 10217 (class 0 OID 0)
-- Dependencies: 782
-- Name: TABLE sltrans_backup; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE sltrans_backup IS 'backup cross references of old and new ids for sltrans 4.0 upgrade.';


--
-- TOC entry 783 (class 1259 OID 146569864)
-- Dependencies: 8592 8
-- Name: sopack; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW sopack AS
    SELECT pack.pack_id AS sopack_id, pack.pack_head_id AS sopack_sohead_id, pack.pack_printed AS sopack_printed, pack.pack_shiphead_id AS sopack_cosmisc_id FROM pack WHERE (pack.pack_head_type = 'SO'::text);


ALTER TABLE public.sopack OWNER TO admin;

--
-- TOC entry 784 (class 1259 OID 146569868)
-- Dependencies: 8
-- Name: sopack_sopack_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE sopack_sopack_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.sopack_sopack_id_seq OWNER TO admin;

--
-- TOC entry 785 (class 1259 OID 146569870)
-- Dependencies: 6655 8
-- Name: source; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE source (
    source_id integer NOT NULL,
    source_module text,
    source_name text NOT NULL,
    source_descrip text,
    CONSTRAINT source_source_name_check CHECK ((source_name <> ''::text))
);


ALTER TABLE public.source OWNER TO admin;

--
-- TOC entry 786 (class 1259 OID 146569877)
-- Dependencies: 785 8
-- Name: source_source_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE source_source_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.source_source_id_seq OWNER TO admin;

--
-- TOC entry 10226 (class 0 OID 0)
-- Dependencies: 786
-- Name: source_source_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE source_source_id_seq OWNED BY source.source_id;


--
-- TOC entry 787 (class 1259 OID 146569879)
-- Dependencies: 6657 8
-- Name: state; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE state (
    state_id integer NOT NULL,
    state_name text NOT NULL,
    state_abbr text,
    state_country_id integer,
    CONSTRAINT state_state_name_check CHECK ((state_name <> ''::text))
);


ALTER TABLE public.state OWNER TO admin;

--
-- TOC entry 10228 (class 0 OID 0)
-- Dependencies: 787
-- Name: TABLE state; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE state IS 'List of states, provinces, and territories associated with various countries.';


--
-- TOC entry 788 (class 1259 OID 146569886)
-- Dependencies: 787 8
-- Name: state_state_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE state_state_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.state_state_id_seq OWNER TO admin;

--
-- TOC entry 10230 (class 0 OID 0)
-- Dependencies: 788
-- Name: state_state_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE state_state_id_seq OWNED BY state.state_id;


--
-- TOC entry 789 (class 1259 OID 146569888)
-- Dependencies: 6659 8
-- Name: status; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE status (
    status_id integer NOT NULL,
    status_type text NOT NULL,
    status_code character(1) NOT NULL,
    status_name text,
    status_seq integer,
    status_color text DEFAULT 'white'::text
);


ALTER TABLE public.status OWNER TO admin;

--
-- TOC entry 790 (class 1259 OID 146569895)
-- Dependencies: 789 8
-- Name: status_status_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE status_status_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.status_status_id_seq OWNER TO admin;

--
-- TOC entry 10233 (class 0 OID 0)
-- Dependencies: 790
-- Name: status_status_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE status_status_id_seq OWNED BY status.status_id;


--
-- TOC entry 791 (class 1259 OID 146569897)
-- Dependencies: 6661 8
-- Name: stdjrnl; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE stdjrnl (
    stdjrnl_id integer NOT NULL,
    stdjrnl_name text NOT NULL,
    stdjrnl_descrip text,
    stdjrnl_notes text,
    CONSTRAINT stdjrnl_stdjrnl_name_check CHECK ((stdjrnl_name <> ''::text))
);


ALTER TABLE public.stdjrnl OWNER TO admin;

--
-- TOC entry 10235 (class 0 OID 0)
-- Dependencies: 791
-- Name: TABLE stdjrnl; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE stdjrnl IS 'Standard Journal information';


--
-- TOC entry 792 (class 1259 OID 146569904)
-- Dependencies: 791 8
-- Name: stdjrnl_stdjrnl_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE stdjrnl_stdjrnl_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.stdjrnl_stdjrnl_id_seq OWNER TO admin;

--
-- TOC entry 10237 (class 0 OID 0)
-- Dependencies: 792
-- Name: stdjrnl_stdjrnl_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE stdjrnl_stdjrnl_id_seq OWNED BY stdjrnl.stdjrnl_id;


--
-- TOC entry 793 (class 1259 OID 146569906)
-- Dependencies: 6663 8
-- Name: stdjrnlgrp; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE stdjrnlgrp (
    stdjrnlgrp_id integer NOT NULL,
    stdjrnlgrp_name text NOT NULL,
    stdjrnlgrp_descrip text,
    CONSTRAINT stdjrnlgrp_stdjrnlgrp_name_check CHECK ((stdjrnlgrp_name <> ''::text))
);


ALTER TABLE public.stdjrnlgrp OWNER TO admin;

--
-- TOC entry 10239 (class 0 OID 0)
-- Dependencies: 793
-- Name: TABLE stdjrnlgrp; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE stdjrnlgrp IS 'Standard Journal Group information';


--
-- TOC entry 794 (class 1259 OID 146569913)
-- Dependencies: 793 8
-- Name: stdjrnlgrp_stdjrnlgrp_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE stdjrnlgrp_stdjrnlgrp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.stdjrnlgrp_stdjrnlgrp_id_seq OWNER TO admin;

--
-- TOC entry 10241 (class 0 OID 0)
-- Dependencies: 794
-- Name: stdjrnlgrp_stdjrnlgrp_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE stdjrnlgrp_stdjrnlgrp_id_seq OWNED BY stdjrnlgrp.stdjrnlgrp_id;


--
-- TOC entry 795 (class 1259 OID 146569915)
-- Dependencies: 8
-- Name: stdjrnlgrpitem; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE stdjrnlgrpitem (
    stdjrnlgrpitem_id integer NOT NULL,
    stdjrnlgrpitem_stdjrnl_id integer,
    stdjrnlgrpitem_toapply integer,
    stdjrnlgrpitem_applied integer,
    stdjrnlgrpitem_effective date,
    stdjrnlgrpitem_expires date,
    stdjrnlgrpitem_stdjrnlgrp_id integer
);


ALTER TABLE public.stdjrnlgrpitem OWNER TO admin;

--
-- TOC entry 10243 (class 0 OID 0)
-- Dependencies: 795
-- Name: TABLE stdjrnlgrpitem; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE stdjrnlgrpitem IS 'Standard Journal Group Item information';


--
-- TOC entry 796 (class 1259 OID 146569918)
-- Dependencies: 795 8
-- Name: stdjrnlgrpitem_stdjrnlgrpitem_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE stdjrnlgrpitem_stdjrnlgrpitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.stdjrnlgrpitem_stdjrnlgrpitem_id_seq OWNER TO admin;

--
-- TOC entry 10245 (class 0 OID 0)
-- Dependencies: 796
-- Name: stdjrnlgrpitem_stdjrnlgrpitem_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE stdjrnlgrpitem_stdjrnlgrpitem_id_seq OWNED BY stdjrnlgrpitem.stdjrnlgrpitem_id;


--
-- TOC entry 797 (class 1259 OID 146569920)
-- Dependencies: 8
-- Name: stdjrnlitem; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE stdjrnlitem (
    stdjrnlitem_id integer NOT NULL,
    stdjrnlitem_stdjrnl_id integer NOT NULL,
    stdjrnlitem_accnt_id integer NOT NULL,
    stdjrnlitem_amount numeric(20,2) NOT NULL,
    stdjrnlitem_notes text
);


ALTER TABLE public.stdjrnlitem OWNER TO admin;

--
-- TOC entry 10247 (class 0 OID 0)
-- Dependencies: 797
-- Name: TABLE stdjrnlitem; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE stdjrnlitem IS 'Standard Journal Item information';


--
-- TOC entry 798 (class 1259 OID 146569926)
-- Dependencies: 797 8
-- Name: stdjrnlitem_stdjrnlitem_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE stdjrnlitem_stdjrnlitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.stdjrnlitem_stdjrnlitem_id_seq OWNER TO admin;

--
-- TOC entry 10249 (class 0 OID 0)
-- Dependencies: 798
-- Name: stdjrnlitem_stdjrnlitem_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE stdjrnlitem_stdjrnlitem_id_seq OWNED BY stdjrnlitem.stdjrnlitem_id;


--
-- TOC entry 799 (class 1259 OID 146569928)
-- Dependencies: 6667 8
-- Name: subaccnt; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE subaccnt (
    subaccnt_id integer NOT NULL,
    subaccnt_number text NOT NULL,
    subaccnt_descrip text,
    CONSTRAINT subaccnt_subaccnt_number_check CHECK ((subaccnt_number <> ''::text))
);


ALTER TABLE public.subaccnt OWNER TO admin;

--
-- TOC entry 10251 (class 0 OID 0)
-- Dependencies: 799
-- Name: TABLE subaccnt; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE subaccnt IS 'Subaccount information';


--
-- TOC entry 800 (class 1259 OID 146569935)
-- Dependencies: 799 8
-- Name: subaccnt_subaccnt_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE subaccnt_subaccnt_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.subaccnt_subaccnt_id_seq OWNER TO admin;

--
-- TOC entry 10253 (class 0 OID 0)
-- Dependencies: 800
-- Name: subaccnt_subaccnt_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE subaccnt_subaccnt_id_seq OWNED BY subaccnt.subaccnt_id;


--
-- TOC entry 801 (class 1259 OID 146569937)
-- Dependencies: 8
-- Name: subaccnttype; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE subaccnttype (
    subaccnttype_id integer NOT NULL,
    subaccnttype_accnt_type character(1) NOT NULL,
    subaccnttype_code text NOT NULL,
    subaccnttype_descrip text
);


ALTER TABLE public.subaccnttype OWNER TO admin;

--
-- TOC entry 10255 (class 0 OID 0)
-- Dependencies: 801
-- Name: TABLE subaccnttype; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE subaccnttype IS 'User defined Sub Account Types.';


--
-- TOC entry 802 (class 1259 OID 146569943)
-- Dependencies: 801 8
-- Name: subaccnttype_subaccnttype_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE subaccnttype_subaccnttype_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.subaccnttype_subaccnttype_id_seq OWNER TO admin;

--
-- TOC entry 10257 (class 0 OID 0)
-- Dependencies: 802
-- Name: subaccnttype_subaccnttype_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE subaccnttype_subaccnttype_id_seq OWNED BY subaccnttype.subaccnttype_id;


--
-- TOC entry 803 (class 1259 OID 146569945)
-- Dependencies: 8
-- Name: tax_tax_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE tax_tax_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.tax_tax_id_seq OWNER TO admin;

--
-- TOC entry 804 (class 1259 OID 146569947)
-- Dependencies: 8
-- Name: taxass; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE taxass (
    taxass_id integer NOT NULL,
    taxass_taxzone_id integer,
    taxass_taxtype_id integer,
    taxass_tax_id integer NOT NULL
);


ALTER TABLE public.taxass OWNER TO admin;


--
-- TOC entry 805 (class 1259 OID 146569950)
-- Dependencies: 804 8
-- Name: taxass_taxass_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE taxass_taxass_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.taxass_taxass_id_seq OWNER TO admin;

--
-- TOC entry 10265 (class 0 OID 0)
-- Dependencies: 805
-- Name: taxass_taxass_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE taxass_taxass_id_seq OWNED BY taxass.taxass_id;


--
-- TOC entry 806 (class 1259 OID 146569952)
-- Dependencies: 284 8
-- Name: taxauth_taxauth_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE taxauth_taxauth_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.taxauth_taxauth_id_seq OWNER TO admin;

--
-- TOC entry 10267 (class 0 OID 0)
-- Dependencies: 806
-- Name: taxauth_taxauth_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE taxauth_taxauth_id_seq OWNED BY taxauth.taxauth_id;


--
-- TOC entry 807 (class 1259 OID 146569954)
-- Dependencies: 6671 8
-- Name: taxclass; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE taxclass (
    taxclass_id integer NOT NULL,
    taxclass_code text NOT NULL,
    taxclass_descrip text,
    taxclass_sequence integer,
    CONSTRAINT taxclass_taxclass_code_check CHECK ((taxclass_code <> ''::text))
);


ALTER TABLE public.taxclass OWNER TO admin;

--
-- TOC entry 10269 (class 0 OID 0)
-- Dependencies: 807
-- Name: TABLE taxclass; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE taxclass IS 'Tax class information';


--
-- TOC entry 10270 (class 0 OID 0)
-- Dependencies: 807
-- Name: COLUMN taxclass.taxclass_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN taxclass.taxclass_id IS 'Primary key';


--
-- TOC entry 10271 (class 0 OID 0)
-- Dependencies: 807
-- Name: COLUMN taxclass.taxclass_code; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN taxclass.taxclass_code IS 'Code';


--
-- TOC entry 10272 (class 0 OID 0)
-- Dependencies: 807
-- Name: COLUMN taxclass.taxclass_descrip; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN taxclass.taxclass_descrip IS 'Description';


--
-- TOC entry 10273 (class 0 OID 0)
-- Dependencies: 807
-- Name: COLUMN taxclass.taxclass_sequence; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN taxclass.taxclass_sequence IS 'Group sequence';


--
-- TOC entry 808 (class 1259 OID 146569961)
-- Dependencies: 807 8
-- Name: taxclass_taxclass_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE taxclass_taxclass_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.taxclass_taxclass_id_seq OWNER TO admin;

--
-- TOC entry 10275 (class 0 OID 0)
-- Dependencies: 808
-- Name: taxclass_taxclass_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE taxclass_taxclass_id_seq OWNED BY taxclass.taxclass_id;


--
-- TOC entry 378 (class 1259 OID 146568112)
-- Dependencies: 377 8
-- Name: taxhist_taxhist_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE taxhist_taxhist_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.taxhist_taxhist_id_seq OWNER TO admin;

--
-- TOC entry 10277 (class 0 OID 0)
-- Dependencies: 378
-- Name: taxhist_taxhist_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE taxhist_taxhist_id_seq OWNED BY taxhist.taxhist_id;


--
-- TOC entry 809 (class 1259 OID 146569963)
-- Dependencies: 8
-- Name: taxrate; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE taxrate (
    taxrate_id integer NOT NULL,
    taxrate_tax_id integer NOT NULL,
    taxrate_percent numeric(10,6) NOT NULL,
    taxrate_curr_id integer,
    taxrate_amount numeric(16,2) NOT NULL,
    taxrate_effective date,
    taxrate_expires date
);


ALTER TABLE public.taxrate OWNER TO admin;

--
-- TOC entry 10279 (class 0 OID 0)
-- Dependencies: 809
-- Name: TABLE taxrate; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE taxrate IS 'Tax rates.';


--
-- TOC entry 10280 (class 0 OID 0)
-- Dependencies: 809
-- Name: COLUMN taxrate.taxrate_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN taxrate.taxrate_id IS 'Primary key.';


--
-- TOC entry 10281 (class 0 OID 0)
-- Dependencies: 809
-- Name: COLUMN taxrate.taxrate_tax_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN taxrate.taxrate_tax_id IS 'The id of the parent tax code.';


--
-- TOC entry 10282 (class 0 OID 0)
-- Dependencies: 809
-- Name: COLUMN taxrate.taxrate_percent; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN taxrate.taxrate_percent IS 'Tax rate percentage.';


--
-- TOC entry 10283 (class 0 OID 0)
-- Dependencies: 809
-- Name: COLUMN taxrate.taxrate_curr_id; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN taxrate.taxrate_curr_id IS 'The currency id of the flat rate amount.';


--
-- TOC entry 10284 (class 0 OID 0)
-- Dependencies: 809
-- Name: COLUMN taxrate.taxrate_amount; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN taxrate.taxrate_amount IS 'Flat tax rate amount.';


--
-- TOC entry 10285 (class 0 OID 0)
-- Dependencies: 809
-- Name: COLUMN taxrate.taxrate_effective; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN taxrate.taxrate_effective IS 'The effective date of the tax rate.  NULL value means always.';


--
-- TOC entry 10286 (class 0 OID 0)
-- Dependencies: 809
-- Name: COLUMN taxrate.taxrate_expires; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN taxrate.taxrate_expires IS 'The expire date of the tax rate.  NULL value means never.';


--
-- TOC entry 810 (class 1259 OID 146569966)
-- Dependencies: 809 8
-- Name: taxrate_taxrate_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE taxrate_taxrate_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.taxrate_taxrate_id_seq OWNER TO admin;

--
-- TOC entry 10288 (class 0 OID 0)
-- Dependencies: 810
-- Name: taxrate_taxrate_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE taxrate_taxrate_id_seq OWNED BY taxrate.taxrate_id;


--
-- TOC entry 811 (class 1259 OID 146569968)
-- Dependencies: 285 8
-- Name: taxreg_taxreg_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE taxreg_taxreg_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.taxreg_taxreg_id_seq OWNER TO admin;

--
-- TOC entry 10290 (class 0 OID 0)
-- Dependencies: 811
-- Name: taxreg_taxreg_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE taxreg_taxreg_id_seq OWNED BY taxreg.taxreg_id;


--
-- TOC entry 812 (class 1259 OID 146569970)
-- Dependencies: 199 8
-- Name: taxtype_taxtype_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE taxtype_taxtype_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.taxtype_taxtype_id_seq OWNER TO admin;

--
-- TOC entry 10292 (class 0 OID 0)
-- Dependencies: 812
-- Name: taxtype_taxtype_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE taxtype_taxtype_id_seq OWNED BY taxtype.taxtype_id;


--
-- TOC entry 813 (class 1259 OID 146569972)
-- Dependencies: 220 8
-- Name: taxzone_taxzone_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE taxzone_taxzone_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.taxzone_taxzone_id_seq OWNER TO admin;

--
-- TOC entry 10294 (class 0 OID 0)
-- Dependencies: 813
-- Name: taxzone_taxzone_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE taxzone_taxzone_id_seq OWNED BY taxzone.taxzone_id;


--
-- TOC entry 814 (class 1259 OID 146569974)
-- Dependencies: 8
-- Name: terms_terms_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE terms_terms_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.terms_terms_id_seq OWNER TO admin;

--
-- TOC entry 815 (class 1259 OID 146569976)
-- Dependencies: 233 8
-- Name: todoitem_todoitem_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE todoitem_todoitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.todoitem_todoitem_id_seq OWNER TO admin;

--
-- TOC entry 10297 (class 0 OID 0)
-- Dependencies: 815
-- Name: todoitem_todoitem_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE todoitem_todoitem_id_seq OWNED BY todoitem.todoitem_id;


--
-- TOC entry 816 (class 1259 OID 146569978)
-- Dependencies: 8
-- Name: trgthist; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE trgthist (
    trgthist_src_cntct_id integer NOT NULL,
    trgthist_trgt_cntct_id integer NOT NULL,
    trgthist_col text NOT NULL,
    trgthist_value text NOT NULL
);


ALTER TABLE public.trgthist OWNER TO admin;

--
-- TOC entry 817 (class 1259 OID 146569984)
-- Dependencies: 6674 8
-- Name: trialbal; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE trialbal (
    trialbal_id integer NOT NULL,
    trialbal_period_id integer,
    trialbal_accnt_id integer,
    trialbal_beginning numeric(20,2),
    trialbal_ending numeric(20,2),
    trialbal_credits numeric(20,2),
    trialbal_debits numeric(20,2),
    trialbal_dirty boolean,
    trialbal_yearend numeric(20,2) DEFAULT 0.00 NOT NULL
);


ALTER TABLE public.trialbal OWNER TO admin;

--
-- TOC entry 10300 (class 0 OID 0)
-- Dependencies: 817
-- Name: TABLE trialbal; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE trialbal IS 'Trial Balance information';


--
-- TOC entry 818 (class 1259 OID 146569988)
-- Dependencies: 817 8
-- Name: trialbal_trialbal_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE trialbal_trialbal_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.trialbal_trialbal_id_seq OWNER TO admin;

--
-- TOC entry 10302 (class 0 OID 0)
-- Dependencies: 818
-- Name: trialbal_trialbal_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE trialbal_trialbal_id_seq OWNED BY trialbal.trialbal_id;


--
-- TOC entry 819 (class 1259 OID 146569990)
-- Dependencies: 200 8
-- Name: uom_uom_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE uom_uom_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.uom_uom_id_seq OWNER TO admin;

--
-- TOC entry 10304 (class 0 OID 0)
-- Dependencies: 819
-- Name: uom_uom_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE uom_uom_id_seq OWNED BY uom.uom_id;


--
-- TOC entry 820 (class 1259 OID 146569992)
-- Dependencies: 6676 8
-- Name: uomconv; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE uomconv (
    uomconv_id integer NOT NULL,
    uomconv_from_uom_id integer NOT NULL,
    uomconv_from_value numeric(20,10) NOT NULL,
    uomconv_to_uom_id integer NOT NULL,
    uomconv_to_value numeric(20,10) NOT NULL,
    uomconv_fractional boolean DEFAULT false NOT NULL
);


ALTER TABLE public.uomconv OWNER TO admin;

--
-- TOC entry 10306 (class 0 OID 0)
-- Dependencies: 820
-- Name: TABLE uomconv; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE uomconv IS 'UOM conversion information. From Unit to To Unit with a value per ratio.';


--
-- TOC entry 821 (class 1259 OID 146569996)
-- Dependencies: 820 8
-- Name: uomconv_uomconv_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE uomconv_uomconv_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.uomconv_uomconv_id_seq OWNER TO admin;

--
-- TOC entry 10308 (class 0 OID 0)
-- Dependencies: 821
-- Name: uomconv_uomconv_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE uomconv_uomconv_id_seq OWNED BY uomconv.uomconv_id;


--
-- TOC entry 822 (class 1259 OID 146569998)
-- Dependencies: 6678 6679 8
-- Name: uomtype; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE uomtype (
    uomtype_id integer NOT NULL,
    uomtype_name text NOT NULL,
    uomtype_descrip text,
    uomtype_multiple boolean DEFAULT false NOT NULL,
    CONSTRAINT uomtype_uomtype_name_check CHECK ((uomtype_name <> ''::text))
);


ALTER TABLE public.uomtype OWNER TO admin;

--
-- TOC entry 10310 (class 0 OID 0)
-- Dependencies: 822
-- Name: TABLE uomtype; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE uomtype IS 'UOM Type values.';


--
-- TOC entry 823 (class 1259 OID 146570006)
-- Dependencies: 822 8
-- Name: uomtype_uomtype_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE uomtype_uomtype_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.uomtype_uomtype_id_seq OWNER TO admin;

--
-- TOC entry 10312 (class 0 OID 0)
-- Dependencies: 823
-- Name: uomtype_uomtype_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE uomtype_uomtype_id_seq OWNED BY uomtype.uomtype_id;


--
-- TOC entry 824 (class 1259 OID 146570008)
-- Dependencies: 244 8
-- Name: urlinfo_url_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE urlinfo_url_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.urlinfo_url_id_seq OWNER TO admin;

--
-- TOC entry 10314 (class 0 OID 0)
-- Dependencies: 824
-- Name: urlinfo_url_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE urlinfo_url_id_seq OWNED BY urlinfo.url_id;


--
-- TOC entry 825 (class 1259 OID 146570010)
-- Dependencies: 6680 8
-- Name: usrpref; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE usrpref (
    usrpref_id integer DEFAULT nextval(('usrpref_usrpref_id_seq'::text)::regclass) NOT NULL,
    usrpref_name text,
    usrpref_value text,
    usrpref_username text
);


ALTER TABLE public.usrpref OWNER TO admin;

--
-- TOC entry 10316 (class 0 OID 0)
-- Dependencies: 825
-- Name: TABLE usrpref; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE usrpref IS 'User Preferences information';


--
-- TOC entry 826 (class 1259 OID 146570017)
-- Dependencies: 8593 8
-- Name: usr; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW usr AS
    SELECT (pg_user.usesysid)::integer AS usr_id, (pg_user.usename)::text AS usr_username, COALESCE((SELECT usrpref.usrpref_value FROM usrpref WHERE ((usrpref.usrpref_username = (pg_user.usename)::text) AND (usrpref.usrpref_name = 'propername'::text))), ''::text) AS usr_propername, NULL::text AS usr_passwd, COALESCE((SELECT (usrpref.usrpref_value)::integer AS usrpref_value FROM usrpref WHERE ((usrpref.usrpref_username = (pg_user.usename)::text) AND (usrpref.usrpref_name = 'locale_id'::text))), COALESCE((SELECT locale.locale_id FROM locale WHERE (lower(locale.locale_code) = 'default'::text) LIMIT 1), (SELECT locale.locale_id FROM locale ORDER BY locale.locale_id LIMIT 1))) AS usr_locale_id, COALESCE((SELECT usrpref.usrpref_value FROM usrpref WHERE ((usrpref.usrpref_username = (pg_user.usename)::text) AND (usrpref.usrpref_name = 'initials'::text))), ''::text) AS usr_initials, COALESCE((SELECT CASE WHEN (usrpref.usrpref_value = 't'::text) THEN true ELSE false END AS "case" FROM usrpref WHERE ((usrpref.usrpref_username = (pg_user.usename)::text) AND (usrpref.usrpref_name = 'agent'::text))), false) AS usr_agent, COALESCE((SELECT CASE WHEN (usrpref.usrpref_value = 't'::text) THEN true ELSE false END AS "case" FROM usrpref WHERE ((usrpref.usrpref_username = (pg_user.usename)::text) AND (usrpref.usrpref_name = 'active'::text))), usercanlogin((pg_user.usename)::text)) AS usr_active, COALESCE((SELECT usrpref.usrpref_value FROM usrpref WHERE ((usrpref.usrpref_username = (pg_user.usename)::text) AND (usrpref.usrpref_name = 'email'::text))), ''::text) AS usr_email, COALESCE((SELECT usrpref.usrpref_value FROM usrpref WHERE ((usrpref.usrpref_username = (pg_user.usename)::text) AND (usrpref.usrpref_name = 'window'::text))), ''::text) AS usr_window FROM pg_user;


ALTER TABLE public.usr OWNER TO admin;

--
-- TOC entry 827 (class 1259 OID 146570022)
-- Dependencies: 6681 8
-- Name: usr_bak; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE usr_bak (
    usr_id integer DEFAULT nextval(('usr_usr_id_seq'::text)::regclass) NOT NULL,
    usr_username text NOT NULL,
    usr_propername text,
    usr_passwd text,
    usr_locale_id integer NOT NULL,
    usr_initials text,
    usr_agent boolean NOT NULL,
    usr_active boolean NOT NULL,
    usr_email text,
    usr_window text
);


ALTER TABLE public.usr_bak OWNER TO admin;

--
-- TOC entry 10319 (class 0 OID 0)
-- Dependencies: 827
-- Name: TABLE usr_bak; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE usr_bak IS 'User information';


--
-- TOC entry 828 (class 1259 OID 146570029)
-- Dependencies: 8
-- Name: usr_usr_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE usr_usr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.usr_usr_id_seq OWNER TO admin;

--
-- TOC entry 829 (class 1259 OID 146570031)
-- Dependencies: 732 8
-- Name: usrgrp_usrgrp_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE usrgrp_usrgrp_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.usrgrp_usrgrp_id_seq OWNER TO admin;

--
-- TOC entry 10322 (class 0 OID 0)
-- Dependencies: 829
-- Name: usrgrp_usrgrp_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE usrgrp_usrgrp_id_seq OWNED BY usrgrp.usrgrp_id;


--
-- TOC entry 830 (class 1259 OID 146570033)
-- Dependencies: 8
-- Name: usrpref_usrpref_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE usrpref_usrpref_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.usrpref_usrpref_id_seq OWNER TO admin;

--
-- TOC entry 831 (class 1259 OID 146570035)
-- Dependencies: 8
-- Name: usrpriv_usrpriv_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE usrpriv_usrpriv_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.usrpriv_usrpriv_id_seq OWNER TO admin;

--
-- TOC entry 832 (class 1259 OID 146570037)
-- Dependencies: 8594 8
-- Name: vend; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW vend AS
    SELECT vendinfo.vend_id, vendinfo.vend_name, m.addr_line1 AS vend_address1, m.addr_line2 AS vend_address2, m.addr_line3 AS vend_address3, m.addr_city AS vend_city, m.addr_state AS vend_state, m.addr_postalcode AS vend_zip, btrim(((c1.cntct_first_name || ' '::text) || c1.cntct_last_name)) AS vend_contact1, c1.cntct_phone AS vend_phone1, btrim(((c2.cntct_first_name || ' '::text) || c2.cntct_last_name)) AS vend_contact2, c2.cntct_phone AS vend_phone2, vendinfo.vend_lastpurchdate, vendinfo.vend_active, vendinfo.vend_po, vendinfo.vend_comments, vendinfo.vend_pocomments, vendinfo.vend_number, c1.cntct_fax AS vend_fax1, c2.cntct_fax AS vend_fax2, c1.cntct_email AS vend_email1, c2.cntct_email AS vend_email2, vendinfo.vend_1099, vendinfo.vend_exported, vendinfo.vend_fobsource, vendinfo.vend_fob, vendinfo.vend_terms_id, vendinfo.vend_shipvia, vendinfo.vend_vendtype_id, vendinfo.vend_qualified, vendinfo.vend_ediemail, vendinfo.vend_ediemailbody, vendinfo.vend_edisubject, vendinfo.vend_edifilename, vendinfo.vend_accntnum, vendinfo.vend_emailpodelivery, vendinfo.vend_restrictpurch, vendinfo.vend_edicc, m.addr_country AS vend_country, vendinfo.vend_curr_id, vendinfo.vend_taxzone_id FROM (((vendinfo LEFT JOIN cntct c1 ON ((vendinfo.vend_cntct1_id = c1.cntct_id))) LEFT JOIN addr m ON ((vendinfo.vend_addr_id = m.addr_id))) LEFT JOIN cntct c2 ON ((vendinfo.vend_cntct2_id = c2.cntct_id)));


ALTER TABLE public.vend OWNER TO admin;

--
-- TOC entry 833 (class 1259 OID 146570042)
-- Dependencies: 8
-- Name: vend_vend_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE vend_vend_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.vend_vend_id_seq OWNER TO admin;

--
-- TOC entry 834 (class 1259 OID 146570044)
-- Dependencies: 8595 8
-- Name: vendaddr; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW vendaddr AS
    SELECT vendaddrinfo.vendaddr_id, vendaddrinfo.vendaddr_vend_id, vendaddrinfo.vendaddr_code, vendaddrinfo.vendaddr_name, m.addr_line1 AS vendaddr_address1, m.addr_line2 AS vendaddr_address2, m.addr_line3 AS vendaddr_address3, btrim(((c1.cntct_first_name || ' '::text) || c1.cntct_last_name)) AS vendaddr_contact1, c1.cntct_phone AS vendaddr_phone1, c1.cntct_fax AS vendaddr_fax1, m.addr_city AS vendaddr_city, m.addr_state AS vendaddr_state, m.addr_postalcode AS vendaddr_zipcode, m.addr_country AS vendaddr_country FROM ((vendaddrinfo LEFT JOIN cntct c1 ON ((vendaddrinfo.vendaddr_cntct_id = c1.cntct_id))) LEFT JOIN addr m ON ((vendaddrinfo.vendaddr_addr_id = m.addr_id)));


ALTER TABLE public.vendaddr OWNER TO admin;

--
-- TOC entry 835 (class 1259 OID 146570049)
-- Dependencies: 8
-- Name: vendaddr_vendaddr_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE vendaddr_vendaddr_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.vendaddr_vendaddr_id_seq OWNER TO admin;

--
-- TOC entry 836 (class 1259 OID 146570051)
-- Dependencies: 393 8
-- Name: vendtype_vendtype_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE vendtype_vendtype_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.vendtype_vendtype_id_seq OWNER TO admin;

--
-- TOC entry 10330 (class 0 OID 0)
-- Dependencies: 836
-- Name: vendtype_vendtype_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE vendtype_vendtype_id_seq OWNED BY vendtype.vendtype_id;


--
-- TOC entry 837 (class 1259 OID 146570053)
-- Dependencies: 6682 6683 6684 6685 8
-- Name: vodist; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE vodist (
    vodist_id integer DEFAULT nextval(('"vodist_vodist_id_seq"'::text)::regclass) NOT NULL,
    vodist_poitem_id integer,
    vodist_vohead_id integer,
    vodist_costelem_id integer,
    vodist_accnt_id integer,
    vodist_amount numeric(18,6),
    vodist_qty numeric(18,6),
    vodist_expcat_id integer DEFAULT (-1),
    vodist_tax_id integer DEFAULT (-1),
    vodist_discountable boolean DEFAULT true NOT NULL,
    vodist_notes text
);


ALTER TABLE public.vodist OWNER TO admin;


--
-- TOC entry 838 (class 1259 OID 146570063)
-- Dependencies: 8
-- Name: vodist_vodist_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE vodist_vodist_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.vodist_vodist_id_seq OWNER TO admin;

--
-- TOC entry 839 (class 1259 OID 146570065)
-- Dependencies: 6686 6687 6688 8
-- Name: vohead; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE vohead (
    vohead_id integer DEFAULT nextval(('vohead_vohead_id_seq'::text)::regclass) NOT NULL,
    vohead_number text NOT NULL,
    vohead_pohead_id integer,
    vohead_posted boolean,
    vohead_duedate date,
    vohead_invcnumber text,
    vohead_amount numeric(16,4),
    vohead_docdate date,
    vohead_1099 boolean,
    vohead_distdate date,
    vohead_reference text,
    vohead_terms_id integer,
    vohead_vend_id integer,
    vohead_curr_id integer DEFAULT basecurrid(),
    vohead_adjtaxtype_id integer,
    vohead_freighttaxtype_id integer,
    vohead_gldistdate date,
    vohead_misc boolean,
    vohead_taxzone_id integer,
    vohead_taxtype_id integer,
    vohead_notes text,
    vohead_recurring_vohead_id integer,
    CONSTRAINT vohead_vohead_number_check CHECK ((vohead_number <> ''::text))
);


ALTER TABLE public.vohead OWNER TO admin;


--
-- TOC entry 840 (class 1259 OID 146570074)
-- Dependencies: 8
-- Name: vohead_vohead_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE vohead_vohead_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.vohead_vohead_id_seq OWNER TO admin;

--
-- TOC entry 841 (class 1259 OID 146570076)
-- Dependencies: 377 8
-- Name: voheadtax; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE voheadtax (
)
INHERITS (taxhist);


ALTER TABLE public.voheadtax OWNER TO admin;

--
-- TOC entry 842 (class 1259 OID 146570082)
-- Dependencies: 6690 6691 8
-- Name: voitem; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE voitem (
    voitem_id integer DEFAULT nextval(('"voitem_voitem_id_seq"'::text)::regclass) NOT NULL,
    voitem_vohead_id integer,
    voitem_poitem_id integer,
    voitem_close boolean,
    voitem_qty numeric(18,6),
    voitem_freight numeric(16,4) DEFAULT 0.0 NOT NULL,
    voitem_taxtype_id integer
);


ALTER TABLE public.voitem OWNER TO admin;

--
-- TOC entry 10339 (class 0 OID 0)
-- Dependencies: 842
-- Name: TABLE voitem; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE voitem IS 'Voucher Line Item information';


--
-- TOC entry 843 (class 1259 OID 146570087)
-- Dependencies: 8
-- Name: voitem_voitem_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE voitem_voitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.voitem_voitem_id_seq OWNER TO admin;

--
-- TOC entry 844 (class 1259 OID 146570089)
-- Dependencies: 377 8
-- Name: voitemtax; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE voitemtax (
)
INHERITS (taxhist);


ALTER TABLE public.voitemtax OWNER TO admin;

--
-- TOC entry 845 (class 1259 OID 146570095)
-- Dependencies: 8596 8
-- Name: warehous; Type: VIEW; Schema: public; Owner: admin
--

CREATE VIEW warehous AS
    SELECT whsinfo.warehous_id, whsinfo.warehous_code, whsinfo.warehous_descrip, m.addr_line1 AS warehous_addr1, m.addr_line2 AS warehous_addr2, m.addr_line3 AS warehous_addr3, m.addr_city AS warehous_addr4, m.addr_city AS warehous_city, m.addr_state AS warehous_state, m.addr_postalcode AS warehous_zip, m.addr_country AS warehous_country, whsinfo.warehous_fob, whsinfo.warehous_active, whsinfo.warehous_sitetype_id, whsinfo.warehous_counttag_prefix, whsinfo.warehous_counttag_number, whsinfo.warehous_bol_prefix, whsinfo.warehous_bol_number, whsinfo.warehous_shipping, whsinfo.warehous_useslips, whsinfo.warehous_usezones, whsinfo.warehous_aislesize, whsinfo.warehous_aislealpha, whsinfo.warehous_racksize, whsinfo.warehous_rackalpha, whsinfo.warehous_binsize, whsinfo.warehous_binalpha, whsinfo.warehous_locationsize, whsinfo.warehous_locationalpha, whsinfo.warehous_enforcearbl, whsinfo.warehous_default_accnt_id, whsinfo.warehous_shipping_commission FROM ((whsinfo LEFT JOIN cntct c1 ON ((whsinfo.warehous_cntct_id = c1.cntct_id))) LEFT JOIN addr m ON ((whsinfo.warehous_addr_id = m.addr_id)));


ALTER TABLE public.warehous OWNER TO admin;

--
-- TOC entry 846 (class 1259 OID 146570100)
-- Dependencies: 8
-- Name: warehous_warehous_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE warehous_warehous_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.warehous_warehous_id_seq OWNER TO admin;

--
-- TOC entry 847 (class 1259 OID 146570102)
-- Dependencies: 343 8
-- Name: whsezone_whsezone_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE whsezone_whsezone_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.whsezone_whsezone_id_seq OWNER TO admin;

--
-- TOC entry 10345 (class 0 OID 0)
-- Dependencies: 847
-- Name: whsezone_whsezone_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE whsezone_whsezone_id_seq OWNED BY whsezone.whsezone_id;


--
-- TOC entry 848 (class 1259 OID 146570104)
-- Dependencies: 8
-- Name: wo_wo_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE wo_wo_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.wo_wo_id_seq OWNER TO admin;

--
-- TOC entry 849 (class 1259 OID 146570106)
-- Dependencies: 8
-- Name: womatl_womatl_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE womatl_womatl_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.womatl_womatl_id_seq OWNER TO admin;

--
-- TOC entry 850 (class 1259 OID 146570108)
-- Dependencies: 8
-- Name: womatlpost; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE womatlpost (
    womatlpost_id integer NOT NULL,
    womatlpost_womatl_id integer,
    womatlpost_invhist_id integer
);


ALTER TABLE public.womatlpost OWNER TO admin;

--
-- TOC entry 10349 (class 0 OID 0)
-- Dependencies: 850
-- Name: TABLE womatlpost; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE womatlpost IS 'Table to tie work order to work order material transactions for efficient queries';


--
-- TOC entry 851 (class 1259 OID 146570111)
-- Dependencies: 850 8
-- Name: womatlpost_womatlpost_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE womatlpost_womatlpost_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.womatlpost_womatlpost_id_seq OWNER TO admin;

--
-- TOC entry 10351 (class 0 OID 0)
-- Dependencies: 851
-- Name: womatlpost_womatlpost_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE womatlpost_womatlpost_id_seq OWNED BY womatlpost.womatlpost_id;


--
-- TOC entry 852 (class 1259 OID 146570113)
-- Dependencies: 6694 6695 8
-- Name: womatlvar; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE womatlvar (
    womatlvar_id integer DEFAULT nextval(('"womatlvar_womatlvar_id_seq"'::text)::regclass) NOT NULL,
    womatlvar_number integer,
    womatlvar_subnumber integer,
    womatlvar_posted date,
    womatlvar_parent_itemsite_id integer,
    womatlvar_component_itemsite_id integer,
    womatlvar_qtyord numeric(18,6),
    womatlvar_qtyrcv numeric(18,6),
    womatlvar_qtyiss numeric(18,6),
    womatlvar_qtyper numeric(18,6),
    womatlvar_scrap numeric(18,6),
    womatlvar_wipscrap numeric(18,6),
    womatlvar_bomitem_id integer,
    womatlvar_ref text,
    womatlvar_notes text,
    womatlvar_qtyfxd numeric(20,8) DEFAULT 0 NOT NULL
);


ALTER TABLE public.womatlvar OWNER TO admin;

--
-- TOC entry 10353 (class 0 OID 0)
-- Dependencies: 852
-- Name: TABLE womatlvar; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE womatlvar IS 'Work Order Material Requirements Variance information';


--
-- TOC entry 10354 (class 0 OID 0)
-- Dependencies: 852
-- Name: COLUMN womatlvar.womatlvar_qtyfxd; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON COLUMN womatlvar.womatlvar_qtyfxd IS 'The fixed quantity required';


--
-- TOC entry 853 (class 1259 OID 146570121)
-- Dependencies: 8
-- Name: womatlvar_womatlvar_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE womatlvar_womatlvar_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE public.womatlvar_womatlvar_id_seq OWNER TO admin;

--
-- TOC entry 854 (class 1259 OID 146570123)
-- Dependencies: 8
-- Name: xcalitem_xcalitem_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE xcalitem_xcalitem_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.xcalitem_xcalitem_id_seq OWNER TO admin;

--
-- TOC entry 855 (class 1259 OID 146570125)
-- Dependencies: 6697 6698 6699 6700 8
-- Name: xsltmap; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE xsltmap (
    xsltmap_id integer NOT NULL,
    xsltmap_name text NOT NULL,
    xsltmap_doctype text NOT NULL,
    xsltmap_system text NOT NULL,
    xsltmap_import text NOT NULL,
    xsltmap_export text DEFAULT ''::text NOT NULL,
    CONSTRAINT xsltmap_check CHECK (((xsltmap_doctype <> ''::text) OR (xsltmap_system <> ''::text))),
    CONSTRAINT xsltmap_xsltmap_importexport_check CHECK (((xsltmap_import <> ''::text) OR (xsltmap_export <> ''::text))),
    CONSTRAINT xsltmap_xsltmap_name_check CHECK ((xsltmap_name <> ''::text))
);


ALTER TABLE public.xsltmap OWNER TO admin;

--
-- TOC entry 10358 (class 0 OID 0)
-- Dependencies: 855
-- Name: TABLE xsltmap; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE xsltmap IS 'Mapping of XML System identifiers to XSLT transformation files';


--
-- TOC entry 856 (class 1259 OID 146570135)
-- Dependencies: 855 8
-- Name: xsltmap_xsltmap_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE xsltmap_xsltmap_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.xsltmap_xsltmap_id_seq OWNER TO admin;

--
-- TOC entry 10360 (class 0 OID 0)
-- Dependencies: 856
-- Name: xsltmap_xsltmap_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE xsltmap_xsltmap_id_seq OWNED BY xsltmap.xsltmap_id;


--
-- TOC entry 857 (class 1259 OID 146570137)
-- Dependencies: 6702 8
-- Name: yearperiod; Type: TABLE; Schema: public; Owner: admin; Tablespace:
--

CREATE TABLE yearperiod (
    yearperiod_id integer NOT NULL,
    yearperiod_start date NOT NULL,
    yearperiod_end date NOT NULL,
    yearperiod_closed boolean DEFAULT false NOT NULL
);


ALTER TABLE public.yearperiod OWNER TO admin;

--
-- TOC entry 10362 (class 0 OID 0)
-- Dependencies: 857
-- Name: TABLE yearperiod; Type: COMMENT; Schema: public; Owner: admin
--

COMMENT ON TABLE yearperiod IS 'Accounting Year Periods information';


--
-- TOC entry 858 (class 1259 OID 146570141)
-- Dependencies: 857 8
-- Name: yearperiod_yearperiod_id_seq; Type: SEQUENCE; Schema: public; Owner: admin
--

CREATE SEQUENCE yearperiod_yearperiod_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;


ALTER TABLE public.yearperiod_yearperiod_id_seq OWNER TO admin;

--
-- TOC entry 10364 (class 0 OID 0)
-- Dependencies: 858
-- Name: yearperiod_yearperiod_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: admin
--

ALTER SEQUENCE yearperiod_yearperiod_id_seq OWNED BY yearperiod.yearperiod_id;


SET search_path = public, pg_catalog;

--
-- TOC entry 6055 (class 2604 OID 146570320)
-- Dependencies: 422 234
-- Name: addr_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY addr ALTER COLUMN addr_id SET DEFAULT nextval('addr_addr_id_seq'::regclass);


--
-- TOC entry 6290 (class 2604 OID 146570321)
-- Dependencies: 425 424
-- Name: alarm_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY alarm ALTER COLUMN alarm_id SET DEFAULT nextval('alarm_alarm_id_seq'::regclass);


--
-- TOC entry 6291 (class 2604 OID 146570322)
-- Dependencies: 427 426
-- Name: apaccnt_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY apaccnt ALTER COLUMN apaccnt_id SET DEFAULT nextval('apaccnt_apaccnt_id_seq'::regclass);


--
-- TOC entry 6292 (class 2604 OID 146570323)
-- Dependencies: 429 428
-- Name: apapply_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY apapply ALTER COLUMN apapply_id SET DEFAULT nextval('apapply_apapply_id_seq'::regclass);


--
-- TOC entry 6310 (class 2604 OID 146570324)
-- Dependencies: 435 434
-- Name: apcreditapply_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY apcreditapply ALTER COLUMN apcreditapply_id SET DEFAULT nextval('apcreditapply_apcreditapply_id_seq'::regclass);


--
-- TOC entry 6312 (class 2604 OID 146570448)
-- Dependencies: 438 378 438
-- Name: taxhist_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY apopentax ALTER COLUMN taxhist_id SET DEFAULT nextval('taxhist_taxhist_id_seq'::regclass);


--
-- TOC entry 6313 (class 2604 OID 146570325)
-- Dependencies: 440 439
-- Name: apselect_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY apselect ALTER COLUMN apselect_id SET DEFAULT nextval('apselect_apselect_id_seq'::regclass);


--
-- TOC entry 6317 (class 2604 OID 146570326)
-- Dependencies: 444 443
-- Name: arapply_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY arapply ALTER COLUMN arapply_id SET DEFAULT nextval('arapply_arapply_id_seq'::regclass);


--
-- TOC entry 6321 (class 2604 OID 146570449)
-- Dependencies: 450 378 450
-- Name: taxhist_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY aropentax ALTER COLUMN taxhist_id SET DEFAULT nextval('taxhist_taxhist_id_seq'::regclass);


--
-- TOC entry 6322 (class 2604 OID 146570327)
-- Dependencies: 452 451
-- Name: asohist_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY asohist ALTER COLUMN asohist_id SET DEFAULT nextval('asohist_asohist_id_seq'::regclass);


--
-- TOC entry 6324 (class 2604 OID 146570450)
-- Dependencies: 453 378 453
-- Name: taxhist_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY asohisttax ALTER COLUMN taxhist_id SET DEFAULT nextval('taxhist_taxhist_id_seq'::regclass);


--
-- TOC entry 6325 (class 2604 OID 146570328)
-- Dependencies: 455 454
-- Name: atlasmap_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY atlasmap ALTER COLUMN atlasmap_id SET DEFAULT nextval('atlasmap_atlasmap_id_seq'::regclass);


--
-- TOC entry 6107 (class 2604 OID 146570329)
-- Dependencies: 457 266
-- Name: bankaccnt_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY bankaccnt ALTER COLUMN bankaccnt_id SET DEFAULT nextval('bankaccnt_bankaccnt_id_seq'::regclass);


--
-- TOC entry 6332 (class 2604 OID 146570330)
-- Dependencies: 459 458
-- Name: bankadj_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY bankadj ALTER COLUMN bankadj_id SET DEFAULT nextval('bankadj_bankadj_id_seq'::regclass);


--
-- TOC entry 6333 (class 2604 OID 146570331)
-- Dependencies: 461 460
-- Name: bankadjtype_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY bankadjtype ALTER COLUMN bankadjtype_id SET DEFAULT nextval('bankadjtype_bankadjtype_id_seq'::regclass);


--
-- TOC entry 6339 (class 2604 OID 146570332)
-- Dependencies: 463 462
-- Name: bankrec_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY bankrec ALTER COLUMN bankrec_id SET DEFAULT nextval('bankrec_bankrec_id_seq'::regclass);


--
-- TOC entry 6340 (class 2604 OID 146570333)
-- Dependencies: 465 464
-- Name: bankrecitem_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY bankrecitem ALTER COLUMN bankrecitem_id SET DEFAULT nextval('bankrecitem_bankrecitem_id_seq'::regclass);


--
-- TOC entry 6346 (class 2604 OID 146570334)
-- Dependencies: 469 468
-- Name: bomitemcost_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY bomitemcost ALTER COLUMN bomitemcost_id SET DEFAULT nextval('bomitemcost_bomitemcost_id_seq'::regclass);


--
-- TOC entry 6092 (class 2604 OID 146570335)
-- Dependencies: 470 258
-- Name: bomitemsub_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY bomitemsub ALTER COLUMN bomitemsub_id SET DEFAULT nextval('bomitemsub_bomitemsub_id_seq'::regclass);


--
-- TOC entry 6347 (class 2604 OID 146570336)
-- Dependencies: 472 471
-- Name: bomwork_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY bomwork ALTER COLUMN bomwork_id SET DEFAULT nextval('bomwork_bomwork_id_seq'::regclass);


--
-- TOC entry 6093 (class 2604 OID 146570337)
-- Dependencies: 474 260
-- Name: budghead_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY budghead ALTER COLUMN budghead_id SET DEFAULT nextval('budghead_budghead_id_seq'::regclass);


--
-- TOC entry 6099 (class 2604 OID 146570338)
-- Dependencies: 475 263
-- Name: budgitem_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY budgitem ALTER COLUMN budgitem_id SET DEFAULT nextval('budgitem_budgitem_id_seq'::regclass);


--
-- TOC entry 6116 (class 2604 OID 146570339)
-- Dependencies: 479 267
-- Name: cashrcpt_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cashrcpt ALTER COLUMN cashrcpt_id SET DEFAULT nextval('cashrcpt_cashrcpt_id_seq'::regclass);


--
-- TOC entry 6118 (class 2604 OID 146570340)
-- Dependencies: 445 269
-- Name: cashrcptitem_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cashrcptitem ALTER COLUMN cashrcptitem_id SET DEFAULT nextval('cashrcptitem_cashrcptitem_id_seq'::regclass);


--
-- TOC entry 6121 (class 2604 OID 146570341)
-- Dependencies: 480 271
-- Name: cashrcptmisc_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cashrcptmisc ALTER COLUMN cashrcptmisc_id SET DEFAULT nextval('cashrcptmisc_cashrcptmisc_id_seq'::regclass);


--
-- TOC entry 6129 (class 2604 OID 146570342)
-- Dependencies: 481 278
-- Name: ccard_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY ccard ALTER COLUMN ccard_id SET DEFAULT nextval('ccard_ccard_id_seq'::regclass);


--
-- TOC entry 6352 (class 2604 OID 146570343)
-- Dependencies: 483 482
-- Name: ccardaud_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY ccardaud ALTER COLUMN ccardaud_id SET DEFAULT nextval('ccardaud_ccardaud_id_seq'::regclass);


--
-- TOC entry 6355 (class 2604 OID 146570344)
-- Dependencies: 485 484
-- Name: ccbank_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY ccbank ALTER COLUMN ccbank_id SET DEFAULT nextval('ccbank_ccbank_id_seq'::regclass);


--
-- TOC entry 6362 (class 2604 OID 146570345)
-- Dependencies: 487 486
-- Name: ccpay_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY ccpay ALTER COLUMN ccpay_id SET DEFAULT nextval('ccpay_ccpay_id_seq'::regclass);


--
-- TOC entry 6070 (class 2604 OID 146570346)
-- Dependencies: 488 236
-- Name: char_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY "char" ALTER COLUMN char_id SET DEFAULT nextval('char_char_id_seq'::regclass);


--
-- TOC entry 6072 (class 2604 OID 146570347)
-- Dependencies: 489 237
-- Name: charass_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY charass ALTER COLUMN charass_id SET DEFAULT nextval('charass_charass_id_seq'::regclass);


--
-- TOC entry 6363 (class 2604 OID 146570348)
-- Dependencies: 491 490
-- Name: charopt_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY charopt ALTER COLUMN charopt_id SET DEFAULT nextval('charopt_charopt_id_seq'::regclass);


--
-- TOC entry 6302 (class 2604 OID 146570349)
-- Dependencies: 492 430
-- Name: checkhead_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY checkhead ALTER COLUMN checkhead_id SET DEFAULT nextval('checkhead_checkhead_id_seq'::regclass);


--
-- TOC entry 6308 (class 2604 OID 146570350)
-- Dependencies: 493 432
-- Name: checkitem_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY checkitem ALTER COLUMN checkitem_id SET DEFAULT nextval('checkitem_checkitem_id_seq'::regclass);


--
-- TOC entry 6265 (class 2604 OID 146568218)
-- Dependencies: 398 397
-- Name: cmd_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cmd ALTER COLUMN cmd_id SET DEFAULT nextval('cmd_cmd_id_seq'::regclass);


--
-- TOC entry 6267 (class 2604 OID 146568234)
-- Dependencies: 401 400
-- Name: cmdarg_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cmdarg ALTER COLUMN cmdarg_id SET DEFAULT nextval('cmdarg_cmdarg_id_seq'::regclass);


--
-- TOC entry 6365 (class 2604 OID 146570451)
-- Dependencies: 497 378 497
-- Name: taxhist_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cmheadtax ALTER COLUMN taxhist_id SET DEFAULT nextval('taxhist_taxhist_id_seq'::regclass);


--
-- TOC entry 6366 (class 2604 OID 146570452)
-- Dependencies: 499 378 499
-- Name: taxhist_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cmitemtax ALTER COLUMN taxhist_id SET DEFAULT nextval('taxhist_taxhist_id_seq'::regclass);


--
-- TOC entry 6075 (class 2604 OID 146570351)
-- Dependencies: 500 239
-- Name: cmnttype_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cmnttype ALTER COLUMN cmnttype_id SET DEFAULT nextval('cmnttype_cmnttype_id_seq'::regclass);


--
-- TOC entry 6367 (class 2604 OID 146570352)
-- Dependencies: 502 501
-- Name: cmnttypesource_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cmnttypesource ALTER COLUMN cmnttypesource_id SET DEFAULT nextval('cmnttypesource_cmnttypesource_id_seq'::regclass);


--
-- TOC entry 5944 (class 2604 OID 146570353)
-- Dependencies: 503 204
-- Name: cntct_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cntct ALTER COLUMN cntct_id SET DEFAULT nextval('cntct_cntct_id_seq'::regclass);


--
-- TOC entry 6368 (class 2604 OID 146570354)
-- Dependencies: 505 504
-- Name: cntctaddr_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cntctaddr ALTER COLUMN cntctaddr_id SET DEFAULT nextval('cntctaddr_cntctaddr_id_seq'::regclass);


--
-- TOC entry 6369 (class 2604 OID 146570355)
-- Dependencies: 507 506
-- Name: cntctdata_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cntctdata ALTER COLUMN cntctdata_id SET DEFAULT nextval('cntctdata_cntctdata_id_seq'::regclass);


--
-- TOC entry 6370 (class 2604 OID 146570356)
-- Dependencies: 509 508
-- Name: cntcteml_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cntcteml ALTER COLUMN cntcteml_id SET DEFAULT nextval('cntcteml_cntcteml_id_seq'::regclass);


--
-- TOC entry 6390 (class 2604 OID 146570453)
-- Dependencies: 515 378 515
-- Name: taxhist_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cobilltax ALTER COLUMN taxhist_id SET DEFAULT nextval('taxhist_taxhist_id_seq'::regclass);


--
-- TOC entry 6393 (class 2604 OID 146570454)
-- Dependencies: 518 378 518
-- Name: taxhist_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cobmisctax ALTER COLUMN taxhist_id SET DEFAULT nextval('taxhist_taxhist_id_seq'::regclass);


--
-- TOC entry 6258 (class 2604 OID 146570447)
-- Dependencies: 379 378 379
-- Name: taxhist_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cohisttax ALTER COLUMN taxhist_id SET DEFAULT nextval('taxhist_taxhist_id_seq'::regclass);


--
-- TOC entry 6394 (class 2604 OID 146570357)
-- Dependencies: 524 523
-- Name: company_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY company ALTER COLUMN company_id SET DEFAULT nextval('company_company_id_seq'::regclass);


--
-- TOC entry 6193 (class 2604 OID 146570358)
-- Dependencies: 525 329
-- Name: contrct_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY contrct ALTER COLUMN contrct_id SET DEFAULT nextval('contrct_contrct_id_seq'::regclass);


--
-- TOC entry 6411 (class 2604 OID 146570359)
-- Dependencies: 539 538
-- Name: country_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY country ALTER COLUMN country_id SET DEFAULT nextval('country_country_id_seq'::regclass);


--
-- TOC entry 5946 (class 2604 OID 146570360)
-- Dependencies: 543 205
-- Name: crmacct_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY crmacct ALTER COLUMN crmacct_id SET DEFAULT nextval('crmacct_crmacct_id_seq'::regclass);


--
-- TOC entry 6433 (class 2604 OID 146570361)
-- Dependencies: 546 545
-- Name: curr_rate_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY curr_rate ALTER COLUMN curr_rate_id SET DEFAULT nextval('curr_rate_curr_rate_id_seq'::regclass);


--
-- TOC entry 5965 (class 2604 OID 146570362)
-- Dependencies: 547 208
-- Name: curr_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY curr_symbol ALTER COLUMN curr_id SET DEFAULT nextval('curr_symbol_curr_id_seq'::regclass);


--
-- TOC entry 6144 (class 2604 OID 146570363)
-- Dependencies: 557 291
-- Name: dept_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY dept ALTER COLUMN dept_id SET DEFAULT nextval('dept_dept_id_seq'::regclass);


--
-- TOC entry 6080 (class 2604 OID 146570364)
-- Dependencies: 247 242
-- Name: docass_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY docass ALTER COLUMN docass_id SET DEFAULT nextval('docass_docass_id_seq'::regclass);


--
-- TOC entry 6149 (class 2604 OID 146570365)
-- Dependencies: 562 292
-- Name: emp_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY emp ALTER COLUMN emp_id SET DEFAULT nextval('emp_emp_id_seq'::regclass);


--
-- TOC entry 6449 (class 2604 OID 146570366)
-- Dependencies: 564 563
-- Name: empgrp_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY empgrp ALTER COLUMN empgrp_id SET DEFAULT nextval('empgrp_empgrp_id_seq'::regclass);


--
-- TOC entry 6451 (class 2604 OID 146570367)
-- Dependencies: 566 565
-- Name: empgrpitem_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY empgrpitem ALTER COLUMN empgrpitem_id SET DEFAULT nextval('empgrpitem_empgrpitem_id_seq'::regclass);


--
-- TOC entry 6228 (class 2604 OID 146570368)
-- Dependencies: 573 358
-- Name: expcat_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY expcat ALTER COLUMN expcat_id SET DEFAULT nextval('expcat_expcat_id_seq'::regclass);


--
-- TOC entry 6084 (class 2604 OID 146570369)
-- Dependencies: 574 243
-- Name: file_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY file ALTER COLUMN file_id SET DEFAULT nextval('file_file_id_seq'::regclass);


--
-- TOC entry 6456 (class 2604 OID 146570370)
-- Dependencies: 576 575
-- Name: filter_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY filter ALTER COLUMN filter_id SET DEFAULT nextval('filter_filter_id_seq'::regclass);


--
-- TOC entry 6458 (class 2604 OID 146570371)
-- Dependencies: 578 577
-- Name: fincharg_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY fincharg ALTER COLUMN fincharg_id SET DEFAULT nextval('fincharg_fincharg_id_seq'::regclass);


--
-- TOC entry 6491 (class 2604 OID 146570372)
-- Dependencies: 583 582
-- Name: flcol_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY flcol ALTER COLUMN flcol_id SET DEFAULT nextval('flcol_flcol_id_seq'::regclass);


--
-- TOC entry 6509 (class 2604 OID 146570373)
-- Dependencies: 585 584
-- Name: flgrp_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY flgrp ALTER COLUMN flgrp_id SET DEFAULT nextval('flgrp_flgrp_id_seq'::regclass);


--
-- TOC entry 6477 (class 2604 OID 146570374)
-- Dependencies: 586 579
-- Name: flhead_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY flhead ALTER COLUMN flhead_id SET DEFAULT nextval('flhead_flhead_id_seq'::regclass);


--
-- TOC entry 6490 (class 2604 OID 146570375)
-- Dependencies: 587 580
-- Name: flitem_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY flitem ALTER COLUMN flitem_id SET DEFAULT nextval('flitem_flitem_id_seq'::regclass);


--
-- TOC entry 6510 (class 2604 OID 146570376)
-- Dependencies: 589 588
-- Name: flnotes_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY flnotes ALTER COLUMN flnotes_id SET DEFAULT nextval('flnotes_flnotes_id_seq'::regclass);


--
-- TOC entry 6512 (class 2604 OID 146570377)
-- Dependencies: 591 590
-- Name: flrpt_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY flrpt ALTER COLUMN flrpt_id SET DEFAULT nextval('flrpt_flrpt_id_seq'::regclass);


--
-- TOC entry 6527 (class 2604 OID 146570378)
-- Dependencies: 593 592
-- Name: flspec_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY flspec ALTER COLUMN flspec_id SET DEFAULT nextval('flspec_flspec_id_seq'::regclass);


--
-- TOC entry 6160 (class 2604 OID 146570379)
-- Dependencies: 596 299
-- Name: freightclass_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY freightclass ALTER COLUMN freightclass_id SET DEFAULT nextval('freightclass_freightclass_id_seq'::regclass);


--
-- TOC entry 6531 (class 2604 OID 146570380)
-- Dependencies: 602 601
-- Name: grp_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY grp ALTER COLUMN grp_id SET DEFAULT nextval('grp_grp_id_seq'::regclass);


--
-- TOC entry 6533 (class 2604 OID 146570381)
-- Dependencies: 604 603
-- Name: grppriv_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY grppriv ALTER COLUMN grppriv_id SET DEFAULT nextval('grppriv_grppriv_id_seq'::regclass);


--
-- TOC entry 6534 (class 2604 OID 146570382)
-- Dependencies: 606 605
-- Name: hnfc_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY hnfc ALTER COLUMN hnfc_id SET DEFAULT nextval('hnfc_hnfc_id_seq'::regclass);


--
-- TOC entry 5955 (class 2604 OID 146570383)
-- Dependencies: 607 206
-- Name: incdt_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY incdt ALTER COLUMN incdt_id SET DEFAULT nextval('incdt_incdt_id_seq'::regclass);


--
-- TOC entry 6168 (class 2604 OID 146570384)
-- Dependencies: 608 304
-- Name: incdtcat_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY incdtcat ALTER COLUMN incdtcat_id SET DEFAULT nextval('incdtcat_incdtcat_id_seq'::regclass);


--
-- TOC entry 6536 (class 2604 OID 146570385)
-- Dependencies: 610 609
-- Name: incdthist_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY incdthist ALTER COLUMN incdthist_id SET DEFAULT nextval('incdthist_incdthist_id_seq'::regclass);


--
-- TOC entry 6170 (class 2604 OID 146570386)
-- Dependencies: 611 305
-- Name: incdtpriority_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY incdtpriority ALTER COLUMN incdtpriority_id SET DEFAULT nextval('incdtpriority_incdtpriority_id_seq'::regclass);


--
-- TOC entry 6172 (class 2604 OID 146570387)
-- Dependencies: 612 306
-- Name: incdtresolution_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY incdtresolution ALTER COLUMN incdtresolution_id SET DEFAULT nextval('incdtresolution_incdtresolution_id_seq'::regclass);


--
-- TOC entry 6174 (class 2604 OID 146570388)
-- Dependencies: 613 307
-- Name: incdtseverity_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY incdtseverity ALTER COLUMN incdtseverity_id SET DEFAULT nextval('incdtseverity_incdtseverity_id_seq'::regclass);


--
-- TOC entry 5935 (class 2604 OID 146570389)
-- Dependencies: 614 202
-- Name: invbal_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY invbal ALTER COLUMN invbal_id SET DEFAULT nextval('invbal_invbal_id_seq'::regclass);


--
-- TOC entry 6025 (class 2604 OID 146570390)
-- Dependencies: 616 224
-- Name: invchead_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY invchead ALTER COLUMN invchead_id SET DEFAULT nextval('invchead_invchead_id_seq'::regclass);


--
-- TOC entry 6539 (class 2604 OID 146570455)
-- Dependencies: 617 378 617
-- Name: taxhist_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY invcheadtax ALTER COLUMN taxhist_id SET DEFAULT nextval('taxhist_taxhist_id_seq'::regclass);


--
-- TOC entry 6034 (class 2604 OID 146570391)
-- Dependencies: 618 229
-- Name: invcitem_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY invcitem ALTER COLUMN invcitem_id SET DEFAULT nextval('invcitem_invcitem_id_seq'::regclass);


--
-- TOC entry 6540 (class 2604 OID 146570456)
-- Dependencies: 619 378 619
-- Name: taxhist_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY invcitemtax ALTER COLUMN taxhist_id SET DEFAULT nextval('taxhist_taxhist_id_seq'::regclass);


--
-- TOC entry 6549 (class 2604 OID 146570392)
-- Dependencies: 626 625
-- Name: invhistexpcat_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY invhistexpcat ALTER COLUMN invhistexpcat_id SET DEFAULT nextval('invhistexpcat_invhistexpcat_id_seq'::regclass);


--
-- TOC entry 6217 (class 2604 OID 146570393)
-- Dependencies: 628 347
-- Name: ipsass_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY ipsass ALTER COLUMN ipsass_id SET DEFAULT nextval('ipsass_ipsass_id_seq'::regclass);


--
-- TOC entry 6162 (class 2604 OID 146570394)
-- Dependencies: 631 300
-- Name: ipsfreight_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY ipsfreight ALTER COLUMN ipsfreight_id SET DEFAULT nextval('ipsfreight_ipsfreight_id_seq'::regclass);


--
-- TOC entry 6223 (class 2604 OID 146570395)
-- Dependencies: 634 351
-- Name: ipsitemchar_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY ipsitemchar ALTER COLUMN ipsitemchar_id SET DEFAULT nextval('ipsitemchar_ipsitemchar_id_seq'::regclass);


--
-- TOC entry 6550 (class 2604 OID 146570396)
-- Dependencies: 637 636
-- Name: ipsprodcat_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY ipsprodcat_bak ALTER COLUMN ipsprodcat_id SET DEFAULT nextval('ipsprodcat_ipsprodcat_id_seq'::regclass);


--
-- TOC entry 6562 (class 2604 OID 146570397)
-- Dependencies: 655 654
-- Name: itemlocpost_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY itemlocpost ALTER COLUMN itemlocpost_id SET DEFAULT nextval('itemlocpost_itemlocpost_id_seq'::regclass);


--
-- TOC entry 6207 (class 2604 OID 146570398)
-- Dependencies: 661 336
-- Name: itemtax_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY itemtax ALTER COLUMN itemtax_id SET DEFAULT nextval('itemtax_itemtax_id_seq'::regclass);


--
-- TOC entry 6563 (class 2604 OID 146570399)
-- Dependencies: 663 662
-- Name: itemtrans_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY itemtrans ALTER COLUMN itemtrans_id SET DEFAULT nextval('itemtrans_itemtrans_id_seq'::regclass);


--
-- TOC entry 6564 (class 2604 OID 146570400)
-- Dependencies: 665 664
-- Name: itemuom_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY itemuom ALTER COLUMN itemuom_id SET DEFAULT nextval('itemuom_itemuom_id_seq'::regclass);


--
-- TOC entry 6208 (class 2604 OID 146570401)
-- Dependencies: 666 338
-- Name: itemuomconv_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY itemuomconv ALTER COLUMN itemuomconv_id SET DEFAULT nextval('itemuomconv_itemuomconv_id_seq'::regclass);


--
-- TOC entry 6566 (class 2604 OID 146570402)
-- Dependencies: 671 670
-- Name: labeldef_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY labeldef ALTER COLUMN labeldef_id SET DEFAULT nextval('labeldef_labeldef_id_seq'::regclass);


--
-- TOC entry 6569 (class 2604 OID 146570403)
-- Dependencies: 675 674
-- Name: lang_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY lang ALTER COLUMN lang_id SET DEFAULT nextval('lang_lang_id_seq'::regclass);


--
-- TOC entry 6270 (class 2604 OID 146568260)
-- Dependencies: 406 405
-- Name: metasql_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY metasql ALTER COLUMN metasql_id SET DEFAULT nextval('metasql_metasql_id_seq'::regclass);


--
-- TOC entry 6577 (class 2604 OID 146570404)
-- Dependencies: 685 684
-- Name: metricenc_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY metricenc ALTER COLUMN metricenc_id SET DEFAULT nextval('metricenc_metricenc_id_seq'::regclass);


--
-- TOC entry 6037 (class 2604 OID 146570405)
-- Dependencies: 695 231
-- Name: ophead_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY ophead ALTER COLUMN ophead_id SET DEFAULT nextval('ophead_ophead_id_seq'::regclass);


--
-- TOC entry 6584 (class 2604 OID 146570406)
-- Dependencies: 697 696
-- Name: opsource_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY opsource ALTER COLUMN opsource_id SET DEFAULT nextval('opsource_opsource_id_seq'::regclass);


--
-- TOC entry 6586 (class 2604 OID 146570407)
-- Dependencies: 699 698
-- Name: opstage_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY opstage ALTER COLUMN opstage_id SET DEFAULT nextval('opstage_opstage_id_seq'::regclass);


--
-- TOC entry 6590 (class 2604 OID 146570408)
-- Dependencies: 701 700
-- Name: optype_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY optype ALTER COLUMN optype_id SET DEFAULT nextval('optype_optype_id_seq'::regclass);


--
-- TOC entry 6594 (class 2604 OID 146570409)
-- Dependencies: 707 706
-- Name: pack_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY pack ALTER COLUMN pack_id SET DEFAULT nextval('pack_pack_id_seq'::regclass);


--
-- TOC entry 6100 (class 2604 OID 146570410)
-- Dependencies: 710 264
-- Name: period_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY period ALTER COLUMN period_id SET DEFAULT nextval('period_period_id_seq'::regclass);




--
-- TOC entry 6616 (class 2604 OID 146570415)
-- Dependencies: 731 730
-- Name: prftcntr_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY prftcntr ALTER COLUMN prftcntr_id SET DEFAULT nextval('prftcntr_prftcntr_id_seq'::regclass);


--
-- TOC entry 6027 (class 2604 OID 146570416)
-- Dependencies: 735 225
-- Name: prj_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY prj ALTER COLUMN prj_id SET DEFAULT nextval('prj_prj_id_seq'::regclass);


--
-- TOC entry 6040 (class 2604 OID 146570417)
-- Dependencies: 736 232
-- Name: prjtask_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY prjtask ALTER COLUMN prjtask_id SET DEFAULT nextval('prjtask_prjtask_id_seq'::regclass);


--
-- TOC entry 6620 (class 2604 OID 146570418)
-- Dependencies: 738 737
-- Name: prjtaskuser_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY prjtaskuser ALTER COLUMN prjtaskuser_id SET DEFAULT nextval('prjtaskuser_prjtaskuser_id_seq'::regclass);


--
-- TOC entry 6621 (class 2604 OID 146570419)
-- Dependencies: 740 739
-- Name: prjtype_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY prjtype ALTER COLUMN prjtype_id SET DEFAULT nextval('prjtype_prjtype_id_seq'::regclass);


--
-- TOC entry 6623 (class 2604 OID 146570420)
-- Dependencies: 743 742
-- Name: qryhead_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY qryhead ALTER COLUMN qryhead_id SET DEFAULT nextval('qryhead_qryhead_id_seq'::regclass);


--
-- TOC entry 6630 (class 2604 OID 146570421)
-- Dependencies: 745 744
-- Name: qryitem_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY qryitem ALTER COLUMN qryitem_id SET DEFAULT nextval('qryitem_qryitem_id_seq'::regclass);


--
-- TOC entry 6638 (class 2604 OID 146570423)
-- Dependencies: 752 751
-- Name: recurtype_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY recurtype ALTER COLUMN recurtype_id SET DEFAULT nextval('recurtype_recurtype_id_seq'::regclass);


--
-- TOC entry 6610 (class 2604 OID 146570424)
-- Dependencies: 753 721
-- Name: recv_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY recv ALTER COLUMN recv_id SET DEFAULT nextval('recv_recv_id_seq'::regclass);


--
-- TOC entry 6006 (class 2604 OID 146570425)
-- Dependencies: 757 214
-- Name: rsncode_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY rsncode ALTER COLUMN rsncode_id SET DEFAULT nextval('rsncode_rsncode_id_seq'::regclass);


--
-- TOC entry 6008 (class 2604 OID 146570426)
-- Dependencies: 761 215
-- Name: salescat_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY salescat ALTER COLUMN salescat_id SET DEFAULT nextval('salescat_salescat_id_seq'::regclass);


--
-- TOC entry 6030 (class 2604 OID 146570427)
-- Dependencies: 765 226
-- Name: saletype_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY saletype ALTER COLUMN saletype_id SET DEFAULT nextval('saletype_saletype_id_seq'::regclass);


--
-- TOC entry 6643 (class 2604 OID 146570428)
-- Dependencies: 767 766
-- Name: schemaord_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY schemaord ALTER COLUMN schemaord_id SET DEFAULT nextval('schemaord_schemaord_id_seq'::regclass);


--
-- TOC entry 6278 (class 2604 OID 146568310)
-- Dependencies: 415 414
-- Name: script_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY script ALTER COLUMN script_id SET DEFAULT nextval('script_script_id_seq'::regclass);


--
-- TOC entry 6154 (class 2604 OID 146570429)
-- Dependencies: 769 293
-- Name: shift_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY shift ALTER COLUMN shift_id SET DEFAULT nextval('shift_shift_id_seq'::regclass);


--
-- TOC entry 6133 (class 2604 OID 146570430)
-- Dependencies: 770 281
-- Name: shipchrg_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY shipchrg ALTER COLUMN shipchrg_id SET DEFAULT nextval('shipchrg_shipchrg_id_seq'::regclass);


--
-- TOC entry 6400 (class 2604 OID 146570431)
-- Dependencies: 773 526
-- Name: shiphead_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY shiphead ALTER COLUMN shiphead_id SET DEFAULT nextval('shiphead_shiphead_id_seq'::regclass);


--
-- TOC entry 6404 (class 2604 OID 146570432)
-- Dependencies: 774 527
-- Name: shipitem_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY shipitem ALTER COLUMN shipitem_id SET DEFAULT nextval('shipitem_shipitem_id_seq'::regclass);


--
-- TOC entry 6261 (class 2604 OID 146570433)
-- Dependencies: 780 387
-- Name: sitetype_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY sitetype ALTER COLUMN sitetype_id SET DEFAULT nextval('sitetype_sitetype_id_seq'::regclass);


--
-- TOC entry 6654 (class 2604 OID 146570434)
-- Dependencies: 786 785
-- Name: source_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY source ALTER COLUMN source_id SET DEFAULT nextval('source_source_id_seq'::regclass);


--
-- TOC entry 6656 (class 2604 OID 146570435)
-- Dependencies: 788 787
-- Name: state_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY state ALTER COLUMN state_id SET DEFAULT nextval('state_state_id_seq'::regclass);


--
-- TOC entry 6658 (class 2604 OID 146570436)
-- Dependencies: 790 789
-- Name: status_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY status ALTER COLUMN status_id SET DEFAULT nextval('status_status_id_seq'::regclass);


--
-- TOC entry 6660 (class 2604 OID 146570437)
-- Dependencies: 792 791
-- Name: stdjrnl_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY stdjrnl ALTER COLUMN stdjrnl_id SET DEFAULT nextval('stdjrnl_stdjrnl_id_seq'::regclass);


--
-- TOC entry 6662 (class 2604 OID 146570438)
-- Dependencies: 794 793
-- Name: stdjrnlgrp_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY stdjrnlgrp ALTER COLUMN stdjrnlgrp_id SET DEFAULT nextval('stdjrnlgrp_stdjrnlgrp_id_seq'::regclass);


--
-- TOC entry 6664 (class 2604 OID 146570439)
-- Dependencies: 796 795
-- Name: stdjrnlgrpitem_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY stdjrnlgrpitem ALTER COLUMN stdjrnlgrpitem_id SET DEFAULT nextval('stdjrnlgrpitem_stdjrnlgrpitem_id_seq'::regclass);


--
-- TOC entry 6665 (class 2604 OID 146570440)
-- Dependencies: 798 797
-- Name: stdjrnlitem_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY stdjrnlitem ALTER COLUMN stdjrnlitem_id SET DEFAULT nextval('stdjrnlitem_stdjrnlitem_id_seq'::regclass);


--
-- TOC entry 6666 (class 2604 OID 146570441)
-- Dependencies: 800 799
-- Name: subaccnt_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY subaccnt ALTER COLUMN subaccnt_id SET DEFAULT nextval('subaccnt_subaccnt_id_seq'::regclass);


--
-- TOC entry 6668 (class 2604 OID 146570442)
-- Dependencies: 802 801
-- Name: subaccnttype_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY subaccnttype ALTER COLUMN subaccnttype_id SET DEFAULT nextval('subaccnttype_subaccnttype_id_seq'::regclass);


--
-- TOC entry 6669 (class 2604 OID 146570443)
-- Dependencies: 805 804
-- Name: taxass_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY taxass ALTER COLUMN taxass_id SET DEFAULT nextval('taxass_taxass_id_seq'::regclass);


--
-- TOC entry 6137 (class 2604 OID 146570444)
-- Dependencies: 806 284
-- Name: taxauth_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY taxauth ALTER COLUMN taxauth_id SET DEFAULT nextval('taxauth_taxauth_id_seq'::regclass);


--
-- TOC entry 6670 (class 2604 OID 146570445)
-- Dependencies: 808 807
-- Name: taxclass_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY taxclass ALTER COLUMN taxclass_id SET DEFAULT nextval('taxclass_taxclass_id_seq'::regclass);


--
-- TOC entry 6257 (class 2604 OID 146570446)
-- Dependencies: 378 377
-- Name: taxhist_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY taxhist ALTER COLUMN taxhist_id SET DEFAULT nextval('taxhist_taxhist_id_seq'::regclass);


--
-- TOC entry 6672 (class 2604 OID 146570459)
-- Dependencies: 810 809
-- Name: taxrate_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY taxrate ALTER COLUMN taxrate_id SET DEFAULT nextval('taxrate_taxrate_id_seq'::regclass);


--
-- TOC entry 6142 (class 2604 OID 146570460)
-- Dependencies: 811 285
-- Name: taxreg_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY taxreg ALTER COLUMN taxreg_id SET DEFAULT nextval('taxreg_taxreg_id_seq'::regclass);


--
-- TOC entry 5929 (class 2604 OID 146570461)
-- Dependencies: 812 199
-- Name: taxtype_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY taxtype ALTER COLUMN taxtype_id SET DEFAULT nextval('taxtype_taxtype_id_seq'::regclass);


--
-- TOC entry 6018 (class 2604 OID 146570462)
-- Dependencies: 813 220
-- Name: taxzone_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY taxzone ALTER COLUMN taxzone_id SET DEFAULT nextval('taxzone_taxzone_id_seq'::regclass);


--
-- TOC entry 6045 (class 2604 OID 146570463)
-- Dependencies: 815 233
-- Name: todoitem_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY todoitem ALTER COLUMN todoitem_id SET DEFAULT nextval('todoitem_todoitem_id_seq'::regclass);


--
-- TOC entry 6673 (class 2604 OID 146570464)
-- Dependencies: 818 817
-- Name: trialbal_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY trialbal ALTER COLUMN trialbal_id SET DEFAULT nextval('trialbal_trialbal_id_seq'::regclass);


--
-- TOC entry 6282 (class 2604 OID 146568328)
-- Dependencies: 418 417
-- Name: uiform_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY uiform ALTER COLUMN uiform_id SET DEFAULT nextval('uiform_uiform_id_seq'::regclass);


--
-- TOC entry 5932 (class 2604 OID 146570465)
-- Dependencies: 819 200
-- Name: uom_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY uom ALTER COLUMN uom_id SET DEFAULT nextval('uom_uom_id_seq'::regclass);


--
-- TOC entry 6675 (class 2604 OID 146570466)
-- Dependencies: 821 820
-- Name: uomconv_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY uomconv ALTER COLUMN uomconv_id SET DEFAULT nextval('uomconv_uomconv_id_seq'::regclass);


--
-- TOC entry 6677 (class 2604 OID 146570467)
-- Dependencies: 823 822
-- Name: uomtype_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY uomtype ALTER COLUMN uomtype_id SET DEFAULT nextval('uomtype_uomtype_id_seq'::regclass);


--
-- TOC entry 6085 (class 2604 OID 146570468)
-- Dependencies: 824 244
-- Name: url_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY urlinfo ALTER COLUMN url_id SET DEFAULT nextval('urlinfo_url_id_seq'::regclass);


--
-- TOC entry 6618 (class 2604 OID 146570469)
-- Dependencies: 829 732
-- Name: usrgrp_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY usrgrp ALTER COLUMN usrgrp_id SET DEFAULT nextval('usrgrp_usrgrp_id_seq'::regclass);


--
-- TOC entry 6263 (class 2604 OID 146570470)
-- Dependencies: 836 393
-- Name: vendtype_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY vendtype ALTER COLUMN vendtype_id SET DEFAULT nextval('vendtype_vendtype_id_seq'::regclass);


--
-- TOC entry 6689 (class 2604 OID 146570457)
-- Dependencies: 841 378 841
-- Name: taxhist_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY voheadtax ALTER COLUMN taxhist_id SET DEFAULT nextval('taxhist_taxhist_id_seq'::regclass);


--
-- TOC entry 6692 (class 2604 OID 146570458)
-- Dependencies: 844 378 844
-- Name: taxhist_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY voitemtax ALTER COLUMN taxhist_id SET DEFAULT nextval('taxhist_taxhist_id_seq'::regclass);


--
-- TOC entry 6216 (class 2604 OID 146570471)
-- Dependencies: 847 343
-- Name: whsezone_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY whsezone ALTER COLUMN whsezone_id SET DEFAULT nextval('whsezone_whsezone_id_seq'::regclass);


--
-- TOC entry 6693 (class 2604 OID 146570472)
-- Dependencies: 851 850
-- Name: womatlpost_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY womatlpost ALTER COLUMN womatlpost_id SET DEFAULT nextval('womatlpost_womatlpost_id_seq'::regclass);


--
-- TOC entry 6696 (class 2604 OID 146570473)
-- Dependencies: 856 855
-- Name: xsltmap_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY xsltmap ALTER COLUMN xsltmap_id SET DEFAULT nextval('xsltmap_xsltmap_id_seq'::regclass);


--
-- TOC entry 6701 (class 2604 OID 146570474)
-- Dependencies: 858 857
-- Name: yearperiod_id; Type: DEFAULT; Schema: public; Owner: admin
--

ALTER TABLE ONLY yearperiod ALTER COLUMN yearperiod_id SET DEFAULT nextval('yearperiod_yearperiod_id_seq'::regclass);


SET search_path = public, pg_catalog;

--
-- TOC entry 7197 (class 2606 OID 146570818)
-- Dependencies: 420 420 8894
-- Name: acalitem_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY acalitem
    ADD CONSTRAINT acalitem_pkey PRIMARY KEY (acalitem_id);

ALTER TABLE ONLY accnt
    ADD CONSTRAINT accnt_pkey PRIMARY KEY (accnt_id);

--
-- TOC entry 6919 (class 2606 OID 146570822)
-- Dependencies: 234 234 8894
-- Name: addr_addr_number_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY addr
    ADD CONSTRAINT addr_addr_number_key UNIQUE (addr_number);


--
-- TOC entry 6921 (class 2606 OID 146570824)
-- Dependencies: 234 234 8894
-- Name: addr_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY addr
    ADD CONSTRAINT addr_pkey PRIMARY KEY (addr_id);


--
-- TOC entry 7199 (class 2606 OID 146570826)
-- Dependencies: 424 424 8894
-- Name: alarm_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY alarm
    ADD CONSTRAINT alarm_pkey PRIMARY KEY (alarm_id);


--
-- TOC entry 7201 (class 2606 OID 146570828)
-- Dependencies: 426 426 8894
-- Name: apaccnt_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY apaccnt
    ADD CONSTRAINT apaccnt_pkey PRIMARY KEY (apaccnt_id);



--
-- TOC entry 7212 (class 2606 OID 146570832)
-- Dependencies: 434 434 8894
-- Name: apcreditapply_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY apcreditapply
    ADD CONSTRAINT apcreditapply_pkey PRIMARY KEY (apcreditapply_id);

ALTER TABLE ONLY apopen
    ADD CONSTRAINT apopen_pkey PRIMARY KEY (apopen_id);

--
-- TOC entry 7214 (class 2606 OID 146570836)
-- Dependencies: 438 438 8894
-- Name: apopentax_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY apopentax
    ADD CONSTRAINT apopentax_pkey PRIMARY KEY (taxhist_id);


--
-- TOC entry 7217 (class 2606 OID 146570838)
-- Dependencies: 439 439 8894
-- Name: apselect_apselect_apopen_id_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY apselect
    ADD CONSTRAINT apselect_apselect_apopen_id_key UNIQUE (apselect_apopen_id);


--
-- TOC entry 7219 (class 2606 OID 146570840)
-- Dependencies: 439 439 8894
-- Name: apselect_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY apselect
    ADD CONSTRAINT apselect_pkey PRIMARY KEY (apselect_id);


--
-- TOC entry 7221 (class 2606 OID 146570842)
-- Dependencies: 441 441 8894
-- Name: araccnt_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY araccnt
    ADD CONSTRAINT araccnt_pkey PRIMARY KEY (araccnt_id);



--
-- TOC entry 7226 (class 2606 OID 146570846)
-- Dependencies: 446 446 8894
-- Name: arcreditapply_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY arcreditapply
    ADD CONSTRAINT arcreditapply_pkey PRIMARY KEY (arcreditapply_id);

ALTER TABLE ONLY aropen
    ADD CONSTRAINT aropen_pkey PRIMARY KEY (aropen_id);

ALTER TABLE ONLY aropenalloc
    ADD CONSTRAINT aropenalloc_pkey PRIMARY KEY (aropenalloc_aropen_id, aropenalloc_doctype, aropenalloc_doc_id);


ALTER TABLE ONLY aropentax
    ADD CONSTRAINT aropentax_pkey PRIMARY KEY (taxhist_id);

ALTER TABLE ONLY asohist
    ADD CONSTRAINT asohist_pkey PRIMARY KEY (asohist_id);



--
-- TOC entry 7232 (class 2606 OID 146570856)
-- Dependencies: 453 453 8894
-- Name: asohisttax_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY asohisttax
    ADD CONSTRAINT asohisttax_pkey PRIMARY KEY (taxhist_id);


--
-- TOC entry 7234 (class 2606 OID 146570858)
-- Dependencies: 454 454 8894
-- Name: atlasmap_atlasmap_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY atlasmap
    ADD CONSTRAINT atlasmap_atlasmap_name_key UNIQUE (atlasmap_name);


--
-- TOC entry 7236 (class 2606 OID 146570860)
-- Dependencies: 454 454 8894
-- Name: atlasmap_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY atlasmap
    ADD CONSTRAINT atlasmap_pkey PRIMARY KEY (atlasmap_id);

ALTER TABLE ONLY bankaccnt
    ADD CONSTRAINT bankaccnt_pkey PRIMARY KEY (bankaccnt_id);

--
-- TOC entry 7238 (class 2606 OID 146570866)
-- Dependencies: 458 458 8894
-- Name: bankadj_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY bankadj
    ADD CONSTRAINT bankadj_pkey PRIMARY KEY (bankadj_id);


--
-- TOC entry 7240 (class 2606 OID 146570868)
-- Dependencies: 460 460 8894
-- Name: bankadjtype_bankadjtype_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY bankadjtype
    ADD CONSTRAINT bankadjtype_bankadjtype_name_key UNIQUE (bankadjtype_name);


--
-- TOC entry 7242 (class 2606 OID 146570870)
-- Dependencies: 460 460 8894
-- Name: bankadjtype_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY bankadjtype
    ADD CONSTRAINT bankadjtype_pkey PRIMARY KEY (bankadjtype_id);


--
-- TOC entry 7244 (class 2606 OID 146570872)
-- Dependencies: 462 462 8894
-- Name: bankrec_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY bankrec
    ADD CONSTRAINT bankrec_pkey PRIMARY KEY (bankrec_id);

ALTER TABLE ONLY bomitem
    ADD CONSTRAINT bomitem_pkey PRIMARY KEY (bomitem_id);

--
-- TOC entry 7250 (class 2606 OID 146570880)
-- Dependencies: 468 468 8894
-- Name: bomitemcost_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY bomitemcost
    ADD CONSTRAINT bomitemcost_pkey PRIMARY KEY (bomitemcost_id);


--
-- TOC entry 6949 (class 2606 OID 146570882)
-- Dependencies: 258 258 8894
-- Name: bomitemsub_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY bomitemsub
    ADD CONSTRAINT bomitemsub_pkey PRIMARY KEY (bomitemsub_id);


--
-- TOC entry 7252 (class 2606 OID 146570884)
-- Dependencies: 471 471 8894
-- Name: bomwork_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY bomwork
    ADD CONSTRAINT bomwork_pkey PRIMARY KEY (bomwork_id);


--
-- TOC entry 6951 (class 2606 OID 146570886)
-- Dependencies: 260 260 8894
-- Name: budghead_budghead_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY budghead
    ADD CONSTRAINT budghead_budghead_name_key UNIQUE (budghead_name);


--
-- TOC entry 6953 (class 2606 OID 146570888)
-- Dependencies: 260 260 8894
-- Name: budghead_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY budghead
    ADD CONSTRAINT budghead_pkey PRIMARY KEY (budghead_id);


--
-- TOC entry 6958 (class 2606 OID 146570890)
-- Dependencies: 263 263 8894
-- Name: budgitem_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY budgitem
    ADD CONSTRAINT budgitem_pkey PRIMARY KEY (budgitem_id);


--
-- TOC entry 7254 (class 2606 OID 146570892)
-- Dependencies: 476 476 8894
-- Name: calhead_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY calhead
    ADD CONSTRAINT calhead_pkey PRIMARY KEY (calhead_id);



--
-- TOC entry 6977 (class 2606 OID 146570902)
-- Dependencies: 278 278 8894
-- Name: ccard_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY ccard
    ADD CONSTRAINT ccard_pkey PRIMARY KEY (ccard_id);


--
-- TOC entry 7258 (class 2606 OID 146570904)
-- Dependencies: 482 482 8894
-- Name: ccardaud_ccard_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY ccardaud
    ADD CONSTRAINT ccardaud_ccard_pkey PRIMARY KEY (ccardaud_id);

ALTER TABLE ONLY ccpay
    ADD CONSTRAINT ccpay_pkey PRIMARY KEY (ccpay_id);

ALTER TABLE ONLY "char"
    ADD CONSTRAINT char_pkey PRIMARY KEY (char_id);

--
-- TOC entry 6927 (class 2606 OID 146570916)
-- Dependencies: 237 237 8894
-- Name: charass_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY charass
    ADD CONSTRAINT charass_pkey PRIMARY KEY (charass_id);


--
-- TOC entry 7269 (class 2606 OID 146570918)
-- Dependencies: 490 490 8894
-- Name: charopt_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY charopt
    ADD CONSTRAINT charopt_pkey PRIMARY KEY (charopt_id);

ALTER TABLE ONLY checkhead
    ADD CONSTRAINT checkhead_pkey PRIMARY KEY (checkhead_id);

--
-- TOC entry 7210 (class 2606 OID 146570922)
-- Dependencies: 432 432 8894
-- Name: checkitem_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY checkitem
    ADD CONSTRAINT checkitem_pkey PRIMARY KEY (checkitem_id);


--
-- TOC entry 7036 (class 2606 OID 146570924)
-- Dependencies: 313 313 8894
-- Name: classcode_classcode_code_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY classcode
    ADD CONSTRAINT classcode_classcode_code_key UNIQUE (classcode_code);


--
-- TOC entry 7038 (class 2606 OID 146570926)
-- Dependencies: 313 313 8894
-- Name: classcode_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY classcode
    ADD CONSTRAINT classcode_pkey PRIMARY KEY (classcode_id);


--
-- TOC entry 7163 (class 2606 OID 146570928)
-- Dependencies: 397 397 8894
-- Name: cmd_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY cmd
    ADD CONSTRAINT cmd_pkey PRIMARY KEY (cmd_id);


--
-- TOC entry 7167 (class 2606 OID 146570930)
-- Dependencies: 400 400 8894
-- Name: cmdarg_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY cmdarg
    ADD CONSTRAINT cmdarg_pkey PRIMARY KEY (cmdarg_id);


--
-- TOC entry 6870 (class 2606 OID 146570932)
-- Dependencies: 218 218 8894
-- Name: cmhead_cmhead_number_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY cmhead
    ADD CONSTRAINT cmhead_cmhead_number_key UNIQUE (cmhead_number);


--
-- TOC entry 6873 (class 2606 OID 146570934)
-- Dependencies: 218 218 8894
-- Name: cmhead_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY cmhead
    ADD CONSTRAINT cmhead_pkey PRIMARY KEY (cmhead_id);


--
-- TOC entry 7271 (class 2606 OID 146570936)
-- Dependencies: 497 497 8894
-- Name: cmheadtax_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY cmheadtax
    ADD CONSTRAINT cmheadtax_pkey PRIMARY KEY (taxhist_id);

ALTER TABLE ONLY cmitem
    ADD CONSTRAINT cmitem_pkey PRIMARY KEY (cmitem_id);

--
-- TOC entry 7273 (class 2606 OID 146570942)
-- Dependencies: 499 499 8894
-- Name: cmitemtax_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY cmitemtax
    ADD CONSTRAINT cmitemtax_pkey PRIMARY KEY (taxhist_id);


--
-- TOC entry 6930 (class 2606 OID 146570944)
-- Dependencies: 239 239 8894
-- Name: cmnttype_cmnttype_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY cmnttype
    ADD CONSTRAINT cmnttype_cmnttype_name_key UNIQUE (cmnttype_name);


--
-- TOC entry 6932 (class 2606 OID 146570946)
-- Dependencies: 239 239 8894
-- Name: cmnttype_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY cmnttype
    ADD CONSTRAINT cmnttype_pkey PRIMARY KEY (cmnttype_id);

ALTER TABLE ONLY cntct
    ADD CONSTRAINT cntct_pkey PRIMARY KEY (cntct_id);

--
-- TOC entry 7277 (class 2606 OID 146570955)
-- Dependencies: 504 504 8894
-- Name: cntctaddr_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY cntctaddr
    ADD CONSTRAINT cntctaddr_pkey PRIMARY KEY (cntctaddr_id);


--
-- TOC entry 7279 (class 2606 OID 146570958)
-- Dependencies: 506 506 8894
-- Name: cntctdata_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY cntctdata
    ADD CONSTRAINT cntctdata_pkey PRIMARY KEY (cntctdata_id);


--
-- TOC entry 7281 (class 2606 OID 146570960)
-- Dependencies: 508 508 8894
-- Name: cntcteml_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY cntcteml
    ADD CONSTRAINT cntcteml_pkey PRIMARY KEY (cntcteml_id);


--
-- TOC entry 7283 (class 2606 OID 146570962)
-- Dependencies: 510 510 8894
-- Name: cntctmrgd_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY cntctmrgd
    ADD CONSTRAINT cntctmrgd_pkey PRIMARY KEY (cntctmrgd_cntct_id);


--
-- TOC entry 7285 (class 2606 OID 146570964)
-- Dependencies: 511 511 8894
-- Name: cntctsel_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY cntctsel
    ADD CONSTRAINT cntctsel_pkey PRIMARY KEY (cntctsel_cntct_id);


--
-- TOC entry 6744 (class 2606 OID 146570967)
-- Dependencies: 189 189 8894
-- Name: cntslip_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY cntslip
    ADD CONSTRAINT cntslip_pkey PRIMARY KEY (cntslip_id);


--
-- TOC entry 7289 (class 2606 OID 146570969)
-- Dependencies: 513 513 8894
-- Name: cobill_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY cobill
    ADD CONSTRAINT cobill_pkey PRIMARY KEY (cobill_id);


--
-- TOC entry 7291 (class 2606 OID 146570972)
-- Dependencies: 515 515 8894
-- Name: cobilltax_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY cobilltax
    ADD CONSTRAINT cobilltax_pkey PRIMARY KEY (taxhist_id);


--
-- TOC entry 7294 (class 2606 OID 146570974)
-- Dependencies: 516 516 8894
-- Name: cobmisc_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY cobmisc
    ADD CONSTRAINT cobmisc_pkey PRIMARY KEY (cobmisc_id);


--
-- TOC entry 7297 (class 2606 OID 146570976)
-- Dependencies: 518 518 8894
-- Name: cobmisctax_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY cobmisctax
    ADD CONSTRAINT cobmisctax_pkey PRIMARY KEY (taxhist_id);

ALTER TABLE ONLY cohead
    ADD CONSTRAINT cohead_pkey PRIMARY KEY (cohead_id);


--
-- TOC entry 7149 (class 2606 OID 146570984)
-- Dependencies: 379 379 8894
-- Name: cohisttax_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY cohisttax
    ADD CONSTRAINT cohisttax_pkey PRIMARY KEY (taxhist_id);


--
-- TOC entry 6781 (class 2606 OID 146570986)
-- Dependencies: 196 196 8894
-- Name: coitem_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY coitem
    ADD CONSTRAINT coitem_pkey PRIMARY KEY (coitem_id);


--
-- TOC entry 6935 (class 2606 OID 146570989)
-- Dependencies: 240 240 8894
-- Name: comment_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY comment
    ADD CONSTRAINT comment_pkey PRIMARY KEY (comment_id);


ALTER TABLE ONLY company
    ADD CONSTRAINT company_pkey PRIMARY KEY (company_id);
ALTER TABLE ONLY company
    ADD CONSTRAINT company_company_number_key UNIQUE (company_number);


--
-- TOC entry 7065 (class 2606 OID 146570995)
-- Dependencies: 329 329 8894
-- Name: contrct_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY contrct
    ADD CONSTRAINT contrct_pkey PRIMARY KEY (contrct_id);


--
-- TOC entry 7056 (class 2606 OID 146570997)
-- Dependencies: 325 325 8894
-- Name: costcat_costcat_code_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY costcat
    ADD CONSTRAINT costcat_costcat_code_key UNIQUE (costcat_code);


--
-- TOC entry 7058 (class 2606 OID 146570999)
-- Dependencies: 325 325 8894
-- Name: costcat_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY costcat
    ADD CONSTRAINT costcat_pkey PRIMARY KEY (costcat_id);


--
-- TOC entry 7048 (class 2606 OID 146571001)
-- Dependencies: 320 320 8894
-- Name: costelem_costelem_type_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY costelem
    ADD CONSTRAINT costelem_costelem_type_key UNIQUE (costelem_type);


--
-- TOC entry 7050 (class 2606 OID 146571004)
-- Dependencies: 320 320 8894
-- Name: costelem_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY costelem
    ADD CONSTRAINT costelem_pkey PRIMARY KEY (costelem_id);


--
-- TOC entry 7314 (class 2606 OID 146571006)
-- Dependencies: 535 535 8894
-- Name: costhist_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY costhist
    ADD CONSTRAINT costhist_pkey PRIMARY KEY (costhist_id);


--
-- TOC entry 7316 (class 2606 OID 146571013)
-- Dependencies: 537 537 8894
-- Name: costupdate_costupdate_item_id_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY costupdate
    ADD CONSTRAINT costupdate_costupdate_item_id_key UNIQUE (costupdate_item_id);


--
-- TOC entry 7318 (class 2606 OID 146571017)
-- Dependencies: 538 538 8894
-- Name: country_country_abbr_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY country
    ADD CONSTRAINT country_country_abbr_key UNIQUE (country_abbr);


--
-- TOC entry 7320 (class 2606 OID 146571019)
-- Dependencies: 538 538 8894
-- Name: country_country_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY country
    ADD CONSTRAINT country_country_name_key UNIQUE (country_name);


--
-- TOC entry 7322 (class 2606 OID 146571021)
-- Dependencies: 538 538 8894
-- Name: country_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY country
    ADD CONSTRAINT country_pkey PRIMARY KEY (country_id);


ALTER TABLE ONLY crmacct
    ADD CONSTRAINT crmacct_pkey PRIMARY KEY (crmacct_id);


--
-- TOC entry 7328 (class 2606 OID 146571027)
-- Dependencies: 544 544 8894
-- Name: crmacctsel_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY crmacctsel
    ADD CONSTRAINT crmacctsel_pkey PRIMARY KEY (crmacctsel_src_crmacct_id);

ALTER TABLE ONLY curr_rate
    ADD CONSTRAINT curr_rate_pkey PRIMARY KEY (curr_rate_id);


--
-- TOC entry 6831 (class 2606 OID 146571033)
-- Dependencies: 208 208 8894
-- Name: curr_symbol_curr_abbr_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY curr_symbol
    ADD CONSTRAINT curr_symbol_curr_abbr_key UNIQUE (curr_abbr);


--
-- TOC entry 6833 (class 2606 OID 146571035)
-- Dependencies: 208 208 8894
-- Name: curr_symbol_curr_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY curr_symbol
    ADD CONSTRAINT curr_symbol_curr_name_key UNIQUE (curr_name);


--
-- TOC entry 6835 (class 2606 OID 146571037)
-- Dependencies: 208 208 8894
-- Name: curr_symbol_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY curr_symbol
    ADD CONSTRAINT curr_symbol_pkey PRIMARY KEY (curr_id);


ALTER TABLE ONLY custinfo
    ADD CONSTRAINT cust_pkey PRIMARY KEY (cust_id);


--
-- TOC entry 7334 (class 2606 OID 146571041)
-- Dependencies: 550 550 8894
-- Name: custform_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY custform
    ADD CONSTRAINT custform_pkey PRIMARY KEY (custform_id);


--
-- TOC entry 7336 (class 2606 OID 146571043)
-- Dependencies: 552 552 8894
-- Name: custgrp_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY custgrp
    ADD CONSTRAINT custgrp_pkey PRIMARY KEY (custgrp_id);


--
-- TOC entry 7338 (class 2606 OID 146571045)
-- Dependencies: 554 554 8894
-- Name: custgrpitem_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY custgrpitem
    ADD CONSTRAINT custgrpitem_pkey PRIMARY KEY (custgrpitem_id);


ALTER TABLE ONLY custtype
    ADD CONSTRAINT custtype_custtype_code_key UNIQUE (custtype_code);


--
-- TOC entry 6981 (class 2606 OID 146571051)
-- Dependencies: 280 280 8894
-- Name: custtype_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY custtype
    ADD CONSTRAINT custtype_pkey PRIMARY KEY (custtype_id);


--
-- TOC entry 6995 (class 2606 OID 146571053)
-- Dependencies: 291 291 8894
-- Name: dept_dept_number_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY dept
    ADD CONSTRAINT dept_dept_number_key UNIQUE (dept_number);


--
-- TOC entry 6997 (class 2606 OID 146571055)
-- Dependencies: 291 291 8894
-- Name: dept_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY dept
    ADD CONSTRAINT dept_pkey PRIMARY KEY (dept_id);


--
-- TOC entry 7340 (class 2606 OID 146571057)
-- Dependencies: 558 558 8894
-- Name: destination_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY destination
    ADD CONSTRAINT destination_pkey PRIMARY KEY (destination_id);


ALTER TABLE ONLY docass
    ADD CONSTRAINT docass_pkey PRIMARY KEY (docass_id);


ALTER TABLE ONLY emp
    ADD CONSTRAINT emp_pkey PRIMARY KEY (emp_id);


--
-- TOC entry 7349 (class 2606 OID 146571068)
-- Dependencies: 563 563 8894
-- Name: empgrp_empgrp_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY empgrp
    ADD CONSTRAINT empgrp_empgrp_name_key UNIQUE (empgrp_name);


--
-- TOC entry 7351 (class 2606 OID 146571070)
-- Dependencies: 563 563 8894
-- Name: empgrp_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY empgrp
    ADD CONSTRAINT empgrp_pkey PRIMARY KEY (empgrp_id);


--
-- TOC entry 7353 (class 2606 OID 146571072)
-- Dependencies: 565 565 8894
-- Name: empgrpitem_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY empgrpitem
    ADD CONSTRAINT empgrpitem_pkey PRIMARY KEY (empgrpitem_id);


--
-- TOC entry 7357 (class 2606 OID 146571075)
-- Dependencies: 567 567 8894
-- Name: evntlog_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY evntlog
    ADD CONSTRAINT evntlog_pkey PRIMARY KEY (evntlog_id);


--
-- TOC entry 7360 (class 2606 OID 146571077)
-- Dependencies: 569 569 8894
-- Name: evntnot_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY evntnot
    ADD CONSTRAINT evntnot_pkey PRIMARY KEY (evntnot_id);


--
-- TOC entry 7363 (class 2606 OID 146571079)
-- Dependencies: 571 571 8894
-- Name: evnttype_evnttype_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY evnttype
    ADD CONSTRAINT evnttype_evnttype_name_key UNIQUE (evnttype_name);


--
-- TOC entry 7365 (class 2606 OID 146571081)
-- Dependencies: 571 571 8894
-- Name: evnttype_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY evnttype
    ADD CONSTRAINT evnttype_pkey PRIMARY KEY (evnttype_id);


--
-- TOC entry 7117 (class 2606 OID 146571083)
-- Dependencies: 358 358 8894
-- Name: expcat_expcat_code_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY expcat
    ADD CONSTRAINT expcat_expcat_code_key UNIQUE (expcat_code);


--
-- TOC entry 7119 (class 2606 OID 146571085)
-- Dependencies: 358 358 8894
-- Name: expcat_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY expcat
    ADD CONSTRAINT expcat_pkey PRIMARY KEY (expcat_id);


--
-- TOC entry 6939 (class 2606 OID 146571087)
-- Dependencies: 243 243 8894
-- Name: file_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY file
    ADD CONSTRAINT file_pkey PRIMARY KEY (file_id);


--
-- TOC entry 7368 (class 2606 OID 146571089)
-- Dependencies: 575 575 8894
-- Name: filter_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY filter
    ADD CONSTRAINT filter_pkey PRIMARY KEY (filter_id);


--
-- TOC entry 7370 (class 2606 OID 146571091)
-- Dependencies: 577 577 8894
-- Name: fincharg_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY fincharg
    ADD CONSTRAINT fincharg_pkey PRIMARY KEY (fincharg_id);


--
-- TOC entry 7378 (class 2606 OID 146571093)
-- Dependencies: 582 582 8894
-- Name: fkey_flcol_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY flcol
    ADD CONSTRAINT fkey_flcol_key PRIMARY KEY (flcol_id);


--
-- TOC entry 7380 (class 2606 OID 146571095)
-- Dependencies: 584 584 8894
-- Name: flgrp_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY flgrp
    ADD CONSTRAINT flgrp_pkey PRIMARY KEY (flgrp_id);


--
-- TOC entry 7372 (class 2606 OID 146571097)
-- Dependencies: 579 579 8894
-- Name: flhead_flhead_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY flhead
    ADD CONSTRAINT flhead_flhead_name_key UNIQUE (flhead_name);


--
-- TOC entry 7374 (class 2606 OID 146571099)
-- Dependencies: 579 579 8894
-- Name: flhead_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY flhead
    ADD CONSTRAINT flhead_pkey PRIMARY KEY (flhead_id);


--
-- TOC entry 7376 (class 2606 OID 146571101)
-- Dependencies: 580 580 8894
-- Name: flitem_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY flitem
    ADD CONSTRAINT flitem_pkey PRIMARY KEY (flitem_id);


--
-- TOC entry 7382 (class 2606 OID 146571103)
-- Dependencies: 588 588 588 8894
-- Name: flnotes_flnotes_flhead_id_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY flnotes
    ADD CONSTRAINT flnotes_flnotes_flhead_id_key UNIQUE (flnotes_flhead_id, flnotes_period_id);


--
-- TOC entry 7384 (class 2606 OID 146571105)
-- Dependencies: 590 590 8894
-- Name: flrpt_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY flrpt
    ADD CONSTRAINT flrpt_pkey PRIMARY KEY (flrpt_id);


--
-- TOC entry 7386 (class 2606 OID 146571107)
-- Dependencies: 592 592 8894
-- Name: flspec_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY flspec
    ADD CONSTRAINT flspec_pkey PRIMARY KEY (flspec_id);


--
-- TOC entry 7388 (class 2606 OID 146571109)
-- Dependencies: 594 594 8894
-- Name: form_form_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY form
    ADD CONSTRAINT form_form_name_key UNIQUE (form_name);


--
-- TOC entry 7390 (class 2606 OID 146571111)
-- Dependencies: 594 594 8894
-- Name: form_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY form
    ADD CONSTRAINT form_pkey PRIMARY KEY (form_id);


--
-- TOC entry 7010 (class 2606 OID 146571113)
-- Dependencies: 299 299 8894
-- Name: freightclass_freightclass_code_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY freightclass
    ADD CONSTRAINT freightclass_freightclass_code_key UNIQUE (freightclass_code);


--
-- TOC entry 7012 (class 2606 OID 146571115)
-- Dependencies: 299 299 8894
-- Name: freightclass_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY freightclass
    ADD CONSTRAINT freightclass_pkey PRIMARY KEY (freightclass_id);


--
-- TOC entry 7392 (class 2606 OID 146571117)
-- Dependencies: 597 597 8894
-- Name: glseries_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY glseries
    ADD CONSTRAINT glseries_pkey PRIMARY KEY (glseries_id);


--
-- TOC entry 7090 (class 2606 OID 146571119)
-- Dependencies: 340 340 8894
-- Name: gltrans_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY gltrans
    ADD CONSTRAINT gltrans_pkey PRIMARY KEY (gltrans_id);

ALTER TABLE ONLY grp
    ADD CONSTRAINT grp_pkey PRIMARY KEY (grp_id);


--
-- TOC entry 7398 (class 2606 OID 146571125)
-- Dependencies: 603 603 8894
-- Name: grppriv_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY grppriv
    ADD CONSTRAINT grppriv_pkey PRIMARY KEY (grppriv_id);


--
-- TOC entry 7400 (class 2606 OID 146571127)
-- Dependencies: 605 605 8894
-- Name: hnfc_hnfc_code_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY hnfc
    ADD CONSTRAINT hnfc_hnfc_code_key UNIQUE (hnfc_code);


--
-- TOC entry 7402 (class 2606 OID 146571129)
-- Dependencies: 605 605 8894
-- Name: hnfc_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY hnfc
    ADD CONSTRAINT hnfc_pkey PRIMARY KEY (hnfc_id);


--
-- TOC entry 6943 (class 2606 OID 146571131)
-- Dependencies: 248 248 8894
-- Name: image_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY image
    ADD CONSTRAINT image_pkey PRIMARY KEY (image_id);


--
-- TOC entry 6945 (class 2606 OID 146571133)
-- Dependencies: 249 249 8894
-- Name: imageass_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY imageass
    ADD CONSTRAINT imageass_pkey PRIMARY KEY (imageass_id);


ALTER TABLE ONLY incdt
    ADD CONSTRAINT incdt_pkey PRIMARY KEY (incdt_id);


--
-- TOC entry 7020 (class 2606 OID 146571139)
-- Dependencies: 304 304 8894
-- Name: incdtcat_incdtcat_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY incdtcat
    ADD CONSTRAINT incdtcat_incdtcat_name_key UNIQUE (incdtcat_name);


--
-- TOC entry 7022 (class 2606 OID 146571141)
-- Dependencies: 304 304 8894
-- Name: incdtcat_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY incdtcat
    ADD CONSTRAINT incdtcat_pkey PRIMARY KEY (incdtcat_id);


--
-- TOC entry 7404 (class 2606 OID 146571143)
-- Dependencies: 609 609 8894
-- Name: incdthist_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY incdthist
    ADD CONSTRAINT incdthist_pkey PRIMARY KEY (incdthist_id);


--
-- TOC entry 7024 (class 2606 OID 146571145)
-- Dependencies: 305 305 8894
-- Name: incdtpriority_incdtpriority_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY incdtpriority
    ADD CONSTRAINT incdtpriority_incdtpriority_name_key UNIQUE (incdtpriority_name);


--
-- TOC entry 7026 (class 2606 OID 146571147)
-- Dependencies: 305 305 8894
-- Name: incdtpriority_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY incdtpriority
    ADD CONSTRAINT incdtpriority_pkey PRIMARY KEY (incdtpriority_id);


--
-- TOC entry 7028 (class 2606 OID 146571149)
-- Dependencies: 306 306 8894
-- Name: incdtresolution_incdtresolution_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY incdtresolution
    ADD CONSTRAINT incdtresolution_incdtresolution_name_key UNIQUE (incdtresolution_name);


--
-- TOC entry 7030 (class 2606 OID 146571151)
-- Dependencies: 306 306 8894
-- Name: incdtresolution_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY incdtresolution
    ADD CONSTRAINT incdtresolution_pkey PRIMARY KEY (incdtresolution_id);


--
-- TOC entry 7032 (class 2606 OID 146571153)
-- Dependencies: 307 307 8894
-- Name: incdtseverity_incdtseverity_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY incdtseverity
    ADD CONSTRAINT incdtseverity_incdtseverity_name_key UNIQUE (incdtseverity_name);


--
-- TOC entry 7034 (class 2606 OID 146571155)
-- Dependencies: 307 307 8894
-- Name: incdtseverity_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY incdtseverity
    ADD CONSTRAINT incdtseverity_pkey PRIMARY KEY (incdtseverity_id);


--
-- TOC entry 6805 (class 2606 OID 146571157)
-- Dependencies: 202 202 8894
-- Name: invbal_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY invbal
    ADD CONSTRAINT invbal_pkey PRIMARY KEY (invbal_id);


ALTER TABLE ONLY invchead
    ADD CONSTRAINT invchead_pkey PRIMARY KEY (invchead_id);


--
-- TOC entry 7406 (class 2606 OID 146571163)
-- Dependencies: 617 617 8894
-- Name: invcheadtax_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY invcheadtax
    ADD CONSTRAINT invcheadtax_pkey PRIMARY KEY (taxhist_id);


ALTER TABLE ONLY invcitem
    ADD CONSTRAINT invcitem_pkey PRIMARY KEY (invcitem_id);


--
-- TOC entry 7408 (class 2606 OID 146571169)
-- Dependencies: 619 619 8894
-- Name: invcitemtax_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY invcitemtax
    ADD CONSTRAINT invcitemtax_pkey PRIMARY KEY (taxhist_id);


--
-- TOC entry 6746 (class 2606 OID 146571171)
-- Dependencies: 190 190 8894
-- Name: invcnt_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY invcnt
    ADD CONSTRAINT invcnt_pkey PRIMARY KEY (invcnt_id);


--
-- TOC entry 7413 (class 2606 OID 146571173)
-- Dependencies: 621 621 8894
-- Name: invdetail_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY invdetail
    ADD CONSTRAINT invdetail_pkey PRIMARY KEY (invdetail_id);


--
-- TOC entry 7418 (class 2606 OID 146571175)
-- Dependencies: 623 623 8894
-- Name: invhist_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY invhist
    ADD CONSTRAINT invhist_pkey PRIMARY KEY (invhist_id);


--
-- TOC entry 7423 (class 2606 OID 146571177)
-- Dependencies: 625 625 625 8894
-- Name: invhistexpcat_invhist_id_expcat_id; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY invhistexpcat
    ADD CONSTRAINT invhistexpcat_invhist_id_expcat_id UNIQUE (invhistexpcat_invhist_id, invhistexpcat_expcat_id);


--
-- TOC entry 7425 (class 2606 OID 146571179)
-- Dependencies: 625 625 8894
-- Name: invhistexpcat_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY invhistexpcat
    ADD CONSTRAINT invhistexpcat_pkey PRIMARY KEY (invhistexpcat_id);


ALTER TABLE ONLY ipsass
    ADD CONSTRAINT ipsass_pkey PRIMARY KEY (ipsass_id);


--
-- TOC entry 7014 (class 2606 OID 146571185)
-- Dependencies: 300 300 8894
-- Name: ipsfreight_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY ipsfreight
    ADD CONSTRAINT ipsfreight_pkey PRIMARY KEY (ipsfreight_id);


ALTER TABLE ONLY ipshead
    ADD CONSTRAINT ipshead_pkey PRIMARY KEY (ipshead_id);


--
-- TOC entry 7103 (class 2606 OID 146571191)
-- Dependencies: 349 349 349 349 349 349 349 8894
-- Name: ipsitem_ipsitem_ipshead_id_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY ipsiteminfo
    ADD CONSTRAINT ipsitem_ipsitem_ipshead_id_key UNIQUE (ipsitem_ipshead_id, ipsitem_item_id, ipsitem_prodcat_id, ipsitem_qtybreak, ipsitem_qty_uom_id, ipsitem_price_uom_id);


--
-- TOC entry 7105 (class 2606 OID 146571193)
-- Dependencies: 349 349 8894
-- Name: ipsitem_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY ipsiteminfo
    ADD CONSTRAINT ipsitem_pkey PRIMARY KEY (ipsitem_id);


--
-- TOC entry 7107 (class 2606 OID 146571195)
-- Dependencies: 351 351 351 351 8894
-- Name: ipsitemchar_ipsitemchar_ipsitem_id_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY ipsitemchar
    ADD CONSTRAINT ipsitemchar_ipsitemchar_ipsitem_id_key UNIQUE (ipsitemchar_ipsitem_id, ipsitemchar_char_id, ipsitemchar_value);


--
-- TOC entry 7109 (class 2606 OID 146571197)
-- Dependencies: 351 351 351 351 8894
-- Name: ipsitemchar_ipsitemchar_ipsitem_id_key1; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY ipsitemchar
    ADD CONSTRAINT ipsitemchar_ipsitemchar_ipsitem_id_key1 UNIQUE (ipsitemchar_ipsitem_id, ipsitemchar_char_id, ipsitemchar_value);


--
-- TOC entry 7111 (class 2606 OID 146571199)
-- Dependencies: 351 351 8894
-- Name: ipsitemchar_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY ipsitemchar
    ADD CONSTRAINT ipsitemchar_pkey PRIMARY KEY (ipsitemchar_id);


--
-- TOC entry 7427 (class 2606 OID 146571201)
-- Dependencies: 636 636 8894
-- Name: ipsprodcat_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY ipsprodcat_bak
    ADD CONSTRAINT ipsprodcat_pkey PRIMARY KEY (ipsprodcat_id);


ALTER TABLE ONLY item
    ADD CONSTRAINT item_pkey PRIMARY KEY (item_id);


ALTER TABLE ONLY itemalias
    ADD CONSTRAINT itemalias_pkey PRIMARY KEY (itemalias_id);


--
-- TOC entry 7054 (class 2606 OID 146571211)
-- Dependencies: 321 321 8894
-- Name: itemcost_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY itemcost
    ADD CONSTRAINT itemcost_pkey PRIMARY KEY (itemcost_id);


--
-- TOC entry 7429 (class 2606 OID 146571213)
-- Dependencies: 643 643 8894
-- Name: itemgrp_itemgrp_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY itemgrp
    ADD CONSTRAINT itemgrp_itemgrp_name_key UNIQUE (itemgrp_name);


--
-- TOC entry 7431 (class 2606 OID 146571215)
-- Dependencies: 643 643 8894
-- Name: itemgrp_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY itemgrp
    ADD CONSTRAINT itemgrp_pkey PRIMARY KEY (itemgrp_id);


--
-- TOC entry 7433 (class 2606 OID 146571217)
-- Dependencies: 645 645 8894
-- Name: itemgrpitem_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY itemgrpitem
    ADD CONSTRAINT itemgrpitem_pkey PRIMARY KEY (itemgrpitem_id);


--
-- TOC entry 7435 (class 2606 OID 146571219)
-- Dependencies: 645 645 645 645 8894
-- Name: itemgrpitem_unique_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY itemgrpitem
    ADD CONSTRAINT itemgrpitem_unique_key UNIQUE (itemgrpitem_itemgrp_id, itemgrpitem_item_id, itemgrpitem_item_type);


--
-- TOC entry 7439 (class 2606 OID 146571221)
-- Dependencies: 649 649 8894
-- Name: itemloc_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY itemloc
    ADD CONSTRAINT itemloc_pkey PRIMARY KEY (itemloc_id);


ALTER TABLE ONLY itemlocdist
    ADD CONSTRAINT itemlocdist_pkey PRIMARY KEY (itemlocdist_id);


--
-- TOC entry 7443 (class 2606 OID 146571225)
-- Dependencies: 654 654 8894
-- Name: itemlocpost_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY itemlocpost
    ADD CONSTRAINT itemlocpost_pkey PRIMARY KEY (itemlocpost_id);


ALTER TABLE ONLY itemsite
    ADD CONSTRAINT itemsite_pkey PRIMARY KEY (itemsite_id);


--
-- TOC entry 7067 (class 2606 OID 146571229)
-- Dependencies: 330 330 330 330 330 330 330 330 330 8894
-- Name: itemsrc_itemsrc_vend_id_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY itemsrc
    ADD CONSTRAINT itemsrc_itemsrc_vend_id_key UNIQUE (itemsrc_vend_id, itemsrc_item_id, itemsrc_effective, itemsrc_expires, itemsrc_vend_item_number, itemsrc_manuf_name, itemsrc_manuf_item_number, itemsrc_contrct_id);


--
-- TOC entry 7069 (class 2606 OID 146571231)
-- Dependencies: 330 330 8894
-- Name: itemsrc_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY itemsrc
    ADD CONSTRAINT itemsrc_pkey PRIMARY KEY (itemsrc_id);


--
-- TOC entry 7073 (class 2606 OID 146571233)
-- Dependencies: 332 332 332 332 332 8894
-- Name: itemsrcp_itemsrcp_itemsrc_id_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY itemsrcp
    ADD CONSTRAINT itemsrcp_itemsrcp_itemsrc_id_key UNIQUE (itemsrcp_itemsrc_id, itemsrcp_warehous_id, itemsrcp_dropship, itemsrcp_qtybreak);


--
-- TOC entry 7075 (class 2606 OID 146571235)
-- Dependencies: 332 332 8894
-- Name: itemsrcp_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY itemsrcp
    ADD CONSTRAINT itemsrcp_pkey PRIMARY KEY (itemsrcp_id);


--
-- TOC entry 7077 (class 2606 OID 146571237)
-- Dependencies: 334 334 334 8894
-- Name: itemsub_itemsub_parent_item_id_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY itemsub
    ADD CONSTRAINT itemsub_itemsub_parent_item_id_key UNIQUE (itemsub_parent_item_id, itemsub_sub_item_id);


--
-- TOC entry 7080 (class 2606 OID 146571239)
-- Dependencies: 334 334 8894
-- Name: itemsub_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY itemsub
    ADD CONSTRAINT itemsub_pkey PRIMARY KEY (itemsub_id);


--
-- TOC entry 7083 (class 2606 OID 146571241)
-- Dependencies: 336 336 8894
-- Name: itemtax_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY itemtax
    ADD CONSTRAINT itemtax_pkey PRIMARY KEY (itemtax_id);


--
-- TOC entry 7445 (class 2606 OID 146571243)
-- Dependencies: 662 662 662 8894
-- Name: itemtrans_itemtrans_source_item_id_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY itemtrans
    ADD CONSTRAINT itemtrans_itemtrans_source_item_id_key UNIQUE (itemtrans_source_item_id, itemtrans_target_item_id);


--
-- TOC entry 7447 (class 2606 OID 146571245)
-- Dependencies: 662 662 8894
-- Name: itemtrans_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY itemtrans
    ADD CONSTRAINT itemtrans_pkey PRIMARY KEY (itemtrans_id);


--
-- TOC entry 7449 (class 2606 OID 146571247)
-- Dependencies: 664 664 8894
-- Name: itemuom_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY itemuom
    ADD CONSTRAINT itemuom_pkey PRIMARY KEY (itemuom_id);


ALTER TABLE ONLY itemuomconv
    ADD CONSTRAINT itemuomconv_pkey PRIMARY KEY (itemuomconv_id);


--
-- TOC entry 7451 (class 2606 OID 146571251)
-- Dependencies: 668 668 8894
-- Name: jrnluse_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY jrnluse
    ADD CONSTRAINT jrnluse_pkey PRIMARY KEY (jrnluse_id);


--
-- TOC entry 7453 (class 2606 OID 146571253)
-- Dependencies: 670 670 8894
-- Name: labeldef_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY labeldef
    ADD CONSTRAINT labeldef_pkey PRIMARY KEY (labeldef_id);


--
-- TOC entry 7455 (class 2606 OID 146571255)
-- Dependencies: 672 672 8894
-- Name: labelform_labelform_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY labelform
    ADD CONSTRAINT labelform_labelform_name_key UNIQUE (labelform_name);


--
-- TOC entry 7457 (class 2606 OID 146571257)
-- Dependencies: 672 672 8894
-- Name: labelform_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY labelform
    ADD CONSTRAINT labelform_pkey PRIMARY KEY (labelform_id);


--
-- TOC entry 7459 (class 2606 OID 146571259)
-- Dependencies: 674 674 8894
-- Name: lang_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY lang
    ADD CONSTRAINT lang_pkey PRIMARY KEY (lang_id);


--
-- TOC entry 7461 (class 2606 OID 146571261)
-- Dependencies: 676 676 8894
-- Name: locale_locale_code_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY locale
    ADD CONSTRAINT locale_locale_code_key UNIQUE (locale_code);


--
-- TOC entry 7463 (class 2606 OID 146571263)
-- Dependencies: 676 676 8894
-- Name: locale_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY locale
    ADD CONSTRAINT locale_pkey PRIMARY KEY (locale_id);


--
-- TOC entry 7093 (class 2606 OID 146571265)
-- Dependencies: 342 342 8894
-- Name: location_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY location
    ADD CONSTRAINT location_pkey PRIMARY KEY (location_id);


--
-- TOC entry 7465 (class 2606 OID 146571267)
-- Dependencies: 679 679 8894
-- Name: locitem_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY locitem
    ADD CONSTRAINT locitem_pkey PRIMARY KEY (locitem_id);


--
-- TOC entry 7173 (class 2606 OID 146571269)
-- Dependencies: 405 405 405 405 8894
-- Name: metasql_metasql_group_name_grade_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY metasql
    ADD CONSTRAINT metasql_metasql_group_name_grade_key UNIQUE (metasql_group, metasql_name, metasql_grade);


--
-- TOC entry 7175 (class 2606 OID 146571271)
-- Dependencies: 405 405 8894
-- Name: metasql_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY metasql
    ADD CONSTRAINT metasql_pkey PRIMARY KEY (metasql_id);


--
-- TOC entry 7467 (class 2606 OID 146571273)
-- Dependencies: 682 682 8894
-- Name: metric_metric_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY metric
    ADD CONSTRAINT metric_metric_name_key UNIQUE (metric_name);


--
-- TOC entry 7469 (class 2606 OID 146571275)
-- Dependencies: 682 682 8894
-- Name: metric_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY metric
    ADD CONSTRAINT metric_pkey PRIMARY KEY (metric_id);


--
-- TOC entry 7471 (class 2606 OID 146571277)
-- Dependencies: 684 684 8894
-- Name: metricenc_metricenc_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY metricenc
    ADD CONSTRAINT metricenc_metricenc_name_key UNIQUE (metricenc_name);


--
-- TOC entry 7473 (class 2606 OID 146571279)
-- Dependencies: 684 684 8894
-- Name: metricenc_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY metricenc
    ADD CONSTRAINT metricenc_pkey PRIMARY KEY (metricenc_id);


--
-- TOC entry 7475 (class 2606 OID 146571281)
-- Dependencies: 687 687 687 687 687 687 8894
-- Name: mrghist_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY mrghist
    ADD CONSTRAINT mrghist_pkey PRIMARY KEY (mrghist_cntct_id, mrghist_table, mrghist_pkey_col, mrghist_pkey_id, mrghist_cntct_col);


--
-- TOC entry 7477 (class 2606 OID 146571283)
-- Dependencies: 688 688 688 688 688 688 8894
-- Name: mrgundo_mrgundo_schema_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY mrgundo
    ADD CONSTRAINT mrgundo_mrgundo_schema_key UNIQUE (mrgundo_schema, mrgundo_table, mrgundo_pkey_col, mrgundo_pkey_id, mrgundo_col);


--
-- TOC entry 7479 (class 2606 OID 146571285)
-- Dependencies: 689 689 8894
-- Name: msg_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY msg
    ADD CONSTRAINT msg_pkey PRIMARY KEY (msg_id);


--
-- TOC entry 7481 (class 2606 OID 146571287)
-- Dependencies: 691 691 8894
-- Name: msguser_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY msguser
    ADD CONSTRAINT msguser_pkey PRIMARY KEY (msguser_id);

ALTER TABLE ONLY ophead
    ADD CONSTRAINT ophead_pkey PRIMARY KEY (ophead_id);


--
-- TOC entry 7485 (class 2606 OID 146571295)
-- Dependencies: 696 696 8894
-- Name: opsource_opsource_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY opsource
    ADD CONSTRAINT opsource_opsource_name_key UNIQUE (opsource_name);


--
-- TOC entry 7487 (class 2606 OID 146571297)
-- Dependencies: 696 696 8894
-- Name: opsource_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY opsource
    ADD CONSTRAINT opsource_pkey PRIMARY KEY (opsource_id);


--
-- TOC entry 7489 (class 2606 OID 146571299)
-- Dependencies: 698 698 8894
-- Name: opstage_opstage_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY opstage
    ADD CONSTRAINT opstage_opstage_name_key UNIQUE (opstage_name);


--
-- TOC entry 7491 (class 2606 OID 146571301)
-- Dependencies: 698 698 8894
-- Name: opstage_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY opstage
    ADD CONSTRAINT opstage_pkey PRIMARY KEY (opstage_id);


--
-- TOC entry 7493 (class 2606 OID 146571303)
-- Dependencies: 700 700 8894
-- Name: optype_optype_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY optype
    ADD CONSTRAINT optype_optype_name_key UNIQUE (optype_name);


--
-- TOC entry 7495 (class 2606 OID 146571305)
-- Dependencies: 700 700 8894
-- Name: optype_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY optype
    ADD CONSTRAINT optype_pkey PRIMARY KEY (optype_id);


--
-- TOC entry 7497 (class 2606 OID 146571307)
-- Dependencies: 704 704 8894
-- Name: orderseq_orderseq_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY orderseq
    ADD CONSTRAINT orderseq_orderseq_name_key UNIQUE (orderseq_name);


--
-- TOC entry 7499 (class 2606 OID 146571309)
-- Dependencies: 704 704 8894
-- Name: orderseq_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY orderseq
    ADD CONSTRAINT orderseq_pkey PRIMARY KEY (orderseq_id);


ALTER TABLE ONLY pack
    ADD CONSTRAINT pack_pkey PRIMARY KEY (pack_id);


--
-- TOC entry 7505 (class 2606 OID 146571313)
-- Dependencies: 708 708 708 8894
-- Name: payaropen_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY payaropen
    ADD CONSTRAINT payaropen_pkey PRIMARY KEY (payaropen_ccpay_id, payaropen_aropen_id);


--
-- TOC entry 6960 (class 2606 OID 146571315)
-- Dependencies: 264 264 8894
-- Name: period_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY period
    ADD CONSTRAINT period_pkey PRIMARY KEY (period_id);


--
-- TOC entry 7538 (class 2606 OID 146571317)
-- Dependencies: 739 739 8894
-- Name: pk_prjtype; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY prjtype
    ADD CONSTRAINT pk_prjtype PRIMARY KEY (prjtype_id);






--
-- TOC entry 7060 (class 2606 OID 146571329)
-- Dependencies: 326 326 8894
-- Name: plancode_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY plancode
    ADD CONSTRAINT plancode_pkey PRIMARY KEY (plancode_id);


--
-- TOC entry 7062 (class 2606 OID 146571331)
-- Dependencies: 326 326 8894
-- Name: plancode_plancode_code_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY plancode
    ADD CONSTRAINT plancode_plancode_code_key UNIQUE (plancode_code);


ALTER TABLE ONLY pohead
    ADD CONSTRAINT pohead_pkey PRIMARY KEY (pohead_id);

ALTER TABLE ONLY poitem
    ADD CONSTRAINT poitem_pkey PRIMARY KEY (poitem_id);

ALTER TABLE ONLY poreject
    ADD CONSTRAINT poreject_pkey PRIMARY KEY (poreject_id);

--
-- TOC entry 7526 (class 2606 OID 146571345)
-- Dependencies: 728 728 8894
-- Name: pr_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY pr
    ADD CONSTRAINT pr_pkey PRIMARY KEY (pr_id);


--
-- TOC entry 7528 (class 2606 OID 146571347)
-- Dependencies: 730 730 8894
-- Name: prftcntr_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY prftcntr
    ADD CONSTRAINT prftcntr_pkey PRIMARY KEY (prftcntr_id);


--
-- TOC entry 7530 (class 2606 OID 146571349)
-- Dependencies: 730 730 8894
-- Name: prftcntr_prftcntr_number_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY prftcntr
    ADD CONSTRAINT prftcntr_prftcntr_number_key UNIQUE (prftcntr_number);

ALTER TABLE ONLY priv
    ADD CONSTRAINT priv_pkey PRIMARY KEY (priv_id);


ALTER TABLE ONLY prj
    ADD CONSTRAINT prj_pkey PRIMARY KEY (prj_id);

ALTER TABLE ONLY prjtask
    ADD CONSTRAINT prjtask_pkey PRIMARY KEY (prjtask_id);


--
-- TOC entry 7536 (class 2606 OID 146571361)
-- Dependencies: 737 737 8894
-- Name: prjtaskuser_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY prjtaskuser
    ADD CONSTRAINT prjtaskuser_pkey PRIMARY KEY (prjtaskuser_id);


--
-- TOC entry 7040 (class 2606 OID 146571363)
-- Dependencies: 314 314 8894
-- Name: prodcat_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY prodcat
    ADD CONSTRAINT prodcat_pkey PRIMARY KEY (prodcat_id);


--
-- TOC entry 7042 (class 2606 OID 146571365)
-- Dependencies: 314 314 8894
-- Name: prodcat_prodcat_code_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY prodcat
    ADD CONSTRAINT prodcat_prodcat_code_key UNIQUE (prodcat_code);

ALTER TABLE ONLY prospect
    ADD CONSTRAINT prospect_pkey PRIMARY KEY (prospect_id);


--
-- TOC entry 7542 (class 2606 OID 146571371)
-- Dependencies: 742 742 8894
-- Name: qryhead_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY qryhead
    ADD CONSTRAINT qryhead_pkey PRIMARY KEY (qryhead_id);


--
-- TOC entry 7544 (class 2606 OID 146571373)
-- Dependencies: 742 742 8894
-- Name: qryhead_qryhead_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY qryhead
    ADD CONSTRAINT qryhead_qryhead_name_key UNIQUE (qryhead_name);


--
-- TOC entry 7546 (class 2606 OID 146571375)
-- Dependencies: 744 744 744 8894
-- Name: qryitem_qryitem_qryhead_id_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY qryitem
    ADD CONSTRAINT qryitem_qryitem_qryhead_id_key UNIQUE (qryitem_qryhead_id, qryitem_name);


--
-- TOC entry 7548 (class 2606 OID 146571377)
-- Dependencies: 744 744 744 8894
-- Name: qryitem_qryitem_qryhead_id_key1; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY qryitem
    ADD CONSTRAINT qryitem_qryitem_qryhead_id_key1 UNIQUE (qryitem_qryhead_id, qryitem_order);


ALTER TABLE ONLY quhead
    ADD CONSTRAINT quhead_pkey PRIMARY KEY (quhead_id);


ALTER TABLE ONLY quitem
    ADD CONSTRAINT quitem_pkey PRIMARY KEY (quitem_id);


--
-- TOC entry 7550 (class 2606 OID 146571385)
-- Dependencies: 748 748 8894
-- Name: rcalitem_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY rcalitem
    ADD CONSTRAINT rcalitem_pkey PRIMARY KEY (rcalitem_id);


--
-- TOC entry 7556 (class 2606 OID 146571391)
-- Dependencies: 751 751 8894
-- Name: recurtype_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY recurtype
    ADD CONSTRAINT recurtype_pkey PRIMARY KEY (recurtype_id);


--
-- TOC entry 7558 (class 2606 OID 146571393)
-- Dependencies: 751 751 8894
-- Name: recurtype_recurtype_type_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY recurtype
    ADD CONSTRAINT recurtype_recurtype_type_key UNIQUE (recurtype_type);


--
-- TOC entry 7520 (class 2606 OID 146571395)
-- Dependencies: 721 721 8894
-- Name: recv_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY recv
    ADD CONSTRAINT recv_pkey PRIMARY KEY (recv_id);


--
-- TOC entry 7185 (class 2606 OID 146571397)
-- Dependencies: 411 411 8894
-- Name: report_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY report
    ADD CONSTRAINT report_pkey PRIMARY KEY (report_id);


--
-- TOC entry 7560 (class 2606 OID 146571399)
-- Dependencies: 755 755 8894
-- Name: rjctcode_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY rjctcode
    ADD CONSTRAINT rjctcode_pkey PRIMARY KEY (rjctcode_id);


--
-- TOC entry 7562 (class 2606 OID 146571401)
-- Dependencies: 755 755 8894
-- Name: rjctcode_rjctcode_code_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY rjctcode
    ADD CONSTRAINT rjctcode_rjctcode_code_key UNIQUE (rjctcode_code);


--
-- TOC entry 6858 (class 2606 OID 146571403)
-- Dependencies: 214 214 8894
-- Name: rsncode_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY rsncode
    ADD CONSTRAINT rsncode_pkey PRIMARY KEY (rsncode_id);


--
-- TOC entry 6860 (class 2606 OID 146571405)
-- Dependencies: 214 214 8894
-- Name: rsncode_rsncode_code_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY rsncode
    ADD CONSTRAINT rsncode_rsncode_code_key UNIQUE (rsncode_code);


--
-- TOC entry 7564 (class 2606 OID 146571407)
-- Dependencies: 758 758 8894
-- Name: sale_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY sale
    ADD CONSTRAINT sale_pkey PRIMARY KEY (sale_id);


--
-- TOC entry 7566 (class 2606 OID 146571409)
-- Dependencies: 758 758 8894
-- Name: sale_sale_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY sale
    ADD CONSTRAINT sale_sale_name_key UNIQUE (sale_name);


--
-- TOC entry 7324 (class 2606 OID 146571411)
-- Dependencies: 540 540 8894
-- Name: salesaccnt_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY salesaccnt
    ADD CONSTRAINT salesaccnt_pkey PRIMARY KEY (salesaccnt_id);


--
-- TOC entry 6862 (class 2606 OID 146571413)
-- Dependencies: 215 215 8894
-- Name: salescat_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY salescat
    ADD CONSTRAINT salescat_pkey PRIMARY KEY (salescat_id);


--
-- TOC entry 6864 (class 2606 OID 146571415)
-- Dependencies: 215 215 8894
-- Name: salescat_salescat_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY salescat
    ADD CONSTRAINT salescat_salescat_name_key UNIQUE (salescat_name);

ALTER TABLE ONLY salesrep
    ADD CONSTRAINT salesrep_pkey PRIMARY KEY (salesrep_id);

ALTER TABLE ONLY saletype
    ADD CONSTRAINT saletype_pkey PRIMARY KEY (saletype_id);


--
-- TOC entry 7568 (class 2606 OID 146571423)
-- Dependencies: 766 766 8894
-- Name: schemaord_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY schemaord
    ADD CONSTRAINT schemaord_pkey PRIMARY KEY (schemaord_id);


--
-- TOC entry 7570 (class 2606 OID 146571425)
-- Dependencies: 766 766 8894
-- Name: schemaord_schemaord_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY schemaord
    ADD CONSTRAINT schemaord_schemaord_name_key UNIQUE (schemaord_name);


--
-- TOC entry 7572 (class 2606 OID 146571427)
-- Dependencies: 766 766 8894
-- Name: schemaord_schemaord_order_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY schemaord
    ADD CONSTRAINT schemaord_schemaord_order_key UNIQUE (schemaord_order);


--
-- TOC entry 7189 (class 2606 OID 146571429)
-- Dependencies: 414 414 8894
-- Name: script_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY script
    ADD CONSTRAINT script_pkey PRIMARY KEY (script_id);


--
-- TOC entry 7005 (class 2606 OID 146571431)
-- Dependencies: 293 293 8894
-- Name: shift_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY shift
    ADD CONSTRAINT shift_pkey PRIMARY KEY (shift_id);


--
-- TOC entry 6983 (class 2606 OID 146571433)
-- Dependencies: 281 281 8894
-- Name: shipchrg_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY shipchrg
    ADD CONSTRAINT shipchrg_pkey PRIMARY KEY (shipchrg_id);


--
-- TOC entry 7008 (class 2606 OID 146571435)
-- Dependencies: 297 297 297 297 297 8894
-- Name: shipdata_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY shipdata
    ADD CONSTRAINT shipdata_pkey PRIMARY KEY (shipdata_cohead_number, shipdata_cosmisc_tracknum, shipdata_cosmisc_packnum_tracknum, shipdata_void_ind);


--
-- TOC entry 7576 (class 2606 OID 146571437)
-- Dependencies: 771 771 771 771 8894
-- Name: shipdatasum_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY shipdatasum
    ADD CONSTRAINT shipdatasum_pkey PRIMARY KEY (shipdatasum_cohead_number, shipdatasum_cosmisc_tracknum, shipdatasum_cosmisc_packnum_tracknum);


--
-- TOC entry 6985 (class 2606 OID 146571439)
-- Dependencies: 282 282 8894
-- Name: shipform_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY shipform
    ADD CONSTRAINT shipform_pkey PRIMARY KEY (shipform_id);


--
-- TOC entry 6987 (class 2606 OID 146571441)
-- Dependencies: 282 282 8894
-- Name: shipform_shipform_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY shipform
    ADD CONSTRAINT shipform_shipform_name_key UNIQUE (shipform_name);

ALTER TABLE ONLY shiphead
    ADD CONSTRAINT shiphead_pkey PRIMARY KEY (shiphead_id);

-- required to meet a f-key constraint later
ALTER TABLE ONLY shiphead
    ADD CONSTRAINT shiphead_shiphead_number_key UNIQUE (shiphead_number);

--
-- TOC entry 7311 (class 2606 OID 146571447)
-- Dependencies: 527 527 8894
-- Name: shipitem_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY shipitem
    ADD CONSTRAINT shipitem_pkey PRIMARY KEY (shipitem_id);


ALTER TABLE ONLY shiptoinfo
    ADD CONSTRAINT shipto_pkey PRIMARY KEY (shipto_id);


--
-- TOC entry 7151 (class 2606 OID 146571453)
-- Dependencies: 386 386 8894
-- Name: shipvia_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY shipvia
    ADD CONSTRAINT shipvia_pkey PRIMARY KEY (shipvia_id);


--
-- TOC entry 7153 (class 2606 OID 146571455)
-- Dependencies: 386 386 8894
-- Name: shipvia_shipvia_code_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY shipvia
    ADD CONSTRAINT shipvia_shipvia_code_key UNIQUE (shipvia_code);


--
-- TOC entry 6898 (class 2606 OID 146571457)
-- Dependencies: 227 227 8894
-- Name: shipzone_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY shipzone
    ADD CONSTRAINT shipzone_pkey PRIMARY KEY (shipzone_id);


--
-- TOC entry 6900 (class 2606 OID 146571459)
-- Dependencies: 227 227 8894
-- Name: shipzone_shipzone_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY shipzone
    ADD CONSTRAINT shipzone_shipzone_name_key UNIQUE (shipzone_name);


--
-- TOC entry 7155 (class 2606 OID 146571461)
-- Dependencies: 387 387 8894
-- Name: sitetype_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY sitetype
    ADD CONSTRAINT sitetype_pkey PRIMARY KEY (sitetype_id);


--
-- TOC entry 7157 (class 2606 OID 146571463)
-- Dependencies: 387 387 8894
-- Name: sitetype_sitetype_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY sitetype
    ADD CONSTRAINT sitetype_sitetype_name_key UNIQUE (sitetype_name);


--
-- TOC entry 7578 (class 2606 OID 146571465)
-- Dependencies: 781 781 8894
-- Name: sltrans_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY sltrans
    ADD CONSTRAINT sltrans_pkey PRIMARY KEY (sltrans_id);

ALTER TABLE ONLY source
    ADD CONSTRAINT source_pkey PRIMARY KEY (source_id);


--
-- TOC entry 7588 (class 2606 OID 146571471)
-- Dependencies: 787 787 8894
-- Name: state_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY state
    ADD CONSTRAINT state_pkey PRIMARY KEY (state_id);


--
-- TOC entry 7590 (class 2606 OID 146571473)
-- Dependencies: 787 787 787 8894
-- Name: state_state_country_id_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY state
    ADD CONSTRAINT state_state_country_id_key UNIQUE (state_country_id, state_name);


--
-- TOC entry 7592 (class 2606 OID 146571475)
-- Dependencies: 789 789 8894
-- Name: status_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY status
    ADD CONSTRAINT status_pkey PRIMARY KEY (status_id);


--
-- TOC entry 7594 (class 2606 OID 146571477)
-- Dependencies: 789 789 789 8894
-- Name: status_status_type_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY status
    ADD CONSTRAINT status_status_type_key UNIQUE (status_type, status_code);


--
-- TOC entry 7596 (class 2606 OID 146571479)
-- Dependencies: 791 791 8894
-- Name: stdjrnl_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY stdjrnl
    ADD CONSTRAINT stdjrnl_pkey PRIMARY KEY (stdjrnl_id);


--
-- TOC entry 7598 (class 2606 OID 146571481)
-- Dependencies: 791 791 8894
-- Name: stdjrnl_stdjrnl_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY stdjrnl
    ADD CONSTRAINT stdjrnl_stdjrnl_name_key UNIQUE (stdjrnl_name);


--
-- TOC entry 7600 (class 2606 OID 146571483)
-- Dependencies: 793 793 8894
-- Name: stdjrnlgrp_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY stdjrnlgrp
    ADD CONSTRAINT stdjrnlgrp_pkey PRIMARY KEY (stdjrnlgrp_id);


--
-- TOC entry 7602 (class 2606 OID 146571485)
-- Dependencies: 793 793 8894
-- Name: stdjrnlgrp_stdjrnlgrp_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY stdjrnlgrp
    ADD CONSTRAINT stdjrnlgrp_stdjrnlgrp_name_key UNIQUE (stdjrnlgrp_name);


--
-- TOC entry 7604 (class 2606 OID 146571487)
-- Dependencies: 795 795 8894
-- Name: stdjrnlgrpitem_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY stdjrnlgrpitem
    ADD CONSTRAINT stdjrnlgrpitem_pkey PRIMARY KEY (stdjrnlgrpitem_id);


--
-- TOC entry 7606 (class 2606 OID 146571489)
-- Dependencies: 797 797 8894
-- Name: stdjrnlitem_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY stdjrnlitem
    ADD CONSTRAINT stdjrnlitem_pkey PRIMARY KEY (stdjrnlitem_id);


--
-- TOC entry 7608 (class 2606 OID 146571491)
-- Dependencies: 799 799 8894
-- Name: subaccnt_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY subaccnt
    ADD CONSTRAINT subaccnt_pkey PRIMARY KEY (subaccnt_id);


--
-- TOC entry 7610 (class 2606 OID 146571493)
-- Dependencies: 799 799 8894
-- Name: subaccnt_subaccnt_number_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY subaccnt
    ADD CONSTRAINT subaccnt_subaccnt_number_key UNIQUE (subaccnt_number);


--
-- TOC entry 7613 (class 2606 OID 146571495)
-- Dependencies: 801 801 8894
-- Name: subaccnttype_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY subaccnttype
    ADD CONSTRAINT subaccnttype_pkey PRIMARY KEY (subaccnttype_id);

ALTER TABLE ONLY tax
    ADD CONSTRAINT tax_pkey PRIMARY KEY (tax_id);

ALTER TABLE ONLY taxass
    ADD CONSTRAINT taxass_pkey PRIMARY KEY (taxass_id);

ALTER TABLE ONLY taxauth
    ADD CONSTRAINT taxauth_pkey PRIMARY KEY (taxauth_id);


--
-- TOC entry 7619 (class 2606 OID 146571507)
-- Dependencies: 807 807 8894
-- Name: taxclass_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY taxclass
    ADD CONSTRAINT taxclass_pkey PRIMARY KEY (taxclass_id);


--
-- TOC entry 7621 (class 2606 OID 146571509)
-- Dependencies: 807 807 8894
-- Name: taxclass_taxclass_code_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY taxclass
    ADD CONSTRAINT taxclass_taxclass_code_key UNIQUE (taxclass_code);

ALTER TABLE ONLY taxhist
    ADD CONSTRAINT taxhist_pkey PRIMARY KEY (taxhist_id);


--
-- TOC entry 7623 (class 2606 OID 146571513)
-- Dependencies: 809 809 8894
-- Name: taxrate_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY taxrate
    ADD CONSTRAINT taxrate_pkey PRIMARY KEY (taxrate_id);


--
-- TOC entry 6993 (class 2606 OID 146571515)
-- Dependencies: 285 285 8894
-- Name: taxreg_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY taxreg
    ADD CONSTRAINT taxreg_pkey PRIMARY KEY (taxreg_id);


--
-- TOC entry 6797 (class 2606 OID 146571517)
-- Dependencies: 199 199 8894
-- Name: taxtype_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY taxtype
    ADD CONSTRAINT taxtype_pkey PRIMARY KEY (taxtype_id);


--
-- TOC entry 6799 (class 2606 OID 146571519)
-- Dependencies: 199 199 8894
-- Name: taxtype_taxtype_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY taxtype
    ADD CONSTRAINT taxtype_taxtype_name_key UNIQUE (taxtype_name);


--
-- TOC entry 6879 (class 2606 OID 146571521)
-- Dependencies: 220 220 8894
-- Name: taxzone_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY taxzone
    ADD CONSTRAINT taxzone_pkey PRIMARY KEY (taxzone_id);


--
-- TOC entry 6881 (class 2606 OID 146571523)
-- Dependencies: 220 220 8894
-- Name: taxzone_taxzone_code_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY taxzone
    ADD CONSTRAINT taxzone_taxzone_code_key UNIQUE (taxzone_code);


--
-- TOC entry 6837 (class 2606 OID 146571525)
-- Dependencies: 209 209 8894
-- Name: terms_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY terms
    ADD CONSTRAINT terms_pkey PRIMARY KEY (terms_id);


--
-- TOC entry 6839 (class 2606 OID 146571527)
-- Dependencies: 209 209 8894
-- Name: terms_terms_code_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY terms
    ADD CONSTRAINT terms_terms_code_key UNIQUE (terms_code);


--
-- TOC entry 6916 (class 2606 OID 146571529)
-- Dependencies: 233 233 8894
-- Name: todoitem_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY todoitem
    ADD CONSTRAINT todoitem_pkey PRIMARY KEY (todoitem_id);


--
-- TOC entry 7626 (class 2606 OID 146571531)
-- Dependencies: 817 817 8894
-- Name: trialbal_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY trialbal
    ADD CONSTRAINT trialbal_pkey PRIMARY KEY (trialbal_id);

ALTER TABLE ONLY uiform
    ADD CONSTRAINT uiform_pkey PRIMARY KEY (uiform_id);


--
-- TOC entry 7540 (class 2606 OID 146571535)
-- Dependencies: 739 739 8894
-- Name: unq_prjtype_code; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY prjtype
    ADD CONSTRAINT unq_prjtype_code UNIQUE (prjtype_code);


--
-- TOC entry 6801 (class 2606 OID 146571537)
-- Dependencies: 200 200 8894
-- Name: uom_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY uom
    ADD CONSTRAINT uom_pkey PRIMARY KEY (uom_id);


--
-- TOC entry 6803 (class 2606 OID 146571539)
-- Dependencies: 200 200 8894
-- Name: uom_uom_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY uom
    ADD CONSTRAINT uom_uom_name_key UNIQUE (uom_name);


--
-- TOC entry 7628 (class 2606 OID 146571541)
-- Dependencies: 820 820 8894
-- Name: uomconv_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY uomconv
    ADD CONSTRAINT uomconv_pkey PRIMARY KEY (uomconv_id);


--
-- TOC entry 7630 (class 2606 OID 146571543)
-- Dependencies: 822 822 8894
-- Name: uomtype_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY uomtype
    ADD CONSTRAINT uomtype_pkey PRIMARY KEY (uomtype_id);


--
-- TOC entry 7632 (class 2606 OID 146571545)
-- Dependencies: 822 822 8894
-- Name: uomtype_uomtype_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY uomtype
    ADD CONSTRAINT uomtype_uomtype_name_key UNIQUE (uomtype_name);


--
-- TOC entry 6941 (class 2606 OID 146571547)
-- Dependencies: 244 244 8894
-- Name: urlinfo_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY urlinfo
    ADD CONSTRAINT urlinfo_pkey PRIMARY KEY (url_id);


--
-- TOC entry 7637 (class 2606 OID 146571549)
-- Dependencies: 827 827 8894
-- Name: usr_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY usr_bak
    ADD CONSTRAINT usr_pkey PRIMARY KEY (usr_id);


--
-- TOC entry 7639 (class 2606 OID 146571551)
-- Dependencies: 827 827 8894
-- Name: usr_usr_username_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY usr_bak
    ADD CONSTRAINT usr_usr_username_key UNIQUE (usr_username);


--
-- TOC entry 7532 (class 2606 OID 146571553)
-- Dependencies: 732 732 8894
-- Name: usrgrp_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY usrgrp
    ADD CONSTRAINT usrgrp_pkey PRIMARY KEY (usrgrp_id);


--
-- TOC entry 7634 (class 2606 OID 146571555)
-- Dependencies: 825 825 8894
-- Name: usrpref_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY usrpref
    ADD CONSTRAINT usrpref_pkey PRIMARY KEY (usrpref_id);


--
-- TOC entry 7534 (class 2606 OID 146571557)
-- Dependencies: 733 733 8894
-- Name: usrpriv_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY usrpriv
    ADD CONSTRAINT usrpriv_pkey PRIMARY KEY (usrpriv_id);

ALTER TABLE ONLY vendinfo
    ADD CONSTRAINT vend_pkey PRIMARY KEY (vend_id);


--
-- TOC entry 7127 (class 2606 OID 146571561)
-- Dependencies: 364 364 8894
-- Name: vendaddr_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY vendaddrinfo
    ADD CONSTRAINT vendaddr_pkey PRIMARY KEY (vendaddr_id);



--
-- TOC entry 7159 (class 2606 OID 146571565)
-- Dependencies: 393 393 8894
-- Name: vendtype_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY vendtype
    ADD CONSTRAINT vendtype_pkey PRIMARY KEY (vendtype_id);


--
-- TOC entry 7161 (class 2606 OID 146571567)
-- Dependencies: 393 393 8894
-- Name: vendtype_vendtype_code_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY vendtype
    ADD CONSTRAINT vendtype_vendtype_code_key UNIQUE (vendtype_code);

ALTER TABLE ONLY vodist
    ADD CONSTRAINT vodist_pkey PRIMARY KEY (vodist_id);

ALTER TABLE ONLY vohead
    ADD CONSTRAINT vohead_pkey PRIMARY KEY (vohead_id);


--
-- TOC entry 7647 (class 2606 OID 146571575)
-- Dependencies: 841 841 8894
-- Name: voheadtax_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY voheadtax
    ADD CONSTRAINT voheadtax_pkey PRIMARY KEY (taxhist_id);


--
-- TOC entry 7649 (class 2606 OID 146571577)
-- Dependencies: 842 842 8894
-- Name: voitem_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY voitem
    ADD CONSTRAINT voitem_pkey PRIMARY KEY (voitem_id);


--
-- TOC entry 7651 (class 2606 OID 146571579)
-- Dependencies: 844 844 8894
-- Name: voitemtax_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY voitemtax
    ADD CONSTRAINT voitemtax_pkey PRIMARY KEY (taxhist_id);

ALTER TABLE ONLY whsinfo
    ADD CONSTRAINT warehous_pkey PRIMARY KEY (warehous_id);


--
-- TOC entry 7096 (class 2606 OID 146571583)
-- Dependencies: 343 343 8894
-- Name: whsezone_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY whsezone
    ADD CONSTRAINT whsezone_pkey PRIMARY KEY (whsezone_id);


--
-- TOC entry 7345 (class 2606 OID 146571587)
-- Dependencies: 560 560 8894
-- Name: wo_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY wo
    ADD CONSTRAINT wo_pkey PRIMARY KEY (wo_id);


--
-- TOC entry 7122 (class 2606 OID 146571589)
-- Dependencies: 359 359 8894
-- Name: womatl_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY womatl
    ADD CONSTRAINT womatl_pkey PRIMARY KEY (womatl_id);


--
-- TOC entry 7653 (class 2606 OID 146571591)
-- Dependencies: 850 850 8894
-- Name: womatlpost_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY womatlpost
    ADD CONSTRAINT womatlpost_pkey PRIMARY KEY (womatlpost_id);


--
-- TOC entry 7655 (class 2606 OID 146571593)
-- Dependencies: 852 852 8894
-- Name: womatlvar_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY womatlvar
    ADD CONSTRAINT womatlvar_pkey PRIMARY KEY (womatlvar_id);


--
-- TOC entry 7657 (class 2606 OID 146571595)
-- Dependencies: 855 855 8894
-- Name: xsltmap_name_key; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY xsltmap
    ADD CONSTRAINT xsltmap_name_key UNIQUE (xsltmap_name);


--
-- TOC entry 7659 (class 2606 OID 146571597)
-- Dependencies: 855 855 8894
-- Name: xsltmap_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY xsltmap
    ADD CONSTRAINT xsltmap_pkey PRIMARY KEY (xsltmap_id);


--
-- TOC entry 7661 (class 2606 OID 146571599)
-- Dependencies: 857 857 8894
-- Name: yearperiod_pkey; Type: CONSTRAINT; Schema: public; Owner: admin; Tablespace:
--

ALTER TABLE ONLY yearperiod
    ADD CONSTRAINT yearperiod_pkey PRIMARY KEY (yearperiod_id);




SET search_path = public, pg_catalog;


--
-- TOC entry 6826 (class 1259 OID 146571647)
-- Dependencies: 207 8894
-- Name: apopen_apopen_open_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX apopen_apopen_open_idx ON apopen USING btree (apopen_open);


--
-- TOC entry 6827 (class 1259 OID 146571648)
-- Dependencies: 207 8894
-- Name: apopen_apopen_vend_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX apopen_apopen_vend_id_idx ON apopen USING btree (apopen_vend_id);


--
-- TOC entry 7215 (class 1259 OID 146571649)
-- Dependencies: 439 8894
-- Name: apselect_apselect_apopen_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX apselect_apselect_apopen_id_idx ON apselect USING btree (apselect_apopen_id);


--
-- TOC entry 7222 (class 1259 OID 146571650)
-- Dependencies: 443 8894
-- Name: arapply_arapply_target_docnumber_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX arapply_arapply_target_docnumber_idx ON arapply USING btree (arapply_target_docnumber);


--
-- TOC entry 6845 (class 1259 OID 146571651)
-- Dependencies: 212 8894
-- Name: aropen_aropen_cust_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX aropen_aropen_cust_id_idx ON aropen USING btree (aropen_cust_id);


--
-- TOC entry 6846 (class 1259 OID 146571652)
-- Dependencies: 212 8894
-- Name: aropen_aropen_docnumber_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX aropen_aropen_docnumber_idx ON aropen USING btree (aropen_docnumber);


--
-- TOC entry 6847 (class 1259 OID 146571653)
-- Dependencies: 212 8894
-- Name: aropen_aropen_doctype_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX aropen_aropen_doctype_idx ON aropen USING btree (aropen_doctype);


--
-- TOC entry 6848 (class 1259 OID 146571654)
-- Dependencies: 212 8894
-- Name: aropen_aropen_open_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX aropen_aropen_open_idx ON aropen USING btree (aropen_open);


--
-- TOC entry 6851 (class 1259 OID 146571655)
-- Dependencies: 212 8894
-- Name: aropen_posted_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX aropen_posted_idx ON aropen USING btree (aropen_posted);


--
-- TOC entry 7135 (class 1259 OID 146571656)
-- Dependencies: 374 8894
-- Name: aropenalloc_aropen_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX aropenalloc_aropen_id_idx ON aropenalloc USING btree (aropenalloc_aropen_id);


--
-- TOC entry 7136 (class 1259 OID 146571657)
-- Dependencies: 374 8894
-- Name: aropenalloc_doc_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX aropenalloc_doc_id_idx ON aropenalloc USING btree (aropenalloc_doc_id);


--
-- TOC entry 6806 (class 1259 OID 146571658)
-- Dependencies: 203 8894
-- Name: bomitem_bomitem_item_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX bomitem_bomitem_item_id_idx ON bomitem USING btree (bomitem_item_id);


--
-- TOC entry 6807 (class 1259 OID 146571659)
-- Dependencies: 203 8894
-- Name: bomitem_effective_key; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX bomitem_effective_key ON bomitem USING btree (bomitem_effective);


--
-- TOC entry 6808 (class 1259 OID 146571660)
-- Dependencies: 203 8894
-- Name: bomitem_expires_key; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX bomitem_expires_key ON bomitem USING btree (bomitem_expires);


--
-- TOC entry 6809 (class 1259 OID 146571661)
-- Dependencies: 203 8894
-- Name: bomitem_parent_item_id; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX bomitem_parent_item_id ON bomitem USING btree (bomitem_parent_item_id);


--
-- TOC entry 7247 (class 1259 OID 146571662)
-- Dependencies: 468 8894
-- Name: bomitemcost_bomitem_id_key; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX bomitemcost_bomitem_id_key ON bomitemcost USING btree (bomitemcost_bomitem_id);


--
-- TOC entry 7248 (class 1259 OID 146571663)
-- Dependencies: 468 468 468 8894
-- Name: bomitemcost_master_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE UNIQUE INDEX bomitemcost_master_idx ON bomitemcost USING btree (bomitemcost_bomitem_id, bomitemcost_costelem_id, bomitemcost_lowlevel);


--
-- TOC entry 6969 (class 1259 OID 146571664)
-- Dependencies: 269 8894
-- Name: cashrcptitem_aropen_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX cashrcptitem_aropen_idx ON cashrcptitem USING btree (cashrcptitem_aropen_id);


--
-- TOC entry 6970 (class 1259 OID 146571665)
-- Dependencies: 269 8894
-- Name: cashrcptitem_cashrcpt_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX cashrcptitem_cashrcpt_idx ON cashrcptitem USING btree (cashrcptitem_cashrcpt_id);


--
-- TOC entry 6975 (class 1259 OID 146571666)
-- Dependencies: 278 8894
-- Name: ccard_cust_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX ccard_cust_id_idx ON ccard USING btree (ccard_cust_id);


--
-- TOC entry 7255 (class 1259 OID 146571667)
-- Dependencies: 482 8894
-- Name: ccardaud_ccard_cust_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX ccardaud_ccard_cust_id_idx ON ccardaud USING btree (ccardaud_ccard_cust_id_new);


--
-- TOC entry 7256 (class 1259 OID 146571668)
-- Dependencies: 482 8894
-- Name: ccardaud_ccard_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX ccardaud_ccard_id_idx ON ccardaud USING btree (ccardaud_ccard_id);


--
-- TOC entry 7263 (class 1259 OID 146571669)
-- Dependencies: 486 8894
-- Name: ccpay_ccard_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX ccpay_ccard_id_idx ON ccpay USING btree (ccpay_ccard_id);


--
-- TOC entry 7264 (class 1259 OID 146571670)
-- Dependencies: 486 8894
-- Name: ccpay_cust_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX ccpay_cust_id_idx ON ccpay USING btree (ccpay_cust_id);


--
-- TOC entry 7265 (class 1259 OID 146571671)
-- Dependencies: 486 8894
-- Name: ccpay_order_number_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX ccpay_order_number_idx ON ccpay USING btree (ccpay_order_number);


--
-- TOC entry 6928 (class 1259 OID 146571672)
-- Dependencies: 237 237 8894
-- Name: charass_target_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX charass_target_idx ON charass USING btree (charass_target_type, charass_target_id);


--
-- TOC entry 7206 (class 1259 OID 146571673)
-- Dependencies: 430 8894
-- Name: checkhead_posted_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX checkhead_posted_idx ON checkhead USING btree (checkhead_posted);


--
-- TOC entry 7207 (class 1259 OID 146571674)
-- Dependencies: 430 8894
-- Name: checkhead_replaced_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX checkhead_replaced_idx ON checkhead USING btree (checkhead_replaced);


--
-- TOC entry 7208 (class 1259 OID 146571675)
-- Dependencies: 432 8894
-- Name: checkitem_apopenitem_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX checkitem_apopenitem_id_idx ON checkitem USING btree (checkitem_apopen_id);


--
-- TOC entry 6871 (class 1259 OID 146571676)
-- Dependencies: 218 8894
-- Name: cmhead_invcnumber_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX cmhead_invcnumber_idx ON cmhead USING btree (cmhead_invcnumber);


--
-- TOC entry 6814 (class 1259 OID 146571677)
-- Dependencies: 204 8894
-- Name: cntct_email_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX cntct_email_idx ON cntct USING btree (cntct_email);


--
-- TOC entry 6815 (class 1259 OID 146571678)
-- Dependencies: 204 8894
-- Name: cntct_name_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX cntct_name_idx ON cntct USING btree (cntct_name);


--
-- TOC entry 7286 (class 1259 OID 146571679)
-- Dependencies: 513 8894
-- Name: cobill_cobmisc_id; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX cobill_cobmisc_id ON cobill USING btree (cobill_cobmisc_id);


--
-- TOC entry 7287 (class 1259 OID 146571680)
-- Dependencies: 513 8894
-- Name: cobill_coitem_id; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX cobill_coitem_id ON cobill USING btree (cobill_coitem_id);


--
-- TOC entry 7292 (class 1259 OID 146571681)
-- Dependencies: 516 8894
-- Name: cobmisc_cohead_id; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX cobmisc_cohead_id ON cobmisc USING btree (cobmisc_cohead_id);


--
-- TOC entry 7295 (class 1259 OID 146571682)
-- Dependencies: 516 8894
-- Name: cobmisc_posted; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX cobmisc_posted ON cobmisc USING btree (cobmisc_posted);


--
-- TOC entry 6769 (class 1259 OID 146571683)
-- Dependencies: 195 8894
-- Name: cohead_cohead_status_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX cohead_cohead_status_idx ON cohead USING btree (cohead_status);


--
-- TOC entry 6770 (class 1259 OID 146571684)
-- Dependencies: 195 8894
-- Name: cohead_cust_id_key; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX cohead_cust_id_key ON cohead USING btree (cohead_cust_id);


--
-- TOC entry 6771 (class 1259 OID 146571685)
-- Dependencies: 195 8894
-- Name: cohead_custponumber_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX cohead_custponumber_idx ON cohead USING btree (cohead_custponumber);


--
-- TOC entry 6772 (class 1259 OID 146571686)
-- Dependencies: 195 8894
-- Name: cohead_number_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE UNIQUE INDEX cohead_number_idx ON cohead USING btree (cohead_number);


--
-- TOC entry 6775 (class 1259 OID 146571687)
-- Dependencies: 195 8894
-- Name: cohead_shipto_id; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX cohead_shipto_id ON cohead USING btree (cohead_shipto_id);


--
-- TOC entry 7139 (class 1259 OID 146571688)
-- Dependencies: 376 8894
-- Name: cohist_cust_id; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX cohist_cust_id ON cohist USING btree (cohist_cust_id);


--
-- TOC entry 7140 (class 1259 OID 146571689)
-- Dependencies: 376 8894
-- Name: cohist_invcnumber; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX cohist_invcnumber ON cohist USING btree (cohist_invcnumber);


--
-- TOC entry 7141 (class 1259 OID 146571690)
-- Dependencies: 376 8894
-- Name: cohist_itemsite_id; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX cohist_itemsite_id ON cohist USING btree (cohist_itemsite_id);


--
-- TOC entry 7144 (class 1259 OID 146571691)
-- Dependencies: 376 8894
-- Name: cohist_shipdate; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX cohist_shipdate ON cohist USING btree (cohist_shipdate);


--
-- TOC entry 7145 (class 1259 OID 146571692)
-- Dependencies: 376 8894
-- Name: cohist_shipto_id; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX cohist_shipto_id ON cohist USING btree (cohist_shipto_id);


--
-- TOC entry 6776 (class 1259 OID 146571693)
-- Dependencies: 196 8894
-- Name: coitem_cohead_id_key; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX coitem_cohead_id_key ON coitem USING btree (coitem_cohead_id);


--
-- TOC entry 6777 (class 1259 OID 146571694)
-- Dependencies: 196 196 196 8894
-- Name: coitem_coitem_cohead_id_key; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE UNIQUE INDEX coitem_coitem_cohead_id_key ON coitem USING btree (coitem_cohead_id, coitem_linenumber, coitem_subnumber);


--
-- TOC entry 6778 (class 1259 OID 146571695)
-- Dependencies: 196 8894
-- Name: coitem_itemsite_id; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX coitem_itemsite_id ON coitem USING btree (coitem_itemsite_id);


--
-- TOC entry 6779 (class 1259 OID 146571696)
-- Dependencies: 196 8894
-- Name: coitem_linenumber_key; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX coitem_linenumber_key ON coitem USING btree (coitem_linenumber);


--
-- TOC entry 6782 (class 1259 OID 146571697)
-- Dependencies: 196 8894
-- Name: coitem_status_key; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX coitem_status_key ON coitem USING btree (coitem_status);


--
-- TOC entry 6933 (class 1259 OID 146571698)
-- Dependencies: 240 240 8894
-- Name: comment_comment_source_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX comment_comment_source_idx ON comment USING btree (comment_source, comment_source_id);


--
-- TOC entry 7063 (class 1259 OID 146571699)
-- Dependencies: 329 329 8894
-- Name: contrct_master_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE UNIQUE INDEX contrct_master_idx ON contrct USING btree (contrct_number, contrct_vend_id);


--
-- TOC entry 6852 (class 1259 OID 146571700)
-- Dependencies: 213 8894
-- Name: cust_number_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE UNIQUE INDEX cust_number_idx ON custinfo USING btree (cust_number);


--
-- TOC entry 7354 (class 1259 OID 146571701)
-- Dependencies: 567 8894
-- Name: evntlog_dispatched_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX evntlog_dispatched_idx ON evntlog USING btree (evntlog_dispatched);


--
-- TOC entry 7355 (class 1259 OID 146571702)
-- Dependencies: 567 8894
-- Name: evntlog_evntlog_username_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX evntlog_evntlog_username_idx ON evntlog USING btree (evntlog_username);


--
-- TOC entry 7358 (class 1259 OID 146571703)
-- Dependencies: 569 8894
-- Name: evntnot_evnttype_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX evntnot_evnttype_id_idx ON evntnot USING btree (evntnot_evnttype_id);


--
-- TOC entry 7361 (class 1259 OID 146571704)
-- Dependencies: 569 8894
-- Name: evntnot_warehous_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX evntnot_warehous_id_idx ON evntnot USING btree (evntnot_warehous_id);


--
-- TOC entry 7366 (class 1259 OID 146571705)
-- Dependencies: 575 575 575 8894
-- Name: filter_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX filter_idx ON filter USING btree (filter_screen, filter_username, filter_name);


--
-- TOC entry 7086 (class 1259 OID 146571706)
-- Dependencies: 340 8894
-- Name: gltrans_gltrans_accnt_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX gltrans_gltrans_accnt_id_idx ON gltrans USING btree (gltrans_accnt_id);


--
-- TOC entry 7087 (class 1259 OID 146571707)
-- Dependencies: 340 8894
-- Name: gltrans_gltrans_date_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX gltrans_gltrans_date_idx ON gltrans USING btree (gltrans_date);


--
-- TOC entry 7088 (class 1259 OID 146571708)
-- Dependencies: 340 8894
-- Name: gltrans_gltrans_journalnumber_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX gltrans_gltrans_journalnumber_idx ON gltrans USING btree (gltrans_journalnumber);


--
-- TOC entry 7091 (class 1259 OID 146571709)
-- Dependencies: 340 8894
-- Name: gltrans_sequence_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX gltrans_sequence_idx ON gltrans USING btree (gltrans_sequence);


--
-- TOC entry 6886 (class 1259 OID 146571710)
-- Dependencies: 224 8894
-- Name: invchead_invchead_ordernumber_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX invchead_invchead_ordernumber_idx ON invchead USING btree (invchead_ordernumber);


--
-- TOC entry 6903 (class 1259 OID 146571711)
-- Dependencies: 229 8894
-- Name: invcitem_invcitem_invchead_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX invcitem_invcitem_invchead_id_idx ON invcitem USING btree (invcitem_invchead_id);


--
-- TOC entry 6904 (class 1259 OID 146571712)
-- Dependencies: 229 229 8894
-- Name: invcitem_invcitem_itemsite_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX invcitem_invcitem_itemsite_id_idx ON invcitem USING btree (invcitem_item_id, invcitem_warehous_id);


--
-- TOC entry 7409 (class 1259 OID 146571713)
-- Dependencies: 619 8894
-- Name: invcitemtax_taxhist_parent_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX invcitemtax_taxhist_parent_id_idx ON invcitemtax USING btree (taxhist_parent_id);


--
-- TOC entry 7410 (class 1259 OID 146571714)
-- Dependencies: 621 8894
-- Name: invdetail_invdetail_invcitem_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX invdetail_invdetail_invcitem_id_idx ON invdetail USING btree (invdetail_invcitem_id);


--
-- TOC entry 7411 (class 1259 OID 146571715)
-- Dependencies: 621 8894
-- Name: invdetail_invdetail_invhist_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX invdetail_invdetail_invhist_id_idx ON invdetail USING btree (invdetail_invhist_id);


--
-- TOC entry 7414 (class 1259 OID 146571716)
-- Dependencies: 623 8894
-- Name: invhist_hasdetail; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX invhist_hasdetail ON invhist USING btree (invhist_hasdetail);


--
-- TOC entry 7415 (class 1259 OID 146571717)
-- Dependencies: 623 8894
-- Name: invhist_invhist_ordnumber_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX invhist_invhist_ordnumber_idx ON invhist USING btree (invhist_ordnumber);


--
-- TOC entry 7416 (class 1259 OID 146571718)
-- Dependencies: 623 8894
-- Name: invhist_itemsite_id; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX invhist_itemsite_id ON invhist USING btree (invhist_itemsite_id);


--
-- TOC entry 7419 (class 1259 OID 146571719)
-- Dependencies: 623 8894
-- Name: invhist_series; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX invhist_series ON invhist USING btree (invhist_series);


--
-- TOC entry 7420 (class 1259 OID 146571720)
-- Dependencies: 623 8894
-- Name: invhist_transdate; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX invhist_transdate ON invhist USING btree (invhist_transdate);


--
-- TOC entry 7421 (class 1259 OID 146571721)
-- Dependencies: 623 8894
-- Name: invhist_transtype; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX invhist_transtype ON invhist USING btree (invhist_transtype);


--
-- TOC entry 7101 (class 1259 OID 146571722)
-- Dependencies: 349 8894
-- Name: ipsitem_ipshead_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX ipsitem_ipshead_id_idx ON ipsiteminfo USING btree (ipsitem_ipshead_id);


--
-- TOC entry 6747 (class 1259 OID 146571723)
-- Dependencies: 191 8894
-- Name: item_classcode_id; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX item_classcode_id ON item USING btree (item_classcode_id);


--
-- TOC entry 6750 (class 1259 OID 146571724)
-- Dependencies: 191 8894
-- Name: item_number_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE UNIQUE INDEX item_number_idx ON item USING btree (item_number);


--
-- TOC entry 6753 (class 1259 OID 146571725)
-- Dependencies: 191 8894
-- Name: item_prodcat_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX item_prodcat_id_idx ON item USING btree (item_prodcat_id);


--
-- TOC entry 6754 (class 1259 OID 146571726)
-- Dependencies: 191 8894
-- Name: item_upccode_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX item_upccode_idx ON item USING btree (item_upccode);


--
-- TOC entry 7051 (class 1259 OID 146571727)
-- Dependencies: 321 8894
-- Name: itemcost_item_id_key; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX itemcost_item_id_key ON itemcost USING btree (itemcost_item_id);


--
-- TOC entry 7052 (class 1259 OID 146571728)
-- Dependencies: 321 321 321 8894
-- Name: itemcost_master_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE UNIQUE INDEX itemcost_master_idx ON itemcost USING btree (itemcost_item_id, itemcost_costelem_id, itemcost_lowlevel);


--
-- TOC entry 7436 (class 1259 OID 146571729)
-- Dependencies: 649 8894
-- Name: itemloc_itemsite_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX itemloc_itemsite_idx ON itemloc USING btree (itemloc_itemsite_id);


--
-- TOC entry 7437 (class 1259 OID 146571730)
-- Dependencies: 649 8894
-- Name: itemloc_location_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX itemloc_location_idx ON itemloc USING btree (itemloc_location_id);


--
-- TOC entry 6755 (class 1259 OID 146571731)
-- Dependencies: 192 8894
-- Name: itemsite_active_key; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX itemsite_active_key ON itemsite USING btree (itemsite_active);


--
-- TOC entry 6756 (class 1259 OID 146571732)
-- Dependencies: 192 8894
-- Name: itemsite_item_id_key; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX itemsite_item_id_key ON itemsite USING btree (itemsite_item_id);


--
-- TOC entry 6757 (class 1259 OID 146571733)
-- Dependencies: 192 192 8894
-- Name: itemsite_item_warehous_id_key; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE UNIQUE INDEX itemsite_item_warehous_id_key ON itemsite USING btree (itemsite_item_id, itemsite_warehous_id);


--
-- TOC entry 6760 (class 1259 OID 146571734)
-- Dependencies: 192 8894
-- Name: itemsite_plancode_id_key; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX itemsite_plancode_id_key ON itemsite USING btree (itemsite_plancode_id);


--
-- TOC entry 6761 (class 1259 OID 146571735)
-- Dependencies: 192 8894
-- Name: itemsite_warehous_id_key; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX itemsite_warehous_id_key ON itemsite USING btree (itemsite_warehous_id);


--
-- TOC entry 7070 (class 1259 OID 146571736)
-- Dependencies: 330 8894
-- Name: itemsrc_vend_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX itemsrc_vend_id_idx ON itemsrc USING btree (itemsrc_vend_id);


--
-- TOC entry 7071 (class 1259 OID 146571737)
-- Dependencies: 332 8894
-- Name: itemsrcp_itemsrc_id_key; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX itemsrcp_itemsrc_id_key ON itemsrcp USING btree (itemsrcp_itemsrc_id);


--
-- TOC entry 7078 (class 1259 OID 146571738)
-- Dependencies: 334 8894
-- Name: itemsub_parent_item_id_key; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX itemsub_parent_item_id_key ON itemsub USING btree (itemsub_parent_item_id);


--
-- TOC entry 7081 (class 1259 OID 146571739)
-- Dependencies: 334 8894
-- Name: itemsub_sub_item_id_key; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX itemsub_sub_item_id_key ON itemsub USING btree (itemsub_sub_item_id);


--
-- TOC entry 7094 (class 1259 OID 146571740)
-- Dependencies: 342 8894
-- Name: location_warehous_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX location_warehous_idx ON location USING btree (location_warehous_id);


--
-- TOC entry 7502 (class 1259 OID 146571741)
-- Dependencies: 708 8894
-- Name: payaropen_aropen_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX payaropen_aropen_id_idx ON payaropen USING btree (payaropen_aropen_id);


--
-- TOC entry 7503 (class 1259 OID 146571742)
-- Dependencies: 708 8894
-- Name: payaropen_ccpay_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX payaropen_ccpay_id_idx ON payaropen USING btree (payaropen_ccpay_id);


--
-- TOC entry 7506 (class 1259 OID 146571743)
-- Dependencies: 709 8894
-- Name: payco_ccpay_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX payco_ccpay_id_idx ON payco USING btree (payco_ccpay_id);


--
-- TOC entry 7507 (class 1259 OID 146571744)
-- Dependencies: 709 8894
-- Name: payco_cohead_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX payco_cohead_id_idx ON payco USING btree (payco_cohead_id);


--
-- TOC entry 6787 (class 1259 OID 146571745)
-- Dependencies: 197 8894
-- Name: pohead_pohead_status_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX pohead_pohead_status_idx ON pohead USING btree (pohead_status);


--
-- TOC entry 6788 (class 1259 OID 146571746)
-- Dependencies: 198 8894
-- Name: poitem_itemsite_id_key; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX poitem_itemsite_id_key ON poitem USING btree (poitem_itemsite_id);


--
-- TOC entry 6789 (class 1259 OID 146571747)
-- Dependencies: 198 198 198 8894
-- Name: poitem_itemsite_status_duedate_key; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX poitem_itemsite_status_duedate_key ON poitem USING btree (poitem_itemsite_id, poitem_status, poitem_duedate);


--
-- TOC entry 6792 (class 1259 OID 146571748)
-- Dependencies: 198 8894
-- Name: poitem_pohead_id_key; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX poitem_pohead_id_key ON poitem USING btree (poitem_pohead_id);


--
-- TOC entry 6795 (class 1259 OID 146571749)
-- Dependencies: 198 8894
-- Name: poitem_status_key; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX poitem_status_key ON poitem USING btree (poitem_status);


--
-- TOC entry 7178 (class 1259 OID 146571750)
-- Dependencies: 408 8894
-- Name: priv_name_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE UNIQUE INDEX priv_name_idx ON priv USING btree (priv_name);


--
-- TOC entry 7134 (class 1259 OID 146571751)
-- Dependencies: 370 8894
-- Name: quitem_quhead_id_key; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX quitem_quhead_id_key ON quitem USING btree (quitem_quhead_id);


--
-- TOC entry 7518 (class 1259 OID 146571752)
-- Dependencies: 721 721 8894
-- Name: recv_ordertypeid_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX recv_ordertypeid_idx ON recv USING btree (recv_order_type, recv_orderitem_id);


--
-- TOC entry 7183 (class 1259 OID 146571753)
-- Dependencies: 411 411 8894
-- Name: report_name_grade_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE UNIQUE INDEX report_name_grade_idx ON report USING btree (report_name, report_grade);


--
-- TOC entry 7325 (class 1259 OID 146571754)
-- Dependencies: 540 8894
-- Name: salesaccnt_prodcat_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX salesaccnt_prodcat_id_idx ON salesaccnt USING btree (salesaccnt_prodcat_id);


--
-- TOC entry 7326 (class 1259 OID 146571755)
-- Dependencies: 540 8894
-- Name: salesaccnt_warehous_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX salesaccnt_warehous_id_idx ON salesaccnt USING btree (salesaccnt_warehous_id);


--
-- TOC entry 7006 (class 1259 OID 146571756)
-- Dependencies: 297 8894
-- Name: shipdata_cohead_number_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX shipdata_cohead_number_idx ON shipdata USING btree (shipdata_cohead_number);


--
-- TOC entry 7573 (class 1259 OID 146571757)
-- Dependencies: 771 8894
-- Name: shipdatasum_cohead_number_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX shipdatasum_cohead_number_idx ON shipdatasum USING btree (shipdatasum_cohead_number);


--
-- TOC entry 7574 (class 1259 OID 146571758)
-- Dependencies: 771 8894
-- Name: shipdatasum_cosmisc_tracknum_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX shipdatasum_cosmisc_tracknum_idx ON shipdatasum USING btree (shipdatasum_cosmisc_tracknum);


--
-- TOC entry 7302 (class 1259 OID 146571759)
-- Dependencies: 526 8894
-- Name: shiphead_order_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX shiphead_order_id_idx ON shiphead USING btree (shiphead_order_id);


--
-- TOC entry 7307 (class 1259 OID 146571760)
-- Dependencies: 526 8894
-- Name: shiphead_shipped_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX shiphead_shipped_idx ON shiphead USING btree (shiphead_shipped);


--
-- TOC entry 7308 (class 1259 OID 146571761)
-- Dependencies: 527 8894
-- Name: shipitem_invcitem_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX shipitem_invcitem_id_idx ON shipitem USING btree (shipitem_invcitem_id);


--
-- TOC entry 7309 (class 1259 OID 146571762)
-- Dependencies: 527 8894
-- Name: shipitem_orderitem_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX shipitem_orderitem_id_idx ON shipitem USING btree (shipitem_orderitem_id);


--
-- TOC entry 7312 (class 1259 OID 146571763)
-- Dependencies: 527 8894
-- Name: shipitem_shiphead_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX shipitem_shiphead_id_idx ON shipitem USING btree (shipitem_shiphead_id);


--
-- TOC entry 7579 (class 1259 OID 146571764)
-- Dependencies: 781 8894
-- Name: sltrans_sequence_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX sltrans_sequence_idx ON sltrans USING btree (sltrans_sequence);


--
-- TOC entry 7580 (class 1259 OID 146571765)
-- Dependencies: 781 8894
-- Name: sltrans_sltrans_accnt_id_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX sltrans_sltrans_accnt_id_idx ON sltrans USING btree (sltrans_accnt_id);


--
-- TOC entry 7581 (class 1259 OID 146571766)
-- Dependencies: 781 8894
-- Name: sltrans_sltrans_date_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX sltrans_sltrans_date_idx ON sltrans USING btree (sltrans_date);


--
-- TOC entry 7582 (class 1259 OID 146571767)
-- Dependencies: 781 8894
-- Name: sltrans_sltrans_journalnumber_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX sltrans_sltrans_journalnumber_idx ON sltrans USING btree (sltrans_journalnumber);


--
-- TOC entry 7611 (class 1259 OID 146571768)
-- Dependencies: 801 8894
-- Name: subaccnttype_code_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE UNIQUE INDEX subaccnttype_code_idx ON subaccnttype USING btree (subaccnttype_code);


--
-- TOC entry 6917 (class 1259 OID 146571769)
-- Dependencies: 233 8894
-- Name: todoitem_todoitem_username_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX todoitem_todoitem_username_idx ON todoitem USING btree (todoitem_username);


--
-- TOC entry 7624 (class 1259 OID 146571770)
-- Dependencies: 817 817 8894
-- Name: trialbal_accnt_period_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE UNIQUE INDEX trialbal_accnt_period_idx ON trialbal USING btree (trialbal_accnt_id, trialbal_period_id);


--
-- TOC entry 7635 (class 1259 OID 146571771)
-- Dependencies: 825 8894
-- Name: usrpref_userpref_name_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX usrpref_userpref_name_idx ON usrpref USING btree (usrpref_name);


--
-- TOC entry 6840 (class 1259 OID 146571772)
-- Dependencies: 210 8894
-- Name: vend_number_idx; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE UNIQUE INDEX vend_number_idx ON vendinfo USING btree (vend_number);


--
-- TOC entry 6762 (class 1259 OID 146571773)
-- Dependencies: 193 8894
-- Name: warehous_code_key; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX warehous_code_key ON whsinfo USING btree (warehous_code bpchar_ops);


--
-- TOC entry 7341 (class 1259 OID 146571774)
-- Dependencies: 560 8894
-- Name: wo_duedate; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX wo_duedate ON wo USING btree (wo_duedate);


--
-- TOC entry 7342 (class 1259 OID 146571775)
-- Dependencies: 560 8894
-- Name: wo_itemsite_id; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX wo_itemsite_id ON wo USING btree (wo_itemsite_id);


--
-- TOC entry 7343 (class 1259 OID 146571776)
-- Dependencies: 560 8894
-- Name: wo_ordtype; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX wo_ordtype ON wo USING btree (wo_ordtype);


--
-- TOC entry 7346 (class 1259 OID 146571777)
-- Dependencies: 560 8894
-- Name: wo_startdate; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX wo_startdate ON wo USING btree (wo_startdate);


--
-- TOC entry 7347 (class 1259 OID 146571778)
-- Dependencies: 560 8894
-- Name: wo_status; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX wo_status ON wo USING btree (wo_status);


--
-- TOC entry 7120 (class 1259 OID 146571779)
-- Dependencies: 359 8894
-- Name: womatl_itemsite_id_key; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX womatl_itemsite_id_key ON womatl USING btree (womatl_itemsite_id);


--
-- TOC entry 7123 (class 1259 OID 146571780)
-- Dependencies: 359 8894
-- Name: womatl_wo_id_key; Type: INDEX; Schema: public; Owner: admin; Tablespace:
--

CREATE INDEX womatl_wo_id_key ON womatl USING btree (womatl_wo_id);



SET search_path = api, pg_catalog;

--
-- TOC entry 8597 (class 2618 OID 146571782)
-- Dependencies: 201 201 201 196 196 196 1672 201 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO salesline DO INSTEAD DELETE FROM public.coitem WHERE (((coitem.coitem_cohead_id = public.getcoheadid((old.order_number)::text)) AND (((coitem.coitem_linenumber)::character varying)::text = (old.line_number)::text)) AND (coitem.coitem_subnumber = 0));


--
-- TOC entry 8598 (class 2618 OID 146571783)
-- Dependencies: 211 211 211 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO apmemo DO INSTEAD NOTHING;


--
-- TOC entry 8599 (class 2618 OID 146571784)
-- Dependencies: 217 217 217 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO armemo DO INSTEAD NOTHING;


--
-- TOC entry 8600 (class 2618 OID 146571785)
-- Dependencies: 194 194 194 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO physinvcount DO INSTEAD NOTHING;


--
-- TOC entry 8601 (class 2618 OID 146571786)
-- Dependencies: 235 235 205 235 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO account DO INSTEAD DELETE FROM public.crmacct WHERE (crmacct.crmacct_number = (old.account_number)::text);


--
-- TOC entry 8602 (class 2618 OID 146571787)
-- Dependencies: 238 238 238 237 237 237 1680 1665 238 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO accountchar DO INSTEAD DELETE FROM public.charass WHERE (((charass.charass_target_type = 'CRMACCT'::text) AND (charass.charass_target_id = public.getcrmacctid((old.account_number)::text))) AND (charass.charass_char_id = public.getcharid((old.characteristic)::text, 'CRMACCT'::text)));


--
-- TOC entry 8603 (class 2618 OID 146571788)
-- Dependencies: 241 241 241 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO accountcomment DO INSTEAD NOTHING;


--
-- TOC entry 8604 (class 2618 OID 146571789)
-- Dependencies: 246 246 246 246 245 245 245 245 1680 246 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO accountfile DO INSTEAD DELETE FROM public.url WHERE ((((url.url_source_id = public.getcrmacctid(old.account_number)) AND (url.url_source = 'CRMA'::text)) AND (url.url_title = old.title)) AND (url.url_url = old.url));


--
-- TOC entry 8605 (class 2618 OID 146571790)
-- Dependencies: 250 250 250 249 249 249 1702 1680 250 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO accountimage DO INSTEAD DELETE FROM public.imageass WHERE (((imageass.imageass_source_id = public.getcrmacctid(old.account_number)) AND (imageass.imageass_source = 'CRMA'::text)) AND (imageass.imageass_image_id = public.getimageid(old.image_name)));


--
-- TOC entry 8606 (class 2618 OID 146571791)
-- Dependencies: 251 251 1658 1400 251 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO address DO INSTEAD SELECT public.deleteaddress(public.getaddrid((old.address_number)::text)) AS deleteaddress;


--
-- TOC entry 8607 (class 2618 OID 146571792)
-- Dependencies: 252 252 252 237 237 237 1665 1658 252 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO addresschar DO INSTEAD DELETE FROM public.charass WHERE (((charass.charass_target_type = 'ADDR'::text) AND (charass.charass_target_id = public.getaddrid((old.address_number)::text))) AND (charass.charass_char_id = public.getcharid((old.characteristic)::text, 'ADDR'::text)));


--
-- TOC entry 8608 (class 2618 OID 146571793)
-- Dependencies: 253 253 253 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO addresscomment DO INSTEAD NOTHING;


--
-- TOC entry 8609 (class 2618 OID 146571794)
-- Dependencies: 255 255 1714 1404 255 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO bom DO INSTEAD SELECT public.deletebom(public.getitemid((old.item_number)::text)) AS deletebom;


--
-- TOC entry 8610 (class 2618 OID 146571795)
-- Dependencies: 256 256 203 1545 256 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO bomitem DO INSTEAD DELETE FROM public.bomitem WHERE ((bomitem.bomitem_id = old.id) AND public.fetchmetricbool('AllowBOMItemDelete'::text));


--
-- TOC entry 8611 (class 2618 OID 146571796)
-- Dependencies: 257 257 257 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO bomitemcomment DO INSTEAD NOTHING;


--
-- TOC entry 8612 (class 2618 OID 146571797)
-- Dependencies: 259 259 259 258 258 1714 259 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO bomitemsubstitute DO INSTEAD DELETE FROM public.bomitemsub WHERE ((bomitemsub.bomitemsub_bomitem_id = old.bomitem_id) AND (bomitemsub.bomitemsub_item_id = public.getitemid((old.substitute_item_number)::text)));


--
-- TOC entry 8613 (class 2618 OID 146571798)
-- Dependencies: 261 261 260 261 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO budget DO INSTEAD DELETE FROM public.budghead WHERE (budghead.budghead_name = old.name);


--
-- TOC entry 8614 (class 2618 OID 146571799)
-- Dependencies: 265 265 265 265 263 263 263 1730 1700 1663 265 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO budgetentry DO INSTEAD DELETE FROM public.budgitem WHERE (((budgitem.budgitem_budghead_id = public.getbudgheadid(old.name)) AND (budgitem.budgitem_period_id = public.getperiodid(old.period_start))) AND (budgitem.budgitem_accnt_id = public.getglaccntid(old.account)));


--
-- TOC entry 8615 (class 2618 OID 146571800)
-- Dependencies: 268 268 268 268 267 1664 1409 268 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO cashreceipt DO INSTEAD SELECT public.deletecashrcpt(cashrcpt.cashrcpt_id) AS deletecashrcpt FROM public.cashrcpt WHERE (cashrcpt.cashrcpt_id = public.getcashrcptid((old.customer_number)::text, CASE WHEN ((old.funds_type)::text = 'Check'::text) THEN 'C'::text WHEN ((old.funds_type)::text = 'Certified Check'::text) THEN 'T'::text WHEN ((old.funds_type)::text = 'Master Card'::text) THEN 'M'::text WHEN ((old.funds_type)::text = 'Visa'::text) THEN 'V'::text WHEN ((old.funds_type)::text = 'American Express'::text) THEN 'A'::text WHEN ((old.funds_type)::text = 'Discover Card'::text) THEN 'D'::text WHEN ((old.funds_type)::text = 'Other Credit Card'::text) THEN 'R'::text WHEN ((old.funds_type)::text = 'Cash'::text) THEN 'K'::text WHEN ((old.funds_type)::text = 'Wire Transfer'::text) THEN 'W'::text ELSE 'O'::text END, (old.check_document_number)::text));


--
-- TOC entry 8616 (class 2618 OID 146571802)
-- Dependencies: 270 270 270 270 270 270 269 269 1664 1660 270 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO cashreceiptapply DO INSTEAD DELETE FROM public.cashrcptitem WHERE ((cashrcptitem.cashrcptitem_cashrcpt_id = public.getcashrcptid((old.customer_number)::text, CASE WHEN ((old.funds_type)::text = 'Check'::text) THEN 'C'::text WHEN ((old.funds_type)::text = 'Certified Check'::text) THEN 'T'::text WHEN ((old.funds_type)::text = 'Master Card'::text) THEN 'M'::text WHEN ((old.funds_type)::text = 'Visa'::text) THEN 'V'::text WHEN ((old.funds_type)::text = 'American Express'::text) THEN 'A'::text WHEN ((old.funds_type)::text = 'Discover Card'::text) THEN 'D'::text WHEN ((old.funds_type)::text = 'Other Credit Card'::text) THEN 'R'::text WHEN ((old.funds_type)::text = 'Cash'::text) THEN 'K'::text WHEN ((old.funds_type)::text = 'Wire Transfer'::text) THEN 'W'::text ELSE 'O'::text END, (old.check_document_number)::text)) AND (cashrcptitem.cashrcptitem_aropen_id = public.getaropenid((old.customer_number)::text, (old.doc_type)::bpchar, (old.doc_number)::text)));


--
-- TOC entry 8617 (class 2618 OID 146571804)
-- Dependencies: 272 272 272 272 272 271 271 1700 1664 272 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO cashreceiptapplymisc DO INSTEAD DELETE FROM public.cashrcptmisc WHERE ((cashrcptmisc.cashrcptmisc_cashrcpt_id = public.getcashrcptid((old.customer_number)::text, CASE WHEN ((old.funds_type)::text = 'Check'::text) THEN 'C'::text WHEN ((old.funds_type)::text = 'Certified Check'::text) THEN 'T'::text WHEN ((old.funds_type)::text = 'Master Card'::text) THEN 'M'::text WHEN ((old.funds_type)::text = 'Visa'::text) THEN 'V'::text WHEN ((old.funds_type)::text = 'American Express'::text) THEN 'A'::text WHEN ((old.funds_type)::text = 'Discover Card'::text) THEN 'D'::text WHEN ((old.funds_type)::text = 'Other Credit Card'::text) THEN 'R'::text WHEN ((old.funds_type)::text = 'Cash'::text) THEN 'K'::text WHEN ((old.funds_type)::text = 'Wire Transfer'::text) THEN 'W'::text ELSE 'O'::text END, (old.check_document_number)::text)) AND (cashrcptmisc.cashrcptmisc_accnt_id = public.getglaccntid((old.account)::text)));


--
-- TOC entry 8618 (class 2618 OID 146571806)
-- Dependencies: 273 273 204 273 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO contact DO INSTEAD DELETE FROM public.cntct WHERE (cntct.cntct_number = (old.contact_number)::text);


--
-- TOC entry 8619 (class 2618 OID 146571807)
-- Dependencies: 274 274 274 237 237 237 1670 1665 274 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO contactchar DO INSTEAD DELETE FROM public.charass WHERE (((charass.charass_target_type = 'CNTCT'::text) AND (charass.charass_target_id = public.getcntctid(old.contact_number))) AND (charass.charass_char_id = public.getcharid((old.characteristic)::text, 'CNTCT'::text)));


--
-- TOC entry 8620 (class 2618 OID 146571808)
-- Dependencies: 275 275 275 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO contactcomment DO INSTEAD NOTHING;


--
-- TOC entry 8621 (class 2618 OID 146571809)
-- Dependencies: 221 221 218 218 218 1414 221 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO creditmemo DO INSTEAD SELECT public.deletecreditmemo(cmhead.cmhead_id) AS deletecreditmemo FROM public.cmhead WHERE ((cmhead.cmhead_number = old.memo_number) AND (cmhead.cmhead_posted = false));


--
-- TOC entry 8622 (class 2618 OID 146571810)
-- Dependencies: 223 223 223 222 222 1668 223 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO creditmemoline DO INSTEAD DELETE FROM public.cmitem WHERE ((cmitem.cmitem_cmhead_id = public.getcmheadid(old.memo_number, false)) AND (cmitem.cmitem_linenumber = old.line_number));


--
-- TOC entry 8623 (class 2618 OID 146571811)
-- Dependencies: 276 276 276 237 237 237 1682 1665 276 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO custchar DO INSTEAD DELETE FROM public.charass WHERE (((charass.charass_target_type = 'C'::text) AND (charass.charass_target_id = public.getcustid((old.customer_number)::text))) AND (charass.charass_char_id = public.getcharid((old.characteristic)::text, 'C'::text)));


--
-- TOC entry 8624 (class 2618 OID 146571812)
-- Dependencies: 277 277 277 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO custcomment DO INSTEAD NOTHING;


--
-- TOC entry 8625 (class 2618 OID 146571813)
-- Dependencies: 279 279 279 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO custcreditcard DO INSTEAD NOTHING;


--
-- TOC entry 8626 (class 2618 OID 146571814)
-- Dependencies: 283 283 213 283 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO customer DO INSTEAD DELETE FROM public.custinfo WHERE (custinfo.cust_number = (old.customer_number)::text);


--
-- TOC entry 8627 (class 2618 OID 146571816)
-- Dependencies: 287 287 280 287 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO customertype DO INSTEAD DELETE FROM public.custtype WHERE (custtype.custtype_code = (old.code)::text);


--
-- TOC entry 8628 (class 2618 OID 146571817)
-- Dependencies: 288 288 288 237 237 237 1686 1665 288 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO customertypechar DO INSTEAD DELETE FROM public.charass WHERE (((charass.charass_target_type = 'CT'::text) AND (charass.charass_target_id = public.getcusttypeid((old.customer_type)::text))) AND (charass.charass_char_id = public.getcharid((old.characteristic)::text, 'CT'::text)));


--
-- TOC entry 8629 (class 2618 OID 146571818)
-- Dependencies: 289 289 289 1756 1456 289 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO custshipto DO INSTEAD SELECT public.deleteshipto(public.getshiptoid((old.customer_number)::text, (old.shipto_number)::text)) AS deleteshipto;


--
-- TOC entry 8630 (class 2618 OID 146571819)
-- Dependencies: 290 290 290 285 285 285 1765 1682 290 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO custtax DO INSTEAD DELETE FROM public.taxreg WHERE (((taxreg.taxreg_rel_type = 'C'::bpchar) AND (taxreg.taxreg_rel_id = public.getcustid((old.customer_number)::text))) AND (taxreg.taxreg_taxauth_id = public.gettaxauthid((old.tax_authority)::text)));


--
-- TOC entry 8631 (class 2618 OID 146571820)
-- Dependencies: 294 294 292 294 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO employee DO INSTEAD DELETE FROM public.emp WHERE (emp.emp_code = (old.code)::text);


--
-- TOC entry 8632 (class 2618 OID 146571821)
-- Dependencies: 295 295 295 237 237 237 1690 1665 295 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO employeechar DO INSTEAD DELETE FROM public.charass WHERE (((charass.charass_target_type = 'EMP'::text) AND (charass.charass_target_id = public.getempid((old.employee_code)::text))) AND (charass.charass_char_id = public.getcharid((old.characteristic)::text, 'EMP'::text)));


--
-- TOC entry 8633 (class 2618 OID 146571822)
-- Dependencies: 296 296 296 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO employeecomment DO INSTEAD NOTHING;


--
-- TOC entry 8634 (class 2618 OID 146571823)
-- Dependencies: 298 298 298 298 298 297 297 297 297 298 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO extshipmaint DO INSTEAD DELETE FROM public.shipdata WHERE ((((shipdata.shipdata_cohead_number = (old.so_number)::text) AND (shipdata.shipdata_shiphead_number = (old.shipment_number)::text)) AND (shipdata.shipdata_shipper = (old.shipper)::text)) AND (shipdata.shipdata_cosmisc_packnum_tracknum = (old.package_tracking_number)::text));


--
-- TOC entry 8635 (class 2618 OID 146571824)
-- Dependencies: 302 302 302 302 302 302 302 302 302 300 300 300 300 300 300 300 300 1780 1759 1684 1697 302 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO freightpricingscheduleitem DO INSTEAD DELETE FROM public.ipsfreight WHERE (((((((((ipsfreight.ipsfreight_ipshead_id = public.getipsheadid((old.pricing_schedule)::text)) AND (ipsfreight.ipsfreight_qtybreak = old.qty_break)) AND (ipsfreight.ipsfreight_price = old.price)) AND ((ipsfreight.ipsfreight_type)::text = CASE WHEN (old.price_type = 'Flat Rate'::text) THEN 'F'::text WHEN (old.price_type = 'Price Per UOM'::text) THEN 'P'::text ELSE NULL::text END)) AND ((ipsfreight.ipsfreight_warehous_id IS NULL) AND (old.from_site = 'Any'::text))) OR ((ipsfreight.ipsfreight_warehous_id = CASE WHEN (old.from_site = 'Any'::text) THEN 0 ELSE public.getwarehousid(old.from_site, 'All'::text) END) AND ((ipsfreight.ipsfreight_shipzone_id IS NULL) AND (old.to_shipzone = 'Any'::text)))) OR ((ipsfreight.ipsfreight_shipzone_id = CASE WHEN (old.to_shipzone = 'Any'::text) THEN 0 ELSE public.getshipzoneid(old.to_shipzone) END) AND ((ipsfreight.ipsfreight_freightclass_id IS NULL) AND (old.freight_class = 'Any'::text)))) OR ((ipsfreight.ipsfreight_freightclass_id = CASE WHEN (old.freight_class = 'Any'::text) THEN 0 ELSE public.getfreightclassid(old.freight_class) END) AND ((ipsfreight.ipsfreight_shipvia IS NULL) AND (old.ship_via = 'Any'::text)))) OR (ipsfreight.ipsfreight_shipvia = old.ship_via));


--
-- TOC entry 8636 (class 2618 OID 146571826)
-- Dependencies: 308 308 308 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO incident DO INSTEAD NOTHING;


--
-- TOC entry 8637 (class 2618 OID 146571827)
-- Dependencies: 309 309 309 237 237 237 1708 1665 309 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO incidentchar DO INSTEAD DELETE FROM public.charass WHERE (((charass.charass_target_type = 'INCDT'::text) AND (charass.charass_target_id = public.getincidentid(old.incident_number))) AND (charass.charass_char_id = public.getcharid((old.characteristic)::text, 'INCDT'::text)));


--
-- TOC entry 8638 (class 2618 OID 146571828)
-- Dependencies: 310 310 310 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO incidentcomment DO INSTEAD NOTHING;


--
-- TOC entry 8639 (class 2618 OID 146571829)
-- Dependencies: 311 311 311 311 245 245 245 245 1708 311 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO incidentfile DO INSTEAD DELETE FROM public.url WHERE ((((url.url_source_id = public.getincidentid(old.incident_number)) AND (url.url_source = 'INCDT'::text)) AND (url.url_title = old.title)) AND (url.url_url = old.url));


--
-- TOC entry 8640 (class 2618 OID 146571830)
-- Dependencies: 312 312 312 249 249 249 1708 1702 312 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO incidentimage DO INSTEAD DELETE FROM public.imageass WHERE (((imageass.imageass_source_id = public.getincidentid(old.incident_number)) AND (imageass.imageass_source = 'INCDT'::text)) AND (imageass.imageass_image_id = public.getimageid(old.image_name)));


--
-- TOC entry 8641 (class 2618 OID 146571831)
-- Dependencies: 228 228 224 224 224 1423 228 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO invoice DO INSTEAD SELECT public.deleteinvoice(invchead.invchead_id) AS deleteinvoice FROM public.invchead WHERE ((invchead.invchead_invcnumber = old.invoice_number) AND (invchead.invchead_posted = false));


--
-- TOC entry 8642 (class 2618 OID 146571832)
-- Dependencies: 230 230 229 224 224 224 230 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO invoiceline DO INSTEAD DELETE FROM public.invcitem WHERE (invcitem.invcitem_invchead_id = (SELECT invchead.invchead_id FROM public.invchead WHERE ((invchead.invchead_invcnumber = old.invoice_number) AND (invchead.invchead_posted = false))));


--
-- TOC entry 8643 (class 2618 OID 146571833)
-- Dependencies: 315 315 1714 1426 315 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO item DO INSTEAD SELECT public.deleteitem(public.getitemid((old.item_number)::text)) AS deleteitem;


--
-- TOC entry 8644 (class 2618 OID 146571834)
-- Dependencies: 317 317 317 316 316 1714 317 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO itemalias DO INSTEAD DELETE FROM public.itemalias WHERE ((itemalias.itemalias_item_id = public.getitemid((old.item_number)::text)) AND (itemalias.itemalias_number = old.alias_number));


--
-- TOC entry 8645 (class 2618 OID 146571835)
-- Dependencies: 318 318 318 237 237 237 1714 1665 318 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO itemchar DO INSTEAD DELETE FROM public.charass WHERE (((charass.charass_target_type = 'I'::text) AND (charass.charass_target_id = public.getitemid((old.item_number)::text))) AND (charass.charass_char_id = public.getcharid((old.characteristic)::text, 'I'::text)));


--
-- TOC entry 8646 (class 2618 OID 146571836)
-- Dependencies: 319 319 319 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO itemcomment DO INSTEAD NOTHING;


--
-- TOC entry 8647 (class 2618 OID 146571837)
-- Dependencies: 322 322 322 1714 1679 1427 322 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO itemcost DO INSTEAD SELECT public.deleteitemcost(public.getitemid((old.item_number)::text), public.getcostelemid((old.costing_element)::text)) AS deleteitemcost;


--
-- TOC entry 8648 (class 2618 OID 146571838)
-- Dependencies: 323 323 323 323 245 245 245 245 1714 323 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO itemfile DO INSTEAD DELETE FROM public.url WHERE ((((url.url_source_id = public.getitemid((old.item_number)::text)) AND (url.url_source = 'I'::text)) AND (url.url_title = old.title)) AND (url.url_url = old.url));


--
-- TOC entry 8649 (class 2618 OID 146571839)
-- Dependencies: 324 324 324 249 249 249 1714 1702 324 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO itemimage DO INSTEAD DELETE FROM public.imageass WHERE (((imageass.imageass_source_id = public.getitemid((old.item_number)::text)) AND (imageass.imageass_source = 'I'::text)) AND (imageass.imageass_image_id = public.getimageid(old.image_name)));


--
-- TOC entry 8650 (class 2618 OID 146571840)
-- Dependencies: 327 327 327 1716 1428 327 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO itemsite DO INSTEAD SELECT public.deleteitemsite(public.getitemsiteid((old.site)::text, (old.item_number)::text)) AS deleteitemsite;


--
-- TOC entry 8651 (class 2618 OID 146571841)
-- Dependencies: 328 328 328 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO itemsitecomment DO INSTEAD NOTHING;


--
-- TOC entry 8652 (class 2618 OID 146571842)
-- Dependencies: 331 331 331 331 331 331 330 330 330 330 330 1778 1714 331 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO itemsource DO INSTEAD DELETE FROM public.itemsrc WHERE (((((itemsrc.itemsrc_item_id = public.getitemid((old.item_number)::text)) AND (itemsrc.itemsrc_vend_id = public.getvendid((old.vendor)::text))) AND (itemsrc.itemsrc_vend_item_number = old.vendor_item_number)) AND (itemsrc.itemsrc_manuf_name = old.manufacturer_name)) AND (itemsrc.itemsrc_manuf_item_number = old.manufacturer_item_number));


--
-- TOC entry 8653 (class 2618 OID 146571843)
-- Dependencies: 333 333 333 333 332 332 1718 333 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO itemsourceprice DO INSTEAD DELETE FROM public.itemsrcp WHERE ((itemsrcp.itemsrcp_itemsrc_id = public.getitemsrcid((old.item_number)::text, (old.vendor)::text)) AND (itemsrcp.itemsrcp_qtybreak = old.qty_break));


--
-- TOC entry 8654 (class 2618 OID 146571844)
-- Dependencies: 335 335 335 334 334 1714 335 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO itemsubstitute DO INSTEAD DELETE FROM public.itemsub WHERE ((itemsub.itemsub_parent_item_id = public.getitemid((old.root_item_number)::text)) AND (itemsub.itemsub_sub_item_id = public.getitemid((old.substitute_item_number)::text)));


--
-- TOC entry 8655 (class 2618 OID 146571845)
-- Dependencies: 337 337 337 337 336 336 336 1768 1767 1714 337 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO itemtaxtype DO INSTEAD DELETE FROM public.itemtax WHERE (((itemtax.itemtax_item_id = public.getitemid((old.item_number)::text)) AND CASE WHEN ((old.tax_zone)::text = 'Any'::text) THEN (itemtax.itemtax_taxzone_id IS NULL) ELSE (itemtax.itemtax_taxzone_id = public.gettaxzoneid((old.tax_zone)::text)) END) AND (itemtax.itemtax_taxtype_id = public.gettaxtypeid(old.tax_type)));


--
-- TOC entry 8656 (class 2618 OID 146571846)
-- Dependencies: 339 339 339 339 338 338 338 338 1771 1714 1430 339 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO itemuomconversion DO INSTEAD SELECT public.deleteitemuomconv(itemuomconv.itemuomconv_id) AS deleteitemuomconv FROM public.itemuomconv WHERE ((itemuomconv.itemuomconv_item_id = public.getitemid((old.item_number)::text)) AND (((itemuomconv.itemuomconv_from_uom_id = public.getuomid((old.uom)::text)) AND (itemuomconv.itemuomconv_to_uom_id = public.getuomid(old.per_uom))) OR ((itemuomconv.itemuomconv_from_uom_id = public.getuomid(old.per_uom)) AND (itemuomconv.itemuomconv_to_uom_id = public.getuomid((old.uom)::text)))));


--
-- TOC entry 8657 (class 2618 OID 146571847)
-- Dependencies: 341 341 341 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO journalentry DO INSTEAD NOTHING;


--
-- TOC entry 8658 (class 2618 OID 146571848)
-- Dependencies: 344 344 344 342 342 1780 344 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO location DO INSTEAD DELETE FROM public.location WHERE ((location.location_warehous_id = public.getwarehousid((old.site)::text, 'ACTIVE'::text)) AND (location.location_name = (old.location)::text));


--
-- TOC entry 8659 (class 2618 OID 146571849)
-- Dependencies: 345 345 345 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO misccounttag DO INSTEAD NOTHING;


--
-- TOC entry 8660 (class 2618 OID 146571850)
-- Dependencies: 346 346 301 346 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO pricingschedule DO INSTEAD DELETE FROM public.ipshead WHERE ((old.name)::text = ipshead.ipshead_name);


--
-- TOC entry 8661 (class 2618 OID 146571851)
-- Dependencies: 348 348 348 348 348 348 348 347 347 347 347 347 347 1756 1684 1686 1682 348 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO pricingscheduleassign DO INSTEAD DELETE FROM public.ipsass WHERE ((((((ipsass.ipsass_ipshead_id = public.getipsheadid((old.pricing_schedule)::text)) AND (ipsass.ipsass_cust_id = CASE WHEN ((old.customer_number)::text = 'Any'::text) THEN (-1) ELSE public.getcustid((old.customer_number)::text) END)) AND (ipsass.ipsass_custtype_id = CASE WHEN ((old.customer_type)::text = 'N/A'::text) THEN (-1) ELSE public.getcusttypeid((old.customer_type)::text) END)) AND (ipsass.ipsass_custtype_pattern = (old.customer_type_pattern)::text)) AND (ipsass.ipsass_shipto_id = CASE WHEN ((old.customer_shipto)::text = 'Any'::text) THEN (-1) ELSE public.getshiptoid((old.customer_number)::text, (old.customer_shipto)::text) END)) AND (ipsass.ipsass_shipto_pattern = (old.customer_shipto_pattern)::text));


--
-- TOC entry 8662 (class 2618 OID 146571852)
-- Dependencies: 350 350 350 350 350 350 350 350 1713 1712 1425 1424 350 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO pricingscheduleitem DO INSTEAD SELECT CASE WHEN ((old.type)::text = 'Item'::text) THEN public.deleteipsitem(public.getipsitemid((old.pricing_schedule)::text, (old.item_number)::text, old.qty_break, (old.qty_uom)::text, (old.price_uom)::text)) WHEN ((old.type)::text = 'Product Category'::text) THEN public.deleteipsprodcat(public.getipsprodcatid((old.pricing_schedule)::text, (old.product_category)::text, old.qty_break)) ELSE NULL::integer END AS result;


--
-- TOC entry 8663 (class 2618 OID 146571853)
-- Dependencies: 352 352 352 352 352 352 352 352 351 351 351 1712 1665 352 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO pricingscheduleitemchar DO INSTEAD DELETE FROM public.ipsitemchar WHERE (((ipsitemchar.ipsitemchar_ipsitem_id = public.getipsitemid((old.pricing_schedule)::text, (old.item_number)::text, old.qty_break, (old.qty_uom)::text, (old.price_uom)::text)) AND (ipsitemchar.ipsitemchar_char_id = public.getcharid((old.characteristic)::text, 'I'::text))) AND (ipsitemchar.ipsitemchar_value = (old.value)::text));


--
-- TOC entry 8664 (class 2618 OID 146571854)
-- Dependencies: 353 353 1736 1444 353 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO project DO INSTEAD SELECT public.deleteproject(public.getprjid(old.number)) AS deleteproject;


--
-- TOC entry 8665 (class 2618 OID 146571855)
-- Dependencies: 354 354 354 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO projectcomment DO INSTEAD NOTHING;


--
-- TOC entry 8666 (class 2618 OID 146571856)
-- Dependencies: 357 357 356 357 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO prospect DO INSTEAD DELETE FROM public.prospect WHERE (prospect.prospect_number = (old.prospect_number)::text);


--
-- TOC entry 8667 (class 2618 OID 146571857)
-- Dependencies: 360 360 360 198 1734 360 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO purchaseline DO INSTEAD DELETE FROM public.poitem WHERE (poitem.poitem_id = public.getpoitemid((old.order_number)::text, old.line_number));


--
-- TOC entry 8668 (class 2618 OID 146571858)
-- Dependencies: 361 361 361 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO purchaselinechar DO INSTEAD NOTHING;


--
-- TOC entry 8669 (class 2618 OID 146571859)
-- Dependencies: 362 362 362 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO purchaselinecomment DO INSTEAD NOTHING;


--
-- TOC entry 8670 (class 2618 OID 146571860)
-- Dependencies: 365 365 197 197 1438 365 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO purchaseorder DO INSTEAD SELECT public.deletepo(pohead.pohead_id) AS deletepo FROM public.pohead WHERE (pohead.pohead_number = (old.order_number)::text);


--
-- TOC entry 8671 (class 2618 OID 146571861)
-- Dependencies: 366 366 366 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO purchaseordercomment DO INSTEAD NOTHING;


--
-- TOC entry 8672 (class 2618 OID 146571862)
-- Dependencies: 368 368 367 367 1447 368 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO quote DO INSTEAD SELECT public.deletequote(quhead.quhead_id, (old.quote_number)::text) AS deletequote FROM public.quhead WHERE (quhead.quhead_number = (old.quote_number)::text);


--
-- TOC entry 8673 (class 2618 OID 146571863)
-- Dependencies: 369 369 369 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO quotecomment DO INSTEAD NOTHING;


--
-- TOC entry 8674 (class 2618 OID 146571864)
-- Dependencies: 371 371 371 370 370 1720 371 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO quoteline DO INSTEAD DELETE FROM public.quitem WHERE ((quitem.quitem_quhead_id = public.getquoteid(old.quote_number)) AND (quitem.quitem_linenumber = old.line_number));


--
-- TOC entry 8675 (class 2618 OID 146571865)
-- Dependencies: 372 372 372 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO quotelinechar DO INSTEAD NOTHING;


--
-- TOC entry 8676 (class 2618 OID 146571866)
-- Dependencies: 373 373 373 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO quotelinecomment DO INSTEAD NOTHING;


--
-- TOC entry 8677 (class 2618 OID 146571867)
-- Dependencies: 380 380 380 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO saleshistory DO INSTEAD NOTHING;


--
-- TOC entry 8678 (class 2618 OID 146571868)
-- Dependencies: 381 381 381 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO saleslinechar DO INSTEAD NOTHING;


--
-- TOC entry 8679 (class 2618 OID 146571869)
-- Dependencies: 382 382 382 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO saleslinecomment DO INSTEAD NOTHING;


--
-- TOC entry 8680 (class 2618 OID 146571870)
-- Dependencies: 383 383 195 195 1458 383 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO salesorder DO INSTEAD SELECT public.deleteso(cohead.cohead_id, (old.order_number)::text) AS deleteso FROM public.cohead WHERE (cohead.cohead_number = (old.order_number)::text);


--
-- TOC entry 8681 (class 2618 OID 146571872)
-- Dependencies: 384 384 384 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO salesordercomment DO INSTEAD NOTHING;


--
-- TOC entry 8682 (class 2618 OID 146571873)
-- Dependencies: 385 385 216 385 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO salesrep DO INSTEAD DELETE FROM public.salesrep WHERE (salesrep.salesrep_number = (old.number)::text);


--
-- TOC entry 8683 (class 2618 OID 146571874)
-- Dependencies: 388 388 388 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO site DO NOTHING;


--
-- TOC entry 8684 (class 2618 OID 146571875)
-- Dependencies: 389 389 389 343 343 1780 389 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO sitezone DO INSTEAD DELETE FROM public.whsezone WHERE ((whsezone.whsezone_warehous_id = public.getwarehousid((old.site)::text, 'ACTIVE'::text)) AND (whsezone.whsezone_name = (old.name)::text));


--
-- TOC entry 8685 (class 2618 OID 146571876)
-- Dependencies: 390 390 390 232 232 1736 390 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO task DO INSTEAD DELETE FROM public.prjtask WHERE ((prjtask.prjtask_prj_id = public.getprjid(old.project_number)) AND (prjtask.prjtask_number = old.number));


--
-- TOC entry 8686 (class 2618 OID 146571877)
-- Dependencies: 391 391 391 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO taskcomment DO INSTEAD NOTHING;


--
-- TOC entry 8687 (class 2618 OID 146571878)
-- Dependencies: 392 392 1468 392 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO todo DO INSTEAD SELECT public.deletetodoitem(old.task_number) AS deletetodoitem;


--
-- TOC entry 8688 (class 2618 OID 146571879)
-- Dependencies: 394 394 210 394 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO vendor DO INSTEAD DELETE FROM public.vendinfo WHERE (vendinfo.vend_number = (old.vendor_number)::text);


--
-- TOC entry 8689 (class 2618 OID 146571880)
-- Dependencies: 395 395 395 1777 1479 395 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO vendoraddress DO INSTEAD SELECT public.deletevendoraddress(public.getvendaddrid((old.vendor_number)::text, (old.vendor_address_number)::text)) AS deletevendoraddress;


--
-- TOC entry 8690 (class 2618 OID 146571881)
-- Dependencies: 396 396 1779 1480 396 8894
-- Name: _DELETE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO vendortype DO INSTEAD SELECT public.deletevendortype(public.getvendtypeid((old.code)::text)) AS deletevendortype;


--
-- TOC entry 8691 (class 2618 OID 146571882)
-- Dependencies: 201 201 1832 201 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO salesline DO INSTEAD SELECT public.insertsalesline(new.*) AS insertsalesline;


--
-- TOC entry 8692 (class 2618 OID 146571883)
-- Dependencies: 211 211 1813 211 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO apmemo DO INSTEAD SELECT public.insertapmemo(new.*) AS insertapmemo;


--
-- TOC entry 8693 (class 2618 OID 146571884)
-- Dependencies: 217 217 1814 217 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO armemo DO INSTEAD SELECT public.insertarmemo(new.*) AS insertarmemo;


--
-- TOC entry 8694 (class 2618 OID 146571885)
-- Dependencies: 194 194 906 194 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO physinvcount DO INSTEAD SELECT insertphysinvcount(new.*) AS insertphysinvcount;


--
-- TOC entry 8695 (class 2618 OID 146571886)
-- Dependencies: 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 235 205 2162 2158 1680 1670 1658 1537 235 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO account DO INSTEAD INSERT INTO public.crmacct (crmacct_number, crmacct_parent_id, crmacct_name, crmacct_active, crmacct_type, crmacct_cntct_id_1, crmacct_cntct_id_2, crmacct_notes) VALUES (COALESCE(new.account_number, ((public.fetchcrmaccountnumber())::text)::character varying), public.getcrmacctid(new.parent_account), new.account_name, COALESCE(new.active, true), CASE WHEN (new.type = 'Individual'::text) THEN 'I'::text ELSE 'O'::text END, public.savecntct(public.getcntctid(new.primary_contact_number), new.primary_contact_number, public.saveaddr(public.getaddrid(new.primary_contact_address_number), new.primary_contact_address_number, new.primary_contact_address1, new.primary_contact_address2, new.primary_contact_address3, new.primary_contact_city, new.primary_contact_state, new.primary_contact_postalcode, new.primary_contact_country, new.primary_contact_address_change), new.primary_contact_honorific, new.primary_contact_first, new.primary_contact_middle, new.primary_contact_last, new.primary_contact_suffix, new.primary_contact_voice, NULL::text, new.primary_contact_fax, new.primary_contact_email, NULL::text, new.primary_contact_job_title, new.primary_contact_change), public.savecntct(public.getcntctid(new.secondary_contact_number), new.secondary_contact_number, public.saveaddr(public.getaddrid(new.secondary_contact_address_number), new.secondary_contact_address_number, new.secondary_contact_address1, new.secondary_contact_address2, new.secondary_contact_address3, new.secondary_contact_city, new.secondary_contact_state, new.secondary_contact_postalcode, new.secondary_contact_country, new.secondary_contact_address_change), new.secondary_contact_honorific, new.secondary_contact_first, new.secondary_contact_middle, new.secondary_contact_last, new.secondary_contact_suffix, new.secondary_contact_voice, NULL::text, new.secondary_contact_fax, new.secondary_contact_email, NULL::text, new.secondary_contact_job_title, new.secondary_contact_change), new.notes);


--
-- TOC entry 8696 (class 2618 OID 146571888)
-- Dependencies: 238 238 238 238 237 1680 1665 238 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO accountchar DO INSTEAD INSERT INTO public.charass (charass_target_type, charass_target_id, charass_char_id, charass_value, charass_default) VALUES ('CRMACCT'::text, public.getcrmacctid((new.account_number)::text), public.getcharid((new.characteristic)::text, 'CRMACCT'::text), new.value, false);


--
-- TOC entry 8697 (class 2618 OID 146571889)
-- Dependencies: 241 241 241 241 241 241 240 1680 1669 910 241 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO accountcomment DO INSTEAD INSERT INTO public.comment (comment_date, comment_source, comment_source_id, comment_user, comment_cmnttype_id, comment_text) VALUES (COALESCE(new.date, now()), 'CRMA'::text, public.getcrmacctid((new.account_number)::text), COALESCE(new.username, public.geteffectivextuser()), public.getcmnttypeid(new.type), new.text);


--
-- TOC entry 8698 (class 2618 OID 146571890)
-- Dependencies: 246 246 246 246 245 1680 246 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO accountfile DO INSTEAD INSERT INTO public.url (url_source_id, url_source, url_title, url_url) VALUES (public.getcrmacctid(new.account_number), 'CRMA'::text, new.title, new.url);


--
-- TOC entry 8699 (class 2618 OID 146571891)
-- Dependencies: 250 250 250 2165 1702 1680 250 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO accountimage DO INSTEAD SELECT public.saveimageass('CRMA'::text, public.getcrmacctid(new.account_number), 'M'::bpchar, public.getimageid(new.image_name)) AS saveimageass;


--
-- TOC entry 8700 (class 2618 OID 146571892)
-- Dependencies: 251 251 251 251 251 251 251 251 251 251 251 2157 251 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO address DO INSTEAD SELECT public.saveaddr(NULL::integer, (new.address_number)::text, new.address1, new.address2, new.address3, new.city, new.state, new.postal_code, new.country, COALESCE(new.active, true), new.notes, NULL::text) AS saveaddr;


--
-- TOC entry 8701 (class 2618 OID 146571893)
-- Dependencies: 252 252 252 252 237 1665 1658 252 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO addresschar DO INSTEAD INSERT INTO public.charass (charass_target_type, charass_target_id, charass_char_id, charass_value, charass_default) VALUES ('ADDR'::text, public.getaddrid((new.address_number)::text), public.getcharid((new.characteristic)::text, 'ADDR'::text), new.value, false);


--
-- TOC entry 8702 (class 2618 OID 146571894)
-- Dependencies: 253 253 253 253 253 253 240 1669 1658 910 253 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO addresscomment DO INSTEAD INSERT INTO public.comment (comment_date, comment_source, comment_source_id, comment_user, comment_cmnttype_id, comment_text) VALUES (COALESCE(new.date, now()), 'ADDR'::text, public.getaddrid((new.address_number)::text), COALESCE(new.username, public.geteffectivextuser()), public.getcmnttypeid(new.type), new.text);


--
-- TOC entry 8703 (class 2618 OID 146571895)
-- Dependencies: 255 255 255 255 255 255 255 2160 1714 255 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO bom DO INSTEAD SELECT public.savebomhead(public.getitemid((new.item_number)::text), (new.revision)::text, new.revision_date, new.document_number, COALESCE(new.batch_size, (0)::numeric), new.total_qty_per) AS savebomhead;


--
-- TOC entry 8704 (class 2618 OID 146571897)
-- Dependencies: 256 467 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 191 191 2233 1771 1742 1714 1665 1650 1546 1519 1311 1148 256 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO bomitem DO INSTEAD SELECT public.createbomitem(COALESCE(new.id, (nextval('public.bomitem_bomitem_id_seq'::regclass))::integer), public.getitemid((new.bom_item_number)::text), public.getitemid(new.item_number), COALESCE(new.sequence_number, (SELECT (max(bomitem.bomitem_seqnumber) + 10) FROM public.bomitem(public.getitemid((new.bom_item_number)::text), COALESCE(public.getrevid('BOM'::text, (new.bom_item_number)::text, (new.bom_revision)::text))) bomitem(bomitem_id, bomitem_parent_item_id, bomitem_seqnumber, bomitem_item_id, bomitem_qtyper, bomitem_scrap, bomitem_status, bomitem_effective, bomitem_expires, bomitem_createwo, bomitem_issuemethod, bomitem_schedatwooper, bomitem_ecn, bomitem_moddate, bomitem_subtype, bomitem_uom_id, bomitem_rev_id, bomitem_booitem_seq_id, bomitem_char_id, bomitem_value, bomitem_notes, bomitem_ref, bomitem_qtyfxd, bomitem_issuewo)), 10), (CASE WHEN (new.issue_method = 'Mixed'::text) THEN 'M'::text WHEN (new.issue_method = 'Push'::text) THEN 'S'::text WHEN (new.issue_method = 'Pull'::text) THEN 'L'::text ELSE public.fetchmetrictext('DefaultWomatlIssueMethod'::text) END)::bpchar, COALESCE(public.getuomid(new.issue_uom), (SELECT item.item_inv_uom_id FROM public.item WHERE (item.item_id = public.getitemid(new.item_number)))), new.qty_per, new.scrap, CASE WHEN (new.effective = 'Always'::text) THEN public.startoftime() ELSE COALESCE((new.effective)::date, public.startoftime()) END, CASE WHEN (new.expires = 'Never'::text) THEN public.endoftime() ELSE COALESCE((new.expires)::date, public.endoftime()) END, COALESCE(new.create_child_wo, false), COALESCE(public.getbooitemseqid((new.bom_item_number)::text, new.used_at), (-1)), COALESCE(new.schedule_at_wo_operation, false), new.ecn_number, (CASE WHEN (new.substitutions = 'No'::text) THEN 'N'::text WHEN (new.substitutions = 'BOM-Defined'::text) THEN 'B'::text ELSE 'I'::text END)::bpchar, COALESCE(public.getrevid('BOM'::text, (new.bom_item_number)::text, (new.bom_revision)::text)), public.getcharid(new.characteristic, 'I'::text), new.value, new.notes, new.reference) AS createbomitem;


--
-- TOC entry 8705 (class 2618 OID 146571899)
-- Dependencies: 257 257 257 257 257 257 240 1669 910 257 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO bomitemcomment DO INSTEAD INSERT INTO public.comment (comment_date, comment_source, comment_source_id, comment_user, comment_cmnttype_id, comment_text) VALUES (COALESCE(new.date, now()), 'BMI'::text, new.bomitem_id, COALESCE(new.username, public.geteffectivextuser()), public.getcmnttypeid(new.type), new.text);


--
-- TOC entry 8706 (class 2618 OID 146571900)
-- Dependencies: 259 259 259 259 259 258 1714 259 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO bomitemsubstitute DO INSTEAD INSERT INTO public.bomitemsub (bomitemsub_bomitem_id, bomitemsub_item_id, bomitemsub_uomratio, bomitemsub_rank) VALUES (new.bomitem_id, public.getitemid((new.substitute_item_number)::text), COALESCE(new.sub_parent_uom_ratio, (1)::numeric), COALESCE(new.ranking, 1));


--
-- TOC entry 8707 (class 2618 OID 146571901)
-- Dependencies: 261 261 261 260 261 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO budget DO INSTEAD INSERT INTO public.budghead (budghead_name, budghead_descrip) VALUES (new.name, new.description);


--
-- TOC entry 8708 (class 2618 OID 146571902)
-- Dependencies: 265 265 265 265 265 263 1730 1700 1663 265 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO budgetentry DO INSTEAD INSERT INTO public.budgitem (budgitem_budghead_id, budgitem_period_id, budgitem_accnt_id, budgitem_amount) VALUES (public.getbudgheadid(new.name), public.getperiodid(new.period_start), public.getglaccntid(new.account), new.amount);


--
-- TOC entry 8709 (class 2618 OID 146571903)
-- Dependencies: 268 268 268 268 268 268 268 268 268 268 268 267 1744 1682 1681 1661 1535 268 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO cashreceipt DO INSTEAD INSERT INTO public.cashrcpt (cashrcpt_cust_id, cashrcpt_number, cashrcpt_amount, cashrcpt_fundstype, cashrcpt_docnumber, cashrcpt_bankaccnt_id, cashrcpt_notes, cashrcpt_distdate, cashrcpt_salescat_id, cashrcpt_curr_id, cashrcpt_usecustdeposit) VALUES (public.getcustid((new.customer_number)::text), (SELECT public.fetchcashrcptnumber() AS fetchcashrcptnumber), COALESCE(new.amount_received, (0)::numeric), CASE WHEN ((new.funds_type)::text = 'Check'::text) THEN 'C'::text WHEN ((new.funds_type)::text = 'Certified Check'::text) THEN 'T'::text WHEN ((new.funds_type)::text = 'Master Card'::text) THEN 'M'::text WHEN ((new.funds_type)::text = 'Visa'::text) THEN 'V'::text WHEN ((new.funds_type)::text = 'American Express'::text) THEN 'A'::text WHEN ((new.funds_type)::text = 'Discover Card'::text) THEN 'D'::text WHEN ((new.funds_type)::text = 'Other Credit Card'::text) THEN 'R'::text WHEN ((new.funds_type)::text = 'Cash'::text) THEN 'K'::text WHEN ((new.funds_type)::text = 'Wire Transfer'::text) THEN 'W'::text ELSE 'O'::text END, COALESCE(new.check_document_number, ''::character varying), public.getbankaccntid(new.post_to), COALESCE(new.notes, ''::text), CASE WHEN (new.distribution_date > ''::text) THEN ((new.distribution_date)::date)::timestamp with time zone ELSE now() END, COALESCE(public.getsalescatid(new.sales_category), (-1)), public.getcurrid((new.currency)::text), CASE WHEN (new.apply_balance_as = 'Customer Deposit'::text) THEN true ELSE false END);


--
-- TOC entry 8710 (class 2618 OID 146571905)
-- Dependencies: 270 270 270 270 270 270 270 270 269 1664 1660 270 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO cashreceiptapply DO INSTEAD INSERT INTO public.cashrcptitem (cashrcptitem_cashrcpt_id, cashrcptitem_aropen_id, cashrcptitem_amount, cashrcptitem_discount) VALUES (public.getcashrcptid((new.customer_number)::text, CASE WHEN ((new.funds_type)::text = 'Check'::text) THEN 'C'::text WHEN ((new.funds_type)::text = 'Certified Check'::text) THEN 'T'::text WHEN ((new.funds_type)::text = 'Master Card'::text) THEN 'M'::text WHEN ((new.funds_type)::text = 'Visa'::text) THEN 'V'::text WHEN ((new.funds_type)::text = 'American Express'::text) THEN 'A'::text WHEN ((new.funds_type)::text = 'Discover Card'::text) THEN 'D'::text WHEN ((new.funds_type)::text = 'Other Credit Card'::text) THEN 'R'::text WHEN ((new.funds_type)::text = 'Cash'::text) THEN 'K'::text WHEN ((new.funds_type)::text = 'Wire Transfer'::text) THEN 'W'::text ELSE 'O'::text END, (new.check_document_number)::text), public.getaropenid((new.customer_number)::text, (new.doc_type)::bpchar, (new.doc_number)::text), COALESCE(new.amount_to_apply, (0)::numeric), COALESCE(new.cashrcptitem_discount, (0)::numeric));


--
-- TOC entry 8711 (class 2618 OID 146571907)
-- Dependencies: 272 272 272 272 272 272 272 271 1700 1664 272 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO cashreceiptapplymisc DO INSTEAD INSERT INTO public.cashrcptmisc (cashrcptmisc_cashrcpt_id, cashrcptmisc_accnt_id, cashrcptmisc_amount, cashrcptmisc_notes) VALUES (public.getcashrcptid((new.customer_number)::text, CASE WHEN ((new.funds_type)::text = 'Check'::text) THEN 'C'::text WHEN ((new.funds_type)::text = 'Certified Check'::text) THEN 'T'::text WHEN ((new.funds_type)::text = 'Master Card'::text) THEN 'M'::text WHEN ((new.funds_type)::text = 'Visa'::text) THEN 'V'::text WHEN ((new.funds_type)::text = 'American Express'::text) THEN 'A'::text WHEN ((new.funds_type)::text = 'Discover Card'::text) THEN 'D'::text WHEN ((new.funds_type)::text = 'Other Credit Card'::text) THEN 'R'::text WHEN ((new.funds_type)::text = 'Cash'::text) THEN 'K'::text WHEN ((new.funds_type)::text = 'Wire Transfer'::text) THEN 'W'::text ELSE 'O'::text END, (new.check_document_number)::text), public.getglaccntid((new.account)::text), COALESCE(new.amount_to_distribute, (0)::numeric), COALESCE(new.notes, ''::text));


--
-- TOC entry 8712 (class 2618 OID 146571909)
-- Dependencies: 273 273 273 273 273 273 273 273 273 273 273 273 273 273 273 273 273 273 273 273 273 273 273 273 273 273 273 2161 2158 1680 1658 273 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO contact DO INSTEAD SELECT public.savecntct(NULL::integer, (new.contact_number)::text, public.getcrmacctid(new.crm_account), public.saveaddr(public.getaddrid(new.address_number), new.address_number, new.address1, new.address2, new.address3, new.city, new.state, new.postal_code, new.country, new.address_change), new.honorific, new.first, new.middle, new.last, new.suffix, new.initials, COALESCE(new.active, true), new.voice, new.alternate, new.fax, new.email, new.web, new.notes, new.job_title, new.contact_change) AS savecntct;


--
-- TOC entry 8713 (class 2618 OID 146571910)
-- Dependencies: 274 274 274 274 237 1670 1665 274 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO contactchar DO INSTEAD INSERT INTO public.charass (charass_target_type, charass_target_id, charass_char_id, charass_value, charass_default) VALUES ('CNTCT'::text, public.getcntctid(new.contact_number), public.getcharid((new.characteristic)::text, 'CNTCT'::text), new.value, false);


--
-- TOC entry 8714 (class 2618 OID 146571911)
-- Dependencies: 275 275 275 275 275 275 240 1670 1669 910 275 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO contactcomment DO INSTEAD INSERT INTO public.comment (comment_date, comment_source, comment_source_id, comment_user, comment_cmnttype_id, comment_text) VALUES (COALESCE(new.date, now()), 'T'::text, public.getcntctid(new.contact_number), COALESCE(new.username, public.geteffectivextuser()), public.getcmnttypeid(new.type), new.text);


--
-- TOC entry 8715 (class 2618 OID 146571912)
-- Dependencies: 221 221 1816 221 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO creditmemo DO INSTEAD SELECT public.insertcreditmemo(new.*) AS insertcreditmemo;


--
-- TOC entry 8716 (class 2618 OID 146571913)
-- Dependencies: 223 223 1817 223 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO creditmemoline DO INSTEAD SELECT public.insertcreditmemoline(new.*) AS insertcreditmemoline;


--
-- TOC entry 8717 (class 2618 OID 146571914)
-- Dependencies: 276 276 276 276 237 1682 1665 276 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO custchar DO INSTEAD INSERT INTO public.charass (charass_target_type, charass_target_id, charass_char_id, charass_value, charass_default) VALUES ('C'::text, public.getcustid((new.customer_number)::text), public.getcharid((new.characteristic)::text, 'C'::text), new.value, false);


--
-- TOC entry 8718 (class 2618 OID 146571915)
-- Dependencies: 277 277 277 277 277 277 240 1682 1669 910 277 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO custcomment DO INSTEAD INSERT INTO public.comment (comment_date, comment_source, comment_source_id, comment_user, comment_cmnttype_id, comment_text) VALUES (COALESCE(new.date, now()), 'C'::text, public.getcustid((new.customer_number)::text), COALESCE(new.username, public.geteffectivextuser()), public.getcmnttypeid(new.type), new.text);


--
-- TOC entry 8719 (class 2618 OID 146571916)
-- Dependencies: 279 279 279 279 279 279 279 279 279 279 279 279 279 279 279 1815 279 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO custcreditcard DO INSTEAD SELECT public.insertccard((new.customer_number)::text, new.active, new.credit_card_type, new.credit_card_number, new.name, new.street_address1, new.street_address2, new.city, new.state, new.postal_code, new.country, new.expiration_month, new.expiration_year, new.key) AS insertccard;


--
-- TOC entry 8720 (class 2618 OID 146571917)
-- Dependencies: 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 216 216 213 2162 2158 1780 1769 1768 1754 1753 1749 1686 1681 1671 1658 1547 1546 1545 1539 1537 907 283 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO customer DO INSTEAD INSERT INTO public.custinfo (cust_active, cust_custtype_id, cust_salesrep_id, cust_commprcnt, cust_name, cust_creditlmt, cust_creditrating, cust_backorder, cust_partialship, cust_terms_id, cust_discntprcnt, cust_balmethod, cust_ffshipto, cust_shipform_id, cust_shipvia, cust_blanketpos, cust_shipchrg_id, cust_creditstatus, cust_comments, cust_ffbillto, cust_usespos, cust_number, cust_autoupdatestatus, cust_autoholdorders, cust_preferred_warehous_id, cust_curr_id, cust_creditlmt_curr_id, cust_cntct_id, cust_corrcntct_id, cust_taxzone_id, cust_gracedays) VALUES (COALESCE(new.active, true), COALESCE((public.getcusttypeid(new.customer_type))::numeric, public.fetchmetricvalue('DefaultCustType'::text)), COALESCE((public.getsalesrepid(new.sales_rep))::numeric, public.fetchmetricvalue('DefaultSalesRep'::text)), COALESCE((new.commission * 0.01), (SELECT salesrep.salesrep_commission FROM public.salesrep WHERE (salesrep.salesrep_id = public.getsalesrepid(new.sales_rep)))), COALESCE(new.customer_name, ''::text), COALESCE((new.credit_limit)::numeric, public.fetchmetricvalue('SOCreditLimit'::text)), COALESCE(new.credit_rating, public.fetchmetrictext('SOCreditRate'::text)), COALESCE(new.accepts_backorders, public.fetchmetricbool('DefaultBackOrders'::text), false), COALESCE(new.accepts_partial_shipments, public.fetchmetricbool('DefaultPartialShipments'::text), false), COALESCE((public.gettermsid(new.default_terms))::numeric, public.fetchmetricvalue('DefaultTerms'::text)), COALESCE(new.default_discount, (0)::numeric), CASE WHEN (new.balance_method = 'Balance Forward'::text) THEN 'B'::text WHEN (new.balance_method = 'Open Items'::text) THEN 'O'::text ELSE COALESCE(public.fetchmetrictext('DefaultBalanceMethod'::text), 'B'::text) END, COALESCE(new.allow_free_form_shipto, public.fetchmetricbool('DefaultFreeFormShiptos'::text), false), COALESCE((public.getshipformid(new.ship_form))::numeric, public.fetchmetricvalue('DefaultShipFormId'::text)), COALESCE(new.ship_via, public.fetchdefaultshipvia()), COALESCE(new.uses_blanket_pos, false), COALESCE(public.getshipchrgid(new.shipping_charges), (-1)), CASE WHEN (new.credit_status = 'On Credit Warning'::text) THEN 'W'::text WHEN (new.credit_status = 'On Credit Hold'::text) THEN 'H'::text ELSE 'G'::text END, COALESCE(new.notes, ''::text), COALESCE(new.allow_free_form_billto, false), COALESCE(new.uses_purchase_orders, false), COALESCE(upper((new.customer_number)::text), (public.fetchcrmaccountnumber())::text), COALESCE(new.credit_status_exceed_warn, false), COALESCE(new.credit_status_exceed_hold, false), COALESCE(public.getwarehousid(new.preferred_selling_site, 'ACTIVE'::text), (-1)), COALESCE(public.getcurrid((new.default_currency)::text), public.basecurrid()), COALESCE(public.getcurrid((new.credit_limit_currency)::text), public.basecurrid()), public.savecntct(public.getcntctid(new.billing_contact_number, false), new.billing_contact_number, public.saveaddr(public.getaddrid(new.billing_contact_address_number), new.billing_contact_address_number, new.billing_contact_address1, new.billing_contact_address2, new.billing_contact_address3, new.billing_contact_city, new.billing_contact_state, new.billing_contact_postalcode, new.billing_contact_country, new.billing_contact_address_change), new.billing_contact_honorific, new.billing_contact_first, new.billing_contact_middle, new.billing_contact_last, new.billing_contact_suffix, new.billing_contact_voice, new.billing_contact_alternate, new.billing_contact_fax, new.billing_contact_email, new.billing_contact_web, new.billing_contact_job_title, new.billing_contact_change), public.savecntct(public.getcntctid(new.correspond_contact_number, false), new.correspond_contact_number, public.saveaddr(public.getaddrid(new.correspond_contact_address_number), new.correspond_contact_address_number, new.correspond_contact_address1, new.correspond_contact_address2, new.correspond_contact_address3, new.correspond_contact_city, new.correspond_contact_state, new.correspond_contact_postalcode, new.correspond_contact_country, new.correspond_contact_address_change), new.correspond_contact_honorific, new.correspond_contact_first, new.correspond_contact_middle, new.correspond_contact_last, new.correspond_contact_suffix, new.correspond_contact_voice, new.correspond_contact_alternate, new.correspond_contact_fax, new.correspond_contact_email, new.correspond_contact_web, new.correspond_contact_job_title, new.correspond_contact_change), public.gettaxzoneid(new.default_tax_zone), CASE WHEN (COALESCE(new.alternate_grace_days, 0) > 0) THEN new.alternate_grace_days ELSE NULL::integer END);


--
-- TOC entry 8721 (class 2618 OID 146571919)
-- Dependencies: 286 286 286 286 286 286 286 285 213 213 2233 1765 1682 1519 286 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO customertaxreg DO INSTEAD INSERT INTO public.taxreg (taxreg_rel_id, taxreg_rel_type, taxreg_taxauth_id, taxreg_taxzone_id, taxreg_number, taxreg_effective, taxreg_expires, taxreg_notes) VALUES (public.getcustid((new.customer_number)::text), 'C'::bpchar, public.gettaxauthid((new.tax_authority)::text), (SELECT custinfo.cust_taxzone_id FROM public.custinfo WHERE (custinfo.cust_id = public.getcustid((new.customer_number)::text))), COALESCE(new.registration_number, ''::text), CASE WHEN (new.start_date = 'Always'::text) THEN public.startoftime() ELSE COALESCE((new.start_date)::date, public.startoftime()) END, CASE WHEN (new.end_date = 'Never'::text) THEN public.endoftime() ELSE COALESCE((new.end_date)::date, public.endoftime()) END, new.notes);


--
-- TOC entry 8722 (class 2618 OID 146571921)
-- Dependencies: 287 287 287 287 280 287 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO customertype DO INSTEAD INSERT INTO public.custtype (custtype_code, custtype_descrip, custtype_char) VALUES (new.code, COALESCE(new.description, ''::text), COALESCE(new.enable_characteristics_profile, false));


--
-- TOC entry 8723 (class 2618 OID 146571922)
-- Dependencies: 288 288 288 288 288 237 1686 1665 288 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO customertypechar DO INSTEAD INSERT INTO public.charass (charass_target_type, charass_target_id, charass_char_id, charass_value, charass_default) VALUES ('CT'::text, public.getcusttypeid((new.customer_type)::text), public.getcharid((new.characteristic)::text, 'CT'::text), new.value, COALESCE(new.is_default, false));


--
-- TOC entry 8724 (class 2618 OID 146571923)
-- Dependencies: 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 219 219 213 213 213 213 213 213 2162 2158 1768 1759 1754 1753 1749 1688 1682 1670 1658 289 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO custshipto DO INSTEAD INSERT INTO public.shiptoinfo (shipto_cust_id, shipto_name, shipto_salesrep_id, shipto_comments, shipto_shipcomments, shipto_shipzone_id, shipto_shipvia, shipto_commission, shipto_shipform_id, shipto_shipchrg_id, shipto_active, shipto_default, shipto_num, shipto_ediprofile_id, shipto_cntct_id, shipto_addr_id, shipto_taxzone_id) VALUES (public.getcustid((new.customer_number)::text), COALESCE(new.name, ''::text), COALESCE(public.getsalesrepid(new.sales_rep), (SELECT custinfo.cust_salesrep_id FROM public.custinfo WHERE (custinfo.cust_id = public.getcustid((new.customer_number)::text)))), COALESCE(new.general_notes, ''::text), COALESCE(new.shipping_notes, ''::text), public.getshipzoneid(new.zone), COALESCE(new.ship_via, (SELECT custinfo.cust_shipvia FROM public.custinfo WHERE (custinfo.cust_id = public.getcustid((new.customer_number)::text)))), COALESCE((new.commission / 100.0), (0)::numeric), COALESCE(public.getshipformid(new.ship_form), (SELECT custinfo.cust_shipform_id FROM public.custinfo WHERE (custinfo.cust_id = public.getcustid((new.customer_number)::text)))), COALESCE(public.getshipchrgid(new.shipping_charges), (SELECT custinfo.cust_shipchrg_id FROM public.custinfo WHERE (custinfo.cust_id = public.getcustid((new.customer_number)::text)))), COALESCE(new.active, true), COALESCE(new.default_flag, false), COALESCE(new.shipto_number, (((SELECT (COALESCE(max((shiptoinfo.shipto_num)::integer), 0) + 1) FROM public.shiptoinfo WHERE ((shiptoinfo.shipto_cust_id = public.getcustid((new.customer_number)::text)) AND (shiptoinfo.shipto_num ~ '^[0-9]*$'::text))))::text)::character varying), CASE WHEN (new.edi_profile = 'No EDI'::text) THEN (-1) WHEN (new.edi_profile = 'Use Customer Master'::text) THEN (-2) ELSE public.getediprofileid(new.edi_profile) END, public.savecntct(public.getcntctid(new.contact_number), new.contact_number, NULL::integer, new.honorific, new.first, new.middle, new.last, new.suffix, new.phone, NULL::text, new.fax, new.email, NULL::text, new.job_title, new.contact_change), public.saveaddr(public.getaddrid(new.address_number), new.address_number, new.address1, new.address2, new.address3, new.city, new.state, new.postal_code, new.country, new.address_change), COALESCE(public.gettaxzoneid(new.tax_zone), (SELECT custinfo.cust_taxzone_id FROM public.custinfo WHERE (custinfo.cust_id = public.getcustid((new.customer_number)::text)))));


--
-- TOC entry 8725 (class 2618 OID 146571925)
-- Dependencies: 290 290 290 290 285 1765 1682 290 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO custtax DO INSTEAD INSERT INTO public.taxreg (taxreg_rel_type, taxreg_rel_id, taxreg_taxauth_id, taxreg_number) VALUES ('C'::bpchar, public.getcustid((new.customer_number)::text), public.gettaxauthid((new.tax_authority)::text), new.registration_number);


--
-- TOC entry 8726 (class 2618 OID 146571926)
-- Dependencies: 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 292 292 2162 2158 1780 1752 1702 1687 1681 1670 1658 907 294 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO employee DO INSTEAD INSERT INTO public.emp (emp_code, emp_number, emp_active, emp_cntct_id, emp_warehous_id, emp_mgr_emp_id, emp_wage_type, emp_wage, emp_wage_curr_id, emp_wage_period, emp_dept_id, emp_shift_id, emp_image_id, emp_extrate, emp_extrate_period, emp_startdate, emp_notes) VALUES (new.code, new.number, COALESCE(new.active, true), public.savecntct(public.getcntctid(new.contact_number), new.contact_number, public.saveaddr(public.getaddrid(new.address_number), new.address_number, new.address1, new.address2, new.address3, new.city, new.state, new.postalcode, new.country, new.address_change), new.honorific, new.first, new.middle, new.last, new.suffix, new.voice, new.alternate, new.fax, new.email, new.web, new.job_title, new.contact_change), public.getwarehousid(new.site, 'ALL'::text), (SELECT emp.emp_id FROM public.emp WHERE (emp.emp_code = new.manager_code)), CASE WHEN (new.wage_type = 'Hourly'::text) THEN 'H'::text WHEN (new.wage_type = 'Salaried'::text) THEN 'S'::text ELSE NULL::text END, new.wage, COALESCE(public.getcurrid((new.wage_currency)::text), public.basecurrid()), CASE WHEN (new.wage_period = 'Hour'::text) THEN 'H'::text WHEN (new.wage_period = 'Day'::text) THEN 'D'::text WHEN (new.wage_period = 'Week'::text) THEN 'W'::text WHEN (new.wage_period = 'Biweek'::text) THEN 'BW'::text WHEN (new.wage_period = 'Month'::text) THEN 'M'::text WHEN (new.wage_period = 'Year'::text) THEN 'Y'::text ELSE NULL::text END, public.getdeptid(new.department), public.getshiftid(new.shift), public.getimageid(new.image), new.rate, CASE WHEN (new.billing_period = 'Hour'::text) THEN 'H'::text WHEN (new.billing_period = 'Day'::text) THEN 'D'::text WHEN (new.billing_period = 'Week'::text) THEN 'W'::text WHEN (new.billing_period = 'Biweek'::text) THEN 'BW'::text WHEN (new.billing_period = 'Month'::text) THEN 'M'::text WHEN (new.billing_period = 'Year'::text) THEN 'Y'::text ELSE NULL::text END, new.start_date, COALESCE(new.notes, ''::text));


--
-- TOC entry 8727 (class 2618 OID 146571928)
-- Dependencies: 295 295 295 295 237 1690 1665 295 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO employeechar DO INSTEAD INSERT INTO public.charass (charass_target_type, charass_target_id, charass_char_id, charass_value, charass_default) VALUES ('EMP'::text, public.getempid((new.employee_code)::text), public.getcharid((new.characteristic)::text, 'EMP'::text), new.value, false);


--
-- TOC entry 8728 (class 2618 OID 146571929)
-- Dependencies: 296 296 296 296 296 296 240 1690 1669 910 296 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO employeecomment DO INSTEAD INSERT INTO public.comment (comment_date, comment_source, comment_source_id, comment_user, comment_cmnttype_id, comment_text) VALUES (COALESCE(new.date, now()), 'EMP'::text, public.getempid((new.code)::text), COALESCE(new.username, public.geteffectivextuser()), public.getcmnttypeid((new.type)::text), new.text);


--
-- TOC entry 8729 (class 2618 OID 146571930)
-- Dependencies: 298 298 298 298 298 298 298 298 298 298 298 298 298 298 298 297 1681 298 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO extshipmaint DO INSTEAD INSERT INTO public.shipdata (shipdata_cohead_number, shipdata_shiphead_number, shipdata_void_ind, shipdata_shipper, shipdata_billing_option, shipdata_weight, shipdata_base_freight, shipdata_base_freight_curr_id, shipdata_total_freight, shipdata_total_freight_curr_id, shipdata_package_type, shipdata_cosmisc_tracknum, shipdata_cosmisc_packnum_tracknum, shipdata_lastupdated) VALUES (new.so_number, new.shipment_number, new.void, new.shipper, new.billing_option, new.weight, new.base_freight, public.getcurrid((new.base_freight_currency)::text), new.total_freight, public.getcurrid((new.total_freight_currency)::text), new.package_type, new.tracking_number, new.package_tracking_number, new.last_updated);


--
-- TOC entry 8730 (class 2618 OID 146571931)
-- Dependencies: 302 302 302 302 302 302 302 302 302 300 1780 1759 1684 1697 302 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO freightpricingscheduleitem DO INSTEAD INSERT INTO public.ipsfreight (ipsfreight_ipshead_id, ipsfreight_qtybreak, ipsfreight_price, ipsfreight_type, ipsfreight_warehous_id, ipsfreight_shipzone_id, ipsfreight_freightclass_id, ipsfreight_shipvia) VALUES (public.getipsheadid((new.pricing_schedule)::text), new.qty_break, new.price, CASE WHEN (new.price_type = 'Flat Rate'::text) THEN 'F'::text ELSE 'P'::text END, CASE WHEN (new.from_site = 'Any'::text) THEN NULL::integer ELSE public.getwarehousid(new.from_site, 'All'::text) END, CASE WHEN (new.to_shipzone = 'Any'::text) THEN NULL::integer ELSE public.getshipzoneid(new.to_shipzone) END, CASE WHEN (new.freight_class = 'Any'::text) THEN NULL::integer ELSE public.getfreightclassid(new.freight_class) END, CASE WHEN (new.ship_via = 'Any'::text) THEN NULL::text ELSE new.ship_via END);


--
-- TOC entry 8731 (class 2618 OID 146571932)
-- Dependencies: 303 303 303 303 303 303 303 303 303 303 303 262 303 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO glaccount DO INSTEAD INSERT INTO public.accnt (accnt_number, accnt_descrip, accnt_comments, accnt_profit, accnt_sub, accnt_type, accnt_extref, accnt_company, accnt_forwardupdate, accnt_subaccnttype_code) VALUES (COALESCE(new.account_number, ''::character varying), COALESCE(new.description, ''::text), COALESCE(new.notes, ''::text), new.profit_center, new.sub_account, CASE WHEN (new.type = 'Asset'::text) THEN 'A'::text WHEN (new.type = 'Liability'::text) THEN 'L'::text WHEN (new.type = 'Expense'::text) THEN 'E'::text WHEN (new.type = 'Revenue'::text) THEN 'R'::text WHEN (new.type = 'Equity'::text) THEN 'Q'::text ELSE NULL::text END, COALESCE(new.ext_reference, ''::text), new.company, COALESCE(new.forward_update_trial_balances, false), COALESCE(new.sub_type, ''::text));


--
-- TOC entry 8732 (class 2618 OID 146571934)
-- Dependencies: 308 308 308 308 308 308 308 308 308 308 308 308 308 308 308 308 308 308 308 308 308 308 308 308 206 2162 1721 1714 1707 1706 1705 1703 1680 1670 308 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO incident DO INSTEAD INSERT INTO public.incdt (incdt_number, incdt_crmacct_id, incdt_cntct_id, incdt_summary, incdt_descrip, incdt_item_id, incdt_status, incdt_assigned_username, incdt_incdtcat_id, incdt_incdtseverity_id, incdt_incdtpriority_id, incdt_incdtresolution_id, incdt_lotserial, incdt_ls_id) VALUES (new.incident_number, public.getcrmacctid(new.crm_account), public.savecntct(public.getcntctid(new.contact_number), new.contact_number, NULL::integer, new.honorific, new.first, new.middle, new.last, new.suffix, new.phone, NULL::text, new.fax, new.email, NULL::text, new.job_title, new.contact_change), COALESCE(new.description, ''::text), COALESCE(new.notes, ''::text), public.getitemid(new.item_number), CASE WHEN (new.status = 'New'::text) THEN 'N'::text WHEN (new.status = 'Feedback'::text) THEN 'F'::text WHEN (new.status = 'Confirmed'::text) THEN 'C'::text WHEN (new.status = 'Assigned'::text) THEN 'A'::text WHEN (new.status = 'Resolved'::text) THEN 'R'::text WHEN (new.status = 'Closed'::text) THEN 'L'::text ELSE ''::text END, COALESCE(new.assigned_to, ''::text), public.getincdtcatid(new.category), public.getincdtseverityid(new.severity), public.getincdtpriorityid(new.priority), public.getincdtresolutionid(new.resolution), COALESCE(new.lot_serial_number, ''::text), public.getlotserialid(new.item_number, new.lot_serial_number));


--
-- TOC entry 8733 (class 2618 OID 146571936)
-- Dependencies: 309 309 309 309 237 1708 1665 309 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO incidentchar DO INSTEAD INSERT INTO public.charass (charass_target_type, charass_target_id, charass_char_id, charass_value, charass_default) VALUES ('INCDT'::text, public.getincidentid(new.incident_number), public.getcharid((new.characteristic)::text, 'INCDT'::text), new.value, false);


--
-- TOC entry 8734 (class 2618 OID 146571937)
-- Dependencies: 310 310 310 310 310 310 310 240 1708 1669 910 310 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO incidentcomment DO INSTEAD INSERT INTO public.comment (comment_date, comment_source, comment_source_id, comment_user, comment_cmnttype_id, comment_text, comment_public) VALUES (COALESCE(new.date, now()), 'INCDT'::text, public.getincidentid(new.incident_number), COALESCE(new.username, public.geteffectivextuser()), public.getcmnttypeid(new.type), new.text, COALESCE(new.public, true));


--
-- TOC entry 8735 (class 2618 OID 146571938)
-- Dependencies: 311 311 311 311 245 1708 311 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO incidentfile DO INSTEAD INSERT INTO public.url (url_source_id, url_source, url_title, url_url) VALUES (public.getincidentid(new.incident_number), 'INCDT'::text, new.title, new.url);


--
-- TOC entry 8736 (class 2618 OID 146571939)
-- Dependencies: 312 312 312 2165 1708 1702 312 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO incidentimage DO INSTEAD SELECT public.saveimageass('INCDT'::text, public.getincidentid(new.incident_number), 'M'::bpchar, public.getimageid(new.image_name)) AS saveimageass;


--
-- TOC entry 8737 (class 2618 OID 146571940)
-- Dependencies: 228 228 1829 228 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO invoice DO INSTEAD SELECT public.insertinvoice(new.*) AS insertinvoice;


--
-- TOC entry 8738 (class 2618 OID 146571941)
-- Dependencies: 230 230 1830 230 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO invoiceline DO INSTEAD SELECT public.insertinvoicelineitem(new.*) AS insertinvoicelineitem;


--
-- TOC entry 8739 (class 2618 OID 146571942)
-- Dependencies: 315 315 315 315 315 315 315 315 315 315 315 315 315 315 315 315 315 315 315 315 315 315 315 191 1771 1738 1666 315 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO item DO INSTEAD INSERT INTO public.item (item_number, item_active, item_descrip1, item_descrip2, item_type, item_maxcost, item_classcode_id, item_inv_uom_id, item_picklist, item_fractional, item_config, item_sold, item_prodcat_id, item_exclusive, item_listprice, item_listcost, item_price_uom_id, item_upccode, item_prodweight, item_packweight, item_comments, item_extdescrip) VALUES (upper((new.item_number)::text), COALESCE(new.active, true), COALESCE(new.description1, ''::text), COALESCE(new.description2, ''::text), CASE WHEN (new.item_type = 'Purchased'::text) THEN 'P'::text WHEN (new.item_type = 'Manufactured'::text) THEN 'M'::text WHEN (new.item_type = 'Job'::text) THEN 'J'::text WHEN (new.item_type = 'Kit'::text) THEN 'K'::text WHEN (new.item_type = 'Phantom'::text) THEN 'F'::text WHEN (new.item_type = 'Reference'::text) THEN 'R'::text WHEN (new.item_type = 'Costing'::text) THEN 'S'::text WHEN (new.item_type = 'Tooling'::text) THEN 'T'::text WHEN (new.item_type = 'Outside Process'::text) THEN 'O'::text WHEN (new.item_type = 'Planning'::text) THEN 'L'::text WHEN (new.item_type = 'Breeder'::text) THEN 'B'::text WHEN (new.item_type = 'Co-Product'::text) THEN 'C'::text WHEN (new.item_type = 'By-Product'::text) THEN 'Y'::text ELSE NULL::text END, COALESCE(new.maximum_desired_cost, (0)::numeric), public.getclasscodeid(new.class_code), public.getuomid(new.inventory_uom), COALESCE(new.pick_list_item, true), COALESCE(new.fractional, false), COALESCE(new.configured, false), COALESCE(new.item_is_sold, true), COALESCE(public.getprodcatid(new.product_category), (-1)), COALESCE(new.exclusive, false), COALESCE(new.list_price, (0)::numeric), COALESCE(new.list_cost, (0)::numeric), COALESCE(public.getuomid(new.list_price_uom), public.getuomid(new.inventory_uom)), new.upc_code, COALESCE(new.product_weight, (0)::numeric), COALESCE(new.packaging_weight, (0)::numeric), new.notes, new.ext_description);


--
-- TOC entry 8740 (class 2618 OID 146571944)
-- Dependencies: 317 317 317 317 317 317 317 316 1714 317 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO itemalias DO INSTEAD INSERT INTO public.itemalias (itemalias_item_id, itemalias_number, itemalias_usedescrip, itemalias_descrip1, itemalias_descrip2, itemalias_comments) VALUES (public.getitemid((new.item_number)::text), new.alias_number, COALESCE(new.use_description, false), COALESCE(new.description1, ''::text), COALESCE(new.description2, ''::text), new.comments);


--
-- TOC entry 8741 (class 2618 OID 146571945)
-- Dependencies: 318 318 318 318 318 237 1714 1665 318 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO itemchar DO INSTEAD INSERT INTO public.charass (charass_target_type, charass_target_id, charass_char_id, charass_value, charass_default) VALUES ('I'::text, public.getitemid((new.item_number)::text), public.getcharid((new.characteristic)::text, 'I'::text), new.value, COALESCE(new.is_default, false));


--
-- TOC entry 8742 (class 2618 OID 146571946)
-- Dependencies: 319 319 319 319 319 319 240 1714 1669 910 319 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO itemcomment DO INSTEAD INSERT INTO public.comment (comment_date, comment_source, comment_source_id, comment_user, comment_cmnttype_id, comment_text) VALUES (COALESCE(new.date, now()), 'IS'::text, public.getitemid((new.item_number)::text), COALESCE(new.username, public.geteffectivextuser()), public.getcmnttypeid(new.type), new.text);


--
-- TOC entry 8743 (class 2618 OID 146571947)
-- Dependencies: 322 322 322 322 322 322 1831 1714 1681 1679 322 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO itemcost DO INSTEAD SELECT public.insertitemcost(public.getitemid((new.item_number)::text), public.getcostelemid((new.costing_element)::text), public.getcurrid((new.currency)::text), new.actual_cost, new.post_to_standard) AS insertitemcost;


--
-- TOC entry 8744 (class 2618 OID 146571948)
-- Dependencies: 323 323 323 323 245 1714 323 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO itemfile DO INSTEAD INSERT INTO public.url (url_source_id, url_source, url_title, url_url) VALUES (public.getitemid((new.item_number)::text), 'I'::text, new.title, new.url);


--
-- TOC entry 8745 (class 2618 OID 146571949)
-- Dependencies: 324 324 324 324 2165 1714 1702 324 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO itemimage DO INSTEAD SELECT public.saveimageass('I'::text, public.getitemid((new.item_number)::text), (CASE WHEN (new.purpose = 'Product Description'::text) THEN 'P'::text WHEN (new.purpose = 'Inventory Description'::text) THEN 'I'::text WHEN (new.purpose = 'Engineering Reference'::text) THEN 'E'::text WHEN (new.purpose = 'Miscellaneous'::text) THEN 'M'::text ELSE 'X'::text END)::bpchar, public.getimageid(new.image_name)) AS saveimageass;


--
-- TOC entry 8746 (class 2618 OID 146571950)
-- Dependencies: 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 192 1780 1732 1693 1716 1714 1678 1547 327 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO itemsite DO INSTEAD INSERT INTO public.itemsite (itemsite_item_id, itemsite_warehous_id, itemsite_active, itemsite_dropship, itemsite_posupply, itemsite_createpr, itemsite_wosupply, itemsite_createwo, itemsite_createsopr, itemsite_createsopo, itemsite_sold, itemsite_soldranking, itemsite_costmethod, itemsite_controlmethod, itemsite_perishable, itemsite_plancode_id, itemsite_costcat_id, itemsite_loccntrl, itemsite_location_id, itemsite_recvlocation_id, itemsite_issuelocation_id, itemsite_location_dist, itemsite_recvlocation_dist, itemsite_issuelocation_dist, itemsite_location, itemsite_location_comments, itemsite_disallowblankwip, itemsite_stocked, itemsite_abcclass, itemsite_autoabcclass, itemsite_cyclecountfreq, itemsite_eventfence, itemsite_useparams, itemsite_reorderlevel, itemsite_ordertoqty, itemsite_minordqty, itemsite_maxordqty, itemsite_multordqty, itemsite_useparamsmanual, itemsite_ordergroup, itemsite_ordergroup_first, itemsite_mps_timefence, itemsite_leadtime, itemsite_safetystock, itemsite_supply_itemsite_id, itemsite_notes, itemsite_qtyonhand, itemsite_warrpurc, itemsite_autoreg, itemsite_freeze, itemsite_value, itemsite_planning_type) VALUES (public.getitemid((new.item_number)::text), public.getwarehousid((new.site)::text, 'ACTIVE'::text), COALESCE(new.active, true), COALESCE(new.dropship, false), COALESCE(new.po_supplied_at_site, false), COALESCE(new.create_prs, false), COALESCE(new.wo_supplied_at_site, false), COALESCE(new.create_wos, false), COALESCE(new.create_soprs, false), COALESCE(new.create_sopos, false), COALESCE(new.sold_from_site, true), COALESCE(new.ranking, 1), CASE WHEN (new.cost_method = 'None'::text) THEN 'N'::text WHEN (new.cost_method = 'Average'::text) THEN 'A'::text WHEN (new.cost_method = 'Standard'::text) THEN 'S'::text WHEN (new.cost_method = 'Job'::text) THEN 'J'::text ELSE NULL::text END, CASE WHEN (new.control_method = 'None'::text) THEN 'N'::text WHEN (new.control_method = 'Regular'::text) THEN 'R'::text WHEN (new.control_method = 'Serial #'::text) THEN 'S'::text WHEN (new.control_method = 'Lot #'::text) THEN 'L'::text ELSE NULL::text END, COALESCE(new.perishable, false), public.getplancodeid(new.planner_code), public.getcostcatid(new.cost_category), COALESCE(new.multiple_location_control, false), COALESCE(public.getlocationid((new.site)::text, new.location), (-1)), COALESCE(public.getlocationid((new.site)::text, new.receive_location), (-1)), COALESCE(public.getlocationid((new.site)::text, new.issue_location), (-1)), COALESCE(new.auto_distr_location, false), COALESCE(new.auto_distr_receive_location, false), COALESCE(new.auto_distr_issue_location, false), COALESCE(new.user_defined_location, ''::text), COALESCE(new.location_comment, ''::text), COALESCE(new.disallow_blank_wip_locations, false), COALESCE(new.stocked, false), COALESCE(new.abc_class, 'A'::bpchar), COALESCE(new.allow_automatic_updates, false), COALESCE(new.cycl_cnt_freq, 0), COALESCE((new.event_fence)::numeric, public.fetchmetricvalue('DefaultEventFence'::text)), COALESCE(new.enforce_order_parameters, false), COALESCE(new.reorder_level, (0)::numeric), COALESCE(new.order_up_to, (0)::numeric), COALESCE(new.minimum_order, (0)::numeric), COALESCE(new.maximum_order, (0)::numeric), COALESCE(new.order_multiple, (0)::numeric), COALESCE(new.enforce_on_manual_orders, false), COALESCE(new.group_mps_mrp_orders, 0), COALESCE(new.first_group, false), COALESCE(new.mps_time_fence, 0), COALESCE(new.lead_time, 0), COALESCE(new.safety_stock, (0)::numeric), CASE WHEN (new.supplied_from_site = 'None'::text) THEN NULL::integer WHEN (new.supplied_from_site = ''::text) THEN NULL::integer ELSE public.getitemsiteid(new.supplied_from_site, (new.item_number)::text) END, COALESCE(new.notes, ''::text), 0, COALESCE(new.require_warranty, false), COALESCE(new.auto_register, false), false, 0, CASE WHEN (new.planning_system = 'None'::text) THEN 'N'::text WHEN (new.planning_system = 'MPS'::text) THEN 'S'::text ELSE 'M'::text END);


--
-- TOC entry 8747 (class 2618 OID 146571952)
-- Dependencies: 328 328 328 328 328 328 328 240 1716 1669 910 328 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO itemsitecomment DO INSTEAD INSERT INTO public.comment (comment_date, comment_source, comment_source_id, comment_user, comment_cmnttype_id, comment_text) VALUES (COALESCE(new.date, now()), 'IS'::text, public.getitemsiteid((new.site)::text, (new.item_number)::text), COALESCE(new.username, public.geteffectivextuser()), public.getcmnttypeid(new.type), new.text);


--
-- TOC entry 8748 (class 2618 OID 146571953)
-- Dependencies: 331 331 331 331 331 331 331 331 331 331 331 331 331 331 331 331 331 331 331 331 331 330 1778 1714 1677 1676 1675 331 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO itemsource DO INSTEAD INSERT INTO public.itemsrc (itemsrc_item_id, itemsrc_vend_id, itemsrc_vend_item_number, itemsrc_vend_item_descrip, itemsrc_comments, itemsrc_vend_uom, itemsrc_invvendoruomratio, itemsrc_minordqty, itemsrc_multordqty, itemsrc_leadtime, itemsrc_ranking, itemsrc_active, itemsrc_default, itemsrc_manuf_name, itemsrc_manuf_item_number, itemsrc_manuf_item_descrip, itemsrc_upccode, itemsrc_contrct_id, itemsrc_effective, itemsrc_expires) VALUES (public.getitemid((new.item_number)::text), public.getvendid((new.vendor)::text), new.vendor_item_number, COALESCE(new.vendor_description, ''::text), COALESCE(new.notes, ''::text), new.vendor_uom, new.inventory_vendor_uom_ratio, new.minimum_order, new.order_multiple, new.lead_time, new.vendor_ranking, COALESCE(new.active, true), COALESCE(new.itemsrc_default, true), COALESCE(new.manufacturer_name, ''::text), COALESCE(new.manufacturer_item_number, ''::text), new.manufacturer_description, new.bar_code, public.getcontrctid(new.contract_number), COALESCE(public.getcontrcteffective(new.contract_number), new.effective_date), COALESCE(public.getcontrctexpires(new.contract_number), new.expires_date));


--
-- TOC entry 8749 (class 2618 OID 146571955)
-- Dependencies: 333 333 333 333 333 333 333 333 333 333 333 332 1780 1718 1681 333 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO itemsourceprice DO INSTEAD INSERT INTO public.itemsrcp (itemsrcp_itemsrc_id, itemsrcp_qtybreak, itemsrcp_price, itemsrcp_curr_id, itemsrcp_updated, itemsrcp_dropship, itemsrcp_warehous_id, itemsrcp_type, itemsrcp_discntprcnt, itemsrcp_fixedamtdiscount) VALUES (public.getitemsrcid((new.item_number)::text, (new.vendor)::text), new.qty_break, new.price_per_unit, public.getcurrid((new.currency)::text), now(), COALESCE(new.dropship_only, false), CASE WHEN (new.pricing_site = 'All'::text) THEN (-1) ELSE COALESCE(public.getwarehousid(new.pricing_site, 'ALL'::text), (-1)) END, CASE WHEN (new.pricing_type = 'Discount'::text) THEN 'D'::text ELSE 'N'::text END, (COALESCE(new.discount_percent, 0.0) / 100.0), new.discount_fixed_amount);


--
-- TOC entry 8750 (class 2618 OID 146571957)
-- Dependencies: 335 335 335 335 335 334 1714 335 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO itemsubstitute DO INSTEAD INSERT INTO public.itemsub (itemsub_parent_item_id, itemsub_sub_item_id, itemsub_uomratio, itemsub_rank) VALUES (public.getitemid((new.root_item_number)::text), public.getitemid((new.substitute_item_number)::text), COALESCE(new.sub_parent_uom_ratio, (1)::numeric), COALESCE(new.ranking, 1));


--
-- TOC entry 8751 (class 2618 OID 146571958)
-- Dependencies: 337 337 337 337 336 1768 1767 1714 337 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO itemtaxtype DO INSTEAD INSERT INTO public.itemtax (itemtax_item_id, itemtax_taxzone_id, itemtax_taxtype_id) VALUES (public.getitemid((new.item_number)::text), CASE WHEN ((new.tax_zone)::text = 'Any'::text) THEN NULL::integer ELSE public.gettaxzoneid((new.tax_zone)::text) END, public.gettaxtypeid(new.tax_type));


--
-- TOC entry 8752 (class 2618 OID 146571959)
-- Dependencies: 339 339 339 339 339 339 339 339 191 191 2172 1774 1771 1714 339 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO itemuomconversion DO INSTEAD SELECT public.saveitemuomconv(public.getitemid((new.item_number)::text), COALESCE(public.getuomid((new.uom)::text), (SELECT item.item_inv_uom_id FROM public.item WHERE (item.item_id = public.getitemid((new.item_number)::text)))), COALESCE(new.uom_value, (1)::numeric), COALESCE(public.getuomid(new.per_uom), (SELECT item.item_inv_uom_id FROM public.item WHERE (item.item_id = public.getitemid((new.item_number)::text)))), COALESCE(new.per_uom_value, (1)::numeric), COALESCE(new.fractional, false), public.getuomtypeid(new.selected_types)) AS saveitemuomconv;


--
-- TOC entry 8753 (class 2618 OID 146571960)
-- Dependencies: 341 341 341 341 341 341 341 341 1820 1700 1681 1384 341 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO journalentry DO INSTEAD SELECT public.insertgltransaction('G/L'::text, 'JE'::text, new.doc_number, new.notes, public.getglaccntid(new.credit), public.getglaccntid(new.debit), (-1), public.currtobase(public.getcurrid((new.currency)::text), new.amount, new.dist_date), new.dist_date) AS insertgltransaction;


--
-- TOC entry 8754 (class 2618 OID 146571961)
-- Dependencies: 344 344 344 344 344 344 344 344 344 344 342 1781 1780 344 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO location DO INSTEAD INSERT INTO public.location (location_warehous_id, location_name, location_descrip, location_restrict, location_netable, location_whsezone_id, location_aisle, location_rack, location_bin) VALUES (public.getwarehousid((new.site)::text, 'ACTIVE'::text), COALESCE(new.location, ''::character varying), COALESCE(new.description, ''::text), COALESCE(new.restricted, false), COALESCE(new.netable, true), public.getwhsezoneid((new.site)::text, new.zone), COALESCE(new.aisle, ''::character varying), COALESCE(new.rack, ''::character varying), COALESCE(new.bin, ''::character varying));


--
-- TOC entry 8755 (class 2618 OID 146571962)
-- Dependencies: 345 825 825 825 345 345 345 345 193 193 2030 1716 910 345 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO misccounttag DO INSTEAD SELECT public.postmisccount(public.getitemsiteid(COALESCE(new.site, (SELECT whsinfo.warehous_code FROM public.usrpref, public.whsinfo WHERE (((usrpref.usrpref_username = public.geteffectivextuser()) AND (usrpref.usrpref_name = 'PreferredWarehouse'::text)) AND (whsinfo.warehous_id = (usrpref.usrpref_value)::integer)))), new.item_number), new.quantity, new.comment) AS postmisccount;


--
-- TOC entry 8756 (class 2618 OID 146571963)
-- Dependencies: 346 632 346 346 346 346 346 301 1681 907 346 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO pricingschedule DO INSTEAD INSERT INTO public.ipshead (ipshead_id, ipshead_name, ipshead_descrip, ipshead_effective, ipshead_expires, ipshead_curr_id, ipshead_updated) VALUES (nextval('public.ipshead_ipshead_id_seq'::regclass), new.name, new.description, CASE WHEN (new.effective = 'Always'::text) THEN '1970-01-01'::date ELSE (COALESCE(new.effective, '1970-01-01'::text))::date END, CASE WHEN (new.expires = 'Never'::text) THEN '2100-01-01'::date ELSE (COALESCE(new.expires, '2100-01-01'::text))::date END, COALESCE(public.getcurrid((new.currency)::text), public.basecurrid()), now());


--
-- TOC entry 8757 (class 2618 OID 146571964)
-- Dependencies: 348 348 348 348 348 348 348 347 1756 1684 1686 1682 348 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO pricingscheduleassign DO INSTEAD INSERT INTO public.ipsass (ipsass_ipshead_id, ipsass_cust_id, ipsass_custtype_id, ipsass_custtype_pattern, ipsass_shipto_id, ipsass_shipto_pattern) VALUES (public.getipsheadid((new.pricing_schedule)::text), CASE WHEN ((new.customer_number)::text = 'Any'::text) THEN (-1) ELSE public.getcustid((new.customer_number)::text) END, CASE WHEN ((new.customer_type)::text = 'N/A'::text) THEN (-1) ELSE public.getcusttypeid((new.customer_type)::text) END, new.customer_type_pattern, CASE WHEN (((new.customer_number)::text = 'Any'::text) OR ((new.customer_shipto)::text = 'Any'::text)) THEN (-1) ELSE public.getshiptoid((new.customer_number)::text, (new.customer_shipto)::text) END, new.customer_shipto_pattern);


--
-- TOC entry 8758 (class 2618 OID 146571965)
-- Dependencies: 350 350 350 350 350 350 350 350 350 350 350 350 2164 2167 1771 1738 1714 1684 350 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO pricingscheduleitem DO INSTEAD SELECT CASE WHEN ((new.type)::text = 'Item'::text) THEN public.saveipsitem(NULL::integer, public.getipsheadid((new.pricing_schedule)::text), public.getitemid((new.item_number)::text), COALESCE(new.qty_break, (0)::numeric), COALESCE(new.price, (0)::numeric), public.getuomid((new.qty_uom)::text), public.getuomid((new.price_uom)::text), new.percent, new.fixedamt, CASE new.pricing_type WHEN 'Nominal'::text THEN 'N'::text WHEN 'Discount'::text THEN 'D'::text WHEN 'Markup'::text THEN 'M'::text ELSE '?'::text END) WHEN ((new.type)::text = 'Product Category'::text) THEN public.saveipsprodcat(NULL::integer, public.getipsheadid((new.pricing_schedule)::text), public.getprodcatid((new.product_category)::text), new.qty_break, new.percent, new.fixedamt, CASE new.pricing_type WHEN 'Nominal'::text THEN 'N'::text WHEN 'Discount'::text THEN 'D'::text WHEN 'Markup'::text THEN 'M'::text ELSE '?'::text END) ELSE NULL::integer END AS "case";


--
-- TOC entry 8759 (class 2618 OID 146571967)
-- Dependencies: 352 352 352 352 352 352 352 352 352 351 1712 1665 352 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO pricingscheduleitemchar DO INSTEAD INSERT INTO public.ipsitemchar (ipsitemchar_ipsitem_id, ipsitemchar_char_id, ipsitemchar_value, ipsitemchar_price) VALUES (public.getipsitemid((new.pricing_schedule)::text, (new.item_number)::text, new.qty_break, (new.qty_uom)::text, (new.price_uom)::text), public.getcharid((new.characteristic)::text, 'I'::text), new.value, COALESCE(new.price, (0)::numeric));


--
-- TOC entry 8760 (class 2618 OID 146571968)
-- Dependencies: 353 353 353 353 353 353 353 353 353 353 353 353 353 353 225 910 353 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO project DO INSTEAD INSERT INTO public.prj (prj_number, prj_name, prj_descrip, prj_owner_username, prj_username, prj_so, prj_wo, prj_po, prj_status, prj_due_date, prj_assigned_date, prj_start_date, prj_completed_date) VALUES (new.number, COALESCE(new.name, ''::text), COALESCE(new.description, ''::text), COALESCE(new.owner, public.geteffectivextuser()), COALESCE(new.assigned_to, public.geteffectivextuser()), COALESCE(new.sales_orders, true), COALESCE(new.work_orders, true), COALESCE(new.purchase_orders, true), CASE WHEN (new.status = 'In-Process'::text) THEN 'O'::text WHEN (new.status = 'Completed'::text) THEN 'C'::text ELSE 'P'::text END, new.due, new.assigned, new.started, new.completed);


--
-- TOC entry 8761 (class 2618 OID 146571970)
-- Dependencies: 354 354 354 354 354 354 240 1736 1669 910 354 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO projectcomment DO INSTEAD INSERT INTO public.comment (comment_date, comment_source, comment_source_id, comment_user, comment_cmnttype_id, comment_text) VALUES (COALESCE(new.date, now()), 'J'::text, public.getprjid((new.project_number)::text), COALESCE(new.username, public.geteffectivextuser()), public.getcmnttypeid(new.type), new.text);


--
-- TOC entry 8762 (class 2618 OID 146571971)
-- Dependencies: 357 357 357 357 357 357 357 357 357 357 357 357 357 357 357 357 357 357 357 357 357 357 357 357 357 357 357 357 357 357 356 2162 2158 1780 1768 1749 1670 1658 357 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO prospect DO INSTEAD INSERT INTO public.prospect (prospect_number, prospect_name, prospect_active, prospect_cntct_id, prospect_taxzone_id, prospect_salesrep_id, prospect_warehous_id, prospect_comments) VALUES (upper((new.prospect_number)::text), COALESCE(new.prospect_name, ''::text), COALESCE(new.active, true), public.savecntct(public.getcntctid(new.contact_number), new.contact_number, public.saveaddr(public.getaddrid(new.contact_address_number), new.contact_address_number, new.contact_address1, new.contact_address2, new.contact_address3, new.contact_city, new.contact_state, new.contact_postalcode, new.contact_country, new.contact_address_change), new.contact_honorific, new.contact_first, new.contact_middle, new.contact_last, new.contact_suffix, new.contact_voice, new.contact_alternate, new.contact_fax, new.contact_email, new.contact_web, new.contact_job_title, new.contact_change), public.gettaxzoneid(new.default_tax_zone), public.getsalesrepid(new.sales_rep), public.getwarehousid(new.site_code, 'ACTIVE'::text), COALESCE(new.notes, ''::text));


--
-- TOC entry 8763 (class 2618 OID 146571973)
-- Dependencies: 360 360 360 360 360 360 360 360 360 360 360 360 360 360 360 360 360 360 360 198 197 197 193 193 1742 1736 1733 1716 1691 1551 360 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO purchaseline DO INSTEAD INSERT INTO public.poitem (poitem_pohead_id, poitem_linenumber, poitem_duedate, poitem_itemsite_id, poitem_vend_item_descrip, poitem_qty_ordered, poitem_unitprice, poitem_vend_item_number, poitem_manuf_name, poitem_manuf_item_number, poitem_manuf_item_descrip, poitem_comments, poitem_expcat_id, poitem_freight, poitem_prj_id, poitem_bom_rev_id, poitem_boo_rev_id) VALUES (public.getpoheadid((new.order_number)::text), new.line_number, new.due_date, public.getitemsiteid(COALESCE(new.site, (SELECT whsinfo.warehous_code FROM (public.pohead JOIN public.whsinfo ON ((whsinfo.warehous_id = pohead.pohead_warehous_id))) WHERE (pohead.pohead_id = public.getpoheadid((new.order_number)::text))), (SELECT whsinfo.warehous_code FROM public.whsinfo WHERE (whsinfo.warehous_id = public.fetchprefwarehousid()))), new.item_number), new.vendor_description, new.qty_ordered, new.unit_price, new.vend_item_number, new.manufacturer_name, new.manufacturer_item_number, new.manufacturer_description, new.notes, public.getexpcatid(new.expense_category), new.freight, public.getprjid(new.project_number), public.getrevid('BOM'::text, new.item_number, new.bill_of_materials_revision), public.getrevid('BOO'::text, new.item_number, new.bill_of_operations_revision));


--
-- TOC entry 8764 (class 2618 OID 146571975)
-- Dependencies: 361 361 361 361 361 237 237 237 236 236 198 198 198 198 197 197 192 192 191 2281 361 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO purchaselinechar DO INSTEAD SELECT DISTINCT public.updatecharassignment('PI'::text, poitem.poitem_id, charass.charass_char_id, new.value) AS updatecharassignment FROM public.pohead, public.poitem, public.itemsite, public.item, public.charass, public."char" WHERE (((((((((pohead.pohead_number = (new.order_number)::text) AND (pohead.pohead_id = poitem.poitem_pohead_id)) AND (poitem.poitem_linenumber = new.line_number)) AND (poitem.poitem_itemsite_id = itemsite.itemsite_id)) AND (item.item_id = itemsite.itemsite_item_id)) AND (charass.charass_target_type = 'I'::text)) AND (charass.charass_target_id = item.item_id)) AND ("char".char_id = charass.charass_char_id)) AND ("char".char_name = new.characteristic));


--
-- TOC entry 8765 (class 2618 OID 146571977)
-- Dependencies: 362 362 362 362 362 362 362 240 198 198 198 197 197 1669 910 362 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO purchaselinecomment DO INSTEAD INSERT INTO public.comment (comment_date, comment_source, comment_source_id, comment_user, comment_cmnttype_id, comment_text) SELECT COALESCE(new.date, (('now'::text)::date)::timestamp with time zone) AS "coalesce", 'PI', poitem.poitem_id, COALESCE(new.username, public.geteffectivextuser()) AS "coalesce", public.getcmnttypeid(new.type) AS getcmnttypeid, new.text FROM public.poitem, public.pohead WHERE (((pohead.pohead_number = (new.order_number)::text) AND (poitem.poitem_pohead_id = pohead.pohead_id)) AND (poitem.poitem_linenumber = new.line_number));


--
-- TOC entry 8766 (class 2618 OID 146571979)
-- Dependencies: 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 210 210 210 210 210 210 210 197 193 193 1780 1778 1777 1769 1768 1681 1672 1670 1658 1551 910 365 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO purchaseorder DO INSTEAD INSERT INTO public.pohead (pohead_number, pohead_orderdate, pohead_status, pohead_terms_id, pohead_taxzone_id, pohead_warehous_id, pohead_agent_username, pohead_vend_id, pohead_vendaddr_id, pohead_fob, pohead_shipvia, pohead_curr_id, pohead_freight, pohead_comments, pohead_dropship, pohead_vend_cntct_id, pohead_vend_cntct_honorific, pohead_vend_cntct_first_name, pohead_vend_cntct_middle, pohead_vend_cntct_last_name, pohead_vend_cntct_suffix, pohead_vend_cntct_phone, pohead_vend_cntct_title, pohead_vend_cntct_fax, pohead_vend_cntct_email, pohead_vendaddress1, pohead_vendaddress2, pohead_vendaddress3, pohead_vendcity, pohead_vendstate, pohead_vendzipcode, pohead_vendcountry, pohead_shipto_cntct_id, pohead_shipto_cntct_honorific, pohead_shipto_cntct_first_name, pohead_shipto_cntct_middle, pohead_shipto_cntct_last_name, pohead_shipto_cntct_suffix, pohead_shipto_cntct_phone, pohead_shipto_cntct_title, pohead_shipto_cntct_fax, pohead_shipto_cntct_email, pohead_shiptoaddress_id, pohead_shiptoaddress1, pohead_shiptoaddress2, pohead_shiptoaddress3, pohead_shiptocity, pohead_shiptostate, pohead_shiptozipcode, pohead_shiptocountry, pohead_cohead_id) SELECT new.order_number, COALESCE(new.order_date, ('now'::text)::date) AS "coalesce", 'U', COALESCE(public.gettermsid(new.terms), vendinfo.vend_terms_id) AS "coalesce", COALESCE(public.gettaxzoneid(new.tax_zone), vendinfo.vend_taxzone_id) AS "coalesce", COALESCE(public.getwarehousid(new.receiving_site, 'ALL'::text), public.fetchprefwarehousid()) AS "coalesce", COALESCE(new.purchasing_agent, public.geteffectivextuser()) AS "coalesce", public.getvendid(new.vendor_number) AS getvendid, CASE WHEN (new.alt_address = 'MAIN'::text) THEN NULL::integer ELSE public.getvendaddrid(new.vendor_number, new.alt_address) END AS getvendaddrid, COALESCE(new.fob, CASE WHEN (vendinfo.vend_fobsource = 'W'::bpchar) THEN (SELECT whsinfo.warehous_fob FROM public.whsinfo WHERE (whsinfo.warehous_id = COALESCE(public.getwarehousid(new.receiving_site, 'ALL'::text), public.fetchprefwarehousid()))) ELSE vendinfo.vend_fob END) AS "coalesce", COALESCE(new.ship_via, vendinfo.vend_shipvia) AS "coalesce", COALESCE(public.getcurrid((new.currency)::text), vendinfo.vend_curr_id) AS "coalesce", COALESCE(new.freight, (0)::numeric) AS "coalesce", new.notes, COALESCE(new.dropship, false) AS "coalesce", public.getcntctid(new.vend_contact_number) AS getcntctid, COALESCE(new.vend_cntct_honorific, ''::text) AS "coalesce", COALESCE(new.vend_cntct_first_name, ''::text) AS "coalesce", COALESCE(new.vend_cntct_middle, ''::text) AS "coalesce", COALESCE(new.vend_cntct_last_name, ''::text) AS "coalesce", COALESCE(new.vend_cntct_suffix, ''::text) AS "coalesce", COALESCE(new.vend_cntct_phone, ''::text) AS "coalesce", COALESCE(new.vend_cntct_title, ''::text) AS "coalesce", COALESCE(new.vend_cntct_fax, ''::text) AS "coalesce", COALESCE(new.vend_cntct_email, ''::text) AS "coalesce", COALESCE(new.vendaddress1, ''::text) AS "coalesce", COALESCE(new.vendaddress2, ''::text) AS "coalesce", COALESCE(new.vendaddress3, ''::text) AS "coalesce", COALESCE(new.vendcity, ''::text) AS "coalesce", COALESCE(new.vendstate, ''::text) AS "coalesce", COALESCE(new.vendzipcode, ''::text) AS "coalesce", COALESCE(new.vendcountry, ''::text) AS "coalesce", public.getcntctid(new.shipto_contact_number) AS getcntctid, COALESCE(new.shipto_cntct_honorific, ''::text) AS "coalesce", COALESCE(new.shipto_cntct_first_name, ''::text) AS "coalesce", COALESCE(new.shipto_cntct_middle, ''::text) AS "coalesce", COALESCE(new.shipto_cntct_last_name, ''::text) AS "coalesce", COALESCE(new.shipto_cntct_suffix, ''::text) AS "coalesce", COALESCE(new.shipto_cntct_phone, ''::text) AS "coalesce", COALESCE(new.shipto_cntct_title, ''::text) AS "coalesce", COALESCE(new.shipto_cntct_fax, ''::text) AS "coalesce", COALESCE(new.shipto_cntct_email, ''::text) AS "coalesce", public.getaddrid(new.shiptoaddress_number) AS getaddrid, COALESCE(new.shiptoaddress1, ''::text) AS "coalesce", COALESCE(new.shiptoaddress2, ''::text) AS "coalesce", COALESCE(new.shiptoaddress3, ''::text) AS "coalesce", COALESCE(new.shiptocity, ''::text) AS "coalesce", COALESCE(new.shiptostate, ''::text) AS "coalesce", COALESCE(new.shiptozipcode, ''::text) AS "coalesce", COALESCE(new.shiptocountry, ''::text) AS "coalesce", public.getcoheadid(new.sales_order_number) AS getcoheadid FROM public.vendinfo WHERE (vendinfo.vend_id = public.getvendid(new.vendor_number));


--
-- TOC entry 8767 (class 2618 OID 146571981)
-- Dependencies: 366 366 366 366 366 366 240 1733 1669 910 366 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO purchaseordercomment DO INSTEAD INSERT INTO public.comment (comment_date, comment_source, comment_source_id, comment_user, comment_cmnttype_id, comment_text) VALUES (COALESCE(new.date, (('now'::text)::date)::timestamp with time zone), 'P'::text, public.getpoheadid((new.order_number)::text), COALESCE(new.username, public.geteffectivextuser()), public.getcmnttypeid(new.type), new.text);


--
-- TOC entry 8768 (class 2618 OID 146571982)
-- Dependencies: 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 367 1780 1769 1768 1767 1759 1756 1751 1749 1736 1700 1683 1681 368 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO quote DO INSTEAD INSERT INTO public.quhead (quhead_number, quhead_cust_id, quhead_custponumber, quhead_quotedate, quhead_warehous_id, quhead_shipto_id, quhead_shiptoname, quhead_shiptoaddress1, quhead_shiptoaddress2, quhead_shiptoaddress3, quhead_salesrep_id, quhead_terms_id, quhead_fob, quhead_shipvia, quhead_shiptocity, quhead_shiptostate, quhead_shiptozipcode, quhead_freight, quhead_misc, quhead_ordercomments, quhead_shipcomments, quhead_shiptophone, quhead_billtoname, quhead_billtoaddress1, quhead_billtoaddress2, quhead_billtoaddress3, quhead_billtocity, quhead_billtostate, quhead_billtozip, quhead_misc_accnt_id, quhead_misc_descrip, quhead_commission, quhead_packdate, quhead_prj_id, quhead_billtocountry, quhead_shiptocountry, quhead_curr_id, quhead_taxzone_id, quhead_taxtype_id, quhead_imported, quhead_expire, quhead_status, quhead_saletype_id, quhead_shipzone_id) VALUES (new.quote_number, public.getcustid(new.customer_number, true), new.cust_po_number, new.quote_date, public.getwarehousid(new.site, 'SHIPPING'::text), public.getshiptoid(new.customer_number, new.shipto_number), new.shipto_name, new.shipto_address1, new.shipto_address2, new.shipto_address3, public.getsalesrepid(new.sales_rep), public.gettermsid(new.terms), new.fob, new.ship_via, new.shipto_city, new.shipto_state, new.shipto_postal_code, new.freight, new.misc_charge, new.order_notes, new.shipping_notes, new.shipto_phone, new.billto_name, new.billto_address1, new.billto_address2, new.billto_address3, new.billto_city, new.billto_state, new.billto_postal_code, public.getglaccntid(new.misc_account_number), new.misc_charge_description, new.commission, new.pack_date, public.getprjid(new.project_number), new.billto_country, new.shipto_country, public.getcurrid((new.currency)::text), public.gettaxzoneid(new.tax_zone), public.gettaxtypeid(new.tax_type), true, new.expire_date, CASE WHEN (new.status = 'Converted'::text) THEN 'C'::text ELSE 'O'::text END, public.getsaletypeid(new.sale_type), public.getshipzoneid(new.shipto_shipzone));


--
-- TOC entry 8769 (class 2618 OID 146571984)
-- Dependencies: 369 369 369 369 369 369 240 1720 1669 910 369 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO quotecomment DO INSTEAD INSERT INTO public.comment (comment_date, comment_source, comment_source_id, comment_user, comment_cmnttype_id, comment_text) VALUES (COALESCE(new.date, (('now'::text)::date)::timestamp with time zone), 'Q'::text, public.getquoteid(new.quote_number), COALESCE(new.username, public.geteffectivextuser()), public.getcmnttypeid(new.type), new.text);


--
-- TOC entry 8770 (class 2618 OID 146571985)
-- Dependencies: 371 825 825 825 371 371 371 371 371 371 371 371 371 371 371 371 371 371 371 370 370 370 367 367 367 367 367 367 193 193 193 193 192 192 192 192 191 191 191 191 2234 1902 1888 1780 1771 1767 1720 1714 911 910 371 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO quoteline DO INSTEAD INSERT INTO public.quitem (quitem_quhead_id, quitem_linenumber, quitem_itemsite_id, quitem_scheddate, quitem_qtyord, quitem_unitcost, quitem_price, quitem_custprice, quitem_memo, quitem_imported, quitem_custpn, quitem_createorder, quitem_order_warehous_id, quitem_item_id, quitem_prcost, quitem_taxtype_id, quitem_qty_uom_id, quitem_qty_invuomratio, quitem_price_uom_id, quitem_price_invuomratio) SELECT public.getquoteid(new.quote_number) AS getquoteid, COALESCE(new.line_number, (SELECT (COALESCE(max(quitem.quitem_linenumber), 0) + 1) FROM public.quitem WHERE (quitem.quitem_quhead_id = public.getquoteid(new.quote_number)))) AS "coalesce", itemsite.itemsite_id, COALESCE(new.scheduled_date, (SELECT min(quitem.quitem_scheddate) AS min FROM public.quitem WHERE (quitem.quitem_quhead_id = public.getquoteid(new.quote_number)))) AS "coalesce", new.qty_ordered, public.stdcost(item.item_id) AS stdcost, COALESCE(new.net_unit_price, public.itemprice(public.getitemid(new.item_number), quhead.quhead_cust_id, quhead.quhead_shipto_id, new.qty_ordered, quhead.quhead_curr_id, quhead.quhead_quotedate)) AS "coalesce", public.itemprice(public.getitemid(new.item_number), quhead.quhead_cust_id, quhead.quhead_shipto_id, new.qty_ordered, quhead.quhead_curr_id, quhead.quhead_quotedate) AS itemprice, COALESCE(new.notes, ''::text) AS "coalesce", true AS bool, new.customer_pn, COALESCE(new.create_order, false) AS "coalesce", COALESCE(public.getwarehousid(new.supplying_site, 'SHIPPING'::text), itemsite.itemsite_warehous_id) AS "coalesce", public.getitemid(new.item_number) AS getitemid, COALESCE(new.overwrite_po_price, (0)::numeric) AS "coalesce", COALESCE(public.gettaxtypeid(new.tax_type), public.getitemtaxtype(itemsite.itemsite_item_id, quhead.quhead_taxzone_id)) AS "coalesce", COALESCE(public.getuomid(new.qty_uom), item.item_inv_uom_id) AS "coalesce", public.itemuomtouomratio(item.item_id, COALESCE(public.getuomid(new.qty_uom), item.item_inv_uom_id), item.item_inv_uom_id) AS itemuomtouomratio, COALESCE(public.getuomid(new.price_uom), item.item_price_uom_id) AS "coalesce", public.itemuomtouomratio(item.item_id, COALESCE(public.getuomid(new.price_uom), item.item_price_uom_id), item.item_price_uom_id) AS itemuomtouomratio FROM public.quhead, public.itemsite, public.item, public.whsinfo WHERE ((quhead.quhead_number = new.quote_number) AND (((((((itemsite.itemsite_warehous_id = whsinfo.warehous_id) AND (itemsite.itemsite_item_id = item.item_id)) AND itemsite.itemsite_active) AND (item.item_number = new.item_number)) AND whsinfo.warehous_active) AND whsinfo.warehous_shipping) AND (whsinfo.warehous_code = COALESCE(new.sold_from_site, (SELECT whsinfo.warehous_code FROM public.usrpref, public.whsinfo WHERE (((usrpref.usrpref_username = public.geteffectivextuser()) AND (usrpref.usrpref_name = 'PreferredWarehouse'::text)) AND (whsinfo.warehous_id = (usrpref.usrpref_value)::integer)))))));


--
-- TOC entry 8771 (class 2618 OID 146571987)
-- Dependencies: 372 372 372 372 372 370 370 370 370 367 367 237 237 237 236 236 192 192 191 2281 372 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO quotelinechar DO INSTEAD SELECT DISTINCT public.updatecharassignment('QI'::text, quitem.quitem_id, charass.charass_char_id, new.value) AS updatecharassignment FROM public.quhead, public.quitem, public.itemsite, public.item, public.charass, public."char" WHERE (((((((((quhead.quhead_number = new.quote_number) AND (quhead.quhead_id = quitem.quitem_quhead_id)) AND (quitem.quitem_linenumber = new.line_number)) AND (quitem.quitem_itemsite_id = itemsite.itemsite_id)) AND (item.item_id = itemsite.itemsite_item_id)) AND (charass.charass_target_type = 'I'::text)) AND (charass.charass_target_id = item.item_id)) AND ("char".char_id = charass.charass_char_id)) AND ("char".char_name = new.characteristic));


--
-- TOC entry 8772 (class 2618 OID 146571989)
-- Dependencies: 373 373 373 373 373 373 373 240 1740 1669 910 373 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO quotelinecomment DO INSTEAD INSERT INTO public.comment (comment_date, comment_source, comment_source_id, comment_user, comment_cmnttype_id, comment_text) VALUES (COALESCE(new.date, (('now'::text)::date)::timestamp with time zone), 'QI'::text, public.getquotelineitemid(new.quote_number, new.line_number), COALESCE(new.username, public.geteffectivextuser()), public.getcmnttypeid(new.type), new.text);


--
-- TOC entry 8773 (class 2618 OID 146571990)
-- Dependencies: 375 375 375 375 375 375 374 1681 1672 1660 375 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO salescredit DO INSTEAD INSERT INTO public.aropenalloc (aropenalloc_aropen_id, aropenalloc_doctype, aropenalloc_doc_id, aropenalloc_amount, aropenalloc_curr_id) VALUES (public.getaropenid(new.customer_number, 'C'::bpchar, new.cm_number), 'S'::bpchar, public.getcoheadid(new.so_number), new.amount, public.getcurrid((new.currency)::text));


--
-- TOC entry 8774 (class 2618 OID 146571991)
-- Dependencies: 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 380 376 1768 1767 1756 1749 1716 1700 1682 1681 907 380 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO saleshistory DO INSTEAD INSERT INTO public.cohist (cohist_cust_id, cohist_itemsite_id, cohist_shipdate, cohist_shipvia, cohist_ordernumber, cohist_orderdate, cohist_invcnumber, cohist_invcdate, cohist_qtyshipped, cohist_unitprice, cohist_shipto_id, cohist_salesrep_id, cohist_duedate, cohist_imported, cohist_billtoname, cohist_billtoaddress1, cohist_billtoaddress2, cohist_billtoaddress3, cohist_billtocity, cohist_billtostate, cohist_billtozip, cohist_shiptoname, cohist_shiptoaddress1, cohist_shiptoaddress2, cohist_shiptoaddress3, cohist_shiptocity, cohist_shiptostate, cohist_shiptozip, cohist_commission, cohist_commissionpaid, cohist_unitcost, cohist_misc_type, cohist_misc_descrip, cohist_misc_id, cohist_doctype, cohist_promisedate, cohist_ponumber, cohist_curr_id, cohist_sequence, cohist_taxzone_id, cohist_taxtype_id) VALUES (public.getcustid(new.customer_number), public.getitemsiteid(new.site_code, new.item_number), new.ship_date, new.ship_via, new.order_number, new.order_date, new.invoice_number, new.invoice_date, new.quantity_shipped, COALESCE(new.unit_price, (0)::numeric), public.getshiptoid(new.customer_number, new.shipto_number), public.getsalesrepid(new.sales_rep), new.due_date, true, new.billto_name, new.billto_address1, new.billto_address2, new.billto_address3, new.billto_city, new.billto_state, new.billto_zip, new.shipto_name, new.shipto_address1, new.shipto_address2, new.shipto_address3, new.shipto_city, new.shipto_state, new.shipto_zip, COALESCE(new.commission, (0)::numeric), COALESCE(new.commission_paid, false), COALESCE(new.unit_cost, (0)::numeric), CASE WHEN (new.misc_type = 'Misc. Charge'::text) THEN 'M'::text WHEN (new.misc_type = 'Freight'::text) THEN 'F'::text ELSE NULL::text END, new.misc_description, CASE WHEN (new.misc_type = 'Misc. Charge'::text) THEN public.getglaccntid(new.misc_info) ELSE NULL::integer END, CASE WHEN (new.document_type = 'Invoice'::text) THEN 'I'::text WHEN (new.document_type = 'Credit Memo'::text) THEN 'C'::text ELSE NULL::text END, new.promise_date, new.purchase_order_number, COALESCE(public.getcurrid((new.currency)::text), public.basecurrid()), new.gl_sequence, public.gettaxzoneid(new.tax_zone), public.gettaxtypeid(new.tax_type));


--
-- TOC entry 8775 (class 2618 OID 146571993)
-- Dependencies: 381 381 381 381 381 237 237 237 236 236 196 196 196 196 195 195 195 195 195 195 192 192 191 2282 1876 1674 381 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO saleslinechar DO INSTEAD SELECT DISTINCT public.updatecharassignment('SI'::text, coitem.coitem_id, charass.charass_char_id, new.value, public.itemcharprice(item.item_id, "char".char_id, new.value, cohead.cohead_cust_id, cohead.cohead_shipto_id, coitem.coitem_qtyord, cohead.cohead_curr_id, cohead.cohead_orderdate)) AS updatecharassignment FROM public.cohead, public.coitem, public.itemsite, public.item, public.charass, public."char" WHERE (((((((((cohead.cohead_number = (new.order_number)::text) AND (cohead.cohead_id = coitem.coitem_cohead_id)) AND (coitem.coitem_id = public.getcoitemid((new.order_number)::text, new.line_number))) AND (coitem.coitem_itemsite_id = itemsite.itemsite_id)) AND (item.item_id = itemsite.itemsite_item_id)) AND (charass.charass_target_type = 'I'::text)) AND (charass.charass_target_id = item.item_id)) AND ("char".char_id = charass.charass_char_id)) AND ("char".char_name = new.characteristic));


--
-- TOC entry 8776 (class 2618 OID 146571995)
-- Dependencies: 382 382 382 382 382 382 382 240 1674 1669 910 382 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO saleslinecomment DO INSTEAD INSERT INTO public.comment (comment_date, comment_source, comment_source_id, comment_user, comment_cmnttype_id, comment_text) VALUES (COALESCE(new.date, (('now'::text)::date)::timestamp with time zone), 'SI'::text, public.getcoitemid((new.order_number)::text, new.line_number), COALESCE(new.username, public.geteffectivextuser()), public.getcmnttypeid(new.type), new.text);


--
-- TOC entry 8777 (class 2618 OID 146571996)
-- Dependencies: 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 213 195 1780 1769 1768 1759 1756 1754 1753 1751 1749 1736 1700 1682 1681 1670 1545 383 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO salesorder DO INSTEAD INSERT INTO public.cohead (cohead_number, cohead_cust_id, cohead_custponumber, cohead_orderdate, cohead_warehous_id, cohead_shipto_id, cohead_shiptoname, cohead_shiptoaddress1, cohead_shiptoaddress2, cohead_shiptoaddress3, cohead_salesrep_id, cohead_terms_id, cohead_fob, cohead_shipvia, cohead_shiptocity, cohead_shiptostate, cohead_shiptozipcode, cohead_freight, cohead_calcfreight, cohead_misc, cohead_imported, cohead_ordercomments, cohead_shipcomments, cohead_shiptophone, cohead_shipchrg_id, cohead_shipform_id, cohead_billtoname, cohead_billtoaddress1, cohead_billtoaddress2, cohead_billtoaddress3, cohead_billtocity, cohead_billtostate, cohead_billtozipcode, cohead_misc_accnt_id, cohead_misc_descrip, cohead_commission, cohead_holdtype, cohead_packdate, cohead_prj_id, cohead_shipcomplete, cohead_billtocountry, cohead_shiptocountry, cohead_curr_id, cohead_taxzone_id, cohead_shipto_cntct_id, cohead_shipto_cntct_honorific, cohead_shipto_cntct_first_name, cohead_shipto_cntct_middle, cohead_shipto_cntct_last_name, cohead_shipto_cntct_suffix, cohead_shipto_cntct_phone, cohead_shipto_cntct_title, cohead_shipto_cntct_fax, cohead_shipto_cntct_email, cohead_billto_cntct_id, cohead_billto_cntct_honorific, cohead_billto_cntct_first_name, cohead_billto_cntct_middle, cohead_billto_cntct_last_name, cohead_billto_cntct_suffix, cohead_billto_cntct_phone, cohead_billto_cntct_title, cohead_billto_cntct_fax, cohead_billto_cntct_email, cohead_saletype_id, cohead_shipzone_id) SELECT new.order_number, public.getcustid(new.customer_number) AS getcustid, new.cust_po_number, new.order_date, public.getwarehousid(new.site, 'SHIPPING'::text) AS getwarehousid, public.getshiptoid(new.customer_number, new.shipto_number) AS getshiptoid, new.shipto_name, new.shipto_address1, new.shipto_address2, new.shipto_address3, public.getsalesrepid(new.sales_rep) AS getsalesrepid, public.gettermsid(new.terms) AS gettermsid, new.fob, new.ship_via, new.shipto_city, new.shipto_state, new.shipto_postal_code, CASE WHEN COALESCE(new.calculate_freight, public.fetchmetricbool('CalculateFreight'::text)) THEN (0)::numeric ELSE new.freight END AS freight, COALESCE(new.calculate_freight, public.fetchmetricbool('CalculateFreight'::text)) AS "coalesce", new.misc_charge, true AS bool, new.order_notes, new.shipping_notes, new.shipto_phone, public.getshipchrgid(new.shipping_chgs) AS getshipchrgid, public.getshipformid(new.shipping_form) AS getshipformid, new.billto_name, new.billto_address1, new.billto_address2, new.billto_address3, new.billto_city, new.billto_state, new.billto_postal_code, public.getglaccntid(new.misc_account_number) AS getglaccntid, new.misc_charge_description, new.commission, CASE WHEN (new.hold_type = 'Credit'::text) THEN 'C'::text WHEN (new.hold_type = 'Shipping'::text) THEN 'S'::text WHEN (new.hold_type = 'Packing'::text) THEN 'P'::text ELSE 'N'::text END AS "case", new.pack_date, public.getprjid(new.project_number) AS getprjid, new.ship_complete, new.billto_country, new.shipto_country, public.getcurrid((new.currency)::text) AS getcurrid, CASE WHEN (new.tax_zone = 'None'::text) THEN (-1) ELSE public.gettaxzoneid(new.tax_zone) END AS gettaxzoneid, public.getcntctid(new.shipto_contact_number) AS getcntctid, new.shipto_contact_honorific, new.shipto_contact_first, new.shipto_contact_middle, new.shipto_contact_last, new.shipto_contact_suffix, new.shipto_contact_phone, new.shipto_contact_title, new.shipto_contact_fax, new.shipto_contact_email, public.getcntctid(new.billto_contact_number) AS getcntctid, new.billto_contact_name, new.billto_contact_first, new.billto_contact_middle, new.billto_contact_last, new.billto_contact_suffix, new.billto_contact_phone, new.billto_contact_title, new.billto_contct_fax, new.billto_contact_email, public.getsaletypeid(new.sale_type) AS getsaletypeid, public.getshipzoneid(new.shipto_shipzone) AS getshipzoneid FROM public.custinfo WHERE (custinfo.cust_number = new.customer_number);


--
-- TOC entry 8778 (class 2618 OID 146571998)
-- Dependencies: 384 384 384 384 384 384 240 1748 1669 910 384 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO salesordercomment DO INSTEAD INSERT INTO public.comment (comment_date, comment_source, comment_source_id, comment_user, comment_cmnttype_id, comment_text) VALUES (COALESCE(new.date, (('now'::text)::date)::timestamp with time zone), 'S'::text, public.getsalesorderid((new.order_number)::text), COALESCE(new.username, public.geteffectivextuser()), public.getcmnttypeid(new.type), new.text);


--
-- TOC entry 8779 (class 2618 OID 146571999)
-- Dependencies: 385 385 385 385 385 385 216 1690 385 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO salesrep DO INSTEAD INSERT INTO public.salesrep (salesrep_active, salesrep_number, salesrep_name, salesrep_commission, salesrep_method, salesrep_emp_id) VALUES (COALESCE(new.active, true), COALESCE(new.number, ''::character varying), COALESCE(new.name, ''::text), COALESCE((new.commission_percent * 0.01), (0)::numeric), ''::bpchar, public.getempid(new.employee));


--
-- TOC entry 8780 (class 2618 OID 146572000)
-- Dependencies: 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 193 2162 2158 1768 1760 1758 1754 1700 1678 1670 1658 1547 388 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO site DO INSTEAD INSERT INTO public.whsinfo (warehous_code, warehous_descrip, warehous_fob, warehous_active, warehous_counttag_prefix, warehous_counttag_number, warehous_bol_prefix, warehous_bol_number, warehous_shipping, warehous_useslips, warehous_usezones, warehous_aislesize, warehous_aislealpha, warehous_racksize, warehous_rackalpha, warehous_binsize, warehous_binalpha, warehous_locationsize, warehous_locationalpha, warehous_enforcearbl, warehous_default_accnt_id, warehous_shipping_commission, warehous_cntct_id, warehous_addr_id, warehous_taxzone_id, warehous_transit, warehous_shipform_id, warehous_shipvia_id, warehous_shipcomments, warehous_costcat_id, warehous_sitetype_id, warehous_sequence) VALUES (COALESCE(new.code, ''::character varying), COALESCE(new.description, ''::text), CASE WHEN new.inventory_type THEN COALESCE(new.default_fob, ''::text) ELSE ''::text END, COALESCE(new.active, true), CASE WHEN new.inventory_type THEN COALESCE(new.next_count_tag_prefix, ''::text) ELSE ''::text END, CASE WHEN new.inventory_type THEN COALESCE(new.next_count_tag_number, 0) ELSE 0 END, CASE WHEN new.inventory_type THEN COALESCE(new.next_bill_of_lading_prefix, ''::text) ELSE ''::text END, CASE WHEN new.inventory_type THEN COALESCE(new.next_bill_of_lading_number, 0) ELSE 0 END, CASE WHEN new.inventory_type THEN COALESCE(new.shipping_site, false) ELSE false END, CASE WHEN new.inventory_type THEN COALESCE(new.force_the_use_of_count_slips, false) ELSE false END, CASE WHEN new.inventory_type THEN COALESCE(new.force_the_use_of_zones, false) ELSE false END, CASE WHEN new.inventory_type THEN COALESCE(new.aisle_size, 0) ELSE 0 END, CASE WHEN new.inventory_type THEN COALESCE(new.aisle_allow_alpha_characters, false) ELSE false END, CASE WHEN new.inventory_type THEN COALESCE(new.rack_size, 0) ELSE 0 END, CASE WHEN new.inventory_type THEN COALESCE(new.rack_allow_alpha_characters, false) ELSE false END, CASE WHEN new.inventory_type THEN COALESCE(new.bin_size, 0) ELSE 0 END, CASE WHEN new.inventory_type THEN COALESCE(new.bin_allow_alpha_characters, false) ELSE false END, CASE WHEN new.inventory_type THEN COALESCE(new.location_size, 0) ELSE 0 END, CASE WHEN new.inventory_type THEN COALESCE(new.location_allow_alpha_characters, false) ELSE false END, CASE WHEN new.inventory_type THEN COALESCE(new.enforce_arbl_naming_convention, false) ELSE false END, COALESCE(public.getglaccntid(new.post_unassigned_transactions_to), (-1)), CASE WHEN new.inventory_type THEN COALESCE((new.shipping_commission * 0.01), (0)::numeric) ELSE (0)::numeric END, public.savecntct(public.getcntctid(new.contact_number), new.contact_number, NULL::integer, new.honorific, new.first, new.middle, new.last, new.suffix, new.phone, NULL::text, new.fax, new.email, NULL::text, new.job_title, new.contact_change), public.saveaddr(public.getaddrid(new.address_number), new.address_number, new.address1, new.address2, new.address3, new.city, new.state, new.postal_code, new.country, new.address_change), CASE WHEN new.inventory_type THEN COALESCE(public.gettaxzoneid(new.tax_zone), (-1)) ELSE NULL::integer END, CASE WHEN new.inventory_type THEN false WHEN new.transit_type THEN true ELSE false END, CASE WHEN new.transit_type THEN COALESCE((public.getshipformid(new.default_shipping_form))::numeric, public.fetchmetricvalue('DefaultShipFormId'::text)) ELSE NULL::numeric END, CASE WHEN new.transit_type THEN COALESCE((public.getshipviaid(new.default_ship_via))::numeric, public.fetchmetricvalue('DefaultShipViaId'::text)) ELSE NULL::numeric END, CASE WHEN new.transit_type THEN COALESCE(new.shipping_comments, ''::text) ELSE ''::text END, CASE WHEN new.transit_type THEN COALESCE(public.getcostcatid(new.default_cost_category), (-1)) ELSE NULL::integer END, COALESCE(public.getsitetypeid(new.type), (-1)), COALESCE(new.scheduling_sequence, 0));


--
-- TOC entry 8781 (class 2618 OID 146572002)
-- Dependencies: 389 389 389 389 343 1780 389 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO sitezone DO INSTEAD INSERT INTO public.whsezone (whsezone_warehous_id, whsezone_name, whsezone_descrip) VALUES (public.getwarehousid((new.site)::text, 'ACTIVE'::text), COALESCE(new.name, ''::character varying), COALESCE(new.description, ''::text));


--
-- TOC entry 8782 (class 2618 OID 146572003)
-- Dependencies: 390 390 390 390 390 390 390 390 390 390 390 390 390 390 390 390 232 1736 910 390 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO task DO INSTEAD INSERT INTO public.prjtask (prjtask_prj_id, prjtask_number, prjtask_name, prjtask_descrip, prjtask_owner_username, prjtask_username, prjtask_hours_budget, prjtask_hours_actual, prjtask_exp_budget, prjtask_exp_actual, prjtask_status, prjtask_due_date, prjtask_assigned_date, prjtask_start_date, prjtask_completed_date) VALUES (public.getprjid(new.project_number), new.number, COALESCE(new.name, ''::text), COALESCE(new.description, ''::text), COALESCE(new.owner, public.geteffectivextuser()), COALESCE(new.assigned_to, public.geteffectivextuser()), COALESCE(new.hours_budgeted, (0)::numeric), COALESCE(new.hours_actual, (0)::numeric), COALESCE(new.expenses_budgeted, (0)::numeric), COALESCE(new.expenses_actual, (0)::numeric), CASE WHEN (new.status = 'In-Process'::text) THEN 'O'::text WHEN (new.status = 'Completed'::text) THEN 'C'::text ELSE 'P'::text END, new.due, new.assigned, new.started, new.completed);


--
-- TOC entry 8783 (class 2618 OID 146572005)
-- Dependencies: 391 391 391 391 391 391 391 240 1737 1669 910 391 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO taskcomment DO INSTEAD INSERT INTO public.comment (comment_date, comment_source, comment_source_id, comment_user, comment_cmnttype_id, comment_text) VALUES (COALESCE(new.date, now()), 'TA'::text, public.getprjtaskid((new.project_number)::text, (new.task_number)::text), COALESCE(new.username, public.geteffectivextuser()), public.getcmnttypeid(new.type), new.text);


--
-- TOC entry 8784 (class 2618 OID 146572006)
-- Dependencies: 392 392 392 392 392 392 392 392 392 392 392 392 392 392 392 1724 1708 1705 1704 1680 1350 392 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO todo DO INSTEAD SELECT public.createtodoitem(NULL::integer, new.assigned_to, COALESCE(new.task_name, ''::text), COALESCE(new.description, ''::text), public.getincidentid(new.incident), COALESCE(public.getincdtcrmacctid(new.incident), public.getcrmacctid(new.account)), public.getopheadid(new.opportunity), CASE WHEN (new.date_started > ''::text) THEN (new.date_started)::date ELSE NULL::date END, CASE WHEN (new.date_due > ''::text) THEN (new.date_due)::date ELSE NULL::date END, (CASE WHEN (new.status = 'Pending Input'::text) THEN 'P'::text WHEN (new.status = 'Deferred'::text) THEN 'D'::text ELSE 'N'::text END)::bpchar, CASE WHEN (new.date_assigned > ''::text) THEN (new.date_assigned)::date ELSE NULL::date END, CASE WHEN (new.date_completed > ''::text) THEN (new.date_completed)::date ELSE NULL::date END, public.getincdtpriorityid(new.priority), COALESCE(new.notes, ''::text), new.owner) AS createtodoitem;


--
-- TOC entry 8785 (class 2618 OID 146572008)
-- Dependencies: 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 210 2162 2158 1779 1769 1768 1766 1700 1691 1681 1670 1658 1547 1539 907 394 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO vendor DO INSTEAD INSERT INTO public.vendinfo (vend_name, vend_lastpurchdate, vend_active, vend_po, vend_comments, vend_pocomments, vend_number, vend_1099, vend_exported, vend_fobsource, vend_fob, vend_terms_id, vend_shipvia, vend_vendtype_id, vend_qualified, vend_ediemail, vend_ediemailbody, vend_edisubject, vend_edifilename, vend_accntnum, vend_emailpodelivery, vend_restrictpurch, vend_edicc, vend_curr_id, vend_cntct1_id, vend_cntct2_id, vend_addr_id, vend_match, vend_taxzone_id, vend_ach_routingnumber, vend_ach_accntnumber, vend_accnt_id, vend_expcat_id, vend_tax_id) VALUES (COALESCE(new.vendor_name, ''::text), NULL::date, COALESCE(new.active, true), COALESCE(new.sells_purchase_order_items, false), COALESCE(new.notes, ''::text), COALESCE(new.po_comments, ''::text), COALESCE(new.vendor_number, ''::character varying), COALESCE(new.receives_1099, false), false, CASE WHEN (new.default_fob = 'Receiving Site'::text) THEN 'W'::text ELSE 'V'::text END, CASE WHEN (new.default_fob = 'Receiving Site'::text) THEN ''::text ELSE new.default_fob END, COALESCE((public.gettermsid(new.default_terms))::numeric, public.fetchmetricvalue('DefaultTerms'::text)), COALESCE(new.ship_via, public.fetchdefaultshipvia()), public.getvendtypeid(new.vendor_type), COALESCE(new.qualified, false), COALESCE(new.po_edi_email, ''::text), COALESCE(new.po_edi_emailbody, ''::text), COALESCE(new.po_edi_subject, ''::text), COALESCE(new.po_edi_filename, ''::text), COALESCE(new.account_number, ''::text), COALESCE(new.allow_email_po_delivery, false), COALESCE(new.may_only_sell_item_source, false), COALESCE(new.po_edi_cc, ''::text), COALESCE(public.getcurrid((new.default_currency)::text), public.basecurrid()), public.savecntct(public.getcntctid(new.contact1_number), new.contact1_number, NULL::integer, new.contact1_honorific, new.contact1_first, new.contact1_middle, new.contact1_last, new.contact1_suffix, new.contact1_voice, new.contact1_alternate, new.contact1_fax, new.contact1_email, new.contact1_web, new.contact1_job_title, new.contact1_change), public.savecntct(public.getcntctid(new.contact2_number), new.contact2_number, NULL::integer, new.contact2_honorific, new.contact2_first, new.contact2_middle, new.contact2_last, new.contact2_suffix, new.contact2_voice, new.contact2_alternate, new.contact2_fax, new.contact2_email, new.contact2_web, new.contact2_job_title, new.contact2_change), public.saveaddr(public.getaddrid(new.address_number), new.address_number, new.address1, new.address2, new.address3, new.city, new.state, new.postalcode, new.country, new.address_change), COALESCE(new.matching_vo_po_amounts, false), public.gettaxzoneid(new.default_tax_zone), '\x'::bytea, '\x'::bytea, COALESCE(public.getglaccntid(new.default_dist_gl_account), (-1)), COALESCE(public.getexpcatid(new.default_dist_expense_category), (-1)), COALESCE(public.gettaxid(new.default_dist_tax_code), (-1)));


--
-- TOC entry 8786 (class 2618 OID 146572010)
-- Dependencies: 395 395 395 395 395 395 395 395 395 395 395 395 395 395 395 395 395 395 395 395 395 395 395 395 395 395 395 364 2162 2158 1778 1670 1658 395 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO vendoraddress DO INSTEAD INSERT INTO public.vendaddrinfo (vendaddr_vend_id, vendaddr_code, vendaddr_name, vendaddr_comments, vendaddr_cntct_id, vendaddr_addr_id) VALUES (public.getvendid((new.vendor_number)::text), COALESCE(new.vendor_address_number, ''::character varying), COALESCE(new.vendor_address_name, ''::text), COALESCE(new.notes, ''::text), public.savecntct(public.getcntctid(new.contact_number), new.contact_number, public.saveaddr(public.getaddrid(new.address_number), new.address_number, new.address1, new.address2, new.address3, new.city, new.state, new.postalcode, new.country, new.address_change), new.contact_honorific, new.contact_first, new.contact_middle, new.contact_last, new.contact_suffix, new.contact_voice, new.contact_alternate, new.contact_fax, new.contact_email, new.contact_web, new.contact_job_title, new.contact_change), public.saveaddr(public.getaddrid(new.address_number), new.address_number, new.address1, new.address2, new.address3, new.city, new.state, new.postalcode, new.country, new.address_change));


--
-- TOC entry 8787 (class 2618 OID 146572012)
-- Dependencies: 396 396 396 393 396 8894
-- Name: _INSERT; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO vendortype DO INSTEAD INSERT INTO public.vendtype (vendtype_code, vendtype_descrip) VALUES (new.code, COALESCE(new.description, ''::text));


--
-- TOC entry 8788 (class 2618 OID 146572013)
-- Dependencies: 360 360 360 237 237 237 237 237 236 198 198 198 198 197 197 192 192 191 360 8894
-- Name: _INSERT_CHAR; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_INSERT_CHAR" AS ON INSERT TO purchaseline DO INSTEAD INSERT INTO public.charass (charass_target_type, charass_target_id, charass_char_id, charass_value) SELECT 'PI', poitem.poitem_id, "char".char_id, charass.charass_value FROM public.pohead, public.poitem, public.charass, public."char", public.itemsite, public.item WHERE (((((((((pohead.pohead_number = (new.order_number)::text) AND (poitem.poitem_pohead_id = pohead.pohead_id)) AND (poitem.poitem_linenumber = new.line_number)) AND (itemsite.itemsite_id = poitem.poitem_itemsite_id)) AND (itemsite.itemsite_item_id = item.item_id)) AND (charass.charass_target_type = 'I'::text)) AND (charass.charass_target_id = item.item_id)) AND charass.charass_default) AND ("char".char_id = charass.charass_char_id));


--
-- TOC entry 8789 (class 2618 OID 146572015)
-- Dependencies: 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 201 196 196 196 192 192 191 191 191 191 191 1902 1771 1767 1714 1700 1674 1672 201 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO salesline DO INSTEAD UPDATE public.coitem SET coitem_status = new.status, coitem_scheddate = new.scheduled_date, coitem_promdate = new.promise_date, coitem_qtyord = new.qty_ordered, coitem_qty_uom_id = public.getuomid(new.qty_uom), coitem_qty_invuomratio = public.itemuomtouomratio(item.item_id, public.getuomid(new.qty_uom), item.item_inv_uom_id), coitem_price = new.net_unit_price, coitem_price_uom_id = public.getuomid(new.price_uom), coitem_price_invuomratio = public.itemuomtouomratio(item.item_id, public.getuomid(new.price_uom), item.item_price_uom_id), coitem_memo = new.notes, coitem_order_type = CASE WHEN (((NOT old.create_order) AND new.create_order) AND (item.item_type = 'M'::bpchar)) THEN 'W'::text WHEN ((((NOT old.create_order) AND new.create_order) AND (item.item_type = 'P'::bpchar)) AND itemsite.itemsite_createsopo) THEN 'P'::text WHEN (((NOT old.create_order) AND new.create_order) AND (item.item_type = 'P'::bpchar)) THEN 'R'::text ELSE NULL::text END, coitem_substitute_item_id = public.getitemid(new.substitute_for), coitem_prcost = new.overwrite_po_price, coitem_taxtype_id = CASE WHEN (new.tax_type = 'None'::text) THEN NULL::integer ELSE public.gettaxtypeid(new.tax_type) END, coitem_warranty = new.warranty, coitem_cos_accnt_id = public.getglaccntid(new.alternate_cos_account), coitem_rev_accnt_id = public.getglaccntid(new.alternate_rev_account) FROM (public.item JOIN public.itemsite ON ((item.item_id = itemsite.itemsite_item_id))) WHERE ((((item.item_number = old.item_number) AND (coitem.coitem_cohead_id = public.getcoheadid((old.order_number)::text))) AND (coitem.coitem_id = public.getcoitemid((old.order_number)::text, (old.line_number)::text))) AND (coitem.coitem_subnumber = 0));


--
-- TOC entry 8790 (class 2618 OID 146572017)
-- Dependencies: 211 211 211 211 211 211 211 207 207 1769 211 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO apmemo DO INSTEAD UPDATE public.apopen SET apopen_duedate = new.due_date, apopen_terms_id = public.gettermsid(new.terms), apopen_amount = new.amount, apopen_notes = new.notes WHERE ((apopen.apopen_docnumber = old.document_number) AND ((apopen.apopen_doctype)::text = CASE WHEN (old.document_type = 'Credit Memo'::text) THEN 'C'::text WHEN (old.document_type = 'Debit Memo'::text) THEN 'D'::text ELSE ''::text END));


--
-- TOC entry 8791 (class 2618 OID 146572018)
-- Dependencies: 217 217 217 217 217 217 217 217 217 217 212 212 1769 1749 1743 217 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO armemo DO INSTEAD UPDATE public.aropen SET aropen_duedate = new.due_date, aropen_terms_id = public.gettermsid(new.terms), aropen_salesrep_id = public.getsalesrepid(new.sales_rep), aropen_amount = new.amount, aropen_commission_due = new.commission_due, aropen_notes = new.notes, aropen_rsncode_id = public.getrsnid(new.reason_code) WHERE ((aropen.aropen_docnumber = old.document_number) AND ((aropen.aropen_doctype)::text = CASE WHEN (old.document_type = 'Credit Memo'::text) THEN 'C'::text WHEN (old.document_type = 'Debit Memo'::text) THEN 'D'::text ELSE ''::text END));


--
-- TOC entry 8792 (class 2618 OID 146572020)
-- Dependencies: 194 194 194 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO physinvcount DO INSTEAD NOTHING;


--
-- TOC entry 8793 (class 2618 OID 146572021)
-- Dependencies: 235 235 235 235 235 235 235 235 235 205 1680 1670 235 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO account DO INSTEAD UPDATE public.crmacct SET crmacct_number = new.account_number, crmacct_parent_id = public.getcrmacctid(new.parent_account), crmacct_name = new.account_name, crmacct_active = new.active, crmacct_type = CASE WHEN (new.type = 'Individual'::text) THEN 'I'::text ELSE 'O'::text END, crmacct_cntct_id_1 = public.getcntctid(new.primary_contact_number), crmacct_cntct_id_2 = public.getcntctid(new.secondary_contact_number), crmacct_notes = new.notes WHERE (crmacct.crmacct_number = (old.account_number)::text);


--
-- TOC entry 8794 (class 2618 OID 146572023)
-- Dependencies: 238 238 238 238 237 237 237 1680 1665 238 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO accountchar DO INSTEAD UPDATE public.charass SET charass_value = new.value WHERE (((charass.charass_target_type = 'CRMACCT'::text) AND (charass.charass_target_id = public.getcrmacctid((old.account_number)::text))) AND (charass.charass_char_id = public.getcharid((old.characteristic)::text, 'CRMACCT'::text)));


--
-- TOC entry 8795 (class 2618 OID 146572024)
-- Dependencies: 241 241 241 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO accountcomment DO INSTEAD NOTHING;


--
-- TOC entry 8796 (class 2618 OID 146572025)
-- Dependencies: 246 246 246 246 245 245 245 245 1680 246 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO accountfile DO INSTEAD UPDATE public.url SET url_title = new.title, url_url = new.url WHERE ((((url.url_source_id = public.getcrmacctid(old.account_number)) AND (url.url_source = 'CRMA'::text)) AND (url.url_title = old.title)) AND (url.url_url = old.url));


--
-- TOC entry 8797 (class 2618 OID 146572026)
-- Dependencies: 250 250 250 249 249 249 1702 1680 250 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO accountimage DO INSTEAD UPDATE public.imageass SET imageass_image_id = public.getimageid(new.image_name) WHERE (((imageass.imageass_source_id = public.getcrmacctid(old.account_number)) AND (imageass.imageass_source = 'CRMA'::text)) AND (imageass.imageass_image_id = public.getimageid(old.image_name)));


--
-- TOC entry 8798 (class 2618 OID 146572027)
-- Dependencies: 251 251 251 251 251 251 251 251 251 251 251 251 2157 1658 251 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO address DO INSTEAD SELECT public.saveaddr(public.getaddrid((new.address_number)::text), (new.address_number)::text, new.address1, new.address2, new.address3, new.city, new.state, new.postal_code, new.country, new.active, new.notes, new.change) AS saveaddr;


--
-- TOC entry 8799 (class 2618 OID 146572028)
-- Dependencies: 252 252 252 252 237 237 237 1665 1658 252 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO addresschar DO INSTEAD UPDATE public.charass SET charass_value = new.value WHERE (((charass.charass_target_type = 'ADDR'::text) AND (charass.charass_target_id = public.getaddrid((old.address_number)::text))) AND (charass.charass_char_id = public.getcharid((old.characteristic)::text, 'ADDR'::text)));


--
-- TOC entry 8800 (class 2618 OID 146572029)
-- Dependencies: 253 253 253 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO addresscomment DO INSTEAD NOTHING;


--
-- TOC entry 8801 (class 2618 OID 146572030)
-- Dependencies: 255 255 255 255 255 255 255 2160 1714 255 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO bom DO INSTEAD SELECT public.savebomhead(public.getitemid((new.item_number)::text), (new.revision)::text, new.revision_date, new.document_number, COALESCE(new.batch_size, (0)::numeric), new.total_qty_per) AS savebomhead;


--
-- TOC entry 8802 (class 2618 OID 146572031)
-- Dependencies: 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 256 203 2233 1771 1742 1665 1650 1519 256 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO bomitem DO INSTEAD UPDATE public.bomitem SET bomitem_issuemethod = CASE WHEN (new.issue_method = 'Mixed'::text) THEN 'M'::text WHEN (new.issue_method = 'Push'::text) THEN 'S'::text WHEN (new.issue_method = 'Pull'::text) THEN 'L'::text ELSE NULL::text END, bomitem_uom_id = public.getuomid(new.issue_uom), bomitem_qtyper = new.qty_per, bomitem_scrap = new.scrap, bomitem_effective = CASE WHEN (new.effective = 'Always'::text) THEN public.startoftime() ELSE (new.effective)::date END, bomitem_expires = CASE WHEN (new.expires = 'Never'::text) THEN public.endoftime() ELSE (new.expires)::date END, bomitem_createwo = new.create_child_wo, bomitem_booitem_seq_id = COALESCE(public.getbooitemseqid((new.bom_item_number)::text, new.used_at), (-1)), bomitem_schedatwooper = new.schedule_at_wo_operation, bomitem_ecn = new.ecn_number, bomitem_subtype = CASE WHEN (new.substitutions = 'No'::text) THEN 'N'::text WHEN (new.substitutions = 'Item-Defined'::text) THEN 'I'::text WHEN (new.substitutions = 'BOM-Defined'::text) THEN 'B'::text ELSE NULL::text END, bomitem_rev_id = public.getrevid('BOM'::text, (new.bom_item_number)::text, (new.bom_revision)::text), bomitem_char_id = public.getcharid(new.characteristic, 'I'::text), bomitem_value = new.value, bomitem_notes = new.notes, bomitem_ref = new.reference WHERE (bomitem.bomitem_id = old.id);


--
-- TOC entry 8803 (class 2618 OID 146572033)
-- Dependencies: 257 257 257 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO bomitemcomment DO INSTEAD NOTHING;


--
-- TOC entry 8804 (class 2618 OID 146572034)
-- Dependencies: 259 259 259 259 259 258 258 1714 259 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO bomitemsubstitute DO INSTEAD UPDATE public.bomitemsub SET bomitemsub_uomratio = new.sub_parent_uom_ratio, bomitemsub_rank = new.ranking WHERE ((bomitemsub.bomitemsub_bomitem_id = old.bomitem_id) AND (bomitemsub.bomitemsub_item_id = public.getitemid((old.substitute_item_number)::text)));


--
-- TOC entry 8805 (class 2618 OID 146572035)
-- Dependencies: 261 261 261 260 261 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO budget DO INSTEAD UPDATE public.budghead SET budghead_name = new.name, budghead_descrip = new.description WHERE (budghead.budghead_name = old.name);


--
-- TOC entry 8806 (class 2618 OID 146572036)
-- Dependencies: 265 265 265 265 265 263 263 263 1730 1700 1663 265 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO budgetentry DO INSTEAD UPDATE public.budgitem SET budgitem_amount = new.amount WHERE (((budgitem.budgitem_budghead_id = public.getbudgheadid(old.name)) AND (budgitem.budgitem_period_id = public.getperiodid(old.period_start))) AND (budgitem.budgitem_accnt_id = public.getglaccntid(old.account)));


--
-- TOC entry 8807 (class 2618 OID 146572037)
-- Dependencies: 268 268 268 268 268 268 268 268 268 268 268 268 267 1744 1681 1664 1661 268 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO cashreceipt DO INSTEAD UPDATE public.cashrcpt SET cashrcpt_amount = new.amount_received, cashrcpt_number = new.cashreceipt_number, cashrcpt_fundstype = CASE WHEN ((new.funds_type)::text = 'Check'::text) THEN 'C'::text WHEN ((new.funds_type)::text = 'Certified Check'::text) THEN 'T'::text WHEN ((new.funds_type)::text = 'Master Card'::text) THEN 'M'::text WHEN ((new.funds_type)::text = 'Visa'::text) THEN 'V'::text WHEN ((new.funds_type)::text = 'American Express'::text) THEN 'A'::text WHEN ((new.funds_type)::text = 'Discover Card'::text) THEN 'D'::text WHEN ((new.funds_type)::text = 'Other Credit Card'::text) THEN 'R'::text WHEN ((new.funds_type)::text = 'Cash'::text) THEN 'K'::text WHEN ((new.funds_type)::text = 'Wire Transfer'::text) THEN 'W'::text ELSE 'O'::text END, cashrcpt_docnumber = new.check_document_number, cashrcpt_bankaccnt_id = public.getbankaccntid(new.post_to), cashrcpt_notes = new.notes, cashrcpt_distdate = CASE WHEN (new.distribution_date > ''::text) THEN (new.distribution_date)::date ELSE NULL::date END, cashrcpt_salescat_id = public.getsalescatid(new.sales_category), cashrcpt_curr_id = public.getcurrid((new.currency)::text), cashrcpt_usecustdeposit = CASE WHEN (new.apply_balance_as = 'Customer Deposit'::text) THEN true ELSE false END WHERE (cashrcpt.cashrcpt_id = public.getcashrcptid((old.customer_number)::text, CASE WHEN ((old.funds_type)::text = 'Check'::text) THEN 'C'::text WHEN ((old.funds_type)::text = 'Certified Check'::text) THEN 'T'::text WHEN ((old.funds_type)::text = 'Master Card'::text) THEN 'M'::text WHEN ((old.funds_type)::text = 'Visa'::text) THEN 'V'::text WHEN ((old.funds_type)::text = 'American Express'::text) THEN 'A'::text WHEN ((old.funds_type)::text = 'Discover Card'::text) THEN 'D'::text WHEN ((old.funds_type)::text = 'Other Credit Card'::text) THEN 'R'::text WHEN ((old.funds_type)::text = 'Cash'::text) THEN 'K'::text WHEN ((old.funds_type)::text = 'Wire Transfer'::text) THEN 'W'::text ELSE 'O'::text END, (old.check_document_number)::text));


--
-- TOC entry 8808 (class 2618 OID 146572039)
-- Dependencies: 270 270 270 270 270 270 270 270 269 269 1664 1660 270 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO cashreceiptapply DO INSTEAD UPDATE public.cashrcptitem SET cashrcptitem_amount = new.amount_to_apply, cashrcptitem_discount = new.cashrcptitem_discount WHERE ((cashrcptitem.cashrcptitem_cashrcpt_id = public.getcashrcptid((old.customer_number)::text, CASE WHEN ((old.funds_type)::text = 'Check'::text) THEN 'C'::text WHEN ((old.funds_type)::text = 'Certified Check'::text) THEN 'T'::text WHEN ((old.funds_type)::text = 'Master Card'::text) THEN 'M'::text WHEN ((old.funds_type)::text = 'Visa'::text) THEN 'V'::text WHEN ((old.funds_type)::text = 'American Express'::text) THEN 'A'::text WHEN ((old.funds_type)::text = 'Discover Card'::text) THEN 'D'::text WHEN ((old.funds_type)::text = 'Other Credit Card'::text) THEN 'R'::text WHEN ((old.funds_type)::text = 'Cash'::text) THEN 'K'::text WHEN ((old.funds_type)::text = 'Wire Transfer'::text) THEN 'W'::text ELSE 'O'::text END, (old.check_document_number)::text)) AND (cashrcptitem.cashrcptitem_aropen_id = public.getaropenid((old.customer_number)::text, (old.doc_type)::bpchar, (old.doc_number)::text)));


--
-- TOC entry 8809 (class 2618 OID 146572041)
-- Dependencies: 272 272 272 272 272 272 272 271 271 1700 1664 272 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO cashreceiptapplymisc DO INSTEAD UPDATE public.cashrcptmisc SET cashrcptmisc_accnt_id = public.getglaccntid((new.account)::text), cashrcptmisc_amount = new.amount_to_distribute, cashrcptmisc_notes = new.notes WHERE ((cashrcptmisc.cashrcptmisc_cashrcpt_id = public.getcashrcptid((old.customer_number)::text, CASE WHEN ((old.funds_type)::text = 'Check'::text) THEN 'C'::text WHEN ((old.funds_type)::text = 'Certified Check'::text) THEN 'T'::text WHEN ((old.funds_type)::text = 'Master Card'::text) THEN 'M'::text WHEN ((old.funds_type)::text = 'Visa'::text) THEN 'V'::text WHEN ((old.funds_type)::text = 'American Express'::text) THEN 'A'::text WHEN ((old.funds_type)::text = 'Discover Card'::text) THEN 'D'::text WHEN ((old.funds_type)::text = 'Other Credit Card'::text) THEN 'R'::text WHEN ((old.funds_type)::text = 'Cash'::text) THEN 'K'::text WHEN ((old.funds_type)::text = 'Wire Transfer'::text) THEN 'W'::text ELSE 'O'::text END, (old.check_document_number)::text)) AND (cashrcptmisc.cashrcptmisc_accnt_id = public.getglaccntid((old.account)::text)));


--
-- TOC entry 8810 (class 2618 OID 146572043)
-- Dependencies: 273 273 273 273 273 273 273 273 273 273 273 273 273 273 273 273 273 273 273 273 273 273 273 273 273 273 273 2161 2158 1680 1670 1658 273 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO contact DO INSTEAD SELECT public.savecntct(public.getcntctid((new.contact_number)::text), (new.contact_number)::text, public.getcrmacctid(new.crm_account), public.saveaddr(public.getaddrid(new.address_number), new.address_number, new.address1, new.address2, new.address3, new.city, new.state, new.postal_code, new.country, new.address_change), new.honorific, new.first, new.middle, new.last, new.suffix, new.initials, new.active, new.voice, new.alternate, new.fax, new.email, new.web, new.notes, new.job_title, new.contact_change) AS savecntct;


--
-- TOC entry 8811 (class 2618 OID 146572044)
-- Dependencies: 274 274 274 274 237 237 237 1670 1665 274 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO contactchar DO INSTEAD UPDATE public.charass SET charass_value = new.value WHERE (((charass.charass_target_type = 'CNTCT'::text) AND (charass.charass_target_id = public.getcntctid(old.contact_number))) AND (charass.charass_char_id = public.getcharid((old.characteristic)::text, 'CNTCT'::text)));


--
-- TOC entry 8812 (class 2618 OID 146572045)
-- Dependencies: 275 275 275 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO contactcomment DO INSTEAD NOTHING;


--
-- TOC entry 8813 (class 2618 OID 146572046)
-- Dependencies: 221 221 221 221 221 221 221 221 221 221 221 221 221 221 221 221 221 221 221 221 221 221 221 221 221 221 221 221 221 221 221 221 221 218 218 214 214 1768 1756 1749 1700 1681 221 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO creditmemo DO INSTEAD UPDATE public.cmhead SET cmhead_custponumber = new.customer_po_number, cmhead_docdate = new.memo_date, cmhead_shipto_id = COALESCE(public.getshiptoid(new.customer_number, new.shipto_number), (-1)), cmhead_shipto_name = new.shipto_name, cmhead_shipto_address1 = new.shipto_address1, cmhead_shipto_address2 = new.shipto_address2, cmhead_shipto_address3 = new.shipto_address3, cmhead_shipto_city = new.shipto_city, cmhead_shipto_state = new.shipto_state, cmhead_shipto_zipcode = new.shipto_postal_code, cmhead_shipto_country = new.shipto_country, cmhead_salesrep_id = public.getsalesrepid(new.sales_rep), cmhead_freight = COALESCE(new.freight, (0)::numeric), cmhead_misc = COALESCE(new.misc_charge_amount, (0)::numeric), cmhead_comments = new.notes, cmhead_billtoname = new.billto_name, cmhead_billtoaddress1 = new.billto_address1, cmhead_billtoaddress2 = new.billto_address2, cmhead_billtoaddress3 = new.billto_address3, cmhead_billtocity = new.billto_city, cmhead_billtostate = new.billto_state, cmhead_billtozip = new.billto_postal_code, cmhead_billtocountry = new.billto_country, cmhead_hold = COALESCE(new.on_hold, false), cmhead_commission = COALESCE(new.commission, (0)::numeric), cmhead_misc_accnt_id = COALESCE(public.getglaccntid(new.misc_charge_credit_account), (-1)), cmhead_misc_descrip = new.misc_charge_description, cmhead_rsncode_id = (SELECT rsncode.rsncode_id FROM public.rsncode WHERE (rsncode.rsncode_code = new.reason_code)), cmhead_curr_id = COALESCE(public.getcurrid((new.currency)::text), (-1)), cmhead_taxzone_id = public.gettaxzoneid(NULLIF(new.tax_zone, 'None'::text)) WHERE ((cmhead.cmhead_number = old.memo_number) AND (cmhead.cmhead_posted = false));


--
-- TOC entry 8814 (class 2618 OID 146572048)
-- Dependencies: 223 223 2287 223 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO creditmemoline DO INSTEAD SELECT public.updatecreditmemoline(new.*, old.*) AS updatecreditmemoline;


--
-- TOC entry 8815 (class 2618 OID 146572049)
-- Dependencies: 276 276 276 276 237 237 237 1682 1665 276 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO custchar DO INSTEAD UPDATE public.charass SET charass_value = new.value WHERE (((charass.charass_target_type = 'C'::text) AND (charass.charass_target_id = public.getcustid((old.customer_number)::text))) AND (charass.charass_char_id = public.getcharid((old.characteristic)::text, 'C'::text)));


--
-- TOC entry 8816 (class 2618 OID 146572050)
-- Dependencies: 277 277 277 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO custcomment DO INSTEAD NOTHING;


--
-- TOC entry 8817 (class 2618 OID 146572051)
-- Dependencies: 279 279 279 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO custcreditcard DO INSTEAD NOTHING;


--
-- TOC entry 8818 (class 2618 OID 146572052)
-- Dependencies: 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 283 213 2162 2158 1780 1769 1768 1754 1753 1749 1686 1682 1681 1671 1658 283 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO customer DO INSTEAD UPDATE public.custinfo SET cust_active = new.active, cust_custtype_id = public.getcusttypeid(new.customer_type), cust_salesrep_id = public.getsalesrepid(new.sales_rep), cust_commprcnt = (new.commission * 0.01), cust_name = new.customer_name, cust_creditlmt = new.credit_limit, cust_creditrating = new.credit_rating, cust_backorder = new.accepts_backorders, cust_partialship = new.accepts_partial_shipments, cust_terms_id = public.gettermsid(new.default_terms), cust_discntprcnt = new.default_discount, cust_balmethod = CASE WHEN (new.balance_method = 'Balance Forward'::text) THEN 'B'::text WHEN (new.balance_method = 'Open Items'::text) THEN 'O'::text ELSE NULL::text END, cust_ffshipto = new.allow_free_form_shipto, cust_shipform_id = public.getshipformid(new.ship_form), cust_shipvia = new.ship_via, cust_blanketpos = new.uses_blanket_pos, cust_shipchrg_id = COALESCE(public.getshipchrgid(new.shipping_charges), (-1)), cust_creditstatus = CASE WHEN (new.credit_status = 'On Credit Warning'::text) THEN 'W'::text WHEN (new.credit_status = 'On Credit Hold'::text) THEN 'H'::text ELSE 'G'::text END, cust_comments = new.notes, cust_ffbillto = new.allow_free_form_billto, cust_usespos = new.uses_purchase_orders, cust_number = new.customer_number, cust_autoupdatestatus = new.credit_status_exceed_warn, cust_autoholdorders = new.credit_status_exceed_hold, cust_preferred_warehous_id = COALESCE(public.getwarehousid(new.preferred_selling_site, 'ACTIVE'::text), (-1)), cust_curr_id = public.getcurrid((new.default_currency)::text), cust_creditlmt_curr_id = public.getcurrid((new.credit_limit_currency)::text), cust_cntct_id = public.savecntct(public.getcntctid(new.billing_contact_number, false), new.billing_contact_number, public.saveaddr(public.getaddrid(new.billing_contact_address_number), new.billing_contact_address_number, new.billing_contact_address1, new.billing_contact_address2, new.billing_contact_address3, new.billing_contact_city, new.billing_contact_state, new.billing_contact_postalcode, new.billing_contact_country, new.billing_contact_address_change), new.billing_contact_honorific, new.billing_contact_first, new.billing_contact_middle, new.billing_contact_last, new.billing_contact_suffix, new.billing_contact_voice, new.billing_contact_alternate, new.billing_contact_fax, new.billing_contact_email, new.billing_contact_web, new.billing_contact_job_title, new.billing_contact_change), cust_corrcntct_id = public.savecntct(public.getcntctid(new.correspond_contact_number, false), new.correspond_contact_number, public.saveaddr(public.getaddrid(new.correspond_contact_address_number), new.correspond_contact_address_number, new.correspond_contact_address1, new.correspond_contact_address2, new.correspond_contact_address3, new.correspond_contact_city, new.correspond_contact_state, new.correspond_contact_postalcode, new.correspond_contact_country, new.correspond_contact_address_change), new.correspond_contact_honorific, new.correspond_contact_first, new.correspond_contact_middle, new.correspond_contact_last, new.correspond_contact_suffix, new.correspond_contact_voice, new.correspond_contact_alternate, new.correspond_contact_fax, new.correspond_contact_email, new.correspond_contact_web, new.correspond_contact_job_title, new.correspond_contact_change), cust_taxzone_id = public.gettaxzoneid(new.default_tax_zone), cust_gracedays = CASE WHEN (COALESCE(new.alternate_grace_days, 0) > 0) THEN new.alternate_grace_days ELSE NULL::integer END WHERE (custinfo.cust_id = public.getcustid((old.customer_number)::text));


--
-- TOC entry 8819 (class 2618 OID 146572054)
-- Dependencies: 287 287 287 287 280 287 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO customertype DO INSTEAD UPDATE public.custtype SET custtype_code = new.code, custtype_descrip = new.description, custtype_char = new.enable_characteristics_profile WHERE (custtype.custtype_code = (old.code)::text);


--
-- TOC entry 8820 (class 2618 OID 146572055)
-- Dependencies: 288 288 288 288 288 237 237 237 1686 1665 288 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO customertypechar DO INSTEAD UPDATE public.charass SET charass_value = new.value, charass_default = new.is_default WHERE (((charass.charass_target_type = 'CT'::text) AND (charass.charass_target_id = public.getcusttypeid((old.customer_type)::text))) AND (charass.charass_char_id = public.getcharid((old.characteristic)::text, 'CT'::text)));


--
-- TOC entry 8821 (class 2618 OID 146572056)
-- Dependencies: 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 289 219 2162 2158 1768 1759 1756 1754 1753 1749 1688 1682 1670 1658 289 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO custshipto DO INSTEAD UPDATE public.shiptoinfo SET shipto_cust_id = public.getcustid((new.customer_number)::text), shipto_name = new.name, shipto_salesrep_id = public.getsalesrepid(new.sales_rep), shipto_comments = new.general_notes, shipto_shipcomments = new.shipping_notes, shipto_shipzone_id = public.getshipzoneid(new.zone), shipto_shipvia = new.ship_via, shipto_commission = (new.commission / (100)::numeric), shipto_shipform_id = public.getshipformid(new.ship_form), shipto_shipchrg_id = public.getshipchrgid(new.shipping_charges), shipto_active = new.active, shipto_default = new.default_flag, shipto_num = old.shipto_number, shipto_ediprofile_id = CASE WHEN (new.edi_profile = 'No EDI'::text) THEN (-1) WHEN (new.edi_profile = 'Use Customer Master'::text) THEN (-2) ELSE public.getediprofileid(new.edi_profile) END, shipto_cntct_id = public.savecntct(public.getcntctid(new.contact_number), new.contact_number, NULL::integer, new.honorific, new.first, new.middle, new.last, new.suffix, new.phone, NULL::text, new.fax, new.email, NULL::text, new.job_title, new.contact_change), shipto_addr_id = public.saveaddr(public.getaddrid(new.address_number), new.address_number, new.address1, new.address2, new.address3, new.city, new.state, new.postal_code, new.country, new.address_change), shipto_taxzone_id = public.gettaxzoneid(new.tax_zone) WHERE (shiptoinfo.shipto_id = public.getshiptoid((old.customer_number)::text, (old.shipto_number)::text));


--
-- TOC entry 8822 (class 2618 OID 146572058)
-- Dependencies: 290 290 290 290 285 285 285 1765 1682 290 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO custtax DO INSTEAD UPDATE public.taxreg SET taxreg_number = new.registration_number WHERE (((taxreg.taxreg_rel_type = 'C'::bpchar) AND (taxreg.taxreg_rel_id = public.getcustid((old.customer_number)::text))) AND (taxreg.taxreg_taxauth_id = public.gettaxauthid((old.tax_authority)::text)));


--
-- TOC entry 8823 (class 2618 OID 146572059)
-- Dependencies: 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 294 292 292 2162 2158 1780 1752 1702 1687 1681 1670 1658 907 294 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO employee DO INSTEAD UPDATE public.emp SET emp_code = new.code, emp_number = new.number, emp_active = new.active, emp_startdate = new.start_date, emp_cntct_id = public.savecntct(public.getcntctid(new.contact_number), new.contact_number, public.saveaddr(public.getaddrid(new.address_number), new.address_number, new.address1, new.address2, new.address3, new.city, new.state, new.postalcode, new.country, new.address_change), new.honorific, new.first, new.middle, new.last, new.suffix, new.voice, new.alternate, new.fax, new.email, new.web, new.job_title, new.contact_change), emp_warehous_id = public.getwarehousid(new.site, 'ALL'::text), emp_mgr_emp_id = (SELECT emp.emp_id FROM public.emp WHERE (emp.emp_code = new.manager_code)), emp_wage_type = CASE WHEN (new.wage_type = 'Hourly'::text) THEN 'H'::text WHEN (new.wage_type = 'Salaried'::text) THEN 'S'::text ELSE NULL::text END, emp_wage = new.wage, emp_wage_curr_id = COALESCE(public.getcurrid((new.wage_currency)::text), public.basecurrid()), emp_wage_period = CASE WHEN (new.wage_period = 'Hour'::text) THEN 'H'::text WHEN (new.wage_period = 'Day'::text) THEN 'D'::text WHEN (new.wage_period = 'Week'::text) THEN 'W'::text WHEN (new.wage_period = 'Biweek'::text) THEN 'BW'::text WHEN (new.wage_period = 'Month'::text) THEN 'M'::text WHEN (new.wage_period = 'Year'::text) THEN 'Y'::text ELSE NULL::text END, emp_dept_id = public.getdeptid(new.department), emp_shift_id = public.getshiftid(new.shift), emp_image_id = public.getimageid(new.image), emp_extrate = new.rate, emp_extrate_period = CASE WHEN (new.billing_period = 'Hour'::text) THEN 'H'::text WHEN (new.billing_period = 'Day'::text) THEN 'D'::text WHEN (new.billing_period = 'Week'::text) THEN 'W'::text WHEN (new.billing_period = 'Biweek'::text) THEN 'BW'::text WHEN (new.billing_period = 'Month'::text) THEN 'M'::text WHEN (new.billing_period = 'Year'::text) THEN 'Y'::text ELSE NULL::text END, emp_notes = COALESCE(new.notes, ''::text) WHERE (emp.emp_code = (old.code)::text);


--
-- TOC entry 8824 (class 2618 OID 146572061)
-- Dependencies: 295 295 295 295 237 237 237 1690 1665 295 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO employeechar DO INSTEAD UPDATE public.charass SET charass_value = new.value WHERE (((charass.charass_target_type = 'EMP'::text) AND (charass.charass_target_id = public.getempid((old.employee_code)::text))) AND (charass.charass_char_id = public.getcharid((old.characteristic)::text, 'EMP'::text)));


--
-- TOC entry 8825 (class 2618 OID 146572062)
-- Dependencies: 296 296 296 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO employeecomment DO INSTEAD NOTHING;


--
-- TOC entry 8826 (class 2618 OID 146572063)
-- Dependencies: 298 298 298 298 298 298 298 298 298 298 298 298 298 298 298 297 297 297 297 1681 298 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO extshipmaint DO INSTEAD UPDATE public.shipdata SET shipdata_cohead_number = new.so_number, shipdata_shiphead_number = new.shipment_number, shipdata_void_ind = new.void, shipdata_shipper = new.shipper, shipdata_billing_option = new.billing_option, shipdata_weight = new.weight, shipdata_base_freight = new.base_freight, shipdata_base_freight_curr_id = public.getcurrid((new.base_freight_currency)::text), shipdata_total_freight = new.total_freight, shipdata_total_freight_curr_id = public.getcurrid((new.total_freight_currency)::text), shipdata_package_type = new.package_type, shipdata_cosmisc_tracknum = new.tracking_number, shipdata_cosmisc_packnum_tracknum = new.package_tracking_number, shipdata_lastupdated = new.last_updated WHERE ((((shipdata.shipdata_cohead_number = (old.so_number)::text) AND (shipdata.shipdata_shiphead_number = (old.shipment_number)::text)) AND (shipdata.shipdata_shipper = (old.shipper)::text)) AND (shipdata.shipdata_cosmisc_packnum_tracknum = (old.package_tracking_number)::text));


--
-- TOC entry 8827 (class 2618 OID 146572064)
-- Dependencies: 302 302 302 302 302 302 302 302 302 300 300 300 300 300 300 300 300 1780 1759 1684 1697 302 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO freightpricingscheduleitem DO INSTEAD UPDATE public.ipsfreight SET ipsfreight_ipshead_id = public.getipsheadid((old.pricing_schedule)::text), ipsfreight_qtybreak = new.qty_break, ipsfreight_price = new.price, ipsfreight_type = CASE WHEN (new.price_type = 'Flat Rate'::text) THEN 'F'::text WHEN (new.price_type = 'Price Per UOM'::text) THEN 'P'::text ELSE NULL::text END, ipsfreight_warehous_id = CASE WHEN (new.from_site = 'Any'::text) THEN NULL::integer ELSE public.getwarehousid(new.from_site, 'All'::text) END, ipsfreight_shipzone_id = CASE WHEN (new.to_shipzone = 'Any'::text) THEN NULL::integer ELSE public.getshipzoneid(new.to_shipzone) END, ipsfreight_freightclass_id = CASE WHEN (new.freight_class = 'Any'::text) THEN NULL::integer ELSE public.getfreightclassid(new.freight_class) END, ipsfreight_shipvia = CASE WHEN (new.ship_via = 'Any'::text) THEN NULL::text ELSE new.ship_via END WHERE (((((((((ipsfreight.ipsfreight_ipshead_id = public.getipsheadid((old.pricing_schedule)::text)) AND (ipsfreight.ipsfreight_qtybreak = old.qty_break)) AND (ipsfreight.ipsfreight_price = old.price)) AND ((ipsfreight.ipsfreight_type)::text = CASE WHEN (old.price_type = 'Flat Rate'::text) THEN 'F'::text WHEN (old.price_type = 'Price Per UOM'::text) THEN 'P'::text ELSE NULL::text END)) AND ((ipsfreight.ipsfreight_warehous_id IS NULL) AND (old.from_site = 'Any'::text))) OR ((ipsfreight.ipsfreight_warehous_id = CASE WHEN (old.from_site = 'Any'::text) THEN 0 ELSE public.getwarehousid(old.from_site, 'All'::text) END) AND ((ipsfreight.ipsfreight_shipzone_id IS NULL) AND (old.to_shipzone = 'Any'::text)))) OR ((ipsfreight.ipsfreight_shipzone_id = CASE WHEN (old.to_shipzone = 'Any'::text) THEN 0 ELSE public.getshipzoneid(old.to_shipzone) END) AND ((ipsfreight.ipsfreight_freightclass_id IS NULL) AND (old.freight_class = 'Any'::text)))) OR ((ipsfreight.ipsfreight_freightclass_id = CASE WHEN (old.freight_class = 'Any'::text) THEN 0 ELSE public.getfreightclassid(old.freight_class) END) AND ((ipsfreight.ipsfreight_shipvia IS NULL) AND (old.ship_via = 'Any'::text)))) OR (ipsfreight.ipsfreight_shipvia = old.ship_via));


--
-- TOC entry 8828 (class 2618 OID 146572066)
-- Dependencies: 303 303 303 303 303 303 303 303 303 303 303 262 1701 303 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO glaccount DO INSTEAD UPDATE public.accnt SET accnt_number = new.account_number, accnt_descrip = new.description, accnt_comments = new.notes, accnt_profit = new.profit_center, accnt_sub = new.sub_account, accnt_type = CASE WHEN (new.type = 'Asset'::text) THEN 'A'::text WHEN (new.type = 'Liability'::text) THEN 'L'::text WHEN (new.type = 'Expense'::text) THEN 'E'::text WHEN (new.type = 'Revenue'::text) THEN 'R'::text WHEN (new.type = 'Equity'::text) THEN 'Q'::text ELSE NULL::text END, accnt_extref = new.ext_reference, accnt_company = new.company, accnt_forwardupdate = new.forward_update_trial_balances, accnt_subaccnttype_code = new.sub_type WHERE (accnt.accnt_id = public.getglaccntid((old.company)::text, (old.profit_center)::text, (old.account_number)::text, (old.sub_account)::text));


--
-- TOC entry 8829 (class 2618 OID 146572068)
-- Dependencies: 308 308 308 308 308 308 308 308 308 308 308 308 308 308 308 308 308 308 308 308 308 308 308 308 206 2162 1721 1714 1708 1707 1706 1705 1703 1680 1670 308 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO incident DO INSTEAD UPDATE public.incdt SET incdt_crmacct_id = public.getcrmacctid(new.crm_account), incdt_cntct_id = public.savecntct(public.getcntctid(new.contact_number), new.contact_number, NULL::integer, new.honorific, new.first, new.middle, new.last, new.suffix, new.phone, NULL::text, new.fax, new.email, NULL::text, new.job_title, new.contact_change), incdt_descrip = new.notes, incdt_summary = new.description, incdt_item_id = public.getitemid(new.item_number), incdt_status = CASE WHEN (new.status = 'New'::text) THEN 'N'::text WHEN (new.status = 'Feedback'::text) THEN 'F'::text WHEN (new.status = 'Confirmed'::text) THEN 'C'::text WHEN (new.status = 'Assigned'::text) THEN 'A'::text WHEN (new.status = 'Resolved'::text) THEN 'R'::text WHEN (new.status = 'Closed'::text) THEN 'L'::text ELSE NULL::text END, incdt_assigned_username = new.assigned_to, incdt_incdtcat_id = public.getincdtcatid(new.category), incdt_incdtseverity_id = public.getincdtseverityid(new.severity), incdt_incdtpriority_id = public.getincdtpriorityid(new.priority), incdt_incdtresolution_id = public.getincdtresolutionid(new.resolution), incdt_lotserial = new.lot_serial_number, incdt_ls_id = public.getlotserialid(new.item_number, new.lot_serial_number) WHERE (incdt.incdt_id = public.getincidentid(old.incident_number));


--
-- TOC entry 8830 (class 2618 OID 146572070)
-- Dependencies: 309 309 309 309 237 237 237 1708 1665 309 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO incidentchar DO INSTEAD UPDATE public.charass SET charass_value = new.value WHERE (((charass.charass_target_type = 'INCDT'::text) AND (charass.charass_target_id = public.getincidentid(old.incident_number))) AND (charass.charass_char_id = public.getcharid((old.characteristic)::text, 'INCDT'::text)));


--
-- TOC entry 8831 (class 2618 OID 146572071)
-- Dependencies: 310 310 310 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO incidentcomment DO INSTEAD NOTHING;


--
-- TOC entry 8832 (class 2618 OID 146572072)
-- Dependencies: 311 311 311 311 245 245 245 245 1708 311 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO incidentfile DO INSTEAD UPDATE public.url SET url_title = new.title, url_url = new.url WHERE ((((url.url_source_id = public.getincidentid(old.incident_number)) AND (url.url_source = 'INCDT'::text)) AND (url.url_title = old.title)) AND (url.url_url = old.url));


--
-- TOC entry 8833 (class 2618 OID 146572073)
-- Dependencies: 312 312 312 249 249 249 1708 1702 312 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO incidentimage DO INSTEAD UPDATE public.imageass SET imageass_image_id = public.getimageid(new.image_name) WHERE (((imageass.imageass_source_id = public.getincidentid(old.incident_number)) AND (imageass.imageass_source = 'INCDT'::text)) AND (imageass.imageass_image_id = public.getimageid(old.image_name)));


--
-- TOC entry 8834 (class 2618 OID 146572074)
-- Dependencies: 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 228 224 224 1769 1768 1759 1756 1751 1749 1736 1700 1682 1681 228 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO invoice DO INSTEAD UPDATE public.invchead SET invchead_invcnumber = old.invoice_number, invchead_ordernumber = new.order_number, invchead_invcdate = new.invoice_date, invchead_shipdate = new.ship_date, invchead_orderdate = new.order_date, invchead_salesrep_id = public.getsalesrepid(new.sales_rep), invchead_commission = new.commission, invchead_taxzone_id = public.gettaxzoneid(NULLIF(new.tax_zone, 'None'::text)), invchead_terms_id = public.gettermsid(new.terms), invchead_cust_id = (SELECT public.getcustid(new.customer_number) AS getcustid), invchead_billto_name = new.billto_name, invchead_billto_address1 = new.billto_address1, invchead_billto_address2 = new.billto_address2, invchead_billto_address3 = new.billto_address3, invchead_billto_city = new.billto_city, invchead_billto_state = new.billto_state, invchead_billto_zipcode = new.billto_postal_code, invchead_billto_country = new.billto_country, invchead_billto_phone = new.billto_phone, invchead_shipto_id = COALESCE(public.getshiptoid(new.customer_number, new.shipto_number), (-1)), invchead_shipto_name = new.shipto_name, invchead_shipto_address1 = new.shipto_address1, invchead_shipto_address2 = new.shipto_address2, invchead_shipto_address3 = new.shipto_address3, invchead_shipto_city = new.shipto_city, invchead_shipto_state = new.shipto_state, invchead_shipto_zipcode = new.shipto_postal_code, invchead_shipto_country = new.shipto_country, invchead_shipto_phone = new.shipto_phone, invchead_ponumber = new.po_number, invchead_shipvia = new.ship_via, invchead_prj_id = COALESCE(public.getprjid(new.project_number), (-1)), invchead_fob = new.fob, invchead_misc_descrip = new.misc_charge_description, invchead_misc_amount = new.misc_charge, invchead_misc_accnt_id = COALESCE(public.getglaccntid(new.misc_charge_account_number), (-1)), invchead_freight = new.freight, invchead_curr_id = COALESCE(public.getcurrid((new.currency)::text), (-1)), invchead_payment = new.payment, invchead_notes = new.notes, invchead_saletype_id = public.getsaletypeid(new.sale_type), invchead_shipzone_id = public.getshipzoneid(new.shipto_shipzone) WHERE ((invchead.invchead_invcnumber = old.invoice_number) AND (invchead.invchead_posted = false));


--
-- TOC entry 8835 (class 2618 OID 146572076)
-- Dependencies: 230 230 2291 230 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO invoiceline DO INSTEAD SELECT public.updateinvoicelineitem(new.*, old.*) AS updateinvoicelineitem;


--
-- TOC entry 8836 (class 2618 OID 146572077)
-- Dependencies: 315 315 315 315 315 315 315 315 315 315 315 315 315 315 315 315 315 315 315 315 315 315 315 191 1771 1738 1714 1666 315 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO item DO INSTEAD UPDATE public.item SET item_active = new.active, item_descrip1 = new.description1, item_descrip2 = new.description2, item_type = CASE WHEN (new.item_type = 'Purchased'::text) THEN 'P'::text WHEN (new.item_type = 'Manufactured'::text) THEN 'M'::text WHEN (new.item_type = 'Job'::text) THEN 'J'::text WHEN (new.item_type = 'Kit'::text) THEN 'K'::text WHEN (new.item_type = 'Phantom'::text) THEN 'F'::text WHEN (new.item_type = 'Reference'::text) THEN 'R'::text WHEN (new.item_type = 'Costing'::text) THEN 'S'::text WHEN (new.item_type = 'Tooling'::text) THEN 'T'::text WHEN (new.item_type = 'Outside Process'::text) THEN 'O'::text WHEN (new.item_type = 'Planning'::text) THEN 'L'::text WHEN (new.item_type = 'Breeder'::text) THEN 'B'::text WHEN (new.item_type = 'Co-Product'::text) THEN 'C'::text WHEN (new.item_type = 'By-Product'::text) THEN 'Y'::text ELSE NULL::text END, item_maxcost = new.maximum_desired_cost, item_classcode_id = public.getclasscodeid(new.class_code), item_inv_uom_id = public.getuomid(new.inventory_uom), item_picklist = new.pick_list_item, item_fractional = new.fractional, item_config = new.configured, item_sold = new.item_is_sold, item_prodcat_id = COALESCE(public.getprodcatid(new.product_category), (-1)), item_exclusive = new.exclusive, item_listprice = new.list_price, item_listcost = new.list_cost, item_price_uom_id = public.getuomid(new.list_price_uom), item_upccode = new.upc_code, item_prodweight = new.product_weight, item_packweight = new.packaging_weight, item_comments = new.notes, item_extdescrip = new.ext_description WHERE (item.item_id = public.getitemid((old.item_number)::text));


--
-- TOC entry 8837 (class 2618 OID 146572079)
-- Dependencies: 317 317 317 317 317 317 317 316 316 1714 317 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO itemalias DO INSTEAD UPDATE public.itemalias SET itemalias_number = new.alias_number, itemalias_usedescrip = new.use_description, itemalias_descrip1 = new.description1, itemalias_descrip2 = new.description2, itemalias_comments = new.comments WHERE ((itemalias.itemalias_item_id = public.getitemid((old.item_number)::text)) AND (itemalias.itemalias_number = old.alias_number));


--
-- TOC entry 8838 (class 2618 OID 146572080)
-- Dependencies: 318 318 318 318 318 237 237 237 1714 1665 318 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO itemchar DO INSTEAD UPDATE public.charass SET charass_value = new.value, charass_default = new.is_default WHERE (((charass.charass_target_type = 'I'::text) AND (charass.charass_target_id = public.getitemid((old.item_number)::text))) AND (charass.charass_char_id = public.getcharid((old.characteristic)::text, 'I'::text)));


--
-- TOC entry 8839 (class 2618 OID 146572081)
-- Dependencies: 319 319 319 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO itemcomment DO INSTEAD NOTHING;


--
-- TOC entry 8840 (class 2618 OID 146572082)
-- Dependencies: 322 322 322 322 322 322 2292 1714 1681 1679 322 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO itemcost DO INSTEAD SELECT public.updateitemcost(public.getitemid((new.item_number)::text), public.getcostelemid((new.costing_element)::text), public.getcurrid((new.currency)::text), new.actual_cost, new.post_to_standard) AS updateitemcost;


--
-- TOC entry 8841 (class 2618 OID 146572083)
-- Dependencies: 323 323 323 323 245 245 245 245 1714 323 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO itemfile DO INSTEAD UPDATE public.url SET url_title = new.title, url_url = new.url WHERE ((((url.url_source_id = public.getitemid((old.item_number)::text)) AND (url.url_source = 'I'::text)) AND (url.url_title = old.title)) AND (url.url_url = old.url));


--
-- TOC entry 8842 (class 2618 OID 146572084)
-- Dependencies: 324 324 324 324 2165 1714 1702 324 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO itemimage DO INSTEAD SELECT public.saveimageass('I'::text, public.getitemid((new.item_number)::text), (CASE WHEN (new.purpose = 'Product Description'::text) THEN 'P'::text WHEN (new.purpose = 'Inventory Description'::text) THEN 'I'::text WHEN (new.purpose = 'Engineering Reference'::text) THEN 'E'::text WHEN (new.purpose = 'Miscellaneous'::text) THEN 'M'::text ELSE 'X'::text END)::bpchar, public.getimageid(new.image_name)) AS saveimageass;


--
-- TOC entry 8843 (class 2618 OID 146572085)
-- Dependencies: 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 327 192 1732 1693 1716 1678 327 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO itemsite DO INSTEAD UPDATE public.itemsite SET itemsite_active = new.active, itemsite_dropship = new.dropship, itemsite_posupply = new.po_supplied_at_site, itemsite_createpr = new.create_prs, itemsite_wosupply = new.wo_supplied_at_site, itemsite_createwo = new.create_wos, itemsite_createsopr = new.create_soprs, itemsite_createsopo = new.create_sopos, itemsite_sold = new.sold_from_site, itemsite_soldranking = new.ranking, itemsite_costmethod = CASE WHEN (new.cost_method = 'None'::text) THEN 'N'::text WHEN (new.cost_method = 'Average'::text) THEN 'A'::text WHEN (new.cost_method = 'Standard'::text) THEN 'S'::text WHEN (new.cost_method = 'Job'::text) THEN 'J'::text ELSE NULL::text END, itemsite_controlmethod = CASE WHEN (new.control_method = 'None'::text) THEN 'N'::text WHEN (new.control_method = 'Regular'::text) THEN 'R'::text WHEN (new.control_method = 'Serial #'::text) THEN 'S'::text WHEN (new.control_method = 'Lot #'::text) THEN 'L'::text ELSE NULL::text END, itemsite_perishable = new.perishable, itemsite_plancode_id = public.getplancodeid(new.planner_code), itemsite_costcat_id = public.getcostcatid(new.cost_category), itemsite_loccntrl = new.multiple_location_control, itemsite_location_id = CASE WHEN (new.location = 'N/A'::text) THEN (-1) ELSE public.getlocationid((new.site)::text, new.location) END, itemsite_recvlocation_id = CASE WHEN (new.receive_location = 'N/A'::text) THEN (-1) ELSE public.getlocationid((new.site)::text, new.receive_location) END, itemsite_issuelocation_id = CASE WHEN (new.issue_location = 'N/A'::text) THEN (-1) ELSE public.getlocationid((new.site)::text, new.issue_location) END, itemsite_location_dist = new.auto_distr_location, itemsite_recvlocation_dist = new.auto_distr_receive_location, itemsite_issuelocation_dist = new.auto_distr_issue_location, itemsite_location = new.user_defined_location, itemsite_location_comments = new.user_defined_location, itemsite_disallowblankwip = new.disallow_blank_wip_locations, itemsite_stocked = new.stocked, itemsite_abcclass = new.abc_class, itemsite_autoabcclass = new.allow_automatic_updates, itemsite_cyclecountfreq = new.cycl_cnt_freq, itemsite_eventfence = new.event_fence, itemsite_useparams = new.enforce_order_parameters, itemsite_reorderlevel = new.reorder_level, itemsite_ordertoqty = new.order_up_to, itemsite_minordqty = new.minimum_order, itemsite_maxordqty = new.maximum_order, itemsite_multordqty = new.order_multiple, itemsite_useparamsmanual = new.enforce_on_manual_orders, itemsite_ordergroup = new.group_mps_mrp_orders, itemsite_ordergroup_first = new.first_group, itemsite_mps_timefence = new.mps_time_fence, itemsite_leadtime = new.lead_time, itemsite_safetystock = new.safety_stock, itemsite_supply_itemsite_id = CASE WHEN (new.supplied_from_site = 'None'::text) THEN NULL::integer WHEN (new.supplied_from_site = ''::text) THEN NULL::integer ELSE public.getitemsiteid(new.supplied_from_site, (new.item_number)::text) END, itemsite_notes = new.notes, itemsite_warrpurc = new.require_warranty, itemsite_autoreg = new.auto_register, itemsite_planning_type = CASE WHEN (new.planning_system = 'None'::text) THEN 'N'::text WHEN (new.planning_system = 'MPS'::text) THEN 'S'::text ELSE 'M'::text END WHERE (itemsite.itemsite_id = public.getitemsiteid((old.site)::text, (old.item_number)::text));


--
-- TOC entry 8844 (class 2618 OID 146572087)
-- Dependencies: 328 328 328 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO itemsitecomment DO INSTEAD NOTHING;


--
-- TOC entry 8845 (class 2618 OID 146572088)
-- Dependencies: 331 331 331 331 331 331 331 331 331 331 331 331 331 331 331 331 331 331 331 331 331 330 330 330 330 330 1778 1714 1677 1676 1675 331 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO itemsource DO INSTEAD UPDATE public.itemsrc SET itemsrc_vend_item_number = new.vendor_item_number, itemsrc_vend_item_descrip = new.vendor_description, itemsrc_comments = new.notes, itemsrc_vend_uom = new.vendor_uom, itemsrc_invvendoruomratio = new.inventory_vendor_uom_ratio, itemsrc_minordqty = new.minimum_order, itemsrc_multordqty = new.order_multiple, itemsrc_leadtime = new.lead_time, itemsrc_ranking = new.vendor_ranking, itemsrc_active = new.active, itemsrc_default = new.itemsrc_default, itemsrc_manuf_name = new.manufacturer_name, itemsrc_manuf_item_number = new.manufacturer_item_number, itemsrc_manuf_item_descrip = new.manufacturer_description, itemsrc_upccode = new.bar_code, itemsrc_contrct_id = public.getcontrctid(new.contract_number), itemsrc_effective = COALESCE(public.getcontrcteffective(new.contract_number), new.effective_date), itemsrc_expires = COALESCE(public.getcontrctexpires(new.contract_number), new.expires_date) WHERE (((((itemsrc.itemsrc_item_id = public.getitemid((old.item_number)::text)) AND (itemsrc.itemsrc_vend_id = public.getvendid((old.vendor)::text))) AND (itemsrc.itemsrc_vend_item_number = old.vendor_item_number)) AND (itemsrc.itemsrc_manuf_name = old.manufacturer_name)) AND (itemsrc.itemsrc_manuf_item_number = old.manufacturer_item_number));


--
-- TOC entry 8846 (class 2618 OID 146572090)
-- Dependencies: 333 333 333 333 333 333 333 333 333 333 333 332 332 1780 1718 1681 333 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO itemsourceprice DO INSTEAD UPDATE public.itemsrcp SET itemsrcp_qtybreak = new.qty_break, itemsrcp_price = new.price_per_unit, itemsrcp_updated = now(), itemsrcp_curr_id = public.getcurrid((new.currency)::text), itemsrcp_dropship = COALESCE(new.dropship_only, false), itemsrcp_warehous_id = CASE WHEN (new.pricing_site = 'All'::text) THEN (-1) ELSE COALESCE(public.getwarehousid(new.pricing_site, 'ALL'::text), (-1)) END, itemsrcp_type = CASE WHEN (new.pricing_type = 'Discount'::text) THEN 'D'::text ELSE 'N'::text END, itemsrcp_discntprcnt = (COALESCE(new.discount_percent, 0.0) / 100.0), itemsrcp_fixedamtdiscount = new.discount_fixed_amount WHERE ((itemsrcp.itemsrcp_itemsrc_id = public.getitemsrcid((old.item_number)::text, (new.vendor)::text)) AND (itemsrcp.itemsrcp_qtybreak = old.qty_break));


--
-- TOC entry 8847 (class 2618 OID 146572092)
-- Dependencies: 335 335 335 335 335 334 334 1714 335 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO itemsubstitute DO INSTEAD UPDATE public.itemsub SET itemsub_uomratio = new.sub_parent_uom_ratio, itemsub_rank = new.ranking WHERE ((itemsub.itemsub_parent_item_id = public.getitemid((old.root_item_number)::text)) AND (itemsub.itemsub_sub_item_id = public.getitemid((old.substitute_item_number)::text)));


--
-- TOC entry 8848 (class 2618 OID 146572093)
-- Dependencies: 337 337 337 337 336 336 336 1768 1767 1714 337 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO itemtaxtype DO INSTEAD UPDATE public.itemtax SET itemtax_taxzone_id = CASE WHEN ((new.tax_zone)::text = 'Any'::text) THEN NULL::integer ELSE public.gettaxzoneid((new.tax_zone)::text) END, itemtax_taxtype_id = public.gettaxtypeid(new.tax_type) WHERE (((itemtax.itemtax_item_id = public.getitemid((old.item_number)::text)) AND CASE WHEN ((old.tax_zone)::text = 'Any'::text) THEN (itemtax.itemtax_taxzone_id IS NULL) ELSE (itemtax.itemtax_taxzone_id = public.gettaxzoneid((old.tax_zone)::text)) END) AND (itemtax.itemtax_taxtype_id = public.gettaxtypeid(old.tax_type)));


--
-- TOC entry 8849 (class 2618 OID 146572094)
-- Dependencies: 339 339 339 339 339 339 339 339 191 191 2172 1774 1771 1714 339 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO itemuomconversion DO INSTEAD SELECT public.saveitemuomconv(public.getitemid((new.item_number)::text), COALESCE(public.getuomid((new.uom)::text), (SELECT item.item_inv_uom_id FROM public.item WHERE (item.item_id = public.getitemid((new.item_number)::text)))), COALESCE(new.uom_value, (1)::numeric), COALESCE(public.getuomid(new.per_uom), (SELECT item.item_inv_uom_id FROM public.item WHERE (item.item_id = public.getitemid((new.item_number)::text)))), COALESCE(new.per_uom_value, (1)::numeric), COALESCE(new.fractional, false), public.getuomtypeid(new.selected_types)) AS saveitemuomconv;


--
-- TOC entry 8850 (class 2618 OID 146572095)
-- Dependencies: 341 341 341 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO journalentry DO INSTEAD NOTHING;


--
-- TOC entry 8851 (class 2618 OID 146572096)
-- Dependencies: 344 344 344 344 344 344 344 344 344 344 342 342 1781 1780 344 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO location DO INSTEAD UPDATE public.location SET location_name = new.location, location_descrip = new.description, location_restrict = new.restricted, location_netable = new.netable, location_whsezone_id = public.getwhsezoneid((new.site)::text, new.zone), location_aisle = new.aisle, location_rack = new.rack, location_bin = new.bin WHERE ((location.location_warehous_id = public.getwarehousid((old.site)::text, 'ACTIVE'::text)) AND (location.location_name = (old.location)::text));


--
-- TOC entry 8852 (class 2618 OID 146572097)
-- Dependencies: 345 345 345 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO misccounttag DO INSTEAD NOTHING;


--
-- TOC entry 8853 (class 2618 OID 146572098)
-- Dependencies: 346 349 349 346 346 346 346 346 301 1684 1681 907 346 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO pricingschedule DO INSTEAD UPDATE public.ipshead SET ipshead_descrip = new.description, ipshead_effective = CASE WHEN (new.effective = 'Always'::text) THEN '1970-01-01'::date ELSE (new.effective)::date END, ipshead_expires = CASE WHEN (new.expires = 'Never'::text) THEN '2100-01-01'::date ELSE (new.expires)::date END, ipshead_updated = now(), ipshead_curr_id = CASE WHEN (SELECT (count(ipsiteminfo.ipsitem_id) = 0) FROM public.ipsiteminfo WHERE (ipsiteminfo.ipsitem_ipshead_id = public.getipsheadid((old.name)::text))) THEN COALESCE(public.getcurrid((new.currency)::text), public.basecurrid()) ELSE public.getcurrid((old.currency)::text) END WHERE (ipshead.ipshead_name = (old.name)::text);


--
-- TOC entry 8854 (class 2618 OID 146572100)
-- Dependencies: 348 348 348 348 348 348 348 347 347 347 347 347 347 1756 1684 1686 1682 348 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO pricingscheduleassign DO INSTEAD UPDATE public.ipsass SET ipsass_ipshead_id = public.getipsheadid((new.pricing_schedule)::text), ipsass_cust_id = CASE WHEN ((new.customer_number)::text = 'Any'::text) THEN (-1) ELSE public.getcustid((new.customer_number)::text) END, ipsass_custtype_id = CASE WHEN ((new.customer_type)::text = 'N/A'::text) THEN (-1) ELSE public.getcusttypeid((new.customer_type)::text) END, ipsass_custtype_pattern = new.customer_type_pattern, ipsass_shipto_id = CASE WHEN (((new.customer_number)::text = 'Any'::text) OR ((new.customer_shipto)::text = 'Any'::text)) THEN (-1) ELSE public.getshiptoid((new.customer_number)::text, (new.customer_shipto)::text) END, ipsass_shipto_pattern = new.customer_shipto_pattern WHERE ((((((ipsass.ipsass_ipshead_id = public.getipsheadid((old.pricing_schedule)::text)) AND (ipsass.ipsass_cust_id = CASE WHEN ((old.customer_number)::text = 'Any'::text) THEN (-1) ELSE public.getcustid((old.customer_number)::text) END)) AND (ipsass.ipsass_custtype_id = CASE WHEN ((old.customer_type)::text = 'N/A'::text) THEN (-1) ELSE public.getcusttypeid((old.customer_type)::text) END)) AND (ipsass.ipsass_custtype_pattern = (old.customer_type_pattern)::text)) AND (ipsass.ipsass_shipto_id = CASE WHEN ((old.customer_shipto)::text = 'Any'::text) THEN (-1) ELSE public.getshiptoid((old.customer_number)::text, (old.customer_shipto)::text) END)) AND (ipsass.ipsass_shipto_pattern = (old.customer_shipto_pattern)::text));


--
-- TOC entry 8855 (class 2618 OID 146572102)
-- Dependencies: 350 350 350 350 350 350 350 350 350 350 350 350 2164 2167 1771 1738 1714 1713 1712 1684 350 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO pricingscheduleitem DO INSTEAD SELECT CASE WHEN ((old.type)::text = 'Item'::text) THEN public.saveipsitem(public.getipsitemid((old.pricing_schedule)::text, (old.item_number)::text, old.qty_break, (old.qty_uom)::text, (old.price_uom)::text), public.getipsheadid((new.pricing_schedule)::text), public.getitemid((new.item_number)::text), new.qty_break, new.price, public.getuomid((new.qty_uom)::text), public.getuomid((new.price_uom)::text), new.percent, new.fixedamt, CASE new.pricing_type WHEN 'Nominal'::text THEN 'N'::text WHEN 'Discount'::text THEN 'D'::text WHEN 'Markup'::text THEN 'M'::text ELSE '?'::text END) WHEN ((old.type)::text = 'Product Category'::text) THEN public.saveipsprodcat(public.getipsprodcatid((old.pricing_schedule)::text, (old.product_category)::text, old.qty_break), public.getipsheadid((new.pricing_schedule)::text), public.getprodcatid((new.product_category)::text), new.qty_break, new.percent, new.fixedamt, CASE new.pricing_type WHEN 'Nominal'::text THEN 'N'::text WHEN 'Discount'::text THEN 'D'::text WHEN 'Markup'::text THEN 'M'::text ELSE '?'::text END) ELSE NULL::integer END AS result;


--
-- TOC entry 8856 (class 2618 OID 146572104)
-- Dependencies: 352 352 352 352 352 352 352 352 352 351 351 351 1712 1665 352 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO pricingscheduleitemchar DO INSTEAD UPDATE public.ipsitemchar SET ipsitemchar_price = new.price WHERE (((ipsitemchar.ipsitemchar_ipsitem_id = public.getipsitemid((old.pricing_schedule)::text, (old.item_number)::text, old.qty_break, (old.qty_uom)::text, (old.price_uom)::text)) AND (ipsitemchar.ipsitemchar_char_id = public.getcharid((old.characteristic)::text, 'I'::text))) AND (ipsitemchar.ipsitemchar_value = (old.value)::text));


--
-- TOC entry 8857 (class 2618 OID 146572105)
-- Dependencies: 353 353 353 353 353 353 353 353 353 353 353 353 353 353 225 353 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO project DO INSTEAD UPDATE public.prj SET prj_name = new.name, prj_descrip = new.description, prj_owner_username = new.owner, prj_username = new.assigned_to, prj_so = new.sales_orders, prj_wo = new.work_orders, prj_po = new.purchase_orders, prj_status = CASE WHEN (new.status = 'In-Process'::text) THEN 'O'::text WHEN (new.status = 'Completed'::text) THEN 'C'::text ELSE 'P'::text END, prj_due_date = new.due, prj_assigned_date = new.assigned, prj_start_date = new.started, prj_completed_date = new.completed WHERE (prj.prj_number = old.number);


--
-- TOC entry 8858 (class 2618 OID 146572106)
-- Dependencies: 354 354 354 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO projectcomment DO INSTEAD NOTHING;


--
-- TOC entry 8859 (class 2618 OID 146572107)
-- Dependencies: 357 357 357 357 357 357 357 357 357 356 1780 1768 1749 1739 1670 357 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO prospect DO INSTEAD UPDATE public.prospect SET prospect_number = upper((new.prospect_number)::text), prospect_name = new.prospect_name, prospect_active = new.active, prospect_cntct_id = public.getcntctid(new.contact_number), prospect_taxzone_id = public.gettaxzoneid(new.default_tax_zone), prospect_salesrep_id = public.getsalesrepid(new.sales_rep), prospect_warehous_id = public.getwarehousid(new.site_code, 'ACTIVE'::text), prospect_comments = new.notes WHERE (prospect.prospect_id = public.getprospectid((old.prospect_number)::text));


--
-- TOC entry 8860 (class 2618 OID 146572108)
-- Dependencies: 360 360 360 360 360 360 360 360 360 360 360 360 360 360 360 360 360 198 1742 1736 1734 360 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO purchaseline DO INSTEAD UPDATE public.poitem SET poitem_duedate = new.due_date, poitem_qty_ordered = new.qty_ordered, poitem_unitprice = new.unit_price, poitem_vend_item_number = new.vend_item_number, poitem_vend_item_descrip = new.vendor_description, poitem_manuf_name = new.manufacturer_name, poitem_manuf_item_number = new.manufacturer_item_number, poitem_manuf_item_descrip = new.manufacturer_description, poitem_comments = new.notes, poitem_freight = new.freight, poitem_prj_id = public.getprjid(new.project_number), poitem_bom_rev_id = public.getrevid('BOM'::text, old.item_number, new.bill_of_materials_revision), poitem_boo_rev_id = public.getrevid('BOO'::text, old.item_number, new.bill_of_operations_revision) WHERE (poitem.poitem_id = public.getpoitemid((old.order_number)::text, old.line_number));


--
-- TOC entry 8861 (class 2618 OID 146572110)
-- Dependencies: 361 361 361 361 361 237 237 237 236 236 198 198 198 198 197 197 192 192 191 2281 361 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO purchaselinechar DO INSTEAD SELECT DISTINCT public.updatecharassignment('PI'::text, poitem.poitem_id, charass.charass_char_id, new.value) AS updatecharassignment FROM public.pohead, public.poitem, public.itemsite, public.item, public.charass, public."char" WHERE (((((((((pohead.pohead_number = (old.order_number)::text) AND (pohead.pohead_id = poitem.poitem_pohead_id)) AND (poitem.poitem_linenumber = old.line_number)) AND (poitem.poitem_itemsite_id = itemsite.itemsite_id)) AND (item.item_id = itemsite.itemsite_item_id)) AND (charass.charass_target_type = 'I'::text)) AND (charass.charass_target_id = item.item_id)) AND ("char".char_id = charass.charass_char_id)) AND ("char".char_name = old.characteristic));


--
-- TOC entry 8862 (class 2618 OID 146572112)
-- Dependencies: 362 362 362 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO purchaselinecomment DO INSTEAD NOTHING;


--
-- TOC entry 8863 (class 2618 OID 146572113)
-- Dependencies: 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 365 197 1780 1777 1769 1768 1681 1672 1670 1658 365 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO purchaseorder DO INSTEAD UPDATE public.pohead SET pohead_terms_id = public.gettermsid(new.terms), pohead_taxzone_id = public.gettaxzoneid(new.tax_zone), pohead_warehous_id = public.getwarehousid(new.receiving_site, 'ALL'::text), pohead_agent_username = new.purchasing_agent, pohead_vendaddr_id = CASE WHEN (new.alt_address = 'MAIN'::text) THEN NULL::integer ELSE public.getvendaddrid(old.vendor_number, new.alt_address) END, pohead_fob = new.fob, pohead_shipvia = new.ship_via, pohead_curr_id = public.getcurrid((new.currency)::text), pohead_freight = new.freight, pohead_comments = new.notes, pohead_dropship = new.dropship, pohead_vend_cntct_id = public.getcntctid(new.vend_contact_number), pohead_vend_cntct_honorific = new.vend_cntct_honorific, pohead_vend_cntct_first_name = new.vend_cntct_first_name, pohead_vend_cntct_middle = new.vend_cntct_middle, pohead_vend_cntct_last_name = new.vend_cntct_last_name, pohead_vend_cntct_suffix = new.vend_cntct_suffix, pohead_vend_cntct_phone = new.vend_cntct_phone, pohead_vend_cntct_title = new.vend_cntct_title, pohead_vend_cntct_fax = new.vend_cntct_fax, pohead_vend_cntct_email = new.vend_cntct_email, pohead_vendaddress1 = new.vendaddress1, pohead_vendaddress2 = new.vendaddress2, pohead_vendaddress3 = new.vendaddress3, pohead_vendcity = new.vendcity, pohead_vendstate = new.vendstate, pohead_vendzipcode = new.vendzipcode, pohead_vendcountry = new.vendcountry, pohead_shipto_cntct_id = public.getcntctid(new.shipto_contact_number), pohead_shipto_cntct_honorific = new.shipto_cntct_honorific, pohead_shipto_cntct_first_name = new.shipto_cntct_first_name, pohead_shipto_cntct_middle = new.shipto_cntct_middle, pohead_shipto_cntct_last_name = new.shipto_cntct_last_name, pohead_shipto_cntct_suffix = new.shipto_cntct_suffix, pohead_shipto_cntct_phone = new.shipto_cntct_phone, pohead_shipto_cntct_title = new.shipto_cntct_title, pohead_shipto_cntct_fax = new.shipto_cntct_fax, pohead_shipto_cntct_email = new.shipto_cntct_email, pohead_shiptoaddress_id = public.getaddrid(new.shiptoaddress_number), pohead_shiptoaddress1 = new.shiptoaddress1, pohead_shiptoaddress2 = new.shiptoaddress2, pohead_shiptoaddress3 = new.shiptoaddress3, pohead_shiptocity = new.shiptocity, pohead_shiptostate = new.shiptostate, pohead_shiptozipcode = new.shiptozipcode, pohead_shiptocountry = new.shiptocountry, pohead_cohead_id = public.getcoheadid(new.sales_order_number) WHERE (pohead.pohead_number = (old.order_number)::text);


--
-- TOC entry 8864 (class 2618 OID 146572115)
-- Dependencies: 366 366 366 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO purchaseordercomment DO INSTEAD NOTHING;


--
-- TOC entry 8865 (class 2618 OID 146572116)
-- Dependencies: 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 368 367 1780 1769 1768 1767 1759 1756 1751 1749 1736 1700 1683 1681 368 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO quote DO INSTEAD UPDATE public.quhead SET quhead_number = old.quote_number, quhead_cust_id = public.getcustid(new.customer_number, true), quhead_custponumber = new.cust_po_number, quhead_quotedate = new.quote_date, quhead_warehous_id = public.getwarehousid(new.site, 'SHIPPING'::text), quhead_shipto_id = public.getshiptoid(new.customer_number, new.shipto_number), quhead_shiptoname = new.shipto_name, quhead_shiptoaddress1 = new.shipto_address1, quhead_shiptoaddress2 = new.shipto_address2, quhead_shiptoaddress3 = new.shipto_address3, quhead_salesrep_id = public.getsalesrepid(new.sales_rep), quhead_terms_id = public.gettermsid(new.terms), quhead_fob = new.fob, quhead_shipvia = new.ship_via, quhead_shiptocity = new.shipto_city, quhead_shiptostate = new.shipto_state, quhead_shiptozipcode = new.shipto_postal_code, quhead_freight = new.freight, quhead_misc = new.misc_charge, quhead_ordercomments = new.order_notes, quhead_shipcomments = new.shipping_notes, quhead_shiptophone = new.shipto_phone, quhead_billtoname = new.billto_name, quhead_billtoaddress1 = new.billto_address1, quhead_billtoaddress2 = new.billto_address2, quhead_billtoaddress3 = new.billto_address3, quhead_billtocity = new.billto_city, quhead_billtostate = new.billto_state, quhead_billtozip = new.billto_postal_code, quhead_misc_accnt_id = public.getglaccntid(new.misc_account_number), quhead_misc_descrip = new.misc_charge_description, quhead_commission = new.commission, quhead_packdate = new.pack_date, quhead_prj_id = public.getprjid(new.project_number), quhead_billtocountry = new.billto_country, quhead_shiptocountry = new.shipto_country, quhead_curr_id = public.getcurrid((new.currency)::text), quhead_taxzone_id = public.gettaxzoneid(new.tax_zone), quhead_taxtype_id = public.gettaxtypeid(new.tax_type), quhead_expire = new.expire_date, quhead_saletype_id = public.getsaletypeid(new.sale_type), quhead_shipzone_id = public.getshipzoneid(new.shipto_shipzone) WHERE (quhead.quhead_number = (old.quote_number)::text);


--
-- TOC entry 8866 (class 2618 OID 146572118)
-- Dependencies: 369 369 369 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO quotecomment DO INSTEAD NOTHING;


--
-- TOC entry 8867 (class 2618 OID 146572119)
-- Dependencies: 371 371 371 371 371 371 371 371 371 371 371 371 371 370 370 191 191 1902 1780 1771 1767 1720 371 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO quoteline DO INSTEAD UPDATE public.quitem SET quitem_scheddate = new.scheduled_date, quitem_qtyord = new.qty_ordered, quitem_qty_uom_id = public.getuomid(new.qty_uom), quitem_qty_invuomratio = public.itemuomtouomratio(item.item_id, COALESCE(public.getuomid(new.qty_uom), item.item_inv_uom_id), item.item_inv_uom_id), quitem_price = new.net_unit_price, quitem_price_uom_id = public.getuomid(new.price_uom), quitem_price_invuomratio = public.itemuomtouomratio(item.item_id, COALESCE(public.getuomid(new.price_uom), item.item_inv_uom_id), item.item_inv_uom_id), quitem_memo = new.notes, quitem_createorder = new.create_order, quitem_order_warehous_id = public.getwarehousid(new.supplying_site, 'SHIPPING'::text), quitem_prcost = new.overwrite_po_price, quitem_taxtype_id = public.gettaxtypeid(new.tax_type) FROM public.item WHERE ((quitem.quitem_quhead_id = public.getquoteid(old.quote_number)) AND (quitem.quitem_linenumber = old.line_number));


--
-- TOC entry 8868 (class 2618 OID 146572121)
-- Dependencies: 372 372 372 372 372 370 370 370 370 367 367 237 237 237 236 236 192 192 191 2281 372 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO quotelinechar DO INSTEAD SELECT DISTINCT public.updatecharassignment('QI'::text, quitem.quitem_id, charass.charass_char_id, new.value) AS updatecharassignment FROM public.quhead, public.quitem, public.itemsite, public.item, public.charass, public."char" WHERE (((((((((quhead.quhead_number = old.quote_number) AND (quhead.quhead_id = quitem.quitem_quhead_id)) AND (quitem.quitem_linenumber = old.line_number)) AND (quitem.quitem_itemsite_id = itemsite.itemsite_id)) AND (item.item_id = itemsite.itemsite_item_id)) AND (charass.charass_target_type = 'I'::text)) AND (charass.charass_target_id = item.item_id)) AND ("char".char_id = charass.charass_char_id)) AND ("char".char_name = old.characteristic));


--
-- TOC entry 8869 (class 2618 OID 146572123)
-- Dependencies: 373 373 373 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO quotelinecomment DO INSTEAD NOTHING;


--
-- TOC entry 8870 (class 2618 OID 146572124)
-- Dependencies: 380 380 380 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO saleshistory DO INSTEAD NOTHING;


--
-- TOC entry 8871 (class 2618 OID 146572125)
-- Dependencies: 381 381 381 381 381 237 237 237 236 236 196 196 196 196 195 195 195 195 195 195 192 192 191 2282 1876 1674 381 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO saleslinechar DO INSTEAD SELECT DISTINCT public.updatecharassignment('SI'::text, coitem.coitem_id, charass.charass_char_id, new.value, public.itemcharprice(item.item_id, "char".char_id, new.value, cohead.cohead_cust_id, cohead.cohead_shipto_id, coitem.coitem_qtyord, cohead.cohead_curr_id, cohead.cohead_orderdate)) AS updatecharassignment FROM public.cohead, public.coitem, public.itemsite, public.item, public.charass, public."char" WHERE (((((((((cohead.cohead_number = (old.order_number)::text) AND (cohead.cohead_id = coitem.coitem_cohead_id)) AND (coitem.coitem_id = public.getcoitemid((old.order_number)::text, old.line_number))) AND (coitem.coitem_itemsite_id = itemsite.itemsite_id)) AND (item.item_id = itemsite.itemsite_item_id)) AND (charass.charass_target_type = 'I'::text)) AND (charass.charass_target_id = item.item_id)) AND ("char".char_id = charass.charass_char_id)) AND ("char".char_name = old.characteristic));


--
-- TOC entry 8872 (class 2618 OID 146572127)
-- Dependencies: 382 382 382 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO saleslinecomment DO INSTEAD NOTHING;


--
-- TOC entry 8873 (class 2618 OID 146572128)
-- Dependencies: 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 383 195 1780 1769 1768 1759 1756 1754 1753 1751 1749 1736 1700 1682 1681 1672 1670 1652 383 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO salesorder DO INSTEAD UPDATE public.cohead SET cohead_number = old.order_number, cohead_cust_id = public.getcustid(new.customer_number), cohead_custponumber = new.cust_po_number, cohead_orderdate = new.order_date, cohead_warehous_id = public.getwarehousid(new.site, 'SHIPPING'::text), cohead_shipto_id = public.getshiptoid(new.customer_number, new.shipto_number), cohead_shiptoname = new.shipto_name, cohead_shiptoaddress1 = new.shipto_address1, cohead_shiptoaddress2 = new.shipto_address2, cohead_shiptoaddress3 = new.shipto_address3, cohead_salesrep_id = public.getsalesrepid(new.sales_rep), cohead_terms_id = public.gettermsid(new.terms), cohead_fob = new.fob, cohead_shipvia = new.ship_via, cohead_shiptocity = new.shipto_city, cohead_shiptostate = new.shipto_state, cohead_shiptozipcode = new.shipto_postal_code, cohead_freight = CASE WHEN new.calculate_freight THEN COALESCE((SELECT sum(freightdetail.freightdata_total) AS sum FROM public.freightdetail('SO'::text, public.getcoheadid((old.order_number)::text), public.getcustid(new.customer_number), public.getshiptoid(new.customer_number, new.shipto_number), new.order_date, new.ship_via, public.getcurrid((new.currency)::text)) freightdetail(freightdata_schedule, freightdata_from, freightdata_to, freightdata_shipvia, freightdata_freightclass, freightdata_weight, freightdata_uom, freightdata_price, freightdata_type, freightdata_total, freightdata_currency)), (0)::numeric) ELSE new.freight END, cohead_calcfreight = new.calculate_freight, cohead_misc = new.misc_charge, cohead_ordercomments = new.order_notes, cohead_shipcomments = new.shipping_notes, cohead_shiptophone = new.shipto_phone, cohead_shipchrg_id = public.getshipchrgid(new.shipping_chgs), cohead_shipform_id = public.getshipformid(new.shipping_form), cohead_billtoname = new.billto_name, cohead_billtoaddress1 = new.billto_address1, cohead_billtoaddress2 = new.billto_address2, cohead_billtoaddress3 = new.billto_address3, cohead_billtocity = new.billto_city, cohead_billtostate = new.billto_state, cohead_billtozipcode = new.billto_postal_code, cohead_misc_accnt_id = public.getglaccntid(new.misc_account_number), cohead_misc_descrip = new.misc_charge_description, cohead_commission = new.commission, cohead_holdtype = CASE WHEN (new.hold_type = 'Credit'::text) THEN 'C'::text WHEN (new.hold_type = 'Shipping'::text) THEN 'S'::text WHEN (new.hold_type = 'Packing'::text) THEN 'P'::text ELSE 'N'::text END, cohead_packdate = new.pack_date, cohead_prj_id = public.getprjid(new.project_number), cohead_shipcomplete = new.ship_complete, cohead_billtocountry = new.billto_country, cohead_shiptocountry = new.shipto_country, cohead_curr_id = public.getcurrid((new.currency)::text), cohead_taxzone_id = public.gettaxzoneid(new.tax_zone), cohead_lastupdated = ('now'::text)::timestamp(6) with time zone, cohead_shipto_cntct_id = public.getcntctid(new.shipto_contact_number), cohead_shipto_cntct_honorific = new.shipto_contact_honorific, cohead_shipto_cntct_first_name = new.shipto_contact_first, cohead_shipto_cntct_middle = new.shipto_contact_middle, cohead_shipto_cntct_last_name = new.shipto_contact_last, cohead_shipto_cntct_suffix = new.shipto_contact_suffix, cohead_shipto_cntct_phone = new.shipto_contact_phone, cohead_shipto_cntct_title = new.shipto_contact_title, cohead_shipto_cntct_fax = new.shipto_contact_fax, cohead_shipto_cntct_email = new.shipto_contact_email, cohead_billto_cntct_id = public.getcntctid(new.billto_contact_number), cohead_billto_cntct_honorific = new.billto_contact_name, cohead_billto_cntct_first_name = new.billto_contact_first, cohead_billto_cntct_middle = new.billto_contact_middle, cohead_billto_cntct_last_name = new.billto_contact_last, cohead_billto_cntct_suffix = new.billto_contact_suffix, cohead_billto_cntct_phone = new.billto_contact_phone, cohead_billto_cntct_title = new.billto_contact_title, cohead_billto_cntct_fax = new.billto_contct_fax, cohead_billto_cntct_email = new.billto_contact_email, cohead_saletype_id = public.getsaletypeid(new.sale_type), cohead_shipzone_id = public.getshipzoneid(new.shipto_shipzone) WHERE (cohead.cohead_number = (old.order_number)::text);


--
-- TOC entry 8874 (class 2618 OID 146572130)
-- Dependencies: 384 384 384 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO salesordercomment DO INSTEAD NOTHING;


--
-- TOC entry 8875 (class 2618 OID 146572131)
-- Dependencies: 385 385 385 385 385 385 216 1690 385 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO salesrep DO INSTEAD UPDATE public.salesrep SET salesrep_active = new.active, salesrep_number = new.number, salesrep_name = new.name, salesrep_commission = (new.commission_percent * 0.01), salesrep_emp_id = public.getempid(new.employee) WHERE (salesrep.salesrep_number = (old.number)::text);


--
-- TOC entry 8876 (class 2618 OID 146572132)
-- Dependencies: 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 388 193 2162 2158 1780 1768 1760 1758 1754 1700 1678 1670 1658 388 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO site DO INSTEAD UPDATE public.whsinfo SET warehous_descrip = new.description, warehous_fob = CASE WHEN new.inventory_type THEN new.default_fob ELSE NULL::text END, warehous_active = new.active, warehous_counttag_prefix = CASE WHEN new.inventory_type THEN new.next_count_tag_prefix ELSE NULL::text END, warehous_counttag_number = CASE WHEN new.inventory_type THEN new.next_count_tag_number ELSE NULL::integer END, warehous_bol_prefix = CASE WHEN new.inventory_type THEN new.next_bill_of_lading_prefix ELSE NULL::text END, warehous_bol_number = CASE WHEN new.inventory_type THEN new.next_bill_of_lading_number ELSE NULL::integer END, warehous_shipping = CASE WHEN new.inventory_type THEN new.shipping_site ELSE NULL::boolean END, warehous_useslips = CASE WHEN new.inventory_type THEN new.force_the_use_of_count_slips ELSE NULL::boolean END, warehous_usezones = CASE WHEN new.inventory_type THEN new.force_the_use_of_zones ELSE NULL::boolean END, warehous_aislesize = CASE WHEN new.inventory_type THEN new.aisle_size ELSE NULL::integer END, warehous_aislealpha = CASE WHEN new.inventory_type THEN new.aisle_allow_alpha_characters ELSE NULL::boolean END, warehous_racksize = CASE WHEN new.inventory_type THEN new.rack_size ELSE NULL::integer END, warehous_rackalpha = CASE WHEN new.inventory_type THEN new.rack_allow_alpha_characters ELSE NULL::boolean END, warehous_binsize = CASE WHEN new.inventory_type THEN new.bin_size ELSE NULL::integer END, warehous_binalpha = CASE WHEN new.inventory_type THEN new.bin_allow_alpha_characters ELSE NULL::boolean END, warehous_locationsize = CASE WHEN new.inventory_type THEN new.location_size ELSE NULL::integer END, warehous_locationalpha = CASE WHEN new.inventory_type THEN new.location_allow_alpha_characters ELSE NULL::boolean END, warehous_enforcearbl = CASE WHEN new.inventory_type THEN new.enforce_arbl_naming_convention ELSE NULL::boolean END, warehous_default_accnt_id = public.getglaccntid(new.post_unassigned_transactions_to), warehous_shipping_commission = CASE WHEN new.inventory_type THEN (new.shipping_commission * 0.01) ELSE NULL::numeric END, warehous_cntct_id = public.savecntct(public.getcntctid(new.contact_number), new.contact_number, NULL::integer, new.honorific, new.first, new.middle, new.last, new.suffix, new.phone, NULL::text, new.fax, new.email, NULL::text, new.job_title, new.contact_change), warehous_addr_id = public.saveaddr(public.getaddrid(new.address_number), new.address_number, new.address1, new.address2, new.address3, new.city, new.state, new.postal_code, new.country, new.address_change), warehous_taxzone_id = CASE WHEN new.inventory_type THEN public.gettaxzoneid(new.tax_zone) ELSE NULL::integer END, warehous_transit = CASE WHEN new.inventory_type THEN false WHEN new.transit_type THEN true ELSE NULL::boolean END, warehous_shipform_id = CASE WHEN new.transit_type THEN public.getshipformid(new.default_shipping_form) ELSE NULL::integer END, warehous_shipvia_id = CASE WHEN new.transit_type THEN public.getshipviaid(new.default_ship_via) ELSE NULL::integer END, warehous_shipcomments = CASE WHEN new.transit_type THEN new.shipping_comments ELSE NULL::text END, warehous_costcat_id = CASE WHEN new.transit_type THEN public.getcostcatid(new.default_cost_category) ELSE NULL::integer END, warehous_sitetype_id = public.getsitetypeid(new.type), warehous_sequence = new.scheduling_sequence WHERE (whsinfo.warehous_id = public.getwarehousid((old.code)::text, 'ALL'::text));


--
-- TOC entry 8877 (class 2618 OID 146572134)
-- Dependencies: 389 389 389 389 343 343 1780 389 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO sitezone DO INSTEAD UPDATE public.whsezone SET whsezone_descrip = new.description WHERE ((whsezone.whsezone_warehous_id = public.getwarehousid((old.site)::text, 'ACTIVE'::text)) AND (whsezone.whsezone_name = (old.name)::text));


--
-- TOC entry 8878 (class 2618 OID 146572135)
-- Dependencies: 390 390 390 390 390 390 390 390 390 390 390 390 390 390 390 390 232 232 1736 390 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO task DO INSTEAD UPDATE public.prjtask SET prjtask_name = new.name, prjtask_descrip = new.description, prjtask_owner_username = new.owner, prjtask_username = new.assigned_to, prjtask_hours_budget = new.hours_budgeted, prjtask_hours_actual = new.hours_actual, prjtask_exp_budget = new.expenses_budgeted, prjtask_exp_actual = new.expenses_actual, prjtask_status = CASE WHEN (new.status = 'In-Process'::text) THEN 'O'::text WHEN (new.status = 'Completed'::text) THEN 'C'::text ELSE 'P'::text END, prjtask_due_date = new.due, prjtask_assigned_date = new.assigned, prjtask_start_date = new.started, prjtask_completed_date = new.completed WHERE ((prjtask.prjtask_prj_id = public.getprjid(old.project_number)) AND (prjtask.prjtask_number = old.number));


--
-- TOC entry 8879 (class 2618 OID 146572137)
-- Dependencies: 391 391 391 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO taskcomment DO INSTEAD NOTHING;


--
-- TOC entry 8880 (class 2618 OID 146572138)
-- Dependencies: 392 392 392 392 392 392 392 392 392 392 392 392 392 392 392 392 392 2310 1724 1708 1705 1704 1680 392 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO todo DO INSTEAD SELECT public.updatetodoitem(old.task_number, old.assigned_to, new.task_name, new.description, public.getincidentid(new.incident), COALESCE(public.getincdtcrmacctid(new.incident), public.getcrmacctid(new.account)), public.getopheadid(new.opportunity), CASE WHEN (new.date_started > ''::text) THEN (new.date_started)::date ELSE NULL::date END, CASE WHEN (new.date_due > ''::text) THEN (new.date_due)::date ELSE NULL::date END, (CASE WHEN (new.status = 'Pending Input'::text) THEN 'P'::text WHEN (new.status = 'Deferred'::text) THEN 'D'::text WHEN (new.status = 'Neither'::text) THEN 'N'::text ELSE NULL::text END)::bpchar, CASE WHEN (new.date_assigned > ''::text) THEN (new.date_assigned)::date ELSE NULL::date END, CASE WHEN (new.date_completed > ''::text) THEN (new.date_completed)::date ELSE NULL::date END, public.getincdtpriorityid(new.priority), new.notes, new.active, new.owner) AS updatetodoitem;


--
-- TOC entry 8881 (class 2618 OID 146572140)
-- Dependencies: 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 394 210 2162 2158 1779 1778 1769 1768 1766 1700 1691 1681 1670 1658 394 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO vendor DO INSTEAD UPDATE public.vendinfo SET vend_name = new.vendor_name, vend_active = new.active, vend_po = new.sells_purchase_order_items, vend_comments = new.notes, vend_pocomments = new.po_comments, vend_1099 = new.receives_1099, vend_fobsource = CASE WHEN (new.default_fob IS NULL) THEN NULL::text WHEN (new.default_fob = 'Receiving Site'::text) THEN 'W'::text ELSE 'V'::text END, vend_fob = CASE WHEN (new.default_fob IS NULL) THEN NULL::text WHEN (new.default_fob = 'Receiving Site'::text) THEN ''::text ELSE new.default_fob END, vend_terms_id = public.gettermsid(new.default_terms), vend_shipvia = new.ship_via, vend_vendtype_id = public.getvendtypeid(new.vendor_type), vend_qualified = new.qualified, vend_ediemail = new.po_edi_email, vend_ediemailbody = new.po_edi_emailbody, vend_edisubject = new.po_edi_subject, vend_edifilename = new.po_edi_filename, vend_accntnum = new.account_number, vend_emailpodelivery = new.allow_email_po_delivery, vend_restrictpurch = new.may_only_sell_item_source, vend_edicc = new.po_edi_cc, vend_curr_id = public.getcurrid((new.default_currency)::text), vend_cntct1_id = public.savecntct(public.getcntctid(new.contact1_number), new.contact1_number, NULL::integer, new.contact1_honorific, new.contact1_first, new.contact1_middle, new.contact1_last, new.contact1_suffix, new.contact1_voice, new.contact1_alternate, new.contact1_fax, new.contact1_email, new.contact1_web, new.contact1_job_title, new.contact1_change), vend_cntct2_id = public.savecntct(public.getcntctid(new.contact2_number), new.contact2_number, NULL::integer, new.contact2_honorific, new.contact2_first, new.contact2_middle, new.contact2_last, new.contact2_suffix, new.contact2_voice, new.contact2_alternate, new.contact2_fax, new.contact2_email, new.contact2_web, new.contact2_job_title, new.contact2_change), vend_addr_id = public.saveaddr(public.getaddrid(new.address_number), new.address_number, new.address1, new.address2, new.address3, new.city, new.state, new.postalcode, new.country, new.address_change), vend_match = new.matching_vo_po_amounts, vend_taxzone_id = public.gettaxzoneid(new.default_tax_zone), vend_accnt_id = COALESCE(public.getglaccntid(NULLIF(new.default_dist_gl_account, 'N/A'::text)), (-1)), vend_expcat_id = COALESCE(public.getexpcatid(NULLIF(new.default_dist_expense_category, 'N/A'::text)), (-1)), vend_tax_id = COALESCE(public.gettaxid(NULLIF(new.default_dist_tax_code, 'N/A'::text)), (-1)) WHERE (vendinfo.vend_id = public.getvendid((old.vendor_number)::text));


--
-- TOC entry 8882 (class 2618 OID 146572142)
-- Dependencies: 395 395 395 395 395 395 395 395 395 395 395 395 395 395 395 395 395 395 395 395 395 395 395 395 395 395 395 364 2162 2158 1778 1777 1670 1658 395 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO vendoraddress DO INSTEAD UPDATE public.vendaddrinfo SET vendaddr_vend_id = public.getvendid((new.vendor_number)::text), vendaddr_code = new.vendor_address_number, vendaddr_name = new.vendor_address_name, vendaddr_comments = new.notes, vendaddr_cntct_id = public.savecntct(public.getcntctid(new.contact_number), new.contact_number, public.saveaddr(public.getaddrid(new.address_number), new.address_number, new.address1, new.address2, new.address3, new.city, new.state, new.postalcode, new.country, new.address_change), new.contact_honorific, new.contact_first, new.contact_middle, new.contact_last, new.contact_suffix, new.contact_voice, new.contact_alternate, new.contact_fax, new.contact_email, new.contact_web, new.contact_job_title, new.contact_change), vendaddr_addr_id = public.saveaddr(public.getaddrid(new.address_number), new.address_number, new.address1, new.address2, new.address3, new.city, new.state, new.postalcode, new.country, new.address_change) WHERE (vendaddrinfo.vendaddr_id = public.getvendaddrid((old.vendor_number)::text, (old.vendor_address_number)::text));


--
-- TOC entry 8883 (class 2618 OID 146572144)
-- Dependencies: 396 396 396 393 396 8894
-- Name: _UPDATE; Type: RULE; Schema: api; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO vendortype DO INSTEAD UPDATE public.vendtype SET vendtype_code = new.code, vendtype_descrip = new.description WHERE (vendtype.vendtype_code = (old.code)::text);


SET search_path = public, pg_catalog;

--
-- TOC entry 8884 (class 2618 OID 146572145)
-- Dependencies: 245 245 245 8894
-- Name: _DELETE; Type: RULE; Schema: public; Owner: admin
--

CREATE RULE "_DELETE" AS ON DELETE TO url DO INSTEAD NOTHING;


--
-- TOC entry 8885 (class 2618 OID 146572146)
-- Dependencies: 245 245 245 1397 245 8894
-- Name: _DELETE_FILE; Type: RULE; Schema: public; Owner: admin
--

CREATE RULE "_DELETE_FILE" AS ON DELETE TO url WHERE (old.url_stream IS NOT NULL) DO INSTEAD SELECT deletefile(old.url_id) AS deletefile;


--
-- TOC entry 8886 (class 2618 OID 146572147)
-- Dependencies: 245 245 245 1474 245 8894
-- Name: _DELETE_URL; Type: RULE; Schema: public; Owner: admin
--

CREATE RULE "_DELETE_URL" AS ON DELETE TO url WHERE (old.url_stream IS NULL) DO INSTEAD SELECT deleteurl(old.url_id) AS deleteurl;


--
-- TOC entry 8887 (class 2618 OID 146572148)
-- Dependencies: 245 245 245 8894
-- Name: _INSERT; Type: RULE; Schema: public; Owner: admin
--

CREATE RULE "_INSERT" AS ON INSERT TO url DO INSTEAD NOTHING;


--
-- TOC entry 8888 (class 2618 OID 146572149)
-- Dependencies: 245 245 247 245 245 245 245 245 245 242 1331 245 8894
-- Name: _INSERT_FILE; Type: RULE; Schema: public; Owner: admin
--

CREATE RULE "_INSERT_FILE" AS ON INSERT TO url WHERE (new.url_stream IS NOT NULL) DO INSTEAD INSERT INTO docass (docass_id, docass_source_id, docass_source_type, docass_target_id, docass_target_type, docass_purpose) VALUES (COALESCE((new.url_id)::bigint, nextval('docass_docass_id_seq'::regclass)), new.url_source_id, new.url_source, createfile(new.url_title, new.url_url, new.url_stream), 'FILE'::text, 'S'::bpchar);


--
-- TOC entry 8889 (class 2618 OID 146572150)
-- Dependencies: 245 245 247 245 245 245 245 245 242 1353 245 8894
-- Name: _INSERT_URL; Type: RULE; Schema: public; Owner: admin
--

CREATE RULE "_INSERT_URL" AS ON INSERT TO url WHERE (new.url_stream IS NULL) DO INSTEAD INSERT INTO docass (docass_id, docass_source_id, docass_source_type, docass_target_id, docass_target_type, docass_purpose) VALUES (COALESCE((new.url_id)::bigint, nextval('docass_docass_id_seq'::regclass)), new.url_source_id, new.url_source, createurl(new.url_title, new.url_url), 'URL'::text, 'S'::bpchar);


--
-- TOC entry 8890 (class 2618 OID 146572151)
-- Dependencies: 245 245 245 8894
-- Name: _UPDATE; Type: RULE; Schema: public; Owner: admin
--

CREATE RULE "_UPDATE" AS ON UPDATE TO url DO INSTEAD NOTHING;


--
-- TOC entry 8891 (class 2618 OID 146572152)
-- Dependencies: 245 245 245 245 245 243 242 242 242 245 8894
-- Name: _UPDATE_FILE; Type: RULE; Schema: public; Owner: admin
--

CREATE RULE "_UPDATE_FILE" AS ON UPDATE TO url WHERE (new.url_stream IS NOT NULL) DO INSTEAD UPDATE file SET file_title = new.url_title, file_stream = new.url_stream FROM docass WHERE (((docass.docass_id = old.url_id) AND (docass.docass_target_id = file.file_id)) AND (docass.docass_target_type = 'FILE'::text));


--
-- TOC entry 8892 (class 2618 OID 146572153)
-- Dependencies: 245 245 245 245 245 244 242 242 242 245 8894
-- Name: _UPDATE_URL; Type: RULE; Schema: public; Owner: admin
--

CREATE RULE "_UPDATE_URL" AS ON UPDATE TO url WHERE (new.url_stream IS NULL) DO INSTEAD UPDATE urlinfo SET url_title = new.url_title, url_url = new.url_url FROM docass WHERE (((docass.docass_id = old.url_id) AND (docass.docass_target_id = urlinfo.url_id)) AND (docass.docass_target_type = 'URL'::text));


SET search_path = public, pg_catalog;

--
-- TOC entry 8197 (class 2620 OID 146572181)
-- Dependencies: 234 917 8894
-- Name: addrtrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER addrtrigger BEFORE INSERT OR DELETE OR UPDATE ON addr FOR EACH ROW EXECUTE PROCEDURE _addrtrigger();


--
-- TOC entry 8283 (class 2620 OID 146572182)
-- Dependencies: 424 918 8894
-- Name: alarmbeforetrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER alarmbeforetrigger BEFORE INSERT ON alarm FOR EACH ROW EXECUTE PROCEDURE _alarmbeforetrigger();


--
-- TOC entry 8205 (class 2620 OID 146572192)
-- Dependencies: 258 925 8894
-- Name: bomitemsubtrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER bomitemsubtrigger BEFORE INSERT OR DELETE OR UPDATE ON bomitemsub FOR EACH ROW EXECUTE PROCEDURE _bomitemsubtrigger();



--
-- TOC entry 8214 (class 2620 OID 146572197)
-- Dependencies: 278 931 8894
-- Name: ccardtrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER ccardtrigger BEFORE INSERT OR UPDATE ON ccard FOR EACH ROW EXECUTE PROCEDURE _ccardtrigger();


--
-- TOC entry 8199 (class 2620 OID 146572198)
-- Dependencies: 237 932 8894
-- Name: charasshistorytrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER charasshistorytrigger BEFORE INSERT OR DELETE OR UPDATE ON charass FOR EACH ROW EXECUTE PROCEDURE _charasshistorytrigger();


--
-- TOC entry 8200 (class 2620 OID 146572199)
-- Dependencies: 237 933 8894
-- Name: charasstrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER charasstrigger AFTER INSERT OR UPDATE ON charass FOR EACH ROW EXECUTE PROCEDURE _charasstrigger();



--
-- TOC entry 8287 (class 2620 OID 146572201)
-- Dependencies: 490 935 8894
-- Name: charopttrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER charopttrigger AFTER DELETE OR UPDATE ON charopt FOR EACH ROW EXECUTE PROCEDURE _charopttrigger();



--
-- TOC entry 8179 (class 2620 OID 146572203)
-- Dependencies: 218 939 8894
-- Name: cmheadbeforetrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER cmheadbeforetrigger BEFORE INSERT OR DELETE OR UPDATE ON cmhead FOR EACH ROW EXECUTE PROCEDURE _cmheadbeforetrigger();


--
-- TOC entry 8180 (class 2620 OID 146572204)
-- Dependencies: 218 940 8894
-- Name: cmheadtrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER cmheadtrigger AFTER INSERT OR DELETE OR UPDATE ON cmhead FOR EACH ROW EXECUTE PROCEDURE _cmheadtrigger();




--
-- TOC entry 8133 (class 2620 OID 146572210)
-- Dependencies: 189 949 8894
-- Name: cntsliptrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER cntsliptrigger BEFORE INSERT OR DELETE OR UPDATE ON cntslip FOR EACH ROW EXECUTE PROCEDURE _cntsliptrigger();


--
-- TOC entry 8288 (class 2620 OID 146572211)
-- Dependencies: 513 950 8894
-- Name: cobillbeforetrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER cobillbeforetrigger BEFORE INSERT OR DELETE OR UPDATE ON cobill FOR EACH ROW EXECUTE PROCEDURE _cobillbeforetrigger();


--
-- TOC entry 8289 (class 2620 OID 146572212)
-- Dependencies: 513 951 8894
-- Name: cobilltrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER cobilltrigger AFTER INSERT OR DELETE OR UPDATE ON cobill FOR EACH ROW EXECUTE PROCEDURE _cobilltrigger();


--
-- TOC entry 8290 (class 2620 OID 146572213)
-- Dependencies: 516 936 8894
-- Name: cobmiscbeforetrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER cobmiscbeforetrigger BEFORE INSERT OR DELETE OR UPDATE ON cobmisc FOR EACH ROW EXECUTE PROCEDURE _cobmiscbeforetrigger();


--
-- TOC entry 8291 (class 2620 OID 146572214)
-- Dependencies: 516 937 8894
-- Name: cobmisctrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER cobmisctrigger AFTER INSERT OR DELETE OR UPDATE ON cobmisc FOR EACH ROW EXECUTE PROCEDURE _cobmisctrigger();


--
-- TOC entry 8201 (class 2620 OID 146572215)
-- Dependencies: 240 944 8894
-- Name: commenttrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER commenttrigger AFTER INSERT OR UPDATE ON comment FOR EACH ROW EXECUTE PROCEDURE _commenttrigger();


--
-- TOC entry 8230 (class 2620 OID 146572217)
-- Dependencies: 329 953 8894
-- Name: contrctaftertrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER contrctaftertrigger AFTER UPDATE ON contrct FOR EACH ROW EXECUTE PROCEDURE _contrctaftertrigger();


--
-- TOC entry 8158 (class 2620 OID 146572218)
-- Dependencies: 205 954 8894
-- Name: crmacctaftertrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER crmacctaftertrigger AFTER INSERT OR DELETE OR UPDATE ON crmacct FOR EACH ROW EXECUTE PROCEDURE _crmacctaftertrigger();


--
-- TOC entry 8159 (class 2620 OID 146572219)
-- Dependencies: 205 955 8894
-- Name: crmacctbeforetrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER crmacctbeforetrigger BEFORE INSERT OR DELETE OR UPDATE ON crmacct FOR EACH ROW EXECUTE PROCEDURE _crmacctbeforetrigger();



--
-- TOC entry 8164 (class 2620 OID 146572221)
-- Dependencies: 208 1381 8894
-- Name: curronebase; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER curronebase AFTER INSERT OR UPDATE ON curr_symbol FOR EACH ROW EXECUTE PROCEDURE curronebase();


--
-- TOC entry 8215 (class 2620 OID 146572226)
-- Dependencies: 280 961 8894
-- Name: custtypeafterdeletetrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER custtypeafterdeletetrigger AFTER DELETE ON custtype FOR EACH ROW EXECUTE PROCEDURE _custtypeafterdeletetrigger();


--
-- TOC entry 8216 (class 2620 OID 146572227)
-- Dependencies: 280 962 8894
-- Name: custtypetrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER custtypetrigger BEFORE INSERT OR UPDATE ON custtype FOR EACH ROW EXECUTE PROCEDURE _custtypetrigger();


--
-- TOC entry 8296 (class 2620 OID 146572233)
-- Dependencies: 567 968 8894
-- Name: evntlogafterinserttrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER evntlogafterinserttrigger AFTER INSERT ON evntlog FOR EACH ROW EXECUTE PROCEDURE _evntlogafterinserttrigger();


--
-- TOC entry 8237 (class 2620 OID 146572234)
-- Dependencies: 340 969 8894
-- Name: gltransaltertrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER gltransaltertrigger BEFORE DELETE OR UPDATE ON gltrans FOR EACH ROW EXECUTE PROCEDURE _gltransaltertrigger();


--
-- TOC entry 8238 (class 2620 OID 146572235)
-- Dependencies: 340 970 8894
-- Name: gltransinserttrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER gltransinserttrigger BEFORE INSERT ON gltrans FOR EACH ROW EXECUTE PROCEDURE _gltransinserttrigger();


--
-- TOC entry 8297 (class 2620 OID 146572236)
-- Dependencies: 603 971 8894
-- Name: grpprivtrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER grpprivtrigger BEFORE INSERT OR UPDATE ON grppriv FOR EACH ROW EXECUTE PROCEDURE _grpprivtrigger();


--
-- TOC entry 8203 (class 2620 OID 146572237)
-- Dependencies: 249 972 8894
-- Name: imageasstrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER imageasstrigger AFTER INSERT OR UPDATE ON imageass FOR EACH ROW EXECUTE PROCEDURE _imageasstrigger();


--
-- TOC entry 8298 (class 2620 OID 146572246)
-- Dependencies: 623 1840 8894
-- Name: invhisttrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER invhisttrigger BEFORE INSERT OR UPDATE ON invhist FOR EACH ROW EXECUTE PROCEDURE invhisttrig();


--
-- TOC entry 8244 (class 2620 OID 146572249)
-- Dependencies: 351 984 8894
-- Name: ipsitemcharbeforetrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER ipsitemcharbeforetrigger BEFORE INSERT OR DELETE OR UPDATE ON ipsitemchar FOR EACH ROW EXECUTE PROCEDURE _ipsitemcharbeforetrigger();


--
-- TOC entry 8243 (class 2620 OID 146572250)
-- Dependencies: 349 985 8894
-- Name: ipsiteminfobeforetrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER ipsiteminfobeforetrigger BEFORE INSERT OR DELETE OR UPDATE ON ipsiteminfo FOR EACH ROW EXECUTE PROCEDURE _ipsiteminfobeforetrigger();

--
-- TOC entry 8228 (class 2620 OID 146572252)
-- Dependencies: 321 988 8894
-- Name: itemcostaftertrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER itemcostaftertrigger AFTER INSERT OR UPDATE ON itemcost FOR EACH ROW EXECUTE PROCEDURE _itemcostaftertrigger();


--
-- TOC entry 8229 (class 2620 OID 146572253)
-- Dependencies: 321 989 8894
-- Name: itemcosttrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER itemcosttrigger BEFORE INSERT OR DELETE OR UPDATE ON itemcost FOR EACH ROW EXECUTE PROCEDURE _itemcosttrigger();


--
-- TOC entry 8231 (class 2620 OID 146572256)
-- Dependencies: 330 992 8894
-- Name: itemsrcaftertrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER itemsrcaftertrigger AFTER INSERT OR UPDATE ON itemsrc FOR EACH ROW EXECUTE PROCEDURE _itemsrcaftertrigger();


--
-- TOC entry 8233 (class 2620 OID 146572257)
-- Dependencies: 332 993 8894
-- Name: itemsrcptrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER itemsrcptrigger BEFORE INSERT OR UPDATE ON itemsrcp FOR EACH ROW EXECUTE PROCEDURE _itemsrcptrigger();


--
-- TOC entry 8232 (class 2620 OID 146572258)
-- Dependencies: 330 994 8894
-- Name: itemsrctrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER itemsrctrigger BEFORE INSERT OR UPDATE ON itemsrc FOR EACH ROW EXECUTE PROCEDURE _itemsrctrigger();


--
-- TOC entry 8234 (class 2620 OID 146572259)
-- Dependencies: 334 995 8894
-- Name: itemsubtrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER itemsubtrigger AFTER INSERT OR UPDATE ON itemsub FOR EACH ROW EXECUTE PROCEDURE _itemsubtrigger();


--
-- TOC entry 8235 (class 2620 OID 146572260)
-- Dependencies: 336 996 8894
-- Name: itemtaxtrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER itemtaxtrigger AFTER INSERT OR UPDATE ON itemtax FOR EACH ROW EXECUTE PROCEDURE _itemtaxtrigger();


--
-- TOC entry 8265 (class 2620 OID 146572265)
-- Dependencies: 405 1001 8894
-- Name: metasqlaltertrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER metasqlaltertrigger BEFORE INSERT OR UPDATE ON metasql FOR EACH ROW EXECUTE PROCEDURE _metasqlaltertrigger();


--
-- TOC entry 8266 (class 2620 OID 146572266)
-- Dependencies: 405 1002 8894
-- Name: metasqltrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER metasqltrigger BEFORE INSERT OR UPDATE ON metasql FOR EACH ROW EXECUTE PROCEDURE _metasqltrigger();



--
-- TOC entry 8209 (class 2620 OID 146572270)
-- Dependencies: 264 1007 8894
-- Name: periodaftertrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER periodaftertrigger AFTER INSERT OR DELETE OR UPDATE ON period FOR EACH STATEMENT EXECUTE PROCEDURE _periodaftertrigger();


--
-- TOC entry 8302 (class 2620 OID 146572287)
-- Dependencies: 728 1045 8894
-- Name: prtrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER prtrigger AFTER INSERT ON pr FOR EACH ROW EXECUTE PROCEDURE _prtrigger();


--
-- TOC entry 8273 (class 2620 OID 146572293)
-- Dependencies: 411 1052 8894
-- Name: reporttrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER reporttrigger BEFORE INSERT OR UPDATE ON report FOR EACH ROW EXECUTE PROCEDURE _reporttrigger();


--
-- TOC entry 8305 (class 2620 OID 146572298)
-- Dependencies: 771 1059 8894
-- Name: shipdatasumtrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER shipdatasumtrigger BEFORE INSERT OR UPDATE ON shipdatasum FOR EACH ROW EXECUTE PROCEDURE _shipdatasumtrigger();


--
-- TOC entry 8226 (class 2620 OID 146572299)
-- Dependencies: 297 1060 8894
-- Name: shipdatatrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER shipdatatrigger BEFORE INSERT OR UPDATE ON shipdata FOR EACH ROW EXECUTE PROCEDURE _shipdatatrigger();


--
-- TOC entry 8217 (class 2620 OID 146572300)
-- Dependencies: 282 1061 8894
-- Name: shipformafterdeletetrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER shipformafterdeletetrigger AFTER DELETE ON shipform FOR EACH ROW EXECUTE PROCEDURE _shipformafterdeletetrigger();


--
-- TOC entry 8255 (class 2620 OID 146572303)
-- Dependencies: 386 1064 8894
-- Name: shipviaafterdeletetrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER shipviaafterdeletetrigger AFTER DELETE ON shipvia FOR EACH ROW EXECUTE PROCEDURE _shipviaafterdeletetrigger();


--
-- TOC entry 8306 (class 2620 OID 146572304)
-- Dependencies: 781 1065 8894
-- Name: sltransaltertrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER sltransaltertrigger BEFORE DELETE OR UPDATE ON sltrans FOR EACH ROW EXECUTE PROCEDURE _sltransaltertrigger();


--
-- TOC entry 8307 (class 2620 OID 146572305)
-- Dependencies: 781 1047 8894
-- Name: sltransinserttrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER sltransinserttrigger BEFORE INSERT ON sltrans FOR EACH ROW EXECUTE PROCEDURE _sltransinserttrigger();


--
-- TOC entry 8165 (class 2620 OID 146572317)
-- Dependencies: 209 1037 8894
-- Name: termsafterdeletetrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER termsafterdeletetrigger AFTER DELETE ON terms FOR EACH ROW EXECUTE PROCEDURE _termsafterdeletetrigger();


--
-- TOC entry 8196 (class 2620 OID 146572318)
-- Dependencies: 233 1076 8894
-- Name: todoitemtrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER todoitemtrigger BEFORE DELETE ON todoitem FOR EACH ROW EXECUTE PROCEDURE _todoitemtrigger();


--
-- TOC entry 8308 (class 2620 OID 146572319)
-- Dependencies: 820 1077 8894
-- Name: uomconvupdate; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER uomconvupdate BEFORE UPDATE ON uomconv FOR EACH ROW EXECUTE PROCEDURE _uomconvupdate();


--
-- TOC entry 8309 (class 2620 OID 146572320)
-- Dependencies: 825 1078 8894
-- Name: usrprefaftertrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER usrprefaftertrigger AFTER INSERT OR DELETE OR UPDATE ON usrpref FOR EACH ROW EXECUTE PROCEDURE _usrprefaftertrigger();


--
-- TOC entry 8310 (class 2620 OID 146572321)
-- Dependencies: 825 1079 8894
-- Name: usrprefbeforetrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER usrprefbeforetrigger BEFORE INSERT OR DELETE OR UPDATE ON usrpref FOR EACH ROW EXECUTE PROCEDURE _usrprefbeforetrigger();


--
-- TOC entry 8303 (class 2620 OID 146572322)
-- Dependencies: 733 1080 8894
-- Name: usrprivtrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER usrprivtrigger BEFORE INSERT OR UPDATE ON usrpriv FOR EACH ROW EXECUTE PROCEDURE _usrprivtrigger();


--
-- TOC entry 8250 (class 2620 OID 146572323)
-- Dependencies: 364 1082 8894
-- Name: vendaddrtrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER vendaddrtrigger BEFORE INSERT OR DELETE OR UPDATE ON vendaddrinfo FOR EACH ROW EXECUTE PROCEDURE _vendaddrtrigger();


--
-- TOC entry 8315 (class 2620 OID 146572332)
-- Dependencies: 842 1091 8894
-- Name: voitemaftertrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER voitemaftertrigger AFTER INSERT OR DELETE OR UPDATE ON voitem FOR EACH ROW EXECUTE PROCEDURE _voitemaftertrigger();


--
-- TOC entry 8316 (class 2620 OID 146572333)
-- Dependencies: 842 1092 8894
-- Name: voitembeforetrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER voitembeforetrigger BEFORE INSERT OR DELETE OR UPDATE ON voitem FOR EACH ROW EXECUTE PROCEDURE _voitembeforetrigger();



--
-- TOC entry 8241 (class 2620 OID 146572335)
-- Dependencies: 343 1094 8894
-- Name: whsezonetrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER whsezonetrigger BEFORE INSERT OR UPDATE ON whsezone FOR EACH ROW EXECUTE PROCEDURE _whsezonetrigger();


--
-- TOC entry 8249 (class 2620 OID 146572336)
-- Dependencies: 359 1095 8894
-- Name: womatlaftertrigger; Type: TRIGGER; Schema: public; Owner: admin
--

CREATE TRIGGER womatlaftertrigger AFTER INSERT OR DELETE OR UPDATE ON womatl FOR EACH ROW EXECUTE PROCEDURE _womatlaftertrigger();


SET search_path = public, pg_catalog;


--
-- TOC entry 7979 (class 2606 OID 146572419)
-- Dependencies: 6834 208 434 8894
-- Name: apcreditapply_curr_symbol; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY apcreditapply
    ADD CONSTRAINT apcreditapply_curr_symbol FOREIGN KEY (apcreditapply_curr_id) REFERENCES curr_symbol(curr_id);



--
-- TOC entry 7980 (class 2606 OID 146572434)
-- Dependencies: 7124 363 438 8894
-- Name: apopentax_taxhist_basis_tax_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY apopentax
    ADD CONSTRAINT apopentax_taxhist_basis_tax_id_fkey FOREIGN KEY (taxhist_basis_tax_id) REFERENCES tax(tax_id);


--
-- TOC entry 7981 (class 2606 OID 146572439)
-- Dependencies: 6828 207 438 8894
-- Name: apopentax_taxhist_parent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY apopentax
    ADD CONSTRAINT apopentax_taxhist_parent_id_fkey FOREIGN KEY (taxhist_parent_id) REFERENCES apopen(apopen_id) ON DELETE CASCADE;


--
-- TOC entry 7982 (class 2606 OID 146572444)
-- Dependencies: 7124 363 438 8894
-- Name: apopentax_taxhist_tax_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY apopentax
    ADD CONSTRAINT apopentax_taxhist_tax_id_fkey FOREIGN KEY (taxhist_tax_id) REFERENCES tax(tax_id);


--
-- TOC entry 7983 (class 2606 OID 146572449)
-- Dependencies: 6796 199 438 8894
-- Name: apopentax_taxhist_taxtype_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY apopentax
    ADD CONSTRAINT apopentax_taxhist_taxtype_id_fkey FOREIGN KEY (taxhist_taxtype_id) REFERENCES taxtype(taxtype_id);


--
-- TOC entry 7984 (class 2606 OID 146572454)
-- Dependencies: 6834 208 439 8894
-- Name: apselect_to_curr_symbol; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY apselect
    ADD CONSTRAINT apselect_to_curr_symbol FOREIGN KEY (apselect_curr_id) REFERENCES curr_symbol(curr_id);



--
-- TOC entry 7986 (class 2606 OID 146572464)
-- Dependencies: 6834 208 446 8894
-- Name: arcreditapply_curr_symbol; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY arcreditapply
    ADD CONSTRAINT arcreditapply_curr_symbol FOREIGN KEY (arcreditapply_curr_id) REFERENCES curr_symbol(curr_id);


--
-- TOC entry 7987 (class 2606 OID 146572484)
-- Dependencies: 7124 363 450 8894
-- Name: aropentax_taxhist_basis_tax_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY aropentax
    ADD CONSTRAINT aropentax_taxhist_basis_tax_id_fkey FOREIGN KEY (taxhist_basis_tax_id) REFERENCES tax(tax_id);


--
-- TOC entry 7988 (class 2606 OID 146572489)
-- Dependencies: 6849 212 450 8894
-- Name: aropentax_taxhist_parent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY aropentax
    ADD CONSTRAINT aropentax_taxhist_parent_id_fkey FOREIGN KEY (taxhist_parent_id) REFERENCES aropen(aropen_id) ON DELETE CASCADE;


--
-- TOC entry 7989 (class 2606 OID 146572494)
-- Dependencies: 7124 363 450 8894
-- Name: aropentax_taxhist_tax_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY aropentax
    ADD CONSTRAINT aropentax_taxhist_tax_id_fkey FOREIGN KEY (taxhist_tax_id) REFERENCES tax(tax_id);


--
-- TOC entry 7990 (class 2606 OID 146572499)
-- Dependencies: 6796 199 450 8894
-- Name: aropentax_taxhist_taxtype_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY aropentax
    ADD CONSTRAINT aropentax_taxhist_taxtype_id_fkey FOREIGN KEY (taxhist_taxtype_id) REFERENCES taxtype(taxtype_id);


--
-- TOC entry 7994 (class 2606 OID 146572519)
-- Dependencies: 7124 363 453 8894
-- Name: asohisttax_taxhist_basis_tax_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY asohisttax
    ADD CONSTRAINT asohisttax_taxhist_basis_tax_id_fkey FOREIGN KEY (taxhist_basis_tax_id) REFERENCES tax(tax_id);


--
-- TOC entry 7995 (class 2606 OID 146572524)
-- Dependencies: 7229 451 453 8894
-- Name: asohisttax_taxhist_parent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY asohisttax
    ADD CONSTRAINT asohisttax_taxhist_parent_id_fkey FOREIGN KEY (taxhist_parent_id) REFERENCES asohist(asohist_id) ON DELETE CASCADE;


--
-- TOC entry 7996 (class 2606 OID 146572529)
-- Dependencies: 7124 363 453 8894
-- Name: asohisttax_taxhist_tax_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY asohisttax
    ADD CONSTRAINT asohisttax_taxhist_tax_id_fkey FOREIGN KEY (taxhist_tax_id) REFERENCES tax(tax_id);


--
-- TOC entry 7997 (class 2606 OID 146572534)
-- Dependencies: 6796 199 453 8894
-- Name: asohisttax_taxhist_taxtype_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY asohisttax
    ADD CONSTRAINT asohisttax_taxhist_taxtype_id_fkey FOREIGN KEY (taxhist_taxtype_id) REFERENCES taxtype(taxtype_id);



--
-- TOC entry 7998 (class 2606 OID 146572544)
-- Dependencies: 6834 208 458 8894
-- Name: bankadj_to_curr_symbol; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY bankadj
    ADD CONSTRAINT bankadj_to_curr_symbol FOREIGN KEY (bankadj_curr_id) REFERENCES curr_symbol(curr_id);





--
-- TOC entry 7999 (class 2606 OID 146572574)
-- Dependencies: 6810 203 468 8894
-- Name: bomitemcost_bomitemcost_bomitem_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY bomitemcost
    ADD CONSTRAINT bomitemcost_bomitemcost_bomitem_id_fkey FOREIGN KEY (bomitemcost_bomitem_id) REFERENCES bomitem(bomitem_id);


--
-- TOC entry 8000 (class 2606 OID 146572579)
-- Dependencies: 7049 320 468 8894
-- Name: bomitemcost_bomitemcost_costelem_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY bomitemcost
    ADD CONSTRAINT bomitemcost_bomitemcost_costelem_id_fkey FOREIGN KEY (bomitemcost_costelem_id) REFERENCES costelem(costelem_id);


--
-- TOC entry 8001 (class 2606 OID 146572584)
-- Dependencies: 6834 208 468 8894
-- Name: bomitemcost_bomitemcost_curr_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY bomitemcost
    ADD CONSTRAINT bomitemcost_bomitemcost_curr_id_fkey FOREIGN KEY (bomitemcost_curr_id) REFERENCES curr_symbol(curr_id);


--
-- TOC entry 7861 (class 2606 OID 146572589)
-- Dependencies: 6810 203 258 8894
-- Name: bomitemsub_bomitemsub_bomitem_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY bomitemsub
    ADD CONSTRAINT bomitemsub_bomitemsub_bomitem_id_fkey FOREIGN KEY (bomitemsub_bomitem_id) REFERENCES bomitem(bomitem_id) ON UPDATE RESTRICT ON DELETE CASCADE;


--
-- TOC entry 7862 (class 2606 OID 146572594)
-- Dependencies: 6751 191 258 8894
-- Name: bomitemsub_bomitemsub_item_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY bomitemsub
    ADD CONSTRAINT bomitemsub_bomitemsub_item_id_fkey FOREIGN KEY (bomitemsub_item_id) REFERENCES item(item_id) ON UPDATE RESTRICT ON DELETE CASCADE;


--
-- TOC entry 8002 (class 2606 OID 146572599)
-- Dependencies: 6924 236 471 8894
-- Name: bomwork_bomwork_char_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY bomwork
    ADD CONSTRAINT bomwork_bomwork_char_id_fkey FOREIGN KEY (bomwork_char_id) REFERENCES "char"(char_id);


--
-- TOC entry 7865 (class 2606 OID 146572604)
-- Dependencies: 6952 260 263 8894
-- Name: budgitem_budgitem_budghead_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY budgitem
    ADD CONSTRAINT budgitem_budgitem_budghead_id_fkey FOREIGN KEY (budgitem_budghead_id) REFERENCES budghead(budghead_id);


--
-- TOC entry 7866 (class 2606 OID 146572609)
-- Dependencies: 6959 264 263 8894
-- Name: budgitem_budgitem_period_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY budgitem
    ADD CONSTRAINT budgitem_budgitem_period_id_fkey FOREIGN KEY (budgitem_period_id) REFERENCES period(period_id);


--
-- TOC entry 7868 (class 2606 OID 146572614)
-- Dependencies: 6963 266 267 8894
-- Name: cashrcpt_bankaccnt_bankaccnt_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cashrcpt
    ADD CONSTRAINT cashrcpt_bankaccnt_bankaccnt_id_fkey FOREIGN KEY (cashrcpt_bankaccnt_id) REFERENCES bankaccnt(bankaccnt_id);


--
-- TOC entry 7869 (class 2606 OID 146572619)
-- Dependencies: 6853 213 267 8894
-- Name: cashrcpt_cust_cust_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cashrcpt
    ADD CONSTRAINT cashrcpt_cust_cust_id_fkey FOREIGN KEY (cashrcpt_cust_id) REFERENCES custinfo(cust_id);


--
-- TOC entry 7870 (class 2606 OID 146572624)
-- Dependencies: 6834 208 267 8894
-- Name: cashrcpt_to_curr_symbol; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cashrcpt
    ADD CONSTRAINT cashrcpt_to_curr_symbol FOREIGN KEY (cashrcpt_curr_id) REFERENCES curr_symbol(curr_id);




--
-- TOC entry 7875 (class 2606 OID 146572649)
-- Dependencies: 6853 213 278 8894
-- Name: ccard_ccard_cust_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY ccard
    ADD CONSTRAINT ccard_ccard_cust_id_fkey FOREIGN KEY (ccard_cust_id) REFERENCES custinfo(cust_id);



--
-- TOC entry 8004 (class 2606 OID 146572659)
-- Dependencies: 6924 236 490 8894
-- Name: charopt_charopt_char_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY charopt
    ADD CONSTRAINT charopt_charopt_char_id_fkey FOREIGN KEY (charopt_char_id) REFERENCES "char"(char_id) ON DELETE CASCADE;



--
-- TOC entry 7975 (class 2606 OID 146572679)
-- Dependencies: 6828 207 432 8894
-- Name: checkitem_checkitem_apopen_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY checkitem
    ADD CONSTRAINT checkitem_checkitem_apopen_id_fkey FOREIGN KEY (checkitem_apopen_id) REFERENCES apopen(apopen_id);


--
-- TOC entry 7976 (class 2606 OID 146572684)
-- Dependencies: 6849 212 432 8894
-- Name: checkitem_checkitem_aropen_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY checkitem
    ADD CONSTRAINT checkitem_checkitem_aropen_id_fkey FOREIGN KEY (checkitem_aropen_id) REFERENCES aropen(aropen_id);


--
-- TOC entry 7977 (class 2606 OID 146572689)
-- Dependencies: 7204 430 432 8894
-- Name: checkitem_checkitem_checkhead_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY checkitem
    ADD CONSTRAINT checkitem_checkitem_checkhead_id_fkey FOREIGN KEY (checkitem_checkhead_id) REFERENCES checkhead(checkhead_id);


--
-- TOC entry 7978 (class 2606 OID 146572694)
-- Dependencies: 6834 208 432 8894
-- Name: checkitem_checkitem_curr_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY checkitem
    ADD CONSTRAINT checkitem_checkitem_curr_id_fkey FOREIGN KEY (checkitem_curr_id) REFERENCES curr_symbol(curr_id);


--
-- TOC entry 7967 (class 2606 OID 146572699)
-- Dependencies: 7162 397 400 8894
-- Name: cmdarg_cmdarg_cmd_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cmdarg
    ADD CONSTRAINT cmdarg_cmdarg_cmd_id_fkey FOREIGN KEY (cmdarg_cmd_id) REFERENCES cmd(cmd_id) ON DELETE CASCADE;


--
-- TOC entry 7813 (class 2606 OID 146572704)
-- Dependencies: 6853 213 218 8894
-- Name: cmhead_cmhead_cust_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cmhead
    ADD CONSTRAINT cmhead_cmhead_cust_id_fkey FOREIGN KEY (cmhead_cust_id) REFERENCES custinfo(cust_id);


--
-- TOC entry 7814 (class 2606 OID 146572709)
-- Dependencies: 6796 199 218 8894
-- Name: cmhead_cmhead_freighttaxtype_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cmhead
    ADD CONSTRAINT cmhead_cmhead_freighttaxtype_id_fkey FOREIGN KEY (cmhead_freighttaxtype_id) REFERENCES taxtype(taxtype_id);


--
-- TOC entry 7815 (class 2606 OID 146572714)
-- Dependencies: 6891 225 218 8894
-- Name: cmhead_cmhead_prj_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cmhead
    ADD CONSTRAINT cmhead_cmhead_prj_id_fkey FOREIGN KEY (cmhead_prj_id) REFERENCES prj(prj_id);


--
-- TOC entry 7816 (class 2606 OID 146572719)
-- Dependencies: 6865 216 218 8894
-- Name: cmhead_cmhead_salesrep_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cmhead
    ADD CONSTRAINT cmhead_cmhead_salesrep_id_fkey FOREIGN KEY (cmhead_salesrep_id) REFERENCES salesrep(salesrep_id);


--
-- TOC entry 7817 (class 2606 OID 146572724)
-- Dependencies: 6895 226 218 8894
-- Name: cmhead_cmhead_saletype_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cmhead
    ADD CONSTRAINT cmhead_cmhead_saletype_id_fkey FOREIGN KEY (cmhead_saletype_id) REFERENCES saletype(saletype_id);


--
-- TOC entry 7818 (class 2606 OID 146572729)
-- Dependencies: 6897 227 218 8894
-- Name: cmhead_cmhead_shipzone_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cmhead
    ADD CONSTRAINT cmhead_cmhead_shipzone_id_fkey FOREIGN KEY (cmhead_shipzone_id) REFERENCES shipzone(shipzone_id);


--
-- TOC entry 7819 (class 2606 OID 146572734)
-- Dependencies: 6878 220 218 8894
-- Name: cmhead_cmhead_taxzone_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cmhead
    ADD CONSTRAINT cmhead_cmhead_taxzone_id_fkey FOREIGN KEY (cmhead_taxzone_id) REFERENCES taxzone(taxzone_id);


--
-- TOC entry 7820 (class 2606 OID 146572739)
-- Dependencies: 6834 208 218 8894
-- Name: cmhead_to_curr_symbol; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cmhead
    ADD CONSTRAINT cmhead_to_curr_symbol FOREIGN KEY (cmhead_curr_id) REFERENCES curr_symbol(curr_id);


--
-- TOC entry 8005 (class 2606 OID 146572744)
-- Dependencies: 7124 363 497 8894
-- Name: cmheadtax_taxhist_basis_tax_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cmheadtax
    ADD CONSTRAINT cmheadtax_taxhist_basis_tax_id_fkey FOREIGN KEY (taxhist_basis_tax_id) REFERENCES tax(tax_id);


--
-- TOC entry 8006 (class 2606 OID 146572749)
-- Dependencies: 6872 218 497 8894
-- Name: cmheadtax_taxhist_parent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cmheadtax
    ADD CONSTRAINT cmheadtax_taxhist_parent_id_fkey FOREIGN KEY (taxhist_parent_id) REFERENCES cmhead(cmhead_id) ON DELETE CASCADE;


--
-- TOC entry 8007 (class 2606 OID 146572754)
-- Dependencies: 7124 363 497 8894
-- Name: cmheadtax_taxhist_tax_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cmheadtax
    ADD CONSTRAINT cmheadtax_taxhist_tax_id_fkey FOREIGN KEY (taxhist_tax_id) REFERENCES tax(tax_id);


--
-- TOC entry 8008 (class 2606 OID 146572759)
-- Dependencies: 6796 199 497 8894
-- Name: cmheadtax_taxhist_taxtype_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cmheadtax
    ADD CONSTRAINT cmheadtax_taxhist_taxtype_id_fkey FOREIGN KEY (taxhist_taxtype_id) REFERENCES taxtype(taxtype_id);



--
-- TOC entry 8009 (class 2606 OID 146572784)
-- Dependencies: 7124 363 499 8894
-- Name: cmitemtax_taxhist_basis_tax_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cmitemtax
    ADD CONSTRAINT cmitemtax_taxhist_basis_tax_id_fkey FOREIGN KEY (taxhist_basis_tax_id) REFERENCES tax(tax_id);


--
-- TOC entry 8010 (class 2606 OID 146572789)
-- Dependencies: 6884 222 499 8894
-- Name: cmitemtax_taxhist_parent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cmitemtax
    ADD CONSTRAINT cmitemtax_taxhist_parent_id_fkey FOREIGN KEY (taxhist_parent_id) REFERENCES cmitem(cmitem_id) ON DELETE CASCADE;


--
-- TOC entry 8011 (class 2606 OID 146572794)
-- Dependencies: 7124 363 499 8894
-- Name: cmitemtax_taxhist_tax_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cmitemtax
    ADD CONSTRAINT cmitemtax_taxhist_tax_id_fkey FOREIGN KEY (taxhist_tax_id) REFERENCES tax(tax_id);


--
-- TOC entry 8012 (class 2606 OID 146572799)
-- Dependencies: 6796 199 499 8894
-- Name: cmitemtax_taxhist_taxtype_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cmitemtax
    ADD CONSTRAINT cmitemtax_taxhist_taxtype_id_fkey FOREIGN KEY (taxhist_taxtype_id) REFERENCES taxtype(taxtype_id);



--
-- TOC entry 8013 (class 2606 OID 146572814)
-- Dependencies: 6920 234 504 8894
-- Name: cntctaddr_cntctaddr_addr_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cntctaddr
    ADD CONSTRAINT cntctaddr_cntctaddr_addr_id_fkey FOREIGN KEY (cntctaddr_addr_id) REFERENCES addr(addr_id);


--
-- TOC entry 8014 (class 2606 OID 146572819)
-- Dependencies: 6816 204 504 8894
-- Name: cntctaddr_cntctaddr_cntct_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cntctaddr
    ADD CONSTRAINT cntctaddr_cntctaddr_cntct_id_fkey FOREIGN KEY (cntctaddr_cntct_id) REFERENCES cntct(cntct_id) ON DELETE CASCADE;


--
-- TOC entry 8015 (class 2606 OID 146572824)
-- Dependencies: 6816 204 506 8894
-- Name: cntctdata_cntctdata_cntct_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cntctdata
    ADD CONSTRAINT cntctdata_cntctdata_cntct_id_fkey FOREIGN KEY (cntctdata_cntct_id) REFERENCES cntct(cntct_id) ON DELETE CASCADE;


--
-- TOC entry 8016 (class 2606 OID 146572829)
-- Dependencies: 6816 204 508 8894
-- Name: cntcteml_cntcteml_cntct_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cntcteml
    ADD CONSTRAINT cntcteml_cntcteml_cntct_id_fkey FOREIGN KEY (cntcteml_cntct_id) REFERENCES cntct(cntct_id) ON DELETE CASCADE;


--
-- TOC entry 8017 (class 2606 OID 146572834)
-- Dependencies: 6816 204 510 8894
-- Name: cntctmrgd_cntctmrgd_cntct_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cntctmrgd
    ADD CONSTRAINT cntctmrgd_cntctmrgd_cntct_id_fkey FOREIGN KEY (cntctmrgd_cntct_id) REFERENCES cntct(cntct_id) ON DELETE CASCADE;


--
-- TOC entry 8018 (class 2606 OID 146572839)
-- Dependencies: 6816 204 511 8894
-- Name: cntctsel_cntctsel_cntct_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cntctsel
    ADD CONSTRAINT cntctsel_cntctsel_cntct_id_fkey FOREIGN KEY (cntctsel_cntct_id) REFERENCES cntct(cntct_id) ON DELETE CASCADE;


--
-- TOC entry 8019 (class 2606 OID 146572844)
-- Dependencies: 6905 229 513 8894
-- Name: cobill_cobill_invcitem_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cobill
    ADD CONSTRAINT cobill_cobill_invcitem_id_fkey FOREIGN KEY (cobill_invcitem_id) REFERENCES invcitem(invcitem_id);


--
-- TOC entry 8020 (class 2606 OID 146572849)
-- Dependencies: 6796 199 513 8894
-- Name: cobill_cobill_taxtype_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cobill
    ADD CONSTRAINT cobill_cobill_taxtype_id_fkey FOREIGN KEY (cobill_taxtype_id) REFERENCES taxtype(taxtype_id);


--
-- TOC entry 8021 (class 2606 OID 146572854)
-- Dependencies: 7124 363 515 8894
-- Name: cobilltax_taxhist_basis_tax_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cobilltax
    ADD CONSTRAINT cobilltax_taxhist_basis_tax_id_fkey FOREIGN KEY (taxhist_basis_tax_id) REFERENCES tax(tax_id);


--
-- TOC entry 8022 (class 2606 OID 146572859)
-- Dependencies: 7288 513 515 8894
-- Name: cobilltax_taxhist_parent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cobilltax
    ADD CONSTRAINT cobilltax_taxhist_parent_id_fkey FOREIGN KEY (taxhist_parent_id) REFERENCES cobill(cobill_id) ON DELETE CASCADE;


--
-- TOC entry 8023 (class 2606 OID 146572864)
-- Dependencies: 7124 363 515 8894
-- Name: cobilltax_taxhist_tax_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cobilltax
    ADD CONSTRAINT cobilltax_taxhist_tax_id_fkey FOREIGN KEY (taxhist_tax_id) REFERENCES tax(tax_id);


--
-- TOC entry 8024 (class 2606 OID 146572869)
-- Dependencies: 6796 199 515 8894
-- Name: cobilltax_taxhist_taxtype_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cobilltax
    ADD CONSTRAINT cobilltax_taxhist_taxtype_id_fkey FOREIGN KEY (taxhist_taxtype_id) REFERENCES taxtype(taxtype_id);


--
-- TOC entry 8025 (class 2606 OID 146572874)
-- Dependencies: 6889 224 516 8894
-- Name: cobmisc_cobmisc_invchead_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cobmisc
    ADD CONSTRAINT cobmisc_cobmisc_invchead_id_fkey FOREIGN KEY (cobmisc_invchead_id) REFERENCES invchead(invchead_id);


--
-- TOC entry 8026 (class 2606 OID 146572879)
-- Dependencies: 6796 199 516 8894
-- Name: cobmisc_cobmisc_taxtype_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cobmisc
    ADD CONSTRAINT cobmisc_cobmisc_taxtype_id_fkey FOREIGN KEY (cobmisc_taxtype_id) REFERENCES taxtype(taxtype_id);


--
-- TOC entry 8027 (class 2606 OID 146572884)
-- Dependencies: 6878 220 516 8894
-- Name: cobmisc_cobmisc_taxzone_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cobmisc
    ADD CONSTRAINT cobmisc_cobmisc_taxzone_id_fkey FOREIGN KEY (cobmisc_taxzone_id) REFERENCES taxzone(taxzone_id);


--
-- TOC entry 8028 (class 2606 OID 146572889)
-- Dependencies: 6834 208 516 8894
-- Name: cobmisc_to_curr_symbol; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cobmisc
    ADD CONSTRAINT cobmisc_to_curr_symbol FOREIGN KEY (cobmisc_curr_id) REFERENCES curr_symbol(curr_id);


--
-- TOC entry 8029 (class 2606 OID 146572894)
-- Dependencies: 7124 363 518 8894
-- Name: cobmisctax_taxhist_basis_tax_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cobmisctax
    ADD CONSTRAINT cobmisctax_taxhist_basis_tax_id_fkey FOREIGN KEY (taxhist_basis_tax_id) REFERENCES tax(tax_id);


--
-- TOC entry 8030 (class 2606 OID 146572899)
-- Dependencies: 7293 516 518 8894
-- Name: cobmisctax_taxhist_parent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cobmisctax
    ADD CONSTRAINT cobmisctax_taxhist_parent_id_fkey FOREIGN KEY (taxhist_parent_id) REFERENCES cobmisc(cobmisc_id) ON DELETE CASCADE;


--
-- TOC entry 8031 (class 2606 OID 146572904)
-- Dependencies: 7124 363 518 8894
-- Name: cobmisctax_taxhist_tax_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cobmisctax
    ADD CONSTRAINT cobmisctax_taxhist_tax_id_fkey FOREIGN KEY (taxhist_tax_id) REFERENCES tax(tax_id);


--
-- TOC entry 8032 (class 2606 OID 146572909)
-- Dependencies: 6796 199 518 8894
-- Name: cobmisctax_taxhist_taxtype_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cobmisctax
    ADD CONSTRAINT cobmisctax_taxhist_taxtype_id_fkey FOREIGN KEY (taxhist_taxtype_id) REFERENCES taxtype(taxtype_id);

ALTER TABLE ONLY cohist
    ADD CONSTRAINT cohist_pkey PRIMARY KEY (cohist_id);

--
-- TOC entry 7963 (class 2606 OID 146573024)
-- Dependencies: 7124 363 379 8894
-- Name: cohisttax_taxhist_basis_tax_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cohisttax
    ADD CONSTRAINT cohisttax_taxhist_basis_tax_id_fkey FOREIGN KEY (taxhist_basis_tax_id) REFERENCES tax(tax_id);


--
-- TOC entry 7964 (class 2606 OID 146573029)
-- Dependencies: 7142 376 379 8894
-- Name: cohisttax_taxhist_parent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cohisttax
    ADD CONSTRAINT cohisttax_taxhist_parent_id_fkey FOREIGN KEY (taxhist_parent_id) REFERENCES cohist(cohist_id) ON DELETE CASCADE;


--
-- TOC entry 7965 (class 2606 OID 146573034)
-- Dependencies: 7124 363 379 8894
-- Name: cohisttax_taxhist_tax_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cohisttax
    ADD CONSTRAINT cohisttax_taxhist_tax_id_fkey FOREIGN KEY (taxhist_tax_id) REFERENCES tax(tax_id);


--
-- TOC entry 7966 (class 2606 OID 146573039)
-- Dependencies: 6796 199 379 8894
-- Name: cohisttax_taxhist_taxtype_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY cohisttax
    ADD CONSTRAINT cohisttax_taxhist_taxtype_id_fkey FOREIGN KEY (taxhist_taxtype_id) REFERENCES taxtype(taxtype_id);



--
-- TOC entry 7859 (class 2606 OID 146573084)
-- Dependencies: 6931 239 240 8894
-- Name: comment_comment_cmnttype_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY comment
    ADD CONSTRAINT comment_comment_cmnttype_id_fkey FOREIGN KEY (comment_cmnttype_id) REFERENCES cmnttype(cmnttype_id);



--
-- TOC entry 7902 (class 2606 OID 146573114)
-- Dependencies: 6841 210 329 8894
-- Name: contrct_contrct_vend_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY contrct
    ADD CONSTRAINT contrct_contrct_vend_id_fkey FOREIGN KEY (contrct_vend_id) REFERENCES vendinfo(vend_id);


--
-- TOC entry 8044 (class 2606 OID 146573119)
-- Dependencies: 6834 208 535 8894
-- Name: costhist_new_to_curr_symbol; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY costhist
    ADD CONSTRAINT costhist_new_to_curr_symbol FOREIGN KEY (costhist_newcurr_id) REFERENCES curr_symbol(curr_id);


--
-- TOC entry 8045 (class 2606 OID 146573124)
-- Dependencies: 6834 208 535 8894
-- Name: costhist_old_to_curr_symbol; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY costhist
    ADD CONSTRAINT costhist_old_to_curr_symbol FOREIGN KEY (costhist_oldcurr_id) REFERENCES curr_symbol(curr_id);



--
-- TOC entry 8046 (class 2606 OID 146573174)
-- Dependencies: 6820 205 544 8894
-- Name: crmacctsel_crmacctsel_dest_crmacct_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY crmacctsel
    ADD CONSTRAINT crmacctsel_crmacctsel_dest_crmacct_id_fkey FOREIGN KEY (crmacctsel_dest_crmacct_id) REFERENCES crmacct(crmacct_id) ON DELETE CASCADE;


--
-- TOC entry 8047 (class 2606 OID 146573179)
-- Dependencies: 6820 205 544 8894
-- Name: crmacctsel_crmacctsel_src_crmacct_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY crmacctsel
    ADD CONSTRAINT crmacctsel_crmacctsel_src_crmacct_id_fkey FOREIGN KEY (crmacctsel_src_crmacct_id) REFERENCES crmacct(crmacct_id) ON DELETE CASCADE;


--
-- TOC entry 8050 (class 2606 OID 146573269)
-- Dependencies: 7002 292 565 8894
-- Name: empgrpitem_empgrpitem_emp_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY empgrpitem
    ADD CONSTRAINT empgrpitem_empgrpitem_emp_id_fkey FOREIGN KEY (empgrpitem_emp_id) REFERENCES emp(emp_id);


--
-- TOC entry 8051 (class 2606 OID 146573274)
-- Dependencies: 7350 563 565 8894
-- Name: empgrpitem_empgrpitem_empgrp_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY empgrpitem
    ADD CONSTRAINT empgrpitem_empgrpitem_empgrp_id_fkey FOREIGN KEY (empgrpitem_empgrp_id) REFERENCES empgrp(empgrp_id);


--
-- TOC entry 8052 (class 2606 OID 146573279)
-- Dependencies: 7373 579 588 8894
-- Name: flnotes_flnotes_flhead_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY flnotes
    ADD CONSTRAINT flnotes_flnotes_flhead_id_fkey FOREIGN KEY (flnotes_flhead_id) REFERENCES flhead(flhead_id) ON DELETE CASCADE;


--
-- TOC entry 8053 (class 2606 OID 146573284)
-- Dependencies: 6959 264 588 8894
-- Name: flnotes_flnotes_period_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY flnotes
    ADD CONSTRAINT flnotes_flnotes_period_id_fkey FOREIGN KEY (flnotes_period_id) REFERENCES period(period_id) ON DELETE CASCADE;


--
-- TOC entry 8054 (class 2606 OID 146573289)
-- Dependencies: 7395 601 603 8894
-- Name: grppriv_grppriv_grp_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY grppriv
    ADD CONSTRAINT grppriv_grppriv_grp_id_fkey FOREIGN KEY (grppriv_grp_id) REFERENCES grp(grp_id);



--
-- TOC entry 8055 (class 2606 OID 146573344)
-- Dependencies: 6824 206 609 8894
-- Name: incdthist_incdthist_incdt_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY incdthist
    ADD CONSTRAINT incdthist_incdthist_incdt_id_fkey FOREIGN KEY (incdthist_incdt_id) REFERENCES incdt(incdt_id);


--
-- TOC entry 7765 (class 2606 OID 146573349)
-- Dependencies: 6758 192 202 8894
-- Name: invbal_invbal_itemsite_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY invbal
    ADD CONSTRAINT invbal_invbal_itemsite_id_fkey FOREIGN KEY (invbal_itemsite_id) REFERENCES itemsite(itemsite_id) ON DELETE CASCADE;


--
-- TOC entry 7766 (class 2606 OID 146573354)
-- Dependencies: 6959 264 202 8894
-- Name: invbal_invbal_period_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY invbal
    ADD CONSTRAINT invbal_invbal_period_id_fkey FOREIGN KEY (invbal_period_id) REFERENCES period(period_id) ON DELETE CASCADE;


--
-- TOC entry 8056 (class 2606 OID 146573379)
-- Dependencies: 7124 363 617 8894
-- Name: invcheadtax_taxhist_basis_tax_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY invcheadtax
    ADD CONSTRAINT invcheadtax_taxhist_basis_tax_id_fkey FOREIGN KEY (taxhist_basis_tax_id) REFERENCES tax(tax_id);


--
-- TOC entry 8057 (class 2606 OID 146573384)
-- Dependencies: 6889 224 617 8894
-- Name: invcheadtax_taxhist_parent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY invcheadtax
    ADD CONSTRAINT invcheadtax_taxhist_parent_id_fkey FOREIGN KEY (taxhist_parent_id) REFERENCES invchead(invchead_id) ON DELETE CASCADE;


--
-- TOC entry 8058 (class 2606 OID 146573389)
-- Dependencies: 7124 363 617 8894
-- Name: invcheadtax_taxhist_tax_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY invcheadtax
    ADD CONSTRAINT invcheadtax_taxhist_tax_id_fkey FOREIGN KEY (taxhist_tax_id) REFERENCES tax(tax_id);


--
-- TOC entry 8059 (class 2606 OID 146573394)
-- Dependencies: 6796 199 617 8894
-- Name: invcheadtax_taxhist_taxtype_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY invcheadtax
    ADD CONSTRAINT invcheadtax_taxhist_taxtype_id_fkey FOREIGN KEY (taxhist_taxtype_id) REFERENCES taxtype(taxtype_id);



--
-- TOC entry 8060 (class 2606 OID 146573424)
-- Dependencies: 7124 363 619 8894
-- Name: invcitemtax_taxhist_basis_tax_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY invcitemtax
    ADD CONSTRAINT invcitemtax_taxhist_basis_tax_id_fkey FOREIGN KEY (taxhist_basis_tax_id) REFERENCES tax(tax_id);


--
-- TOC entry 8061 (class 2606 OID 146573429)
-- Dependencies: 6905 229 619 8894
-- Name: invcitemtax_taxhist_parent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY invcitemtax
    ADD CONSTRAINT invcitemtax_taxhist_parent_id_fkey FOREIGN KEY (taxhist_parent_id) REFERENCES invcitem(invcitem_id) ON DELETE CASCADE;


--
-- TOC entry 8062 (class 2606 OID 146573434)
-- Dependencies: 7124 363 619 8894
-- Name: invcitemtax_taxhist_tax_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY invcitemtax
    ADD CONSTRAINT invcitemtax_taxhist_tax_id_fkey FOREIGN KEY (taxhist_tax_id) REFERENCES tax(tax_id);


--
-- TOC entry 8063 (class 2606 OID 146573439)
-- Dependencies: 6796 199 619 8894
-- Name: invcitemtax_taxhist_taxtype_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY invcitemtax
    ADD CONSTRAINT invcitemtax_taxhist_taxtype_id_fkey FOREIGN KEY (taxhist_taxtype_id) REFERENCES taxtype(taxtype_id);


--
-- TOC entry 8064 (class 2606 OID 146573444)
-- Dependencies: 7118 358 625 8894
-- Name: invhistexpcat_invhistexpcat_expcat_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY invhistexpcat
    ADD CONSTRAINT invhistexpcat_invhistexpcat_expcat_id_fkey FOREIGN KEY (invhistexpcat_expcat_id) REFERENCES expcat(expcat_id) ON UPDATE CASCADE ON DELETE CASCADE;


--
-- TOC entry 8065 (class 2606 OID 146573449)
-- Dependencies: 7417 623 625 8894
-- Name: invhistexpcat_invhistexpcat_invhist_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY invhistexpcat
    ADD CONSTRAINT invhistexpcat_invhistexpcat_invhist_id_fkey FOREIGN KEY (invhistexpcat_invhist_id) REFERENCES invhist(invhist_id) ON UPDATE CASCADE ON DELETE CASCADE;



--
-- TOC entry 7891 (class 2606 OID 146573459)
-- Dependencies: 7011 299 300 8894
-- Name: ipsfreight_ipsfreight_freightclass_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY ipsfreight
    ADD CONSTRAINT ipsfreight_ipsfreight_freightclass_id_fkey FOREIGN KEY (ipsfreight_freightclass_id) REFERENCES freightclass(freightclass_id);


--
-- TOC entry 7892 (class 2606 OID 146573464)
-- Dependencies: 7017 301 300 8894
-- Name: ipsfreight_ipsfreight_ipshead_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY ipsfreight
    ADD CONSTRAINT ipsfreight_ipsfreight_ipshead_id_fkey FOREIGN KEY (ipsfreight_ipshead_id) REFERENCES ipshead(ipshead_id);


--
-- TOC entry 7893 (class 2606 OID 146573469)
-- Dependencies: 6897 227 300 8894
-- Name: ipsfreight_ipsfreight_shipzone_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY ipsfreight
    ADD CONSTRAINT ipsfreight_ipsfreight_shipzone_id_fkey FOREIGN KEY (ipsfreight_shipzone_id) REFERENCES shipzone(shipzone_id);


--
-- TOC entry 7894 (class 2606 OID 146573474)
-- Dependencies: 6763 193 300 8894
-- Name: ipsfreight_ipsfreight_warehous_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY ipsfreight
    ADD CONSTRAINT ipsfreight_ipsfreight_warehous_id_fkey FOREIGN KEY (ipsfreight_warehous_id) REFERENCES whsinfo(warehous_id);


--
-- TOC entry 7917 (class 2606 OID 146573484)
-- Dependencies: 7017 301 349 8894
-- Name: ipsitem_ipshead_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY ipsiteminfo
    ADD CONSTRAINT ipsitem_ipshead_id_fk FOREIGN KEY (ipsitem_ipshead_id) REFERENCES ipshead(ipshead_id) ON DELETE CASCADE;


--
-- TOC entry 7918 (class 2606 OID 146573489)
-- Dependencies: 6800 200 349 8894
-- Name: ipsitem_ipsitem_price_uom_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY ipsiteminfo
    ADD CONSTRAINT ipsitem_ipsitem_price_uom_id_fkey FOREIGN KEY (ipsitem_price_uom_id) REFERENCES uom(uom_id);


--
-- TOC entry 7919 (class 2606 OID 146573494)
-- Dependencies: 6800 200 349 8894
-- Name: ipsitem_ipsitem_qty_uom_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY ipsiteminfo
    ADD CONSTRAINT ipsitem_ipsitem_qty_uom_id_fkey FOREIGN KEY (ipsitem_qty_uom_id) REFERENCES uom(uom_id);


--
-- TOC entry 7920 (class 2606 OID 146573499)
-- Dependencies: 6763 193 349 8894
-- Name: ipsitem_ipsitem_warehous_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY ipsiteminfo
    ADD CONSTRAINT ipsitem_ipsitem_warehous_id_fkey FOREIGN KEY (ipsitem_warehous_id) REFERENCES whsinfo(warehous_id);


--
-- TOC entry 7921 (class 2606 OID 146573504)
-- Dependencies: 6751 191 349 8894
-- Name: ipsitem_item_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY ipsiteminfo
    ADD CONSTRAINT ipsitem_item_id_fk FOREIGN KEY (ipsitem_item_id) REFERENCES item(item_id);


--
-- TOC entry 7922 (class 2606 OID 146573509)
-- Dependencies: 6924 236 351 8894
-- Name: ipsitemchar_ipsitemchar_char_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY ipsitemchar
    ADD CONSTRAINT ipsitemchar_ipsitemchar_char_id_fkey FOREIGN KEY (ipsitemchar_char_id) REFERENCES "char"(char_id);


--
-- TOC entry 7923 (class 2606 OID 146573514)
-- Dependencies: 7104 349 351 8894
-- Name: ipsitemchar_ipsitemchar_ipsitem_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY ipsitemchar
    ADD CONSTRAINT ipsitemchar_ipsitemchar_ipsitem_id_fkey FOREIGN KEY (ipsitemchar_ipsitem_id) REFERENCES ipsiteminfo(ipsitem_id) ON DELETE CASCADE;



--
-- TOC entry 7898 (class 2606 OID 146573549)
-- Dependencies: 7049 320 321 8894
-- Name: itemcost_itemcost_costelem_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY itemcost
    ADD CONSTRAINT itemcost_itemcost_costelem_id_fkey FOREIGN KEY (itemcost_costelem_id) REFERENCES costelem(costelem_id);


--
-- TOC entry 7899 (class 2606 OID 146573554)
-- Dependencies: 6834 208 321 8894
-- Name: itemcost_itemcost_curr_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY itemcost
    ADD CONSTRAINT itemcost_itemcost_curr_id_fkey FOREIGN KEY (itemcost_curr_id) REFERENCES curr_symbol(curr_id);


--
-- TOC entry 7900 (class 2606 OID 146573559)
-- Dependencies: 6751 191 321 8894
-- Name: itemcost_itemcost_item_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY itemcost
    ADD CONSTRAINT itemcost_itemcost_item_id_fkey FOREIGN KEY (itemcost_item_id) REFERENCES item(item_id);


--
-- TOC entry 7901 (class 2606 OID 146573564)
-- Dependencies: 6834 208 321 8894
-- Name: itemcost_to_curr_symbol; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY itemcost
    ADD CONSTRAINT itemcost_to_curr_symbol FOREIGN KEY (itemcost_curr_id) REFERENCES curr_symbol(curr_id);


--
-- TOC entry 7903 (class 2606 OID 146573589)
-- Dependencies: 7064 329 330 8894
-- Name: itemsrc_itemsrc_contrct_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY itemsrc
    ADD CONSTRAINT itemsrc_itemsrc_contrct_id_fkey FOREIGN KEY (itemsrc_contrct_id) REFERENCES contrct(contrct_id);


--
-- TOC entry 7904 (class 2606 OID 146573594)
-- Dependencies: 6751 191 330 8894
-- Name: itemsrc_itemsrc_item_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY itemsrc
    ADD CONSTRAINT itemsrc_itemsrc_item_id_fkey FOREIGN KEY (itemsrc_item_id) REFERENCES item(item_id) ON DELETE CASCADE;


--
-- TOC entry 7905 (class 2606 OID 146573599)
-- Dependencies: 6841 210 330 8894
-- Name: itemsrc_itemsrc_vend_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY itemsrc
    ADD CONSTRAINT itemsrc_itemsrc_vend_id_fkey FOREIGN KEY (itemsrc_vend_id) REFERENCES vendinfo(vend_id) ON DELETE CASCADE;


--
-- TOC entry 7906 (class 2606 OID 146573604)
-- Dependencies: 7068 330 332 8894
-- Name: itemsrcp_itemsrcp_itemsrc_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY itemsrcp
    ADD CONSTRAINT itemsrcp_itemsrcp_itemsrc_id_fkey FOREIGN KEY (itemsrcp_itemsrc_id) REFERENCES itemsrc(itemsrc_id) ON DELETE CASCADE;


--
-- TOC entry 7907 (class 2606 OID 146573609)
-- Dependencies: 6834 208 332 8894
-- Name: itemsrcp_to_curr_symbol; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY itemsrcp
    ADD CONSTRAINT itemsrcp_to_curr_symbol FOREIGN KEY (itemsrcp_curr_id) REFERENCES curr_symbol(curr_id);


--
-- TOC entry 7908 (class 2606 OID 146573614)
-- Dependencies: 6751 191 334 8894
-- Name: itemsub_itemsub_parent_item_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY itemsub
    ADD CONSTRAINT itemsub_itemsub_parent_item_id_fkey FOREIGN KEY (itemsub_parent_item_id) REFERENCES item(item_id);


--
-- TOC entry 7909 (class 2606 OID 146573619)
-- Dependencies: 6751 191 334 8894
-- Name: itemsub_itemsub_sub_item_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY itemsub
    ADD CONSTRAINT itemsub_itemsub_sub_item_id_fkey FOREIGN KEY (itemsub_sub_item_id) REFERENCES item(item_id);


--
-- TOC entry 7910 (class 2606 OID 146573624)
-- Dependencies: 6751 191 336 8894
-- Name: itemtax_itemtax_item_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY itemtax
    ADD CONSTRAINT itemtax_itemtax_item_id_fkey FOREIGN KEY (itemtax_item_id) REFERENCES item(item_id);


--
-- TOC entry 7911 (class 2606 OID 146573629)
-- Dependencies: 6796 199 336 8894
-- Name: itemtax_itemtax_taxtype_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY itemtax
    ADD CONSTRAINT itemtax_itemtax_taxtype_id_fkey FOREIGN KEY (itemtax_taxtype_id) REFERENCES taxtype(taxtype_id);


--
-- TOC entry 7912 (class 2606 OID 146573634)
-- Dependencies: 6878 220 336 8894
-- Name: itemtax_itemtax_taxzone_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY itemtax
    ADD CONSTRAINT itemtax_itemtax_taxzone_id_fkey FOREIGN KEY (itemtax_taxzone_id) REFERENCES taxzone(taxzone_id);


--
-- TOC entry 8066 (class 2606 OID 146573639)
-- Dependencies: 6751 191 662 8894
-- Name: itemtrans_itemtrans_source_item_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY itemtrans
    ADD CONSTRAINT itemtrans_itemtrans_source_item_id_fkey FOREIGN KEY (itemtrans_source_item_id) REFERENCES item(item_id);


--
-- TOC entry 8067 (class 2606 OID 146573644)
-- Dependencies: 6751 191 662 8894
-- Name: itemtrans_itemtrans_target_item_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY itemtrans
    ADD CONSTRAINT itemtrans_itemtrans_target_item_id_fkey FOREIGN KEY (itemtrans_target_item_id) REFERENCES item(item_id);


--
-- TOC entry 8068 (class 2606 OID 146573649)
-- Dependencies: 7084 338 664 8894
-- Name: itemuom_itemuom_itemuomconv_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY itemuom
    ADD CONSTRAINT itemuom_itemuom_itemuomconv_id_fkey FOREIGN KEY (itemuom_itemuomconv_id) REFERENCES itemuomconv(itemuomconv_id);


--
-- TOC entry 8069 (class 2606 OID 146573654)
-- Dependencies: 7629 822 664 8894
-- Name: itemuom_itemuom_uomtype_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY itemuom
    ADD CONSTRAINT itemuom_itemuom_uomtype_id_fkey FOREIGN KEY (itemuom_uomtype_id) REFERENCES uomtype(uomtype_id);



--
-- TOC entry 8070 (class 2606 OID 146573674)
-- Dependencies: 6816 204 687 8894
-- Name: mrghist_mrghist_cntct_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY mrghist
    ADD CONSTRAINT mrghist_mrghist_cntct_id_fkey FOREIGN KEY (mrghist_cntct_id) REFERENCES cntct(cntct_id) ON DELETE CASCADE;


--
-- TOC entry 8088 (class 2606 OID 146573874)
-- Dependencies: 7541 742 744 8894
-- Name: qryitem_qryitem_qryhead_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY qryitem
    ADD CONSTRAINT qryitem_qryitem_qryhead_id_fkey FOREIGN KEY (qryitem_qryhead_id) REFERENCES qryhead(qryhead_id);


--
-- TOC entry 8077 (class 2606 OID 146573969)
-- Dependencies: 6834 208 721 8894
-- Name: recv_recv_freight_curr_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY recv
    ADD CONSTRAINT recv_recv_freight_curr_id_fkey FOREIGN KEY (recv_freight_curr_id) REFERENCES curr_symbol(curr_id);


--
-- TOC entry 8078 (class 2606 OID 146573974)
-- Dependencies: 6758 192 721 8894
-- Name: recv_recv_itemsite_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY recv
    ADD CONSTRAINT recv_recv_itemsite_id_fkey FOREIGN KEY (recv_itemsite_id) REFERENCES itemsite(itemsite_id);


--
-- TOC entry 8079 (class 2606 OID 146573979)
-- Dependencies: 6834 208 721 8894
-- Name: recv_recv_purchcost_curr_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY recv
    ADD CONSTRAINT recv_recv_purchcost_curr_id_fkey FOREIGN KEY (recv_purchcost_curr_id) REFERENCES curr_symbol(curr_id);


--
-- TOC entry 8080 (class 2606 OID 146573984)
-- Dependencies: 6834 208 721 8894
-- Name: recv_recv_recvcost_curr_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY recv
    ADD CONSTRAINT recv_recv_recvcost_curr_id_fkey FOREIGN KEY (recv_recvcost_curr_id) REFERENCES curr_symbol(curr_id);


--
-- TOC entry 8081 (class 2606 OID 146573989)
-- Dependencies: 7519 721 721 8894
-- Name: recv_recv_splitfrom_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY recv
    ADD CONSTRAINT recv_recv_splitfrom_id_fkey FOREIGN KEY (recv_splitfrom_id) REFERENCES recv(recv_id);


--
-- TOC entry 8082 (class 2606 OID 146573994)
-- Dependencies: 6841 210 721 8894
-- Name: recv_recv_vend_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY recv
    ADD CONSTRAINT recv_recv_vend_id_fkey FOREIGN KEY (recv_vend_id) REFERENCES vendinfo(vend_id);


--
-- TOC entry 8083 (class 2606 OID 146573999)
-- Dependencies: 7642 839 721 8894
-- Name: recv_recv_vohead_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY recv
    ADD CONSTRAINT recv_recv_vohead_id_fkey FOREIGN KEY (recv_vohead_id) REFERENCES vohead(vohead_id);


--
-- TOC entry 8084 (class 2606 OID 146574004)
-- Dependencies: 7648 842 721 8894
-- Name: recv_recv_voitem_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY recv
    ADD CONSTRAINT recv_recv_voitem_id_fkey FOREIGN KEY (recv_voitem_id) REFERENCES voitem(voitem_id);



--
-- TOC entry 7888 (class 2606 OID 146574014)
-- Dependencies: 6834 208 297 8894
-- Name: shipdata_shipdata_base_freight_curr_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY shipdata
    ADD CONSTRAINT shipdata_shipdata_base_freight_curr_id_fkey FOREIGN KEY (shipdata_base_freight_curr_id) REFERENCES curr_symbol(curr_id);


--
-- TOC entry 7889 (class 2606 OID 146574019)
-- Dependencies: 7305 526 297 8894
-- Name: shipdata_shipdata_shiphead_number_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY shipdata
    ADD CONSTRAINT shipdata_shipdata_shiphead_number_fkey FOREIGN KEY (shipdata_shiphead_number) REFERENCES shiphead(shiphead_number);


--
-- TOC entry 7890 (class 2606 OID 146574024)
-- Dependencies: 6834 208 297 8894
-- Name: shipdata_shipdata_total_freight_curr_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY shipdata
    ADD CONSTRAINT shipdata_shipdata_total_freight_curr_id_fkey FOREIGN KEY (shipdata_total_freight_curr_id) REFERENCES curr_symbol(curr_id);


--
-- TOC entry 8089 (class 2606 OID 146574029)
-- Dependencies: 6834 208 771 8894
-- Name: shipdatasum_shipdatasum_base_freight_curr_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY shipdatasum
    ADD CONSTRAINT shipdatasum_shipdatasum_base_freight_curr_id_fkey FOREIGN KEY (shipdatasum_base_freight_curr_id) REFERENCES curr_symbol(curr_id);


--
-- TOC entry 8090 (class 2606 OID 146574034)
-- Dependencies: 7305 526 771 8894
-- Name: shipdatasum_shipdatasum_shiphead_number_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY shipdatasum
    ADD CONSTRAINT shipdatasum_shipdatasum_shiphead_number_fkey FOREIGN KEY (shipdatasum_shiphead_number) REFERENCES shiphead(shiphead_number);


--
-- TOC entry 8091 (class 2606 OID 146574039)
-- Dependencies: 6834 208 771 8894
-- Name: shipdatasum_shipdatasum_total_freight_curr_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY shipdatasum
    ADD CONSTRAINT shipdatasum_shipdatasum_total_freight_curr_id_fkey FOREIGN KEY (shipdatasum_total_freight_curr_id) REFERENCES curr_symbol(curr_id);



--
-- TOC entry 8041 (class 2606 OID 146574059)
-- Dependencies: 6905 229 527 8894
-- Name: shipitem_shipitem_invcitem_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY shipitem
    ADD CONSTRAINT shipitem_shipitem_invcitem_id_fkey FOREIGN KEY (shipitem_invcitem_id) REFERENCES invcitem(invcitem_id);


--
-- TOC entry 8042 (class 2606 OID 146574064)
-- Dependencies: 7417 623 527 8894
-- Name: shipitem_shipitem_invhist_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY shipitem
    ADD CONSTRAINT shipitem_shipitem_invhist_id_fkey FOREIGN KEY (shipitem_invhist_id) REFERENCES invhist(invhist_id);


--
-- TOC entry 8043 (class 2606 OID 146574069)
-- Dependencies: 7303 526 527 8894
-- Name: shipitem_shipitem_shiphead_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY shipitem
    ADD CONSTRAINT shipitem_shipitem_shiphead_id_fkey FOREIGN KEY (shipitem_shiphead_id) REFERENCES shiphead(shiphead_id);


--
-- TOC entry 8092 (class 2606 OID 146574119)
-- Dependencies: 7321 538 787 8894
-- Name: state_state_country_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY state
    ADD CONSTRAINT state_state_country_id_fkey FOREIGN KEY (state_country_id) REFERENCES country(country_id);


--
-- TOC entry 8096 (class 2606 OID 146574189)
-- Dependencies: 6834 208 809 8894
-- Name: taxrate_taxrate_curr_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY taxrate
    ADD CONSTRAINT taxrate_taxrate_curr_id_fkey FOREIGN KEY (taxrate_curr_id) REFERENCES curr_symbol(curr_id);


--
-- TOC entry 8097 (class 2606 OID 146574194)
-- Dependencies: 7124 363 809 8894
-- Name: taxrate_taxrate_tax_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY taxrate
    ADD CONSTRAINT taxrate_taxrate_tax_id_fkey FOREIGN KEY (taxrate_tax_id) REFERENCES tax(tax_id);


--
-- TOC entry 7879 (class 2606 OID 146574199)
-- Dependencies: 6988 284 285 8894
-- Name: taxreg_taxreg_taxauth_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY taxreg
    ADD CONSTRAINT taxreg_taxreg_taxauth_id_fkey FOREIGN KEY (taxreg_taxauth_id) REFERENCES taxauth(taxauth_id);


--
-- TOC entry 7880 (class 2606 OID 146574204)
-- Dependencies: 6878 220 285 8894
-- Name: taxreg_taxreg_taxzone_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY taxreg
    ADD CONSTRAINT taxreg_taxreg_taxzone_id_fkey FOREIGN KEY (taxreg_taxzone_id) REFERENCES taxzone(taxzone_id);


--
-- TOC entry 7854 (class 2606 OID 146574209)
-- Dependencies: 6816 204 233 8894
-- Name: todoitem_todoitem_cntct_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY todoitem
    ADD CONSTRAINT todoitem_todoitem_cntct_id_fkey FOREIGN KEY (todoitem_cntct_id) REFERENCES cntct(cntct_id);


--
-- TOC entry 7855 (class 2606 OID 146574214)
-- Dependencies: 6820 205 233 8894
-- Name: todoitem_todoitem_crmacct_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY todoitem
    ADD CONSTRAINT todoitem_todoitem_crmacct_id_fkey FOREIGN KEY (todoitem_crmacct_id) REFERENCES crmacct(crmacct_id);


--
-- TOC entry 7856 (class 2606 OID 146574219)
-- Dependencies: 6824 206 233 8894
-- Name: todoitem_todoitem_incdt_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY todoitem
    ADD CONSTRAINT todoitem_todoitem_incdt_id_fkey FOREIGN KEY (todoitem_incdt_id) REFERENCES incdt(incdt_id);


--
-- TOC entry 7857 (class 2606 OID 146574224)
-- Dependencies: 6909 231 233 8894
-- Name: todoitem_todoitem_ophead_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY todoitem
    ADD CONSTRAINT todoitem_todoitem_ophead_id_fkey FOREIGN KEY (todoitem_ophead_id) REFERENCES ophead(ophead_id) ON UPDATE RESTRICT ON DELETE RESTRICT;


--
-- TOC entry 7858 (class 2606 OID 146574229)
-- Dependencies: 6915 233 233 8894
-- Name: todoitem_todoitem_recurring_todoitem_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY todoitem
    ADD CONSTRAINT todoitem_todoitem_recurring_todoitem_id_fkey FOREIGN KEY (todoitem_recurring_todoitem_id) REFERENCES todoitem(todoitem_id);


--
-- TOC entry 8098 (class 2606 OID 146574234)
-- Dependencies: 7282 510 816 8894
-- Name: trgthist_trgthist_src_cntct_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY trgthist
    ADD CONSTRAINT trgthist_trgthist_src_cntct_id_fkey FOREIGN KEY (trgthist_src_cntct_id) REFERENCES cntctmrgd(cntctmrgd_cntct_id) ON DELETE CASCADE;


--
-- TOC entry 8099 (class 2606 OID 146574239)
-- Dependencies: 6816 204 816 8894
-- Name: trgthist_trgthist_trgt_cntct_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY trgthist
    ADD CONSTRAINT trgthist_trgthist_trgt_cntct_id_fkey FOREIGN KEY (trgthist_trgt_cntct_id) REFERENCES cntct(cntct_id) ON DELETE CASCADE;


--
-- TOC entry 8100 (class 2606 OID 146574244)
-- Dependencies: 6800 200 820 8894
-- Name: uomconv_uomconv_from_uom_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY uomconv
    ADD CONSTRAINT uomconv_uomconv_from_uom_id_fkey FOREIGN KEY (uomconv_from_uom_id) REFERENCES uom(uom_id);


--
-- TOC entry 8101 (class 2606 OID 146574249)
-- Dependencies: 6800 200 820 8894
-- Name: uomconv_uomconv_to_uom_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY uomconv
    ADD CONSTRAINT uomconv_uomconv_to_uom_id_fkey FOREIGN KEY (uomconv_to_uom_id) REFERENCES uom(uom_id);


--
-- TOC entry 8087 (class 2606 OID 146574254)
-- Dependencies: 7395 601 732 8894
-- Name: usrgrp_usrgrp_grp_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY usrgrp
    ADD CONSTRAINT usrgrp_usrgrp_grp_id_fkey FOREIGN KEY (usrgrp_grp_id) REFERENCES grp(grp_id);



--
-- TOC entry 7934 (class 2606 OID 146574279)
-- Dependencies: 6816 204 364 8894
-- Name: vendaddrinfo_vendaddr_cntct_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY vendaddrinfo
    ADD CONSTRAINT vendaddrinfo_vendaddr_cntct_id_fkey FOREIGN KEY (vendaddr_cntct_id) REFERENCES cntct(cntct_id);


--
-- TOC entry 7935 (class 2606 OID 146574284)
-- Dependencies: 6878 220 364 8894
-- Name: vendaddrinfo_vendaddr_taxzone_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY vendaddrinfo
    ADD CONSTRAINT vendaddrinfo_vendaddr_taxzone_id_fkey FOREIGN KEY (vendaddr_taxzone_id) REFERENCES taxzone(taxzone_id);


--
-- TOC entry 8108 (class 2606 OID 146574334)
-- Dependencies: 7124 363 841 8894
-- Name: voheadtax_taxhist_basis_tax_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY voheadtax
    ADD CONSTRAINT voheadtax_taxhist_basis_tax_id_fkey FOREIGN KEY (taxhist_basis_tax_id) REFERENCES tax(tax_id);


--
-- TOC entry 8109 (class 2606 OID 146574339)
-- Dependencies: 7642 839 841 8894
-- Name: voheadtax_taxhist_parent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY voheadtax
    ADD CONSTRAINT voheadtax_taxhist_parent_id_fkey FOREIGN KEY (taxhist_parent_id) REFERENCES vohead(vohead_id) ON DELETE CASCADE;


--
-- TOC entry 8110 (class 2606 OID 146574344)
-- Dependencies: 7124 363 841 8894
-- Name: voheadtax_taxhist_tax_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY voheadtax
    ADD CONSTRAINT voheadtax_taxhist_tax_id_fkey FOREIGN KEY (taxhist_tax_id) REFERENCES tax(tax_id);


--
-- TOC entry 8111 (class 2606 OID 146574349)
-- Dependencies: 6796 199 841 8894
-- Name: voheadtax_taxhist_taxtype_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY voheadtax
    ADD CONSTRAINT voheadtax_taxhist_taxtype_id_fkey FOREIGN KEY (taxhist_taxtype_id) REFERENCES taxtype(taxtype_id);


--
-- TOC entry 8112 (class 2606 OID 146574354)
-- Dependencies: 6796 199 842 8894
-- Name: voitem_voitem_taxtype_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY voitem
    ADD CONSTRAINT voitem_voitem_taxtype_id_fkey FOREIGN KEY (voitem_taxtype_id) REFERENCES taxtype(taxtype_id);


--
-- TOC entry 8113 (class 2606 OID 146574359)
-- Dependencies: 7124 363 844 8894
-- Name: voitemtax_taxhist_basis_tax_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY voitemtax
    ADD CONSTRAINT voitemtax_taxhist_basis_tax_id_fkey FOREIGN KEY (taxhist_basis_tax_id) REFERENCES tax(tax_id);


--
-- TOC entry 8114 (class 2606 OID 146574364)
-- Dependencies: 7648 842 844 8894
-- Name: voitemtax_taxhist_parent_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY voitemtax
    ADD CONSTRAINT voitemtax_taxhist_parent_id_fkey FOREIGN KEY (taxhist_parent_id) REFERENCES voitem(voitem_id) ON DELETE CASCADE;


--
-- TOC entry 8115 (class 2606 OID 146574369)
-- Dependencies: 7124 363 844 8894
-- Name: voitemtax_taxhist_tax_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY voitemtax
    ADD CONSTRAINT voitemtax_taxhist_tax_id_fkey FOREIGN KEY (taxhist_tax_id) REFERENCES tax(tax_id);


--
-- TOC entry 8116 (class 2606 OID 146574374)
-- Dependencies: 6796 199 844 8894
-- Name: voitemtax_taxhist_taxtype_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY voitemtax
    ADD CONSTRAINT voitemtax_taxhist_taxtype_id_fkey FOREIGN KEY (taxhist_taxtype_id) REFERENCES taxtype(taxtype_id);



--
-- TOC entry 7928 (class 2606 OID 146574424)
-- Dependencies: 6800 200 359 8894
-- Name: womatl_womatl_uom_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY womatl
    ADD CONSTRAINT womatl_womatl_uom_id_fkey FOREIGN KEY (womatl_uom_id) REFERENCES uom(uom_id);


--
-- TOC entry 8117 (class 2606 OID 146574429)
-- Dependencies: 7417 623 850 8894
-- Name: womatlpost_womatlpost_invhist_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY womatlpost
    ADD CONSTRAINT womatlpost_womatlpost_invhist_id_fkey FOREIGN KEY (womatlpost_invhist_id) REFERENCES invhist(invhist_id);


--
-- TOC entry 8118 (class 2606 OID 146574434)
-- Dependencies: 7121 359 850 8894
-- Name: womatlpost_womatlpost_womatl_id_fkey; Type: FK CONSTRAINT; Schema: public; Owner: admin
--

ALTER TABLE ONLY womatlpost
    ADD CONSTRAINT womatlpost_womatlpost_womatl_id_fkey FOREIGN KEY (womatlpost_womatl_id) REFERENCES womatl(womatl_id) ON DELETE CASCADE;


DO $$
  DECLARE
    _pkgheadExists BOOLEAN;
  BEGIN
    _pkgheadExists := EXISTS(SELECT 1 FROM pg_class WHERE relname = 'pkghead');
    IF NOT _pkgheadExists THEN
      -- dummy pkghead table to allow fixacl() to run
      CREATE TABLE pkghead (pkghead_name TEXT);
    END IF;

    PERFORM fixACL();

    IF NOT _pkgheadExists THEN DROP TABLE pkghead; END IF;
  END
$$ LANGUAGE plpgsql;


-- 2018-03-23 Add new column that did not exist in the 440 schema so it can be
-- populated by demo_data.sql. Data is populated on this 440 schema before it is
-- upgraded to the latest version.
ALTER TABLE company
  ADD CCOLUMN company_unassigned_accnt_id integer;
